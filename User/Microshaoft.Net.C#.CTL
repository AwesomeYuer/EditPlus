#TITLE=01.Microshaoft .Net C#
#INFO
New Cliptext library
#SORT=y

#T=10条实用的代码
C#程序开发中经常遇到的10条实用的代码

1 读取操作系统和CLR的版本
OperatingSystem os = System.Environment.OSVersion;
Console.WriteLine("Platform: {0}", os.Platform);
Console.WriteLine("Service Pack: {0}", os.ServicePack);
Console.WriteLine("Version: {0}", os.Version);
Console.WriteLine("VersionString: {0}", os.VersionString);
Console.WriteLine("CLR Version: {0}", System.Environment.Version);
 
在我的Windows 7系统中，输出以下信息

Platform: Win32NT 
Service Pack: 
Version: 6.1.7600.0 
VersionString: Microsoft Windows NT 6.1.7600.0 
CLR Version: 4.0.21006.1

 

2 读取CPU数量，内存容量
可以通过Windows Management Instrumentation (WMI)提供的接口读取所需要的信息。

private static UInt32 CountPhysicalProcessors()
{
     ManagementObjectSearcher objects = new ManagementObjectSearcher(
        "SELECT * FROM Win32_ComputerSystem");
     ManagementObjectCollection coll = objects.Get();
     foreach(ManagementObject obj in coll)
    {
        return (UInt32)obj["NumberOfProcessors"];
    } 
    return 0;
}
private static UInt64 CountPhysicalMemory()
{
   ManagementObjectSearcher objects =new ManagementObjectSearcher(
      "SELECT * FROM Win32_PhysicalMemory");
   ManagementObjectCollection coll = objects.Get();
   UInt64 total = 0;
   foreach (ManagementObject obj in coll)
   {
       total += (UInt64)obj["Capacity"];
    }
    return total;
}
请添加对程序集System.Management的引用，确保代码可以正确编译。

Console.WriteLine("Machine: {0}", Environment.MachineName);
Console.WriteLine("# of processors (logical): {0}", Environment.ProcessorCount);
Console.WriteLine("# of processors (physical): {0}"  CountPhysicalProcessors());
Console.WriteLine("RAM installed: {0:N0} bytes",  CountPhysicalMemory());
Console.WriteLine("Is OS 64-bit? {0}",   Environment.Is64BitOperatingSystem);
Console.WriteLine("Is process 64-bit? {0}",  Environment.Is64BitProcess);
Console.WriteLine("Little-endian: {0}", BitConverter.IsLittleEndian);
foreach (Screen screen in  System.Windows.Forms.Screen.AllScreens)
{
     Console.WriteLine("Screen {0}", screen.DeviceName);
     Console.WriteLine("\tPrimary {0}", screen.Primary);
     Console.WriteLine("\tBounds: {0}", screen.Bounds);
     Console.WriteLine("\tWorking Area: {0}",screen.WorkingArea);
     Console.WriteLine("\tBitsPerPixel: {0}",screen.BitsPerPixel);
}
 
 
3 读取注册表键值对
using (RegistryKey keyRun = Registry.LocalMachine.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run"))
{
    foreach (string valueName in keyRun.GetValueNames())
    {
     Console.WriteLine("Name: {0}\tValue: {1}", valueName, keyRun.GetValue(valueName));
    }
}
请添加命名空间Microsoft.Win32，以确保上面的代码可以编译。

 

4 启动，停止Windows服务
这项API提供的实用功能常常用来管理应用程序中的服务，而不必到控制面板的管理服务中进行操作。

ServiceController controller = new ServiceController("e-M-POWER");      
controller.Start();      
if (controller.CanPauseAndContinue)      
{      
    controller.Pause();      
    controller.Continue();      
}      
controller.Stop();      
.net提供的API中，可以实现一句话安装与卸载服务

 if (args[0] == "/i")
 {
       ManagedInstallerClass.InstallHelper(new string[] { Assembly.GetExecutingAssembly().Location });
 }
 else if (args[0] == "/u")
 {
   ManagedInstallerClass.InstallHelper(new string[] { "/u", Assembly.GetExecutingAssembly().Location });
 }
 

如代码所示，给应用程序传入i或u参数，以表示是卸载或是安装程序。

 

5 验证程序是否有strong name (P/Invoke)
比如在程序中，为了验证程序集是否有签名，可调用如下方法

[DllImport("mscoree.dll", CharSet=CharSet.Unicode)]
static extern bool StrongNameSignatureVerificationEx(string wszFilePath, bool fForceVerification, ref bool  pfWasVerified);

bool notForced = false;
bool verified = StrongNameSignatureVerificationEx(assembly, false, ref notForced);
Console.WriteLine("Verified: {0}\nForced: {1}", verified, !notForced);
这个功能常用在软件保护方法，可用来验证签名的组件。即使你的签名被人去掉，或是所有程序集的签名都被去除，只要程序中有这一项调用代码，则可以停止程序运行。

 

6 响应系统配置项的变更
比如我们锁定系统后，如果QQ没有退出，则它会显示了忙碌状态。

请添加命名空间Microsoft.Win32，然后对注册下面的事件。

. DisplaySettingsChanged (包含Changing)  显示设置 
. InstalledFontsChanged  字体变化 
. PaletteChanged  
. PowerModeChanged 电源状态 
. SessionEnded (用户正在登出或是会话结束) 
. SessionSwitch (变更当前用户) 
. TimeChanged 时间改变 
. UserPreferenceChanged (用户偏号 包含Changing)

我们的ERP系统，会监测系统时间是否改变，如果将时间调整后ERP许可文件之外的范围，会导致ERP软件不可用。

 

7 运用Windows7的新特性
Windows7系统引入一些新特性，比如打开文件对话框，状态栏可显示当前任务的进度。

Microsoft.WindowsAPICodePack.Dialogs.CommonOpenFileDialog ofd = new  Microsoft.WindowsAPICodePack.Dialogs.CommonOpenFileDialog();
ofd.AddToMostRecentlyUsedList = true;
ofd.IsFolderPicker = true;
ofd.AllowNonFileSystemItems = true;
ofd.ShowDialog();
 
 

用这样的方法打开对话框，与BCL自带类库中的OpenFileDialog功能更多一些。不过只限于Windows 7系统中，所以要调用这段代码，还要检查操作系统的版本要大于6，并且添加对程序集Windows API Code Pack for Microsoft?.NET Framework的引用，请到这个地址下载 http://code.msdn.microsoft.com/WindowsAPICodePack

 

8 检查程序对内存的消耗
用下面的方法，可以检查.NET给程序分配的内存数量

long available = GC.GetTotalMemory(false);
Console.WriteLine("Before allocations: {0:N0}", available);
int allocSize = 40000000;
byte[] bigArray = new byte[allocSize];
available = GC.GetTotalMemory(false);
Console.WriteLine("After allocations: {0:N0}", available);
 

在我的系统中，它运行的结果如下所示

Before allocations: 651,064
After allocations: 40,690,080
 
使用下面的方法，可以检查当前应用程序占用的内存

Process proc = Process.GetCurrentProcess();
Console.WriteLine("Process Info: "+Environment.NewLine+ 
 "Private Memory Size: {0:N0}"+Environment.NewLine +
"Virtual Memory Size: {1:N0}" + Environment.NewLine +
"Working Set Size: {2:N0}" + Environment.NewLine +
"Paged Memory Size: {3:N0}" + Environment.NewLine +
"Paged System Memory Size: {4:N0}" + Environment.NewLine +
  "Non-paged System Memory Size: {5:N0}" + Environment.NewLine,
proc.PrivateMemorySize64,   proc.VirtualMemorySize64,  proc.WorkingSet64,  proc.PagedMemorySize64, proc.PagedSystemMemorySize64,  proc.NonpagedSystemMemorySize64 );
 
 
9 使用记秒表检查程序运行时间
如果你担忧某些代码非常耗费时间，可以用StopWatch来检查这段代码消耗的时间，如下面的代码所示

System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();
timer.Start();
Decimal total = 0;
int limit = 1000000;
for (int i = 0; i < limit; ++i)
{
      total = total + (Decimal)Math.Sqrt(i);
}
timer.Stop();
Console.WriteLine("Sum of sqrts: {0}",total);
Console.WriteLine("Elapsed milliseconds: {0}",
timer.ElapsedMilliseconds);
Console.WriteLine("Elapsed time: {0}", timer.Elapsed);
 
现在已经有专门的工具来检测程序的运行时间，可以细化到每个方法，比如dotNetPerformance软件。

以上面的代码为例子，您需要直接修改源代码，如果是用来测试程序，则有些不方便。请参考下面的例子。

class AutoStopwatch : System.Diagnostics.Stopwatch, IDisposable
{
   public AutoStopwatch()
   { 
       Start();
   }
   public void Dispose()
   {
       Stop();
       Console.WriteLine("Elapsed: {0}", this.Elapsed);
   }
}
借助于using语法，像下面的代码所示，可以检查一段代码的运行时间，并打印在控制台上。

using (new AutoStopwatch())
{
    Decimal total2 = 0;
    int limit2 = 1000000;
    for (int i = 0; i < limit2; ++i)
    {
       total2 = total2 + (Decimal)Math.Sqrt(i);
    }
}
 
 

 
10 使用光标
当程序正在后台运行保存或是册除操作时，应当将光标状态修改为忙碌。可使用下面的技巧。

class AutoWaitCursor : IDisposable
{
private Control _target;
private Cursor _prevCursor = Cursors.Default;
public AutoWaitCursor(Control control)
{
   if (control == null)
   {
     throw new ArgumentNullException("control");
   }
   _target = control;
   _prevCursor = _target.Cursor;
   _target.Cursor = Cursors.WaitCursor;
}
public void Dispose()
{
   _target.Cursor = _prevCursor;
}
}
 
用法如下所示，这个写法，是为了预料到程序可能会抛出异常

using (new AutoWaitCursor(this))
{
...
throw new Exception();
}
如代码所示，即使抛出异常，光标也可以恢复到之间的状态。
#T=157《编写高质量代码：改善C#程序的157个建议》源码下载
157《编写高质量代码：改善C#程序的157个建议》源码下载
====

目录

前　言
第一部分　语言篇
第1章　基本语言要素 / 2
建议1：正确操作字符串 / 2
建议2：使用默认转型方法 / 6
建议3：区别对待强制转型与as和is / 9
建议4：TryParse比Parse好 / 12
建议5：使用int?来确保值类型也可以为null / 15
建议6：区别readonly和const的使用方法 / 16
建议7：将0值作为枚举的默认值 / 19
建议8：避免给枚举类型的元素提供显式的值 / 20
建议9：习惯重载运算符 / 22
建议10：创建对象时需要考虑是否实现比较器 / 23
建议11：区别对待==和Equals / 27
建议12：重写Equals时也要重写GetHashCode / 29
建议13：为类型输出格式化字符串 / 32
建议14：正确实现浅拷贝和深拷贝 / 36
建议15：使用dynamic来简化反射实现 / 40


第2章　集合和LINQ / 43
建议16：元素数量可变的情况下不应使用数组 / 43
建议17：多数情况下使用foreach进行循环遍历 / 45
建议18：foreach不能代替for / 51
建议19：使用更有效的对象和集合初始化 / 53
建议20：使用泛型集合代替非泛型集合 / 54
建议21：选择正确的集合 / 57
建议22：确保集合的线程安全 / 61
建议23：避免将List作为自定义集合类的基类 / 64
建议24：迭代器应该是只读的 / 67
建议25：谨慎集合属性的可写操作 / 68
建议26：使用匿名类型存储LINQ查询结果 / 70
建议27：在查询中使用Lambda表达式 / 73
建议28：理解延迟求值和主动求值之间的区别 / 75
建议29：区别LINQ查询中的IEnumerable和IQueryable / 78
建议30：使用LINQ取代集合中的比较器和迭代器 / 80
建议31：在LINQ查询中避免不必要的迭代 / 83


第3章　泛型、委托和事件 / 86
建议32：总是优先考虑泛型 / 86
建议33：避免在泛型类型中声明静态成员 / 88
建议34：为泛型参数设定约束 / 90
建议35：使用default为泛型类型变量指定初始值 / 92
建议36：使用FCL中的委托声明 / 94
建议37：使用Lambda表达式代替方法和匿名方法 / 96
建议38：小心闭包中的陷阱 / 99
建议39：了解委托的实质 / 103
建议40：使用event关键字为委托施加保护 / 106
建议41：实现标准的事件模型 / 108
建议42：使用泛型参数兼容泛型接口的不可变性 / 109
建议43：让接口中的泛型参数支持协变 / 111
建议44：理解委托中的协变 / 112
建议45：为泛型类型参数指定逆变 / 114


第4章　资源管理和序列化 / 116
建议46：显式释放资源需继承接口IDisposable / 116
建议47：即使提供了显式释放方法，也应该在终结器中提供隐式清理 / 119
建议48：Dispose方法应允许被多次调用 / 120
建议49：在Dispose模式中应提取一个受保护的虚方法 / 121
建议50：在Dispose模式中应区别对待托管资源和非托管资源 / 123
建议51：具有可释放字段的类型或拥有本机资源的类型应该是可释放的 / 124
建议52：及时释放资源 / 125
建议53：必要时应将不再使用的对象引用赋值为null / 127
建议54：为无用字段标注不可序列化 / 131
建议55：利用定制特性减少可序列化的字段 / 136
建议56：使用继承ISerializable接口更灵活地控制序列化过程 / 137
建议57：实现ISerializable的子类型应负责父类的序列化 / 140


第5章　异常与自定义异常 / 144
建议58：用抛出异常代替返回错误代码 / 144
建议59：不要在不恰当的场合下引发异常 / 147
建议60：重新引发异常时使用Inner Exception　/ 150
建议61：避免在finally内撰写无效代码 / 151
建议62：避免嵌套异常 / 157
建议63：避免“吃掉”异常 / 160
建议64：为循环增加Tester-Doer模式而不是将try-catch置于循环内 / 161
建议65：总是处理未捕获的异常 / 162
建议66：正确捕获多线程中的异常 / 166
建议67：慎用自定义异常 / 168
建议68：从System.Exception或其他常见的基本异常中派生异常 / 170
建议69：应使用finally避免资源泄漏 / 172
建议70：避免在调用栈较低的位置记录异常 / 175


第6章　异步、多线程、任务和并行 / 177
建议71：区分异步和多线程应用场景 / 177
建议72：在线程同步中使用信号量 / 180
建议73：避免锁定不恰当的同步对象 / 184
建议74：警惕线程的IsBackground / 188
建议75：警惕线程不会立即启动 / 189
建议76：警惕线程的优先级 / 191
建议77：正确停止线程 / 193
建议78：应避免线程数量过多 / 194
建议79：使用ThreadPool或BackgroundWorker代替Thread / 196
建议80：用Task代替ThreadPool / 198
建议81：使用Parallel简化同步状态下Task的使用 / 202
建议82：Parallel简化但不等同于Task默认行为 / 204
建议83：小心Parallel中的陷阱 / 205
建议84：使用PLINQ / 208
建议85：Task中的异常处理 / 209
建议86：Parallel中的异常处理 / 214
建议87：区分WPF和WinForm的线程模型 / 216
建议88：并行并不总是速度更快 / 220
建议89：在并行方法体中谨慎使用锁 / 222


第二部分　架构篇 
第7章　成员设计 / 226
建议90：不要为抽象类提供公开的构造方法 / 226
建议91：可见字段应该重构为属性 / 226
建议92：谨慎将数组或集合作为属性 / 227
建议93：构造方法应初始化主要属性和字段 / 228
建议94：区别对待override和new / 229
建议95：避免在构造方法中调用虚成员 / 235
建议96：成员应优先考虑公开基类型或接口 / 236
建议97：优先考虑将基类型或接口作为参数传递 / 237
建议98：用params减少重复参数 / 237
建议99：重写时不应使用子类参数 / 238
建议100：静态方法和实例方法没有区别 / 239
建议101：使用扩展方法，向现有类型“添加”方法 / 240


第8章　类型设计 / 243
建议102：区分接口和抽象类的应用场合 / 243
建议103：区分组合和继承的应用场合 / 245
建议104：用多态代替条件语句 / 248
建议105：使用私有构造函数强化单例 / 251
建议106：为静态类添加静态构造函数 / 253
建议107：区分静态类和单例 / 255
建议108：将类型标识为sealed / 255
建议109：谨慎使用嵌套类 / 256
建议110：用类来代替enum / 257
建议111：避免双向耦合 / 260
建议112：将现实世界中的对象抽象为类，将可复用对象圈起来就是命名空间 / 262


第9章　安全性设计 / 264
建议113：声明变量前考虑最大值 / 264
建议114：MD5不再安全 / 265
建议115：通过HASH来验证文件是否被篡改 / 268
建议116：避免用非对称算法加密文件 / 269
建议117：使用SSL确保通信中的数据安全 / 273
建议118：使用SecureString保存密钥等机密字符串 / 284
建议119：不要使用自己的加密算法 / 289
建议120：为程序集指定强名称 / 289
建议121：为应用程序设定运行权限 / 291


第三部分　编码规范及习惯 
第10章　命名规范 / 296
建议122：以.为命名空间命名 / 296
建议123：程序集不必与命名空间同名 / 296
建议124：考虑在命名空间中使用复数 / 297
建议125：避免用FCL的类型名称命名自己的类型 /　/ 297
建议126：用名词和名词组给类型命名 / 298
建议127：用形容词组给接口命名 / 299
建议128：考虑让派生类的名字以基类名字作为后缀 / 300
建议129：泛型类型参数要以T作为前缀 / 300
建议130：以复数命名枚举类型，以单数命名枚举元素 / 301
建议131：用PascalCasing命名公开元素 / 302
建议132：考虑用类名作为属性名 / 302
建议133：用camelCasing命名私有字段和局部变量　/ 303
建议134：有条件地使用前缀　/ 304
建议135： 考虑使用肯定性的短语命名布尔属性 / 305
建议136：优先使用后缀表示已有类型的新版本 / 306
建议137：委托和事件类型应添加上级后缀 / 307
建议138：事件和委托变量使用动词或形容词短语命名 / 308
建议139：事件处理器命名采用组合方式 / 309


第11章　代码整洁 / 311
建议140：使用默认的访问修饰符 / 311
建议141：不知道该不该用大括号时，就用 / 312
建议142：总是提供有意义的命名 / 314
建议143：方法抽象级别应在同一层次 / 315
建议144：一个方法只做一件事 / 316
建议145：避免过长的方法和过长的类 / 317
建议146：只对外公布必要的操作 / 318
建议147：重构多个相关属性为一个类 / 319
建议148：不重复代码 / 320
建议149：使用表驱动法避免过长的if和switch分支 / 321
建议150：使用匿名方法、Lambda表达式代替方法 / 324
建议151：使用事件访问器替换公开的事件成员变量　/ 325
建议152：最少，甚至是不要注释 / 326
建议153：若抛出异常，则必须要注释 / 326


第12章　规范开发行为 / 327
建议154：不要过度设计，在敏捷中体会重构的乐趣 / 327
建议155：随生产代码一起提交单元测试代码 / 336
建议156：利用特性为应用程序提供多个版本 / 342
建议157：从写第一个界面开始，就进行自动化测试　/ 344

====

#T=64 bits Process detect
namespace Test
{
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	using System.Management;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Version: " + Environment.OSVersion.VersionString);
			// Determine the whether the current OS is a 64-bit operating system. 
			Console.WriteLine("Current OS is {0}64-bit",
				Environment.Is64BitOperatingSystem ? "" : "not ");
			// Determine whether the current process is a 64-bit process. 
			Console.WriteLine("Current process is {0}64-bit",
				Environment.Is64BitProcess ? "" : "not ");
			// Determine whether an arbitrary process running on the system is 
			// a 64-bit process.
				int processId = Process.GetCurrentProcess().Id;
				string input = string.Empty;
				Console.WriteLine("请输入ProcessID");
				while ("q" != (input = Console.ReadLine()))
				{
					processId = int.Parse(input);
					IntPtr hProcess = 
							NativeMethods
								.OpenProcess
									(
										NativeMethods.PROCESS_QUERY_INFORMATION
										, false
										, processId
									);
					if (hProcess != IntPtr.Zero)
					{
						{
							// Detect whether the specified process is a 64-bit.
							bool is64bitProc = Is64BitProcess(hProcess);
							Console.WriteLine("Process {0} is {1}64-bit",
								processId.ToString(), is64bitProc ? "" : "not ");
						}
					}
				}
			
		}
		/// <summary>
		/// Determines whether the specified process is a 64-bit process.
		/// </summary>
		/// <param name="hProcess">The process handle</param>
		/// <returns>
		/// true if the given process is 64-bit; otherwise, false.
		/// </returns>
		static bool Is64BitProcess(IntPtr hProcess)
		{
			bool flag = false;
			if (Environment.Is64BitOperatingSystem)
			{
				// On 64-bit OS, if a process is not running under Wow64 mode, 
				// the process must be a 64-bit process.
				flag = !(NativeMethods.IsWow64Process(hProcess, out flag) && flag);
			}
			return flag;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	public static class NativeMethods
	{
		public const Int32 PROCESS_QUERY_INFORMATION = 0x0400;
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern IntPtr OpenProcess(int dwDesiredAccess,
			[MarshalAs(UnmanagedType.Bool)]bool bInheritHandle,
			int dwProcessId);
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool CloseHandle(IntPtr hObject);
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool IsWow64Process(IntPtr hProcess, out bool wow64Process);
	}
}
#T=aaa代码引用灰表格
<!-- 代码引用灰表格 -->
<table border="1" cellspacing="0" cellpadding="0"  bgcolor="#eeece1">
	<tr>
		<td>
<!-- begin code -->



<!-- end code -->
		</td>
	</tr>
</table>
#T=AccessibleObject MSAA
namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.Windows.Forms;
	public class Form1 : System.Windows.Forms.Form
	{
		// Test out the Chart Control.
		private ChartControl chart1;

		[STAThread]
		static void Main() 
		{
			Application.Run(new Form1());
		}

		public Form1() {
			// Create a chart control and add it to the form.
			this.chart1 = new ChartControl();
			this.ClientSize = new System.Drawing.Size(920, 566);

			this.chart1.Location = new System.Drawing.Point(47, 16);
			this.chart1.Size = new System.Drawing.Size(600, 400);

			this.Controls.Add(this.chart1);
		}
	}

	// Declare a chart control that demonstrates accessibility in Windows Forms.
	public class ChartControl : System.Windows.Forms.UserControl
	{
		private CurveLegend legend1;
		private CurveLegend legend2; 

		public ChartControl()
		{
			// The ChartControl draws the chart in the OnPaint override.
			SetStyle(ControlStyles.ResizeRedraw, true);
			SetStyle(ControlStyles.DoubleBuffer, true);
			SetStyle(ControlStyles.AllPaintingInWmPaint, true);

			this.BackColor = System.Drawing.Color.White;
			this.Name = "ChartControl";

			this.Click += new System.EventHandler(this.ChartControl_Click);
			this.QueryAccessibilityHelp += 
				new System.Windows.Forms.QueryAccessibilityHelpEventHandler(
										this.ChartControl_QueryAccessibilityHelp);

			// The CurveLengend is not Control-based, it just
			// represents the parts of the legend.
			legend1 = new CurveLegend(this, "A");
			legend1.Location = new Point(20, 30);
			legend2 = new CurveLegend(this, "B");		
			legend2.Location = new Point(20, 50);
		}

		// Overridden to return the custom AccessibleObject 
		// for the entire chart.
		protected override AccessibleObject CreateAccessibilityInstance() 
		{			
			return new ChartControlAccessibleObject(this);
		}

		protected override void OnPaint(PaintEventArgs e) 
		{
			// The ChartControl draws the chart in the OnPaint override.
			base.OnPaint(e);

			Rectangle bounds = this.ClientRectangle;
			int border = 5;

			// Draws the legends first.
			StringFormat format = new StringFormat();
			format.Alignment = StringAlignment.Center;
			format.LineAlignment = StringAlignment.Center;
			
			if (legend1 != null) {
				if (legend1.Selected) {
					e.Graphics.FillRectangle(new SolidBrush(Color.Blue), legend1.Bounds);
				} else {
					e.Graphics.DrawRectangle(Pens.Blue, legend1.Bounds);
				}

				e.Graphics.DrawString(legend1.Name, this.Font, Brushes.Black, legend1.Bounds, format);				
			}
			if (legend2 != null) {
				if (legend2.Selected) {
					e.Graphics.FillRectangle(new SolidBrush(Color.Red), legend2.Bounds);
				} else {
					e.Graphics.DrawRectangle(Pens.Red, legend2.Bounds);
				}
				e.Graphics.DrawString(legend2.Name, this.Font, Brushes.Black, legend2.Bounds, format);
			}			

			// Charts out the actual curves that represent data in the Chart.
			bounds.Inflate(-border, -border);
			Point[] curve1 = new Point[] {new Point(bounds.Left, bounds.Bottom),
							new Point(bounds.Left + bounds.Width / 3, bounds.Top + bounds.Height / 5),
							new Point(bounds.Right - bounds.Width / 3, (bounds.Top + bounds.Bottom) / 2),
							new Point(bounds.Right, bounds.Top)};

			Point[] curve2 = new Point[] {new Point(bounds.Left, bounds.Bottom - bounds.Height / 3),
							new Point(bounds.Left + bounds.Width / 3, bounds.Top + bounds.Height / 5),
							new Point(bounds.Right - bounds.Width / 3, (bounds.Top + bounds.Bottom) / 2),
							new Point(bounds.Right, bounds.Top + bounds.Height / 2)};

			// Draws the actual curve only if it is selected.
			if (legend1.Selected) e.Graphics.DrawCurve(Pens.Blue, curve1);
			if (legend2.Selected) e.Graphics.DrawCurve(Pens.Red, curve2);

			e.Graphics.DrawRectangle(Pens.Blue, bounds);			
		}

		// Handles the QueryAccessibilityHelp event.
		private void ChartControl_QueryAccessibilityHelp(object sender, 
									System.Windows.Forms.QueryAccessibilityHelpEventArgs e)
		{			
			e.HelpString = "Displays chart data";
		}		  

		// Handles the Click event for the chart. 
		// Toggles the selection of whatever legend was clicked on
		private void ChartControl_Click(object sender, System.EventArgs e)
		{
			Point pt = this.PointToClient(Control.MousePosition);
			if (legend1.Bounds.Contains(pt)) {
				legend1.Selected = !legend1.Selected;

			} else if (legend2.Bounds.Contains(pt)) {
				legend2.Selected = !legend2.Selected;
			}
		}

		// Gets an array of CurveLengends used in the Chart.
		public CurveLegend[] Legends
		{   
			get {				
				return new CurveLegend[] { legend1, legend2 };
			}			
		}				

		// Inner class ChartControlAccessibleObject represents accessible information associated with the ChartControl.
		// The ChartControlAccessibleObject is returned in the ChartControl.CreateAccessibilityInstance override.
		public class ChartControlAccessibleObject : ControlAccessibleObject
		{
			ChartControl chartControl;

			public ChartControlAccessibleObject(ChartControl ctrl) : base(ctrl) 
			{
				chartControl = ctrl;
			}

			// Gets the role for the Chart. This is used by accessibility programs.
			public override AccessibleRole Role
			{  
				get {
					return AccessibleRole.Chart;
				}
			}

			// Gets the state for the Chart. This is used by accessibility programs.
			public override AccessibleStates State
			{  
				get {					
					return AccessibleStates.ReadOnly;
				}
			}

			// The CurveLegend objects are "child" controls in terms of accessibility so 
			// return the number of ChartLengend objects.
			public override int GetChildCount()
			{  
				return chartControl.Legends.Length;
			}

			// Gets the Accessibility object of the child CurveLegend idetified by index.
			public override AccessibleObject GetChild(int index)
			{  
				if (index >= 0 && index < chartControl.Legends.Length) {
					return chartControl.Legends[index].AccessibilityObject;
				}				
				return null;
			}

			// Helper function that is used by the CurveLegend's accessibility object
			// to navigate between sibiling controls. Specifically, this function is used in
			// the CurveLegend.CurveLegendAccessibleObject.Navigate function.
			internal AccessibleObject NavigateFromChild(CurveLegend.CurveLegendAccessibleObject child, 
														AccessibleNavigation navdir) 
			{  
				switch(navdir) {
					case AccessibleNavigation.Down:
					case AccessibleNavigation.Next:
						return GetChild(child.ID + 1);
						
					case AccessibleNavigation.Up:
					case AccessibleNavigation.Previous:
						return GetChild(child.ID - 1);						
				}
				return null;
			}

			// Helper function that is used by the CurveLegend's accessibility object
			// to select a specific CurveLegend control. Specifically, this function is used
			// in the CurveLegend.CurveLegendAccessibleObject.Select function.
			internal void SelectChild(CurveLegend.CurveLegendAccessibleObject child, AccessibleSelection selection) 
			{   
				int childID = child.ID;

				// Determine which selection action should occur, based on the
				// AccessibleSelection value.
				if ((selection & AccessibleSelection.TakeSelection) != 0) {
					for(int i = 0; i < chartControl.Legends.Length; i++) {
						if (i == childID) {
							chartControl.Legends[i].Selected = true;						
						} else {
							chartControl.Legends[i].Selected = false;
						}
					}

					// AccessibleSelection.AddSelection means that the CurveLegend will be selected.
					if ((selection & AccessibleSelection.AddSelection) != 0) {
						chartControl.Legends[childID].Selected = true;						
					}

					// AccessibleSelection.AddSelection means that the CurveLegend will be unselected.
					if ((selection & AccessibleSelection.RemoveSelection) != 0) {
						chartControl.Legends[childID].Selected = false;						
					}
				}			
			}
		}

		// Inner Class that represents a legend for a curve in the chart.
		public class CurveLegend 
		{
			private string name;
			private ChartControl chart;
			private CurveLegendAccessibleObject accObj;
			private bool selected = true;
			private Point location;

			public CurveLegend(ChartControl chart, string name) 
			{
				this.chart = chart;
				this.name = name;
			}

			// Gets the accessibility object for the curve legend.
			public AccessibleObject AccessibilityObject
			{
				get {
					if (accObj == null) {
						accObj = new CurveLegendAccessibleObject(this);
					}
					return accObj;
				}
			}
			
			// Gets the bounds for the curve legend.
			public Rectangle Bounds
			{   
				get {
					return new Rectangle(Location, Size);
				}
			}

			// Gets or sets the location for the curve legend.
			public Point Location
			{   
				get {
					return location;
				}
				set {
					location = value;
					chart.Invalidate();

					// Notifies the chart of the location change. This is used for
					// the accessibility information. AccessibleEvents.LocationChange
					// tells the chart the reason for the notification.

					chart.AccessibilityNotifyClients(AccessibleEvents.LocationChange, 
						((CurveLegendAccessibleObject)AccessibilityObject).ID);
				}
			}			
		
			// Gets or sets the Name for the curve legend.
			public string Name
			{   
				get {
					return name;
				}
				set {
					if (name != value) 
					{
						name = value;
						chart.Invalidate();

						// Notifies the chart of the name change. This is used for
						// the accessibility information. AccessibleEvents.NameChange
						// tells the chart the reason for the notification.

						chart.AccessibilityNotifyClients(AccessibleEvents.NameChange, 
							((CurveLegendAccessibleObject)AccessibilityObject).ID);
					}
				}
			}

			// Gets or sets the Selected state for the curve legend.
			public bool Selected
			{   
				get {
					return selected;
				}
				set {
					if (selected != value) 
					{
						selected = value;
						chart.Invalidate();

						// Notifies the chart of the selection value change. This is used for
						// the accessibility information. The AccessibleEvents value depends upon
						// if the selection is true (AccessibleEvents.SelectionAdd) or 
						// false (AccessibleEvents.SelectionRemove).
						chart.AccessibilityNotifyClients(
							selected ? AccessibleEvents.SelectionAdd : AccessibleEvents.SelectionRemove, 
							((CurveLegendAccessibleObject)AccessibilityObject).ID);
					}
				}
			}

			// Gets the Size for the curve legend.
			public Size Size
			{   
				get {					
					int legendHeight = chart.Font.Height + 4;
					Graphics g = chart.CreateGraphics();
					int legendWidth = (int)g.MeasureString(Name, chart.Font).Width + 4;			

					return new Size(legendWidth, legendHeight);
				}
			}
	
			// Inner class CurveLegendAccessibleObject represents accessible information 
			// associated with the CurveLegend object.
			public class CurveLegendAccessibleObject : AccessibleObject
			{
				private CurveLegend curveLegend;

				public CurveLegendAccessibleObject(CurveLegend curveLegend) : base() 
				{
					this.curveLegend = curveLegend;					
				}				

				// Private property that helps get the reference to the parent ChartControl.
				private ChartControlAccessibleObject ChartControl
				{   
					get {
						return Parent as ChartControlAccessibleObject;
					}
				}

				// Internal helper function that returns the ID for this CurveLegend.
				internal int ID
				{
					get {
						for(int i = 0; i < ChartControl.GetChildCount(); i++) {
							if (ChartControl.GetChild(i) == this) {
								return i;
							}
						}
						return -1;
					}
				}

				// Gets the Bounds for the CurveLegend. This is used by accessibility programs.
				public override Rectangle Bounds
				{
					get {						
						// The bounds is in screen coordinates.
						Point loc = curveLegend.Location;
						return new Rectangle(curveLegend.chart.PointToScreen(loc), curveLegend.Size);
					}
				}

				// Gets or sets the Name for the CurveLegend. This is used by accessibility programs.
				public override string Name
				{
					get {
						return curveLegend.Name;
					}
					set {
						curveLegend.Name = value;						
					}
				}

				// Gets the Curve Legend Parent's Accessible object.
				// This is used by accessibility programs.
				public override AccessibleObject Parent
				{
					get {
						return curveLegend.chart.AccessibilityObject;
					}
				}

				// Gets the role for the CurveLegend. This is used by accessibility programs.
				public override AccessibleRole Role 
				{
					get {
						return AccessibleRole.StaticText;
					}
				}

				// Gets the state based on the selection for the CurveLegend. 
				// This is used by accessibility programs.
				public override AccessibleStates State 
				{
					get {
						AccessibleStates state = AccessibleStates.Selectable;
						if (curveLegend.Selected) 
						{
							state |= AccessibleStates.Selected;
						}
						return state;
					}
				}

				// Navigates through siblings of this CurveLegend. This is used by accessibility programs.
				public override AccessibleObject Navigate(AccessibleNavigation navdir) 
				{
					// Uses the internal NavigateFromChild helper function that exists
					// on ChartControlAccessibleObject.
					return ChartControl.NavigateFromChild(this, navdir);
				}

				// Selects or unselects this CurveLegend. This is used by accessibility programs.
				public override void Select(AccessibleSelection selection) 
				{
					// Uses the internal SelectChild helper function that exists
					// on ChartControlAccessibleObject.
					ChartControl.SelectChild(this, selection);
				}
			}
		}
	}
}


#T=ACL
namespace FileSystemExample
{
	using System;
	using System.IO;
	using System.Security.AccessControl;
	class FileExample
	{
		public static void Main()
		{
			try
			{
				string fileName = "test.xml";
				Console.WriteLine("Adding access control entry for "
					+ fileName);
				// Add the access control entry to the file.
				AddFileSecurity(fileName, @"DomainName\AccountName",
					FileSystemRights.ReadData, AccessControlType.Allow);
				Console.WriteLine("Removing access control entry from "
					+ fileName);
				// Remove the access control entry from the file.
				RemoveFileSecurity(fileName, @"DomainName\AccountName",
					FileSystemRights.ReadData, AccessControlType.Allow);
				Console.WriteLine("Done.");
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
			}
		}
		// Adds an ACL entry on the specified file for the specified account.
		public static void AddFileSecurity(string fileName, string account,
			FileSystemRights rights, AccessControlType controlType)
		{
			// Get a FileSecurity object that represents the
			// current security settings.
			FileSecurity fSecurity = File.GetAccessControl(fileName);
			// Add the FileSystemAccessRule to the security settings.
			fSecurity.AddAccessRule(new FileSystemAccessRule(account,
				rights, controlType));
			// Set the new access settings.
			File.SetAccessControl(fileName, fSecurity);
		}
		// Removes an ACL entry on the specified file for the specified account.
		public static void RemoveFileSecurity(string fileName, string account,
			FileSystemRights rights, AccessControlType controlType)
		{
			// Get a FileSecurity object that represents the
			// current security settings.
			FileSecurity fSecurity = File.GetAccessControl(fileName);
			// Remove the FileSystemAccessRule from the security settings.
			fSecurity.RemoveAccessRule(new FileSystemAccessRule(account,
				rights, controlType));
			// Set the new access settings.
			File.SetAccessControl(fileName, fSecurity);
		}
	}
}
#T=ACL NTFS
	using System;
	using System.Collections;
	using System.IO;
	using System.Security.AccessControl;
	static class Tester
	{
		public static void Main()
		{
			try
			{
				string filename = @"f:k"; //目标目录
				string account = @"Administrator";//用户名
				string userrights = @"RW";//权限字符串，自己定义的
				AddDirectorySecurity(filename, account, userrights);
				Console.ReadLine();
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
				Console.ReadLine();
			}
		}
		static public void AddDirectorySecurity(string FileName, string Account, string UserRights)
		{
			FileSystemRights Rights = new FileSystemRights();
			if (UserRights.IndexOf("R") >= 0)
			{
				Rights = Rights | FileSystemRights.Read;
			}
			if (UserRights.IndexOf("C") >= 0)
			{
				Rights = Rights | FileSystemRights.ChangePermissions;
			}
			if (UserRights.IndexOf("F") >= 0)
			{
				Rights = Rights | FileSystemRights.FullControl;
			}
			if (UserRights.IndexOf("W") >= 0)
			{
				Rights = Rights | FileSystemRights.Write;
			}
			bool ok;
			DirectoryInfo dInfo = new DirectoryInfo(FileName);
			DirectorySecurity dSecurity = dInfo.GetAccessControl();
			InheritanceFlags iFlags = new InheritanceFlags();
			iFlags = InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit;
			FileSystemAccessRule AccessRule2 = new FileSystemAccessRule(Account, Rights, iFlags, PropagationFlags.None, AccessControlType.Allow);
			 dSecurity.ModifyAccessRule(AccessControlModification.Add, AccessRule2, out ok);
			dInfo.SetAccessControl(dSecurity);
			//列出目标目录所具有的权限
			DirectorySecurity sec = Directory.GetAccessControl(FileName, AccessControlSections.All);
			foreach (FileSystemAccessRule rule in sec.GetAccessRules(true, true, typeof(System.Security.Principal.NTAccount)))
			{
				 Console.WriteLine("----------------------------------");
				 Console.WriteLine(rule.IdentityReference.Value);
				if ((rule.FileSystemRights & FileSystemRights.Read) != 0)
					 Console.WriteLine(rule.FileSystemRights.ToString());
			}
			 Console.Read();
		}
	}

#T=Active Directory Util
namespace AdTest			// Change namespace for your project
{
	using System;
	using System.DirectoryServices;		// Be sure to set a reference to "System.DirectoryServices.dll"


	// Structures for returning user information
	public struct UserInfo
	{
		public string LoginName;
		public string FirstName;
		public string LastName;
	}

	public struct UserInfoEx
	{
		public string LoginName;
		public string Password;
		public string FirstName;
		public string LastName;
		public string EmailAddress;
		public string Title;
		public string Company;
		public string Address;
		public string City;
		public string State;
		public string PostalCode;
		public string Phone;
		public string Country;
	}

	// Static class containing all the supported user property names
	public class UserProperty
	{
		public static string CommonName = "cn";
		public static string Password = "homePhone";
		public static string UserName = "sAMAccountName";
		public static string Country = "co";
		public static string Company = "company";
		public static string Department = "department";
		public static string Description = "description";
		public static string DisplayName = "displayName";
		public static string FirstName = "givenName";
		public static string City = "l";
		public static string Email = "mail";
		public static string PostalCode = "postalCode";
		public static string LastName = "sn";
		public static string State = "st";
		public static string Address = "streetAddress";
		public static string Phone = "telephoneNumber";
		public static string Title = "title";
	}

	// Active Directory Utility Class
	public class ADUtil
	{
		public ADUtil()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		#region Constants
		// *** SECURE CONSTANTS ***
		// Reality Check: In production, these would be stored in a secure are of the registry
		// or another secure location. In production, instead of "Administrator", an account
		// would be created which has ONLY the privileges it needs for the AD operations
		// and no more.

		// Domain Settings:
		const string usersLdapPath = "LDAP://MYDOMAIN.local/CN=Users, DC=MYDOMAIN, DC=local";
		const string adLoginName = "MYDOMAIN\\Administrator";
		const string adLoginPassword = "password";
		#endregion

		// GetUserCN - given the CMS user string, returns a friendly name for the user
		static public string GetUserCN (string username)
		{
			DirectoryEntry usersDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (usersDE);
			ds.Filter = "(sAMAccountName=" + username + ")";
			ds.PropertiesToLoad.Add (UserProperty.FirstName);
			ds.PropertiesToLoad.Add (UserProperty.LastName);
			SearchResult r = ds.FindOne();

			return (r.Properties[UserProperty.FirstName][0].ToString()
				    + " "
				    + r.Properties[UserProperty.LastName][0].ToString());
		}

		// GetUserInfo - given the CMS user string, returns user information
		static public UserInfo GetUserInfo (string username)
		{
			DirectoryEntry usersDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (usersDE);
			ds.Filter = "(sAMAccountName=" + username + ")";
			ds.PropertiesToLoad.Add ("cn");
			ds.PropertiesToLoad.Add (UserProperty.UserName);
			ds.PropertiesToLoad.Add (UserProperty.FirstName);
			ds.PropertiesToLoad.Add (UserProperty.LastName);
			SearchResult r = ds.FindOne();

			UserInfo result = new UserInfo();

			result.FirstName = r.Properties[UserProperty.FirstName][0].ToString();
			result.LastName = r.Properties[UserProperty.LastName][0].ToString();
			result.LoginName = r.Properties[UserProperty.UserName][0].ToString();

			return (result);
		}

		// GetUserInfoEx - given the CMS user string, returns user information
		static public UserInfoEx GetUserInfoEx (string username)
		{
			DirectoryEntry usersDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (usersDE);
			ds.Filter = "(sAMAccountName=" + username + ")";
			ds.PropertiesToLoad.Add ("cn");
			ds.PropertiesToLoad.Add (UserProperty.UserName);
			ds.PropertiesToLoad.Add (UserProperty.Password);
			ds.PropertiesToLoad.Add (UserProperty.FirstName);
			ds.PropertiesToLoad.Add (UserProperty.LastName);
			ds.PropertiesToLoad.Add (UserProperty.Email);
			ds.PropertiesToLoad.Add (UserProperty.Title);
			ds.PropertiesToLoad.Add (UserProperty.Company);
			ds.PropertiesToLoad.Add (UserProperty.Address);
			ds.PropertiesToLoad.Add (UserProperty.City);
			ds.PropertiesToLoad.Add (UserProperty.State);
			ds.PropertiesToLoad.Add (UserProperty.PostalCode);
			ds.PropertiesToLoad.Add (UserProperty.Phone);
			ds.PropertiesToLoad.Add (UserProperty.Country);
			SearchResult r = ds.FindOne();

			UserInfoEx result = new UserInfoEx();

			result.LoginName = r.Properties[UserProperty.UserName][0].ToString();
			if (r.Properties[UserProperty.FirstName] != null)
			{
				result.FirstName = r.Properties[UserProperty.FirstName][0].ToString();
			}
			else
			{
				result.FirstName = "";
			}
			if (r.Properties[UserProperty.Password] != null)
			{
				result.Password = r.Properties[UserProperty.Password][0].ToString();
			}
			else
			{
				result.Password = "";
			}
			if (r.Properties[UserProperty.LastName] != null)
			{
				result.LastName = r.Properties[UserProperty.LastName][0].ToString();
			}
			else
			{
				result.LastName = "";
			}
			if (r.Properties[UserProperty.Email] != null)
			{
				result.EmailAddress = r.Properties[UserProperty.Email][0].ToString();
			}
			else
			{
				result.EmailAddress = "";
			}
			if (r.Properties[UserProperty.Title] != null)
			{
				result.Title = r.Properties[UserProperty.Title][0].ToString();
			}
			else
			{
				result.Title = "";
			}
			if (r.Properties[UserProperty.Company] != null)
			{
				result.Company = r.Properties[UserProperty.Company][0].ToString();
			}
			else
			{
				result.Company = "";
			}
			if (r.Properties[UserProperty.Address] != null)
			{
				result.Address = r.Properties[UserProperty.Address][0].ToString();
			}
			else
			{
				result.Address = "";
			}
			if (r.Properties[UserProperty.City] != null)
			{
				result.City = r.Properties[UserProperty.City][0].ToString();
			}
			else
			{
				result.City = "";
			}
			if (r.Properties[UserProperty.State] != null)
			{
				result.State = r.Properties[UserProperty.State][0].ToString();
			}
			else
			{
				result.State = "";
			}
			if (r.Properties[UserProperty.PostalCode] != null)
			{
				result.PostalCode = r.Properties[UserProperty.PostalCode][0].ToString();
			}
			else
			{
				result.PostalCode = "";
			}
			if (r.Properties[UserProperty.Phone] != null)
			{
				result.Phone = r.Properties[UserProperty.Phone][0].ToString();
			}
			else
			{
				result.Phone = "";
			}
			if (r.Properties[UserProperty.Country] != null)
			{
				result.Country = r.Properties[UserProperty.Country][0].ToString();
			}
			else
			{
				result.Country = "";
			}

			return (result);
		}

		// UpdateUserProperty - Updates a property for the AD User
		static public void UpdateUserProperty (string username, string propertyName,
						string propertyValue)
		{
			// First, get a DE for the user
			DirectoryEntry userContainerDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (userContainerDE);
			ds.Filter = "(sAMAccountName=" + username + ")";
			ds.PropertiesToLoad.Add ("cn");
			SearchResult r = ds.FindOne();
			DirectoryEntry theUserDE = new DirectoryEntry (r.Path, adLoginName, adLoginPassword);

			// Now update the property setting
			if (theUserDE.Properties[propertyName].Count == 0)
			{
				theUserDE.Properties[propertyName].Add (propertyValue);
			}
			else
			{
				theUserDE.Properties[propertyName][0] = propertyValue;
			}
			theUserDE.CommitChanges();
		}


		// GetAdGroups - Return all Active Directory security groups with a given prefix
		static private string[] GetAdGroups(string prefix)
		{
			string [] results;

			DirectoryEntry groupsDE = new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher groupsDS = new DirectorySearcher (groupsDE);
			groupsDS.Filter = "(&(objectClass=group)(CN=" + prefix + "*))";
			groupsDS.PropertiesToLoad.Add ("cn");
			SearchResultCollection sr = groupsDS.FindAll();

			results = new String [sr.Count];

			for (int i=0; i<sr.Count; i++)
			{
				SearchResult r = sr[i];
				results[i] = r.Properties["cn"][0].ToString();
			}

			return (results);
		}

		// GetGroupsForUser - Returns all groups the user belongs to
		static public string [] GetGroupsForUser (string username)
		{
			string [] results;

			DirectoryEntry usersDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (usersDE);
			ds.Filter = "(sAMAccountName=" + username + ")";
			ds.PropertiesToLoad.Add ("memberof");
			SearchResultCollection sr = ds.FindAll();
			SearchResult r = sr[0];

			if (r.Properties["memberof"] == null)
			{
				return (null);
			}

			results = new string [r.Properties["memberof"].Count];
			for (int i=0; i<r.Properties["memberof"].Count; i++)
			{
				string theGroupPath = r.Properties["memberof"][i].ToString();
				results[i] = theGroupPath.Substring (3, theGroupPath.IndexOf (",")-3);
			}

			return (results);
		}
		
		// FindUsers - Returns all users matching a pattern
		static public UserInfo [] FindUsers (string username)
		{
			UserInfo [] results;

			DirectoryEntry usersDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (usersDE);
			ds.Filter = "(&(objectClass=user)(sAMAccountName=" + username + "*))";
			ds.PropertiesToLoad.Add (UserProperty.UserName);
			ds.PropertiesToLoad.Add (UserProperty.FirstName);
			ds.PropertiesToLoad.Add (UserProperty.LastName);

			SearchResultCollection sr = ds.FindAll();

			results = new UserInfo [sr.Count];

			for (int i=0; i<sr.Count; i++)
			{
				results[i].LoginName = sr[i].Properties[UserProperty.UserName][0].ToString();
				if (sr[i].Properties[UserProperty.FirstName] != null)
				{
					results[i].FirstName = sr[i].Properties[UserProperty.FirstName][0].ToString();
				}
				else
				{
					results[i].FirstName = "";
				}
				if (sr[i].Properties[UserProperty.LastName] != null)
				{
					results[i].LastName = sr[i].Properties[UserProperty.LastName][0].ToString();
				}
				else
				{
					results[i].LastName = "";
				}
			}

			return (results);
		}

		// AddUserToGroup - Adds user to a specified group
		static public void AddUserToGroup (string username, string groupName)
		{
			// First, get a DE for the user
			DirectoryEntry userContainerDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (userContainerDE);
			ds.Filter = "(sAMAccountName=" + username + ")";
			ds.PropertiesToLoad.Add ("cn");
			SearchResult r = ds.FindOne();
			DirectoryEntry theUserDE = new DirectoryEntry (r.Path, adLoginName, adLoginPassword);

			// Now get a DE for the group
			ds.Filter = "(cn=" + groupName + ")";
			r = ds.FindOne();
			DirectoryEntry theGroupDE = new DirectoryEntry (r.Path, adLoginName, adLoginPassword);

			// Next we extract the user path from the LDAP string
			string userPath = theUserDE.Path;
			userPath = userPath.Substring (userPath.IndexOf("CN="));

			// Now add the user to the group
			theGroupDE.Properties["member"].Add (userPath);
			theGroupDE.CommitChanges();
		}

		// RemoveUserFromGroup - Removes user from a specified group
		static public void RemoveUserFromGroup (string username, string groupName)
		{
			// First, get a DE for the user
			DirectoryEntry userContainerDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (userContainerDE);
			ds.Filter = "(sAMAccountName=" + username + ")";
			ds.PropertiesToLoad.Add ("cn");
			SearchResult r = ds.FindOne();
			DirectoryEntry theUserDE = new DirectoryEntry (r.Path, adLoginName, adLoginPassword);

			// Now get a DE for the group
			ds.Filter = "(cn=" + groupName + ")";
			r = ds.FindOne();
			DirectoryEntry theGroupDE = new DirectoryEntry (r.Path, adLoginName, adLoginPassword);

			// Next we extract the user path from the LDAP string
			string userPath = theUserDE.Path;
			userPath = userPath.Substring (userPath.IndexOf("CN="));

			// Now add the user to the group
			theGroupDE.Properties["member"].Remove (userPath);
			theGroupDE.CommitChanges();
		}

		// AddNewUser - Creates a new user account
		static public void AddNewUser (string username, string password, string firstName,
									   string lastName,	string description)
		{
			DirectoryEntry userContainerDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);

			DirectoryEntry newUser = userContainerDE.Children.Add ("CN="+username, "user");
			newUser.Invoke ("Put", new object [] {UserProperty.Description, description});
			newUser.Invoke ("Put", new object [] {UserProperty.UserName, username});
			newUser.Invoke ("Put", new object [] {UserProperty.LastName, lastName});
			newUser.Invoke ("Put", new object [] {UserProperty.FirstName, firstName});
			newUser.Invoke ("Put", new object [] {UserProperty.Password, password});
			newUser.CommitChanges();

			newUser.Invoke ("SetPassword", new object[] {password});
			int userFlags = (int) newUser.Properties["userAccountControl"][0];
			userFlags = userFlags & 0xFFFD;
			newUser.Properties["userAccountControl"][0] = userFlags;
			newUser.CommitChanges();
		}

		static public void ChangeUserPassword (string username, string newPassword)
		{
			// First, get a DE for the user
			DirectoryEntry userContainerDE =
				new DirectoryEntry (usersLdapPath, adLoginName, adLoginPassword);
			DirectorySearcher ds = new DirectorySearcher (userContainerDE);
			ds.Filter = "(sAMAccountName=" + username + ")";
			ds.PropertiesToLoad.Add ("cn");
			SearchResult r = ds.FindOne();
			DirectoryEntry theUserDE = new DirectoryEntry (r.Path, adLoginName, adLoginPassword);

			// Now update the property setting
			if (theUserDE.Properties[UserProperty.Password].Count == 0)
			{
				theUserDE.Properties[UserProperty.Password].Add (newPassword);
			}
			else
			{
				theUserDE.Properties[UserProperty.Password][0] = newPassword;
			}
			theUserDE.CommitChanges();

			// Now update the password
			theUserDE.Invoke ("SetPassword", new object[] {newPassword});
			theUserDE.CommitChanges();
		}

	}
}

#T=ActiveX IE simple
//namespace Microshaoft
//{
	using System;
	//using System.Reflection;
	//using System.Runtime.CompilerServices;
	using System.Runtime.InteropServices;
	[assembly: ComVisible(true)]
	[assembly: Guid("f25acdc9-9218-4121-a1ba-242677206b0e")]
//}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Runtime.InteropServices;
	[ComImport, Guid("CB5BDC81-93C1-11CF-8F20-00805F2CD064")]
	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
	public interface IObjectSafety
	{
		[PreserveSig]
		int GetInterfaceSafetyOptions
						(
							ref Guid riid
							, [MarshalAs(UnmanagedType.U4)] ref int pdwSupportedOptions
							, [MarshalAs(UnmanagedType.U4)] ref int pdwEnabledOptions
						);
		[PreserveSig()]
		int SetInterfaceSafetyOptions(ref Guid riid, [MarshalAs(UnmanagedType.U4)] int dwOptionSetMask, [MarshalAs(UnmanagedType.U4)] int dwEnabledOptions);
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Management;
	using System.Runtime.InteropServices;
	using System.Text;
	[Guid("65D8E97F-D3E2-462A-B389-241D7C38C518")]
	public class MacActiveX : ActiveXControl
	{
		public string Hello(string who)
		{
			return string.Format("{1}{0}{2}", ":", "hello", who);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	public abstract class ActiveXControl : IObjectSafety
	{
		#region IObjectSafety 成员
		private const string _IID_IDispatch = "{00020400-0000-0000-C000-000000000046}";
		private const string _IID_IDispatchEx = "{a6ef9860-c720-11d0-9337-00a0c90dcaa9}";
		private const string _IID_IPersistStorage = "{0000010A-0000-0000-C000-000000000046}";
		private const string _IID_IPersistStream = "{00000109-0000-0000-C000-000000000046}";
		private const string _IID_IPersistPropertyBag = "{37D84F60-42CB-11CE-8135-00AA004BB851}";
		private const int INTERFACESAFE_FOR_UNTRUSTED_CALLER = 0x00000001;
		private const int INTERFACESAFE_FOR_UNTRUSTED_DATA = 0x00000002;
		private const int S_OK = 0;
		private const int E_FAIL = unchecked((int)0x80004005);
		private const int E_NOINTERFACE = unchecked((int)0x80004002);
		private bool _fSafeForScripting = true;
		private bool _fSafeForInitializing = true;
		public int GetInterfaceSafetyOptions
							(
								ref Guid riid
								, ref int pdwSupportedOptions
								, ref int pdwEnabledOptions
							)
		{
			int Rslt = E_FAIL;
			string strGUID = riid.ToString("B");
			pdwSupportedOptions =
									INTERFACESAFE_FOR_UNTRUSTED_CALLER
									| INTERFACESAFE_FOR_UNTRUSTED_DATA;
			switch (strGUID)
			{
				case _IID_IDispatch:
				case _IID_IDispatchEx:
					Rslt = S_OK;
					pdwEnabledOptions = 0;
					if (_fSafeForScripting == true)
					{
						pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
					}
					break;
				case _IID_IPersistStorage:
				case _IID_IPersistStream:
				case _IID_IPersistPropertyBag:
					Rslt = S_OK;
					pdwEnabledOptions = 0;
					if (_fSafeForInitializing == true)
					{
						pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
					}
					break;
				default:
					Rslt = E_NOINTERFACE;
					break;
			}
			return Rslt;
		}
		public int SetInterfaceSafetyOptions(ref Guid riid, int dwOptionSetMask, int dwEnabledOptions)
		{
			int Rslt = E_FAIL;
			string strGUID = riid.ToString("B");
			switch (strGUID)
			{
				case _IID_IDispatch:
				case _IID_IDispatchEx:
					if
						(
							(
								(dwEnabledOptions & dwOptionSetMask) == INTERFACESAFE_FOR_UNTRUSTED_CALLER
							)
							&& (_fSafeForScripting == true)
						)
					{
						Rslt = S_OK;
					}
					break;
				case _IID_IPersistStorage:
				case _IID_IPersistStream:
				case _IID_IPersistPropertyBag:
					if
						(
							(
								(dwEnabledOptions & dwOptionSetMask) == INTERFACESAFE_FOR_UNTRUSTED_DATA
							)
							&& (_fSafeForInitializing == true)
						)
					{
						Rslt = S_OK;
					}
					break;
				default:
					Rslt = E_NOINTERFACE;
					break;
			}
			return Rslt;
		}
		#endregion
	}
}
/*
Microshaoft.ActiveX.INF
=========================================================
[version]
signature="$CHICAGO$"
AdvancedINF=2.0
[Setup Hooks]
install=install
[install]
run=msiexec.exe /package %EXTRACT_DIR%\Setup1.msi /qn
=========================================================
MakecabArgs.ddf
=========================================================
.OPTION EXPLICIT
.Set DiskDirectoryTemplate=cab
.Set CabinetNameTemplate=DemoCSharpActiveX.cab
Setup1.msi
Microshaoft.ActiveX.inf
=========================================================
%WINDIR%\System32\Makecab.exe /f MakecabArgs.ddf
=========================================================
TestActiveX.html
=========================================================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title> new document </title>
	<META NAME="Generator" CONTENT="EditPlus,Microshaoft">
	<META NAME="Author" CONTENT="EditPlus,Microshaoft">
	<META NAME="Keywords" CONTENT="EditPlus,Microshaoft">
	<META NAME="Description" CONTENT="EditPlus,Microshaoft">
</head>
<body>
<object id="foo" classid="clsid:65D8E97F-D3E2-462A-B389-241D7C38C518" codebase="DemoCSharpActiveX.cab"></object>
<input type="button" value="test" onclick="alert(foo.Hello('asdsa'));" />
</body>
</html>
*/
#T=Alt-Tab 不可见
			this.ControlBox = false;
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Text = "";
			this.ShowInTaskbar = false;
#T=AntiXss Library v2.0
namespace Microshaoft
{
	using System;
	using System.Text;

	public class AntiXss
	{
		// Fields
		private const string EmptyString_JavaScript = "''";
		private const string EmptyString_VBS = "\"\"";

		// Methods
		private static string EncodeHtml(string strInput)
		{
			if (strInput == null)
			{
				return null;
			}
			if (strInput.Length == 0)
			{
				return string.Empty;
			}
			StringBuilder builder = new StringBuilder("", strInput.Length * 2);
			foreach (char ch in strInput)
			{
				if ((((ch > '`') && (ch < '{')) || ((ch > '@') && (ch < '['))) || (((ch == ' ') || ((ch > '/') && (ch < ':'))) || (((ch == '.') || (ch == ',')) || ((ch == '-') || (ch == '_')))))
				{
					builder.Append(ch);
				}
				else
				{
					builder.Append("&#" + ((int) ch).ToString() + ";");
				}
			}
			return builder.ToString();
		}

		private static string EncodeHtmlAttribute(string strInput)
		{
			if (strInput == null)
			{
				return null;
			}
			if (strInput.Length == 0)
			{
				return string.Empty;
			}
			StringBuilder builder = new StringBuilder("", strInput.Length * 2);
			foreach (char ch in strInput)
			{
				if ((((ch > '`') && (ch < '{')) || ((ch > '@') && (ch < '['))) || (((ch > '/') && (ch < ':')) || (((ch == '.') || (ch == ',')) || ((ch == '-') || (ch == '_')))))
				{
					builder.Append(ch);
				}
				else
				{
					builder.Append("&#" + ((int) ch).ToString() + ";");
				}
			}
			return builder.ToString();
		}

		private static string EncodeJs(string strInput)
		{
			if (strInput == null)
			{
				return null;
			}
			if (strInput.Length == 0)
			{
				return "''";
			}
			StringBuilder builder = new StringBuilder("'", strInput.Length * 2);
			foreach (char ch in strInput)
			{
				if ((((ch > '`') && (ch < '{')) || ((ch > '@') && (ch < '['))) || (((ch == ' ') || ((ch > '/') && (ch < ':'))) || (((ch == '.') || (ch == ',')) || ((ch == '-') || (ch == '_')))))
				{
					builder.Append(ch);
				}
				else if (ch > '\x007f')
				{
					builder.Append(@"\u" + TwoByteHex(ch));
				}
				else
				{
					builder.Append(@"\x" + SingleByteHex(ch));
				}
			}
			builder.Append("'");
			return builder.ToString();
		}

		private static string EncodeUrl(string strInput)
		{
			if (strInput == null)
			{
				return null;
			}
			if (strInput.Length == 0)
			{
				return string.Empty;
			}
			StringBuilder builder = new StringBuilder("", strInput.Length * 2);
			foreach (char ch in strInput)
			{
				if ((((ch > '`') && (ch < '{')) || ((ch > '@') && (ch < '['))) || (((ch > '/') && (ch < ':')) || (((ch == '.') || (ch == '-')) || (ch == '_'))))
				{
					builder.Append(ch);
				}
				else if (ch > '\x007f')
				{
					builder.Append("%u" + TwoByteHex(ch));
				}
				else
				{
					builder.Append("%" + SingleByteHex(ch));
				}
			}
			return builder.ToString();
		}

		private static string EncodeVbs(string strInput)
		{
			if (strInput == null)
			{
				return null;
			}
			if (strInput.Length == 0)
			{
				return "\"\"";
			}
			StringBuilder builder = new StringBuilder("", strInput.Length * 2);
			bool flag = false;
			foreach (char ch in strInput)
			{
				if ((((ch > '`') && (ch < '{')) || ((ch > '@') && (ch < '['))) || (((ch == ' ') || ((ch > '/') && (ch < ':'))) || (((ch == '.') || (ch == ',')) || ((ch == '-') || (ch == '_')))))
				{
					if (!flag)
					{
						builder.Append("&\"");
						flag = true;
					}
					builder.Append(ch);
				}
				else
				{
					if (flag)
					{
						builder.Append("\"");
						flag = false;
					}
					builder.Append("&chrw(" + ((uint) ch).ToString() + ")");
				}
			}
			if ((builder.Length > 0) && (builder[0] == '&'))
			{
				builder.Remove(0, 1);
			}
			if (builder.Length == 0)
			{
				builder.Insert(0, "\"\"");
			}
			if (flag)
			{
				builder.Append("\"");
			}
			return builder.ToString();
		}

		private static string EncodeXml(string strInput)
		{
			return EncodeHtml(strInput);
		}

		private static string EncodeXmlAttribute(string strInput)
		{
			return EncodeHtmlAttribute(strInput);
		}

		public static string HtmlAttributeEncode(string s)
		{
			return EncodeHtmlAttribute(s);
		}

		public static string HtmlEncode(string s)
		{
			return EncodeHtml(s);
		}

		public static string JavaScriptEncode(string s)
		{
			return EncodeJs(s);
		}

		private static string SingleByteHex(char c)
		{
			uint num = c;
			return num.ToString("x").PadLeft(2, '0');
		}

		private static string TwoByteHex(char c)
		{
			uint num = c;
			return num.ToString("x").PadLeft(4, '0');
		}

		public static string UrlEncode(string s)
		{
			return EncodeUrl(s);
		}

		public static string VisualBasicScriptEncode(string s)
		{
			return EncodeVbs(s);
		}

		public static string XmlAttributeEncode(string s)
		{
			return EncodeXmlAttribute(s);
		}

		public static string XmlEncode(string s)
		{
			return EncodeXml(s);
		}
	}
}
#T=AntiXss Library v3.0
namespace Microsoft.Security.Application
{
	#region Namespaces
	using System;
	using System.Drawing;
	using System.Web;
	using System.Text;
	#endregion
	#region Namespace - Microsoft.Security.Application
	public class AntiXss
	{
		#region MEMBERS
		///---------------------------------------------------------------------
		/// <summary>
		///	 Empty string for Visual Basic Script contextes
		/// </summary>
		///---------------------------------------------------------------------
		private const string EmptyStringVBS = "\"\"";
		///---------------------------------------------------------------------
		/// <summary>
		///	 Empty string for Java Script contextes
		/// </summary>
		///---------------------------------------------------------------------
		private const string EmptyStringJavaScript = "''";
		#region WHITELIST_CHAR_ARRAY_INITIALIZATION
		/// <summary>
		/// Initializes character Html encoding array
		/// </summary>
		private static char[][] WhitelistCodes = InitWhitelistCodes();
		private static char[][] InitWhitelistCodes()
		{
			char[][] allCharacters = new char[65536][];
			char[] thisChar;
			for (int i = 0; i < allCharacters.Length; i++)
			{
				if (
					(i >= 97 && i <= 122) ||		// a-z
					(i >= 65 && i <= 90) ||		 // A-Z
					(i >= 48 && i <= 57) ||		 // 0-9
					i == 32 ||					  // space
					i == 46 ||					  // .
					i == 44 ||					  // ,
					i == 45 ||					  // -
					i == 95 ||					  // _
					(i >= 256 && i <= 591) ||	   // Latin,Extended-A,Latin Extended-B
					(i >= 880 && i <= 2047) ||	  // Greek and Coptic,Cyrillic,Cyrillic Supplement,Armenian,Hebrew,Arabic,Syriac,Arabic,Supplement,Thaana,NKo
					(i >= 2304 && i <= 6319) ||	 // Devanagari,Bengali,Gurmukhi,Gujarati,Oriya,Tamil,Telugu,Kannada,Malayalam,Sinhala,Thai,Lao,Tibetan,Myanmar,eorgian,Hangul Jamo,Ethiopic,Ethiopic Supplement,Cherokee,Unified Canadian Aboriginal Syllabics,Ogham,Runic,Tagalog,Hanunoo,Buhid,Tagbanwa,Khmer,Mongolian
					(i >= 6400 && i <= 6687) ||	 // Limbu, Tai Le, New Tai Lue, Khmer, Symbols, Buginese
					(i >= 6912 && i <= 7039) ||	 // Balinese
					(i >= 7680 && i <= 8191) ||	 // Latin Extended Additional, Greek Extended
					(i >= 11264 && i <= 11743) ||   // Glagolitic, Latin Extended-C, Coptic, Georgian Supplement, Tifinagh, Ethiopic Extended
					(i >= 12352 && i <= 12591) ||   // Hiragana, Katakana, Bopomofo
					(i >= 12688 && i <= 12735) ||   // Kanbun, Bopomofo Extended
					(i >= 12784 && i <= 12799) ||   // Katakana, Phonetic Extensions
					(i >= 40960 && i <= 42191) ||   // Yi Syllables, Yi Radicals
					(i >= 42784 && i <= 43055) ||   // Latin Extended-D, Syloti, Nagri
					(i >= 43072 && i <= 43135) ||   // Phags-pa
					(i >= 44032 && i <= 55215) ||   // Hangul Syllables
					(i >= 19968 && i <= 40899)	  // Mixed japanese/chinese/korean
				)
				{
					allCharacters[i] = null;
				}
				else
				{
					string iString = i.ToString();
					int iStringLen = iString.Length;
					thisChar = new char[iStringLen];	 // everything else
					for (int j = 0; j < iStringLen; j++)
					{
						thisChar[j] = iString[j];
					}
					allCharacters[i] = thisChar;
				}
			}
			return allCharacters;
		}
		#endregion
		#endregion
		#region Encoding Methods
		#region HTMLEncode - string input
		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input strings for use in HTML.
		/// </summary>
		/// <param name="input">String to be encoded</param>
		/// <returns>
		///	 Encoded string for use in HTML.
		/// </returns>
		/// <remarks>
		/// This function will encode all but known safe characters.  Encoded characters are encoded using the &amp;#DECIMAL; notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>,</term><description>Comma</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Space</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSS Attack!');</term><description>alert&#40;&#39;XSS Attack&#33;&#39;&#41;&#59;</description></item>
		/// <item><term>user@contoso.com</term><description>user&#64;contoso.com</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>Anti-Cross Site Scripting Library</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string HtmlEncode(string input)
		{
			if (String.IsNullOrEmpty(input))
			{
				return string.Empty;
			}
			// Use a new char array.
			int len = 0;
			int tLen = input.Length;
			char[] returnMe = new char[tLen * 8];
			char[] thisChar;
			int thisCharID;
			for (int i = 0; i < tLen; i++)
			{
				thisCharID = (int)input[i];
				if (WhitelistCodes[thisCharID] != null)
				{
					// character needs to be encoded
					thisChar = WhitelistCodes[thisCharID];
					returnMe[len++] = '&';
					returnMe[len++] = '#';
					for (int j = 0; j < thisChar.Length; j++)
					{
						returnMe[len++] = thisChar[j];
					}
					returnMe[len++] = ';';
				}
				else
				{
					// character does not need encoding
					returnMe[len++] = input[i];
				}
			}
			return new String(returnMe, 0, len);
		}
		#endregion
		#region HTMLEncode - string input, KnownColor clr
		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input string and embeds in a SPAN tag for use in HTML.
		/// </summary>
		/// <param name="input">String to be encoded</param>
		/// <param name="clr">KnownColor like System.Drawing.KnownColor.CadetBlue</param>
		/// <returns>
		///	 Encoded string embebded within SPAN tag and style settings for use in HTML.
		/// </returns>
		/// <remarks>
		/// This function will encode all but known safe characters.  Encoded characters are encoded using the &amp;#DECIMAL; notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>,</term><description>Comma</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Space</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSS Attack!');</term><description><div style='background-color : #ffffff'>alert&#40;&#39;XSS Attack&#33;&#39;&#41;&#59;</div></description></item>
		/// <item><term>user@contoso.com</term><description>user&#64;contoso.com</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>Anti-Cross Site Scripting Library</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string HtmlEncode(string input, KnownColor clr)
		{
			//HTMLEncode will handle the encoding
			// This check is for making sure that bgcolor is required or not.
			if (HttpContext.Current.Request.QueryString["MarkAntiXssOutput"] != null)
			{
				string returnInput = "<span name='#markantixssoutput' style ='background-color : " + Color.FromKnownColor(clr).Name + "'>" + HtmlEncode(input) + "</span>";
				return returnInput;
			}
			else
			{
				return HtmlEncode(input);
			}
		}
		#endregion
		#region HTMLAttributeEncode_Method
		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input strings for use in HTML attributes.
		/// </summary>
		/// <param name="input">String to be encoded</param>
		/// <returns>
		///	 Encoded string for use in HTML attributes.
		/// </returns>
		/// <remarks>
		/// This function will encode all but known safe characters.  Encoded characters are encoded using the &amp;#DECIMAL; notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>,</term><description>Comma</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSS Attack!');</term><description>alert&#40;&#39;XSS&#32;Attack&#33;&#39;&#41;&#59;</description></item>
		/// <item><term>user@contoso.com</term><description>user&#64;contoso.com</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>Anti-Cross&#32;Site&#32;Scripting&#32;Library</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string HtmlAttributeEncode(string input)
		{
			if (String.IsNullOrEmpty(input))
			{
				return string.Empty;
			}
			// Use a new char array.
			int len = 0;
			int tLen = input.Length;
			char[] returnMe = new char[tLen * 8]; // worst case length scenario
			char[] thisChar;
			int thisCharID;
			for (int i = 0; i < tLen; i++)
			{
				thisCharID = (int)input[i];
				if ((WhitelistCodes[thisCharID] != null)
					|| (thisCharID == 32)   //escaping space for HTMLAttribute Encoding
					)
				{
					// character needs to be encoded
					thisChar = WhitelistCodes[thisCharID];
					returnMe[len++] = '&';
					returnMe[len++] = '#';
					if (thisCharID == 32)
					{
						returnMe[len++] = '3';
						returnMe[len++] = '2';
					}
					else
					{
						for (int j = 0; j < thisChar.Length; j++)
						{
							returnMe[len++] = thisChar[j];
						}
					}
					returnMe[len++] = ';';
				}
				else
				{
					// character does not need encoding
					returnMe[len++] = input[i];
				}
			}
			return new String(returnMe, 0, len);
		}
		#endregion
		#region URLEncode_Method
		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input strings for use in universal resource locators (URLs).
		/// </summary>
		/// <param name="input">String to be encoded</param>
		/// <returns>
		///	 Encoded string for use in URLs.
		/// </returns>
		/// <remarks>
		/// This function will encode all but known safe characters.  Encoded characters are encoded using the %SINGLE_BYTE_HEX and %uDOUBLE_BYTE_HEX notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSS Attack!');</term><description>alert%28%27XSS%20Attack%21%27%29%3b</description></item>
		/// <item><term>user@contoso.com</term><description>user%40contoso.com</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>Anti-Cross%20Site%20Scripting%20Library</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string UrlEncode(string input)
		{
			if (String.IsNullOrEmpty(input))
			{
				return string.Empty;
			}
			// Use a new char array.
			int len = 0;
			int tLen = input.Length;
			int thisCharID;
			string thisChar;
			char ch;
			Encoding inputEncoding = null;
			// Use a new char array.
			char[] returnMe = new char[tLen * 24];
			for (int i = 0; i < tLen; i++)
			{
				thisCharID = (int)input[i];
				thisChar = input[i].ToString();
				if ((WhitelistCodes[thisCharID] != null)
					|| (thisCharID == 32) || (thisCharID == 44)	//escaping SPACE and COMMA for URL Encoding
					 )
				{
					// Character needs to be encoded to default UTF-8.
					inputEncoding = Encoding.UTF8;
					byte[] inputEncodingBytes = inputEncoding.GetBytes(thisChar);
					int noinputEncodingBytes = inputEncodingBytes.Length;
					for (int index = 0; index < noinputEncodingBytes; index++)
					{
						ch = (char)inputEncodingBytes[index];
						// character needs to be encoded. Infact the byte cannot be greater than 256.
						if (ch <= 256)
						{
							returnMe[len++] = '%';
							string hex = ((int)ch).ToString("x").PadLeft(2, '0');
							returnMe[len++] = hex[0];
							returnMe[len++] = hex[1];
						}
					}
				}
				else
				{
					// character does not need encoding
					returnMe[len++] = input[i];
				}
			}
			return new String(returnMe, 0, len);
		}

		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input strings for use in universal resource locators (URLs).
		/// </summary>
		/// <param name="input">Input string</param>
		/// <param name="codepage">Codepage number of the input</param>
		/// <returns>
		///	 Encoded string for use in URLs.
		/// </returns>
		/// <remarks>
		/// This function will encodes the output as per the encoding parameter (codepage) passed to it. It will encode all but known safe characters.  Encoded characters are encoded using the %SINGLE_BYTE_HEX and %DOUBLE_BYTE_HEX notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSSあAttack!');</term><description>alert%28%27XSS%82%a0Attack%21%27%29%3b</description></item>
		/// <item><term>user@contoso.com</term><description>user%40contoso.com</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>Anti-Cross%20Site%20Scripting%20Library</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string UrlEncode(string input, int codepage)
		{
			if (String.IsNullOrEmpty(input))
			{
				return string.Empty;
			}
			int len = 0;
			int thisCharID;
			int tLen = input.Length;
			char ch;
			string thisChar;
			Encoding inputEncoding = null;
			// Use a new char array.
			char[] returnMe = new char[tLen * 24]; // worst case length scenario
			for (int i = 0; i < tLen; i++)
			{
				thisCharID = (int)input[i];
				thisChar = input[i].ToString();
				if ((WhitelistCodes[thisCharID] != null)
					|| (thisCharID == 32) || (thisCharID == 44)	//escaping SPACE and COMMA for URL Encoding
					 )
				{
					// character needs to be encoded
					inputEncoding = Encoding.GetEncoding(codepage);
					byte[] inputEncodingBytes = inputEncoding.GetBytes(thisChar);
					int noinputEncodingBytes = inputEncodingBytes.Length;
					for (int index = 0; index < noinputEncodingBytes; index++)
					{
						ch = (char)inputEncodingBytes[index];
						// character needs to be encoded. Infact the byte cannot be greater than 256.
						if (ch <= 256)
						{
							returnMe[len++] = '%';
							string hex = ((int)ch).ToString("x").PadLeft(2, '0');
							returnMe[len++] = hex[0];
							returnMe[len++] = hex[1];
						}
					}
				}
				else
				{
					// character does not need encoding
					returnMe[len++] = input[i];
				}
			}
			return new String(returnMe, 0, len);
		}
		#endregion
		#region XMLEncode_Method
		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input strings for use in XML.
		/// </summary>
		/// <param name="input">String to be encoded</param>
		/// <returns>
		///	 Encoded string for use in XML.
		/// </returns>
		/// <remarks>
		/// This function will encode all but known safe characters.  Encoded characters are encoded using the &amp;#DECIMAL; notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>,</term><description>Comma</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Space</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSS Attack!');</term><description>alert&#40;&#39;XSS Attack&#33;&#39;&#41;&#59;</description></item>
		/// <item><term>user@contoso.com</term><description>user&#64;contoso.com</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>Anti-Cross Site Scripting Library</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string XmlEncode(string input)
		{
			// HtmlEncode will handle input
			return HtmlEncode(input);
		}
		#endregion
		#region XMLAttributeEncode_Method
		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input strings for use in XML attributes.
		/// </summary>
		/// <param name="input">String to be encoded</param>
		/// <returns>
		///	 Encoded string for use in XML attributes.
		/// </returns>
		/// <remarks>
		/// This function will encode all but known safe characters.  Encoded characters are encoded using the &amp;#DECIMAL; notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>,</term><description>Comma</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSS Attack!');</term><description>alert&#40;&#39;XSS&#32;Attack&#33;&#39;&#41;&#59;</description></item>
		/// <item><term>user@contoso.com</term><description>user&#64;contoso.com</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>Anti-Cross&#32;Site&#32;Scripting&#32;Library</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string XmlAttributeEncode(string input)
		{
			//HtmlEncodeAttribute will handle input
			return HtmlAttributeEncode(input);
		}
		#endregion
		#region JavaScriptEncode_Method
		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input strings for use in JavaScript.
		/// </summary>
		/// <param name="input">String to be encoded</param>
		/// <returns>
		///	 Encoded string for use in JavaScript.
		/// </returns>
		/// <remarks>
		/// This function will encode all but known safe characters.  Encoded characters are encoded using the \xSINGLE_BYTE_HEX and \uDOUBLE_BYTE_HEX notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>,</term><description>Comma</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Space</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSS Attack!');</term><description>'alert\x28\x27XSS Attack\x21\x27\x29\x3b'</description></item>
		/// <item><term>user@contoso.com</term><description>'user\x40contoso.com'</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>'Anti-Cross Site Scripting Library'</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string JavaScriptEncode(string input)
		{
			return JavaScriptEncode(input, true);
		}
		///---------------------------------------------------------------------
		/// <summary>
		/// Encodes input strings for use in JavaScript.
		/// </summary>
		/// <param name="input">String to be encoded</param>
		/// /// <param name="flagforQuote">bool flag to determin to emit quote or not. true - emit quote. false = no quote.</param>
		/// <returns>
		///	 Encoded string for use in JavaScript and does not return the output with en quotes.
		/// </returns>
		/// <remarks>
		/// This function will encode all but known safe characters.  Encoded characters are encoded using the \xSINGLE_BYTE_HEX and \uDOUBLE_BYTE_HEX notation.
		/// <newpara/>
		/// Safe characters include:
		/// <list type="table">
		/// <item><term>a-z</term><description>Lower case alphabet</description></item>
		/// <item><term>A-Z</term><description>Upper case alphabet</description></item>
		/// <item><term>0-9</term><description>Numbers</description></item>
		/// <item><term>,</term><description>Comma</description></item>
		/// <item><term>.</term><description>Period</description></item>
		/// <item><term>-</term><description>Dash</description></item>
		/// <item><term>_</term><description>Underscore</description></item>
		/// <item><term> </term><description>Space</description></item>
		/// <item><term> </term><description>Other International character ranges</description></item>
		/// </list>
		/// <newpara/>
		/// Example inputs and encoded outputs:
		/// <list type="table">
		/// <item><term>alert('XSS Attack!');</term><description>'alert\x28\x27XSS Attack\x21\x27\x29\x3b'</description></item>
		/// <item><term>user@contoso.com</term><description>'user\x40contoso.com'</description></item>
		/// <item><term>Anti-Cross Site Scripting Library</term><description>'Anti-Cross Site Scripting Library'</description></item>
		/// </list></remarks>
		///---------------------------------------------------------------------
		public static string JavaScriptEncode(string input, bool flagforQuote)
		{
			// Input validation: empty or null string condition
			if (String.IsNullOrEmpty(input))
			{
				if (flagforQuote)
				{
					return (EmptyStringJavaScript);
				}
				else
				{
					return "";
				}
			}
			// Use a new char array.
			int len = 0;
			int tLen = input.Length;
			char[] returnMe = new char[tLen * 8]; // worst case length scenario
			char[] thisChar;
			char ch;
			int thisCharID;
			// First step is to start the encoding with an apostrophe if flag is true.
			if (flagforQuote)
			{
				returnMe[len++] = '\'';
			}
			for (int i = 0; i < tLen; i++)
			{
				thisCharID = (int)input[i];
				ch = input[i];
				if (WhitelistCodes[thisCharID] != null)
				{
					// character needs to be encoded
					thisChar = WhitelistCodes[thisCharID];
					if (thisCharID > 127)
					{
						returnMe[len++] = '\\';
						returnMe[len++] = 'u';
						string hex = ((int)ch).ToString("x").PadLeft(4, '0');
						returnMe[len++] = hex[0];
						returnMe[len++] = hex[1];
						returnMe[len++] = hex[2];
						returnMe[len++] = hex[3];
					}
					else
					{
						returnMe[len++] = '\\';
						returnMe[len++] = 'x';
						string hex = ((int)ch).ToString("x").PadLeft(2, '0');
						returnMe[len++] = hex[0];
						returnMe[len++] = hex[1];
					}
				}
				else
				{
					// character does not need encoding
					returnMe[len++] = input[i];
				}
			}
			// Last step is to end the encoding with an apostrophe if flag is true.
			if (flagforQuote)
			{
				returnMe[len++] = '\'';
			}
			return new String(returnMe, 0, len);
		}
		#endregion
		#region VisualBasicScriptEncode_Method
		public static string VisualBasicScriptEncode(string input)
		{
			// Input validation: empty or null string condition
			if (String.IsNullOrEmpty(input))
			{
				return (EmptyStringVBS);
			}
			// Use a new char array.
			int len = 0;
			int tLen = input.Length;
			char[] returnMe = new char[tLen * 12]; // worst case length scenario
			char ch2;
			string temp;
			int thisCharID;
			//flag to surround double quotes around safe characters
			bool bInQuotes = false;
			for (int i = 0; i < tLen; i++)
			{
				thisCharID = (int)input[i];
				ch2 = input[i];
				if (WhitelistCodes[thisCharID] != null)
				{
					// character needs to be encoded
					// surround in quotes
					if (bInQuotes)
					{
						// get out of quotes
						returnMe[len++] = '"'; ;
						bInQuotes = false;
					}
					// adding "encoded" characters
					temp = "&chrw(" + ((uint)ch2).ToString() + ")";
					foreach (char ch in temp)
					{
						returnMe[len++] = ch;
					}
				}
				else
				{
					// character does not need encoding
					//surround in quotes
					if (!bInQuotes)
					{
						// add quotes to start
						returnMe[len++] = '&';
						returnMe[len++] = '"';
						bInQuotes = true;
					}
					returnMe[len++] = input[i];
				}
			}
			// if we're inside of quotes, close them
			if (bInQuotes)
			{
				returnMe[len++] = '"';
			}
			// finally strip extraneous "&" from beginning of the string, if necessary and RETURN
			if (returnMe.Length > 0 && returnMe[0] == '&')
			{
				return new String(returnMe, 1, len - 1);
			}
			else
			{
				return new String(returnMe, 0, len);
			}
		}
		#endregion
		#endregion
	}
}
^#endregion

#T=AOP RealProxy (不能嵌套、不能多截获)
namespace Microshaoft
{
	using System;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Activation;
	using System.Runtime.Remoting.Messaging;
	using System.Runtime.Remoting.Proxies;
	using System.Runtime.Remoting.Services;
	public class IntercepterProcessorProxy : RealProxy
	{
		MarshalByRefObject _target = null;
		public IntercepterProcessorProxy
						(
							Type type
							, MarshalByRefObject target
						)
							: base(type)
		{
			_target = target;
		}
		private Func<IConstructionCallMessage, bool> _beforeContructorCallInterceptProcessFunc = null;
		private Action<IConstructionCallMessage, IMethodReturnMessage> _afterContructorCallInterceptProcessAction = null;
		private Func<IMethodCallMessage, bool> _beforeMethodCallInterceptProcessFunc = null;
		private Action<IMethodCallMessage, IMethodReturnMessage> _afterMethodCallInterceptProcessAction = null;
		internal void AttachCallInterceptProcess
						(
						 Func<IConstructionCallMessage, bool> beforeContructorCallInterceptProcessFunc
						, Action<IConstructionCallMessage, IMethodReturnMessage> afterContructorCallInterceptProcessAction
						, Func<IMethodCallMessage, bool> beforeMethodCallInterceptProcessFunc
						, Action<IMethodCallMessage, IMethodReturnMessage> afterMethodCallInterceptProcessAction
					)
		{
			_beforeContructorCallInterceptProcessFunc = beforeContructorCallInterceptProcessFunc;
			_afterContructorCallInterceptProcessAction = afterContructorCallInterceptProcessAction;
			_beforeMethodCallInterceptProcessFunc = beforeMethodCallInterceptProcessFunc;
			_afterMethodCallInterceptProcessAction = afterMethodCallInterceptProcessAction;
		}
		//覆写Invoke，处理RealProxy截获的各种消息,
		//此种方式最简捷，但不能截获远程对象的激活,好在我们并不是真的要Remoting
		public override IMessage Invoke(IMessage message)
		{
			IMethodCallMessage methodCaller = (IMethodCallMessage) message;
			IConstructionCallMessage constructorCaller = methodCaller as IConstructionCallMessage;
			IMethodReturnMessage methodReturn = null;
			AttachCallInterceptProcess
					(
						(x) =>
						{
							Console.WriteLine("调用" + x.ActivationType.Name + "类型的构造函数");
							return false;
						}
						, (x, y) =>
							{
								Console.WriteLine("返回结果为:" + y.ReturnValue.ToString());
							}
						, (x) =>
							{
								Console.WriteLine("调用" + x.MethodName + "成员函数");
								var args = x.Args;
								Array.ForEach
										(
											args
											, (xx) =>
												{
													Console.WriteLine("调用参数: {0}", xx);
												}
										);
								return false;
							}
						, (x, y) =>
							{
								Console.WriteLine("返回结果为:" + y.ReturnValue.ToString());
							}
					);
			bool r = false;
			//构造函数，只有ContextBoundObject(Inherit from MarshalByRefObject)对象才能截获构造函数
			if (constructorCaller != null)
			{
				
				if (_beforeContructorCallInterceptProcessFunc != null)
				{
					r = _beforeContructorCallInterceptProcessFunc(constructorCaller);
				}
				if (!r)
				{
					RealProxy proxy = RemotingServices.GetRealProxy(_target);
					//如果不做下面这一步，_target还是一个没有直正实例化被代理对象的透明代理，
					//这样的话，会导致没有直正构建对象。
					proxy.InitializeServerObject(constructorCaller);
					//本类是一个RealProxy，它可通过GetTransparentProxy函数得到透明代理
					methodReturn = EnterpriseServicesHelper.CreateConstructionReturnMessage
																(
																	constructorCaller
																	, (MarshalByRefObject)GetTransparentProxy()
																);
					if (_afterContructorCallInterceptProcessAction != null)
					{
						_afterContructorCallInterceptProcessAction(constructorCaller, methodReturn);
					}
				}
			}
			//MarshalByRefObject对象就可截获普通的调用消息，
			//MarshalByRefObject对象告诉编译器，不能将其内部简单的成员函数优化成内联代码，
			//这样才能保证函数调用都能截获。
			else
			{
				if (_beforeMethodCallInterceptProcessFunc != null)
				{
					r = _beforeMethodCallInterceptProcessFunc(methodCaller);
				}
				if (!r)
				{
					//Console.Write("调用成员函数:" + methodCaller.MethodName);
					methodReturn = RemotingServices.ExecuteMessage(_target, methodCaller);
					//Console.WriteLine(",返回结果为:" + methodReturn.ReturnValue.ToString());
					if (_afterMethodCallInterceptProcessAction != null)
					{
						_afterMethodCallInterceptProcessAction(methodCaller, methodReturn);
					}
				}
			}
			return methodReturn;
		}
	}
	//从ProxyAttribute继承，自动实现RealProxy植入
	[AttributeUsage(AttributeTargets.Class)]
	public class IntercepterProxyAttribute : ProxyAttribute
	{
		//覆写CreateInstance函数，返回我们自建的代理
		public override MarshalByRefObject CreateInstance(Type serverType)
		{
			MarshalByRefObject obj = base.CreateInstance(serverType);
			IntercepterProcessorProxy proxy = new IntercepterProcessorProxy(serverType, obj);
			return (MarshalByRefObject)proxy.GetTransparentProxy();
		}
	}
}
namespace Test
{
	using Microshaoft;
	//MyCBO代码
	using System;
	[IntercepterProxyAttribute]
	class Class1 : ContextBoundObject
	{
		public int Add(int a, int b)
		{
			return a + b;
		}
		public int Divide(int a, int b)
		{
			return a / b;
		}
	}
	class Program
	{
		static void Main(string[] args)
		{
			Class1 x = new Class1();
			x.Add(1, 2);
			Console.ReadLine();
		}
	}
}

#T=ApplicationHostHelper Web
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Web;
	using System.Web.Hosting;
	public class MyHost : MarshalByRefObject
	{
		public string RenderAndGetHTML(string page, string query)
		{
			StringBuilder sb = new StringBuilder();
			using (StringWriter sw = new StringWriter(sb))
			{
				SimpleWorkerRequest swr = new SimpleWorkerRequest(page, query, sw);
				HttpRuntime.ProcessRequest(swr);
			}
			return sb.ToString();
		}
	}
	public static class WebApplicationHostHelper
	{
		public static T CreateApplicationHost<T>(string physicalDir)
											where T : MarshalByRefObject
		{
			return (T) ApplicationHost.CreateApplicationHost(typeof(T), "/", physicalDir);
		}
	}
}
namespace Test
{
	using System;
	using System.Web;
	using System.Web.Hosting;
	using Microshaoft;
	public class Program
	{
		static void Main(string[] args)
		{
			var s = @"D:\TestWeb\";
			Console.WriteLine(s);
			MyHost host = WebApplicationHostHelper.CreateApplicationHost<MyHost>(s);
			s = host.RenderAndGetHTML("gridviewsql.aspx", "");
			Console.WriteLine(s);
			Console.ReadLine();
		}
	}
}
#T=ArrayPool System.Buffers
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
namespace Microshaoft.Buffers
{
	using System;
	using System.Runtime.CompilerServices;
	internal static class Utilities
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SelectBucketIndex(int bufferSize)
		{
			uint bitsRemaining = ((uint)bufferSize - 1) >> 4;
			int poolIndex = 0;
			while (bitsRemaining > 0)
			{
				bitsRemaining >>= 1;
				poolIndex++;
			}
			return poolIndex;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxSizeForBucket(int binIndex)
		{
			checked
			{
				int result = 2;
				int shifts = binIndex + 3;
				result <<= shifts;
				return result;
			}
		}
	}
}
namespace Microshaoft.Buffers
{
	using System;
	using System.Reflection;
	using System.Runtime.InteropServices;
	using System.Threading;
	internal sealed class DefaultArrayPool<T> : ArrayPool<T>
	{
		private const int MinimiumArraySize = 16;
		private ArrayPoolBucket<T>[] _buckets;
		internal DefaultArrayPool(int maxLength, int arraysPerBucket)
		{
			if (maxLength <= 0)
				throw new ArgumentOutOfRangeException("maxLength");
			if (arraysPerBucket <= 0)
				throw new ArgumentOutOfRangeException("arraysPerBucket");
			// Our bucketing algorithm has a minimum length of 16
			if (maxLength < MinimiumArraySize)
				maxLength = MinimiumArraySize;
			
			int maxBuckets = Utilities.SelectBucketIndex(maxLength);
			_buckets = new ArrayPoolBucket<T>[maxBuckets + 1];
			for (int i = 0; i < _buckets.Length; i++)
				_buckets[i] = new ArrayPoolBucket<T>(Utilities.GetMaxSizeForBucket(i), arraysPerBucket);
		}
		public override T[] Rent(int minimumLength)
		{
			if (minimumLength <= 0)
				throw new ArgumentOutOfRangeException("minimumLength");
			int index = Utilities.SelectBucketIndex(minimumLength);
			if (index < _buckets.Length)
			{
				T[] buffer = null;
				// Search for an array starting at the 'index' bucket. If the bucket
				// is empty, bump up to the next higher bucket and try that one
				for (int i = index; i < _buckets.Length; i++)
				{
					buffer = _buckets[i].Rent();
					// If the bucket has an array left and returned it, give it to the caller
					if (buffer != null)
					{
						return buffer;
					}
				}
			}
			// Gettings here means we have too big of a request OR all the buckets from 
			// index through _buckets.Length are taken so we need to allocate a buffer on-demand.
			return new T[Utilities.GetMaxSizeForBucket(index)];
		}
		public override void Return(T[] buffer, bool clearArray = false)
		{
			if (buffer == null)
				throw new ArgumentNullException("buffer");
			// If we can tell that the buffer was allocated, drop it. Otherwise, check if we have space in the pool
			int bucket = Utilities.SelectBucketIndex(buffer.Length);
			if (bucket < _buckets.Length)
			{
				// Clear the array if the user requests
				if (clearArray) Array.Clear(buffer, 0, buffer.Length);
				_buckets[bucket].Return(buffer);
			}
		}
	}
}
namespace Microshaoft.Buffers
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	/// <summary>
	/// Provides a thread-safe bucket containing buffers that can be Rented and Returned as part 
	/// of a buffer pool; it should not be used independent of the pool.
	/// </summary>
	internal sealed class ArrayPoolBucket<T>
	{
		private int _index;
		private readonly T[][] _data;
		private readonly int _bufferLength;
		private SpinLock _lock;
		/// <summary>
		/// Creates the pool with numberOfBuffers arrays where each buffer is of bufferLength length.
		/// </summary>
		internal ArrayPoolBucket(int bufferLength, int numberOfBuffers)
		{
			_lock = new SpinLock();
			_data = new T[numberOfBuffers][];
			_bufferLength = bufferLength;
		}
		/// <summary>
		/// Returns an array from the Bucket sized according to the Bucket size.
		/// If the Bucket is empty, null is returned.
		/// </summary>
		/// <returns>Returns a valid buffer when the bucket has free buffers; otherwise, returns null</returns>
		internal T[] Rent()
		{
			T[] buffer = null;
			// Use a SpinLock since it is super lightweight
			// and our lock is very short lived. Wrap in try-finally
			// to protect against thread-aborts
			bool taken = false;
			try
			{
				_lock.Enter(ref taken);
				// Check if all of our buffers have been rented
				if (_index < _data.Length)
				{
					buffer = _data[_index] ?? new T[_bufferLength];
					_data[_index++] = null;
				}
			}
			finally
			{
				if (taken) _lock.Exit(false);
			}
			return buffer;
		}
		/// <summary>
		/// Attempts to return a Buffer to the bucket. This can fail
		/// if the buffer being returned was allocated and we don't have
		/// room for it in the bucket.
		/// </summary>
		internal void Return(T[] buffer)
		{
			// Use a SpinLock since it is super lightweight
			// and our lock is very short lived. Wrap in try-finally
			// to protect against thread-aborts
			bool taken = false;
			try
			{
				_lock.Enter(ref taken);
				// If we have space to put the buffer back, do it. If we don't
				// then there was a buffer alloc'd that was returned instead so
				// we can just drop this buffer
				if (_index != 0)
				{
					_data[--_index] = buffer;
				}
			}
			finally
			{
				if (taken) _lock.Exit(false);
			}
		}
	}
}
namespace Microshaoft.Buffers
{
	using System;
	using System.Reflection;
	using System.Runtime.InteropServices;
	using System.Threading;
	/// <summary>
	/// This class provides resource pooling for arrays of any type. This is can increase performance
	/// of certain applications where lots of arrays are created and destroyed in rapid succession.
	/// This class is thread-safe.
	/// </summary>
	public abstract class ArrayPool<T>
	{
		/// <summary>The default number of arrays that are available for rent.</summary>
		private const int DefaultNumberOfArraysPerBucket = 50;
		/// <summary>The default length of each Rent'able array; equal to 1MB in bytes</summary>
		private const int DefaultArrayLength = 1048576;
		private static ArrayPool<T> s_sharedInstance = null;
		/// <summary>
		/// Retrieves a shared instance pool that is thread-safe and can be used by 
		/// multiple components of the same system. When using the default Shared pool,
		/// buffers will be allocated when all of the pooled buffers have been exhausted.
		/// </summary>
		public static ArrayPool<T> Shared
		{
			get
			{
				ArrayPool<T> instance = Volatile.Read(ref s_sharedInstance);
				if (instance == null)
				{
					Interlocked.CompareExchange(ref s_sharedInstance, new DefaultArrayPool<T>(DefaultArrayLength, DefaultNumberOfArraysPerBucket), null);
					instance = s_sharedInstance;
				}
				return instance;
			}
		}
		/// <summary>
		/// Creates a new ArrayPool instance of the given type using the default configuration options.
		/// </summary>
		/// <returns>Returns a new ArrayPool<T> instance with the specified configuration options</return>
		public static ArrayPool<T> Create()
		{
			return Create(DefaultArrayLength, DefaultNumberOfArraysPerBucket);
		}
		/// <summary>
		/// Creates a new ArrayPool instance of the given type.
		/// </summary>
		/// <param name="maxArrayLength">The maximum length of any Rent request.</param>
		/// <param name-"numberOfArrays">The maximum number of arrays that will be rented.</param>
		/// <returns>Returns a new ArrayPool<T> instance with the specified configuration options</return>
		public static ArrayPool<T> Create(int maxArrayLength, int numberOfArrays)
		{
			return new DefaultArrayPool<T>(maxArrayLength, numberOfArrays);
		}
		/// <summary>
		/// Retrieves a buffer from the pool that is at least the requested length. This buffer is loaned
		/// to the caller and the caller must call Return when finished with the buffer.
		/// </summary>
		/// <param name="length">The number of elements in the desired buffer</param>
		/// <returns>Returns an array of type T that is at least 'length' in size</returns>
		public abstract T[] Rent(int minimumLength);
		/// <summary>
		/// Returns a buffer to the pool that has been Rented or Enlarged. Once a buffer has been
		/// Returned, the caller gives up all ownership of the buffer and cannot use the reference
		/// again. A buffer must only be Returned once.
		/// </summary>
		/// <param name="buffer">The buffer that will be Returned to the pool for general use.</param>
		/// <param name="clearArray">
		/// If true, the buffer will be cleared of any data; otherwise, the buffer will be returned with any
		/// data intact.
		/// </param>
		public abstract void Return(T[] buffer, bool clearArray = false);
	}
}

#T=as is SafeCasting
namespace Microshaoft
{
	using System;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	class SafeCasting
	{
		class Animal
		{
			public void Eat() { Console.WriteLine("Eating."); }
			public override string ToString()
			{
				return "I am an animal.";
			}
		}
		class Mammal : Animal { }
		class Giraffe : Mammal { }
		class SuperNova { }
		static void Main()
		{
			SafeCasting app = new SafeCasting();
			// Use the is operator to verify the type.
			// before performing a cast.
			Giraffe g = new Giraffe();
			app.UseIsOperator(g);
			// Use the as operator and test for null
			// before referencing the variable.
			app.UseAsOperator(g);
			// Use the as operator to test
			// an incompatible type.
			SuperNova sn = new SuperNova();
			app.UseAsOperator(sn);
			// Use the as operator with a value type.
			// Note the implicit conversion to int? in 
			// the method body.
			int i = 5;
			app.UseAsWithNullable(i);
			double d = 9.78654;
			app.UseAsWithNullable(d);
			// Keep the console window open in debug mode.
			System.Console.WriteLine("Press any key to exit.");
			System.Console.ReadKey();
		}
		void UseIsOperator(Animal a)
		{
			if (a is Mammal)
			{
				Mammal m = (Mammal)a;
				m.Eat();
			}
		}
		void UseAsOperator(object o)
		{
			Mammal m = o as Mammal;
			if (m != null)
			{
				Console.WriteLine(m.ToString());
			}
			else
			{
				Console.WriteLine("{0} is not a Mammal", o.GetType().Name);
			}
		}
		void UseAsWithNullable(System.ValueType val)
		{
			int? j = val as int?;
			if (j != null)
			{
				Console.WriteLine(j);
			}
			else
			{
				Console.WriteLine("Could not convert " + val.ToString());
			}
		}
	}
}

#T=as is 安全类型转换 多态 接口 泛型
//as is 安全类型转换 多态 接口 泛型
namespace Microshaoft
{
	using System;
	class Class1
	{
		interface IAnimal
		{
			void Eat();
			void Shout();
		}
		interface IMeat : IAnimal
		{
			//void Eat();
		}
		class Tiger : IAnimal, IMeat
		{
			public void Eat()
			{
				Console.WriteLine("吃森林肉");
			}
			public void Shout()
			{
				Console.WriteLine("虎");
			}
		}
		class Lion : IAnimal, IMeat
		{
			public void Eat()
			{
				Console.WriteLine("吃草原肉");
			}
			public void Shout()
			{
				Console.WriteLine("狮子");
			}
		}
		class Horse : IAnimal
		{
			public void Eat()
			{
				Console.WriteLine("吃草");
			}
			public void Shout()
			{
				Console.WriteLine("马");
			}
		}
		static void Main()
		{
			Class1 app = new Class1();
			// Use the is operator to verify the type.
			// before performing a cast.
			IAnimal a;
			IMeat m;
			Tiger t;
			Horse h;
			Lion l;
			IAnimal aa = new Lion();
			IMeat mm = new Tiger();
			Tiger tt = new Tiger();
			Horse hh = new Horse();
			Lion ll = new Lion();
			bool r = TrySafeCast<IAnimal, IMeat>(aa, out m);
			Console.WriteLine("before cast:");
			aa.Eat();
			aa.Shout();
			if (r)
			{
				Console.WriteLine("after cast successfully:");
				m.Eat();
				m.Shout();
			}
			Console.WriteLine("Press any key to exit.");
			Console.ReadKey();
		}
		public static bool TrySafeCast<TOriginal, TResult>
							(
								TOriginal x
								, out TResult result
							)
						where TOriginal : class
						where TResult : class
		{
			result = x as TResult;
			//return (result == null);
			bool b = (result is TResult);
			if (b)
			{
				Console.WriteLine("{0} instance can cast to {1} instance", typeof(TOriginal).Name, typeof(TResult).Name);
			}
			else
			{
				Console.WriteLine("{0} instance can NOT cast to {1} instance", typeof(TOriginal).Name, typeof(TResult).Name);
			}
			return b;
		}
	}
}
#T=ASCII/UnicodeCategory
namespace ConsoleApplication
{
	using System;
	using System.Text;
	using System.Linq;
	using System.Globalization;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			for (int i = 0; i < 0xFF; i++)
			{
				char c = (char) i;
				var uc = Char.GetUnicodeCategory(c);
				string ucName = Enum.GetName(uc.GetType(), uc);
				Console.WriteLine
							(
								"[{1}]{0}[{2}]{0}[{3}]"
								, ":"
								, i
								, c
								, ucName
							);
			}
			Console.WriteLine("===============================================");
			Console.ReadLine();
			Enum.GetNames(typeof(UnicodeCategory)).ToList().ForEach
															(
																(x) =>
																{
																	Console.WriteLine(x);
																}
															);
			Console.WriteLine("===============================================");
			Console.ReadLine();
			"\r\n～！＃￥％……＆~!@#$%^&*()_+`1234567890-= QWERTYUIOP{}|   qwertyuiop[]:\";'<>?,./".ToList<Char>().ForEach
										(
											(x) =>
											{
												var uc = Char.GetUnicodeCategory(x);
												string ucName = Enum.GetName(uc.GetType(), uc);
												Console.WriteLine("{1}{0}{2}", ": ", x, ucName);
												
											}
										);
			Console.WriteLine("===============================================");
			Console.ReadLine();
		}
	}
}

#T=ASN.1
//
// ASN1.cs: Abstract Syntax Notation 1 - micro-parser and generator
//
// Authors:
//	Sebastien Pouliot  <sebastien@ximian.com>
//	Jesper Pedersen  <jep@itplus.dk>
//
// (C) 2002, 2003 Motus Technologies Inc. (http://www.motus.com)
// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
// (C) 2004 IT+ A/S (http://www.itplus.dk)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

namespace Mono.Security
{
	using System;
	using System.Collections;
	using System.IO;
	using System.Text;
	using System.Collections.Generic;
	// References:
	// a.	ITU ASN.1 standards (free download)
	//	http://www.itu.int/ITU-T/studygroups/com17/languages/

	//#if INSIDE_CORLIB
	//internal
	//#else
	//public
	//#endif
	public class ASN1
	{
		private byte m_nTag;
		private byte[] m_aValue;
		//private ArrayList elist;
		private List<ASN1> elist;
		public ASN1()
					: this(0x00, null)
		{
		}
		public ASN1(byte tag)
					: this(tag, null)
		{
		}
		public ASN1(byte tag, byte[] data)
		{
			m_nTag = tag;
			m_aValue = data;
		}

		public ASN1(byte[] data)
		{
			m_nTag = data[0];

			int nLenLength = 0;
			int nLength = data[1];

			if (nLength > 0x80)
			{
				// composed length
				nLenLength = nLength - 0x80;
				nLength = 0;
				for (int i = 0; i < nLenLength; i++)
				{
					nLength *= 256;
					nLength += data[i + 2];
				}
			}
			else if (nLength == 0x80)
			{
				// undefined length encoding
				throw new NotSupportedException("Undefined length encoding.");
			}

			m_aValue = new byte[nLength];
			Buffer.BlockCopy(data, (2 + nLenLength), m_aValue, 0, nLength);

			if ((m_nTag & 0x20) == 0x20)
			{
				int nStart = (2 + nLenLength);
				Decode(data, ref nStart, data.Length);
			}
		}

		public int Count
		{
			get
			{
				if (elist == null)
					return 0;
				return elist.Count;
			}
		}

		public byte Tag
		{
			get { return m_nTag; }
		}

		public int Length
		{
			get
			{
				if (m_aValue != null)
					return m_aValue.Length;
				else
					return 0;
			}
		}

		public byte[] Value
		{
			get
			{
				if (m_aValue == null)
					GetBytes();
				return (byte[]) m_aValue.Clone();
			}
			set
			{
				if (value != null)
					m_aValue = (byte[]) value.Clone();
			}
		}

		private bool CompareArray(byte[] array1, byte[] array2)
		{
			bool bResult = (array1.Length == array2.Length);
			if (bResult)
			{
				for (int i = 0; i < array1.Length; i++)
				{
					if (array1[i] != array2[i])
						return false;
				}
			}
			return bResult;
		}

		public bool Equals(byte[] asn1)
		{
			return CompareArray(this.GetBytes(), asn1);
		}

		public bool CompareValue(byte[] value)
		{
			return CompareArray(m_aValue, value);
		}

		public ASN1 Add(ASN1 asn1)
		{
			if (asn1 != null)
			{
				if (elist == null)
					elist = new List<ASN1>();
				elist.Add(asn1);
			}
			return asn1;
		}

		public virtual byte[] GetBytes()
		{
			byte[] val = null;

			if (Count > 0)
			{
				int esize = 0;
				List<byte[]> al = new List<byte[]>();
				foreach (ASN1 a in elist)
				{
					byte[] item = a.GetBytes();
					al.Add(item);
					esize += item.Length;
				}
				val = new byte[esize];
				int pos = 0;
				for (int i = 0; i < elist.Count; i++)
				{
					byte[] item = al[i];
					Buffer.BlockCopy(item, 0, val, pos, item.Length);
					pos += item.Length;
				}
			}
			else if (m_aValue != null)
			{
				val = m_aValue;
			}

			byte[] der;
			int nLengthLen = 0;

			if (val != null)
			{
				int nLength = val.Length;
				// special for length > 127
				if (nLength > 127)
				{
					if (nLength <= Byte.MaxValue)
					{
						der = new byte[3 + nLength];
						Buffer.BlockCopy(val, 0, der, 3, nLength);
						nLengthLen = 0x81;
						der[2] = (byte)(nLength);
					}
					else if (nLength <= UInt16.MaxValue)
					{
						der = new byte[4 + nLength];
						Buffer.BlockCopy(val, 0, der, 4, nLength);
						nLengthLen = 0x82;
						der[2] = (byte)(nLength >> 8);
						der[3] = (byte)(nLength);
					}
					else if (nLength <= 0xFFFFFF)
					{
						// 24 bits
						der = new byte[5 + nLength];
						Buffer.BlockCopy(val, 0, der, 5, nLength);
						nLengthLen = 0x83;
						der[2] = (byte)(nLength >> 16);
						der[3] = (byte)(nLength >> 8);
						der[4] = (byte)(nLength);
					}
					else
					{
						// max (Length is an integer) 32 bits
						der = new byte[6 + nLength];
						Buffer.BlockCopy(val, 0, der, 6, nLength);
						nLengthLen = 0x84;
						der[2] = (byte)(nLength >> 24);
						der[3] = (byte)(nLength >> 16);
						der[4] = (byte)(nLength >> 8);
						der[5] = (byte)(nLength);
					}
				}
				else
				{
					// basic case (no encoding)
					der = new byte[2 + nLength];
					Buffer.BlockCopy(val, 0, der, 2, nLength);
					nLengthLen = nLength;
				}
				if (m_aValue == null)
					m_aValue = val;
			}
			else
				der = new byte[2];

			der[0] = m_nTag;
			der[1] = (byte)nLengthLen;

			return der;
		}

		// Note: Recursive
		protected void Decode(byte[] asn1, ref int anPos, int anLength)
		{
			byte nTag;
			int nLength;
			byte[] aValue;

			// minimum is 2 bytes (tag + length of 0)
			while (anPos < anLength - 1)
			{
				DecodeTLV(asn1, ref anPos, out nTag, out nLength, out aValue);
				// sometimes we get trailing 0
				if (nTag == 0)
					continue;

				ASN1 elm = Add(new ASN1(nTag, aValue));

				if ((nTag & 0x20) == 0x20)
				{
					int nConstructedPos = anPos;
					elm.Decode(asn1, ref nConstructedPos, nConstructedPos + nLength);
				}
				anPos += nLength; // value length
			}
		}

		// TLV : Tag - Length - Value
		protected void DecodeTLV(byte[] asn1, ref int pos, out byte tag, out int length, out byte[] content)
		{
			tag = asn1[pos++];
			length = asn1[pos++];

			// special case where L contains the Length of the Length + 0x80
			if ((length & 0x80) == 0x80)
			{
				int nLengthLen = length & 0x7F;
				length = 0;
				for (int i = 0; i < nLengthLen; i++)
					length = length * 256 + asn1[pos++];
			}

			content = new byte[length];
			Buffer.BlockCopy(asn1, pos, content, 0, length);
		}

		public ASN1 this[int index]
		{
			get
			{
				try
				{
					if ((elist == null) || (index >= elist.Count))
						return null;
					return elist[index];
				}
				catch (ArgumentOutOfRangeException)
				{
					return null;
				}
			}
		}

		public ASN1 Element(int index, byte anTag)
		{
			try
			{
				if ((elist == null) || (index >= elist.Count))
					return null;

				ASN1 elm = elist[index];
				if (elm.Tag == anTag)
					return elm;
				else
					return null;
			}
			catch (ArgumentOutOfRangeException)
			{
				return null;
			}
		}

		public override string ToString()
		{
			StringBuilder hexLine = new StringBuilder();
			// Add tag
			hexLine.AppendFormat("Tag: {0} {1}", m_nTag.ToString("X2"), Environment.NewLine);

			// Add length
			hexLine.AppendFormat("Length: {0} {1}", Value.Length, Environment.NewLine);

			// Add value
			hexLine.Append("Value: ");
			hexLine.Append(Environment.NewLine);
			for (int i = 0; i < Value.Length; i++)
			{
				hexLine.AppendFormat("{0} ", Value[i].ToString("X2"));
				if ((i + 1) % 16 == 0)
					hexLine.AppendFormat(Environment.NewLine);
			}
			return hexLine.ToString();
		}

		public void SaveToFile(string filename)
		{
			if (filename == null)
				throw new ArgumentNullException("filename");

			using (FileStream fs = File.OpenWrite(filename))
			{
				byte[] data = GetBytes();
				fs.Write(data, 0, data.Length);
				fs.Flush();
				fs.Close();
			}
		}
	}
}

#T=ASP.NET 中在指定的位置处插入字符
<%@ Page Language="C#" AutoEventWireup="true" %>
<script runat="server">
  protected void Page_Load(object sender, EventArgs e)
  {
   TextBox1.Attributes.Add("onclick", "getCursor('" + TextBox1.ClientID + "','" + Hidden1.ClientID + "');");
  }
  protected void Button1_Click(object sender, EventArgs e)
  {
   string fileName = FileUpload1.FileName;
   //保存文件省略
   int pos = 0;
   Int32.TryParse(Hidden1.Value, out pos);
   TextBox1.Text = TextBox1.Text.Insert(pos, fileName);
  }
 </script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
<title>ASP.NET 中在指定的位置处插入字符</title>
 <script type="text/javascript">
    function getCursor(param1,param2)
    {
     var pos = 0;     
     var t = document.getElementById(param1);
     if(document.selection )
     { 
      t.focus();
      var rng = document.selection.createRange();
      rng.setEndPoint("EndToStart", t.createTextRange());
      pos = rng.text.length;
     }
     else if(t.selectionStart)
     {
      pos = t.selectionStart;
     }
     document.getElementById(param2).value = pos;
    }
 </script>

</head>
<body>
 <form id="form1" runat="server">
 <div>
  <asp:TextBox ID="TextBox1" runat="server" Width="629px">123456789</asp:TextBox>
  <input id="Hidden1" type="hidden" runat="server" />
 </div>
 <asp:FileUpload ID="FileUpload1" runat="server" />
 <asp:Button ID="Button1" runat="server" Text="上载文件" OnClick="Button1_Click" />
 </form>
</body>
</html>

#T=assembly.GetLoadableTypes()
namespace ConsoleApplication
{
	using System;
	using System.Linq;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			var assembly = AppDomain.CurrentDomain.GetAssemblies().First();
			var types = assembly.GetLoadableTypes();
			foreach (var t in types)
			{
				Console.WriteLine(t);
			}
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Reflection;
	using System.Collections.Generic;
	public static class ExtensionsMethodsManager
	{
		public static IEnumerable<Type> GetLoadableTypes(this Assembly assembly)
		{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			try
			{
				return assembly.GetTypes();
			}
			catch (ReflectionTypeLoadException e)
			{
				return e.Types.Where
								(
									(x) => 
									{
										return x != null;
									}
								);
			}
		}
	}
}
#T=Async Await Lucian
/*
	http://blogs.msdn.com/b/lucian/
	Async best practices
	Three Essential Tips for Using Async in Microsoft Visual C# and Visual Basic
*/
//#pragma warning disable 1998
namespace Microshaoft
{
	using System;
	class Program
	{
		[STAThread]
		static void Main(string[] args)
		{
			//DemoThreadpoolScaling.Run();
			DemoConfigureAwait.Run();
			//DemoCacheTask.Run();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Runtime.Remoting.Messaging;
	using System.Threading.Tasks;
	using System.IO;
	using System.Threading;
	class DemoCacheTask
	{
		const int ITERS = 100;
		internal static void Run()
		{
			byte[] data = new byte[0x10000000];
			while (true)
			{
				TrackGcs(new MemStream1(data));
				TrackGcs(new MemStream2(data));
				Console.ReadLine();
			}
		}
		static void TrackGcs(Stream input)
		{
			GC.Collect();
			int gen0 = GC.CollectionCount(0)
				, gen1 = GC.CollectionCount(1)
				, gen2 = GC.CollectionCount(2);
			for (int i = 0; i < ITERS; i++)
			{
				input.Position = 0;
				input.CopyToAsync(Stream.Null).Wait();
			}
			int newGen0 = GC.CollectionCount(0)
				, newGen1 = GC.CollectionCount(1)
				, newGen2 = GC.CollectionCount(2);
			Console.WriteLine
					(
						"{0}\tGen0:{1}   Gen1:{2}   Gen2:{3}"
						, input.GetType().Name
						, newGen0 - gen0
						, newGen1 - gen1
						, newGen2 - gen2
					);
		}
		class MemStream1 : MemoryStream
		{
			public MemStream1(byte[] data) : base(data) { }
			public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
			{
				return Read(buffer, offset, count);
			}
		}
		class MemStream2 : MemoryStream
		{
			public MemStream2(byte[] data) : base(data) { }
			private Task<int> m_cachedTask;
			public override Task<int> ReadAsync
								(
									byte[] buffer
									, int offset
									, int count
									, CancellationToken cancellationToken
								)
			{
				int numRead = Read(buffer, offset, count);
				if (m_cachedTask != null && m_cachedTask.Result == numRead)
				{
					return m_cachedTask;
				}
				m_cachedTask = Task.FromResult(numRead);
				return m_cachedTask;
			}
		}
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	using System.Drawing;
	using System.Threading.Tasks;
	using System.Windows.Forms;
	class DemoConfigureAwait
	{
		const int ITERS = 20000;
		private static async Task WithSyncCtx()
		{
			for (int i = 0; i < ITERS; i++)
			{
				var t = Task.Run(() => { });
				await t;
			}
		}
		private static async Task WithoutSyncCtx()
		{
			for (int i = 0; i < ITERS; i++)
			{
				var t = Task.Run(() => { });
				await t.ConfigureAwait(continueOnCapturedContext: false);
			}
		}
		internal static void Run()
		{
			var f = new Form() { Width = 600, Height = 400 };
			var b = new Button() { Text = "Run", Dock = DockStyle.Fill, Font = new Font("Consolas", 18) };
			f.Controls.Add(b);
			b.Click += async delegate
			{
				b.Text = "... Running ... ";
				await Task.WhenAll(WithSyncCtx(), WithoutSyncCtx()); // warm-up
				var sw = new Stopwatch();
				sw.Restart();
				await WithSyncCtx();
				var withTime = sw.Elapsed;
				sw.Restart();
				await WithoutSyncCtx();
				var withoutTime = sw.Elapsed;
				b.Text = string.Format
									(
										"With    : {0}\nWithout : {1}\n\nDiff    : {2:F2}x"
										, withTime
										, withoutTime
										, withTime.TotalSeconds / withoutTime.TotalSeconds
									);
			};
			f.ShowDialog();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Drawing;
	using System.Linq;
	using System.Text;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Windows.Forms;
	class DemoThreadpoolScaling
	{
		// Application code:
		internal static void Run()
		{
			var f = new Form()
				{
					Width = 240
					, Height = 100
				};
			var b = new Button()
				{
					Text = "Run"
					, Dock = DockStyle.Fill
					, Font = new Font("Consolas", 18)
				};
			f.Controls.Add(b);
			b.Click += async delegate
			{
				var tasks = new List<Task>();
				for (int i = 0; i < 100; i++)
				{
					int fileNum = i;
					tasks.Add(Library.FetchFileAsync(fileNum));
				}
				await Task.WhenAll(tasks);
				Console.WriteLine("Fetched all files!");
			};
			f.ShowDialog();
		}
		// Library code:
		class Library
		{
			public static async Task FetchFileAsync(int fileNum)
			{
				await Task.Run(() =>
				{
					var contents = IO.DownloadFile();
					Console.WriteLine("Fetched file #{0}: {1}", fileNum, contents);
				});
			}
		}
		class IO
		{
			public static string DownloadFile()
			{
				Thread.Sleep(1000);
				return "file contents";
			}
			public static async Task<string> DownloadFileAsync()
			{
				await Task.Delay(1000);
				return "file contents";
			}
		}
	}
}
#T=Async Await sample
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Program
	{
		static void Main(string[] args)
		{
			// 同步方式
			Console.WriteLine("同步方式测试开始！");
			SyncMethod(0);
			Console.WriteLine("同步方式结束！");
			Console.ReadKey();
			Console.WriteLine("\n异步方式测试开始！");
			AsyncMethod(0);
			Console.WriteLine("调用异步方式结束！");
			Console.ReadKey(); 
		}
		// 异步操作
		private static async void AsyncMethod(int input)
		{
			Console.WriteLine("进入异步操作！");
			var result = await AsyncWork(input);
			Console.WriteLine("最终结果{0}", result);
			Console.WriteLine("退出异步操作！");
		}
		// 模拟耗时操作（异步方法）
		private static async Task<int> AsyncWork(int val)
		{
			for (int i = 0; i < 5; ++i)
			{
				Console.WriteLine("耗时操作{0}", i);
				await Task.Delay(100);
				val++;
			}
			return val;
		}
		// 同步操作
		private static void SyncMethod(int input)
		{
			Console.WriteLine("进入同步操作！");
			var result = SyancWork(input);
			Console.WriteLine("最终结果{0}", result);
			Console.WriteLine("退出同步操作！");
		}
		// 模拟耗时操作（同步方法）
		private static int SyancWork(int val)
		{
			for (int i = 0; i < 5; ++i)
			{
				Console.WriteLine("耗时操作{0}", i);
				Thread.Sleep(100);
				val++;
			}
			return val;
		}
	}
}

#T=async await simple sample
namespace ConsoleApplication1
{
	using System;
	using System.Threading.Tasks;
	using System.Threading;
	class Program
	{
		static void Main(string[] args)
		{
			string r = SyncInvokeRunAsync(5);
			Console.WriteLine(r);
			Console.WriteLine("=======================================");
			Console.ReadLine();
		}
		public static Action _action;
		public static string SyncInvokeRunAsync(int sleepSeconds)
		{
			string r = string.Empty;
			if (_action == null)
			{
				_action = new Action
									(
										 async () =>
												{
													 r = await RunAsync(sleepSeconds);
												}
									);
			}
			_action();
			return r;
		}
		public static async Task<string> RunAsync(int sleepSeconds)
		{
			return
				await
					Task.FromResult
							(
								Run
									(
										sleepSeconds
									)
							);
		}
		public static string Run(int sleepSeconds)
		{
			//Task.Delay(sleepSeconds * 1000);
			Thread.Sleep(sleepSeconds * 1000);
			return "Finished";
		}
	}
}

#T=Attribute Test
namespace ConsoleApplication
{
	using System;
	using System.Reflection;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	[AttributeUsage(AttributeTargets.Parameter)]
	public class ParameterAttribute : Attribute
	{
		public int Min = 100;
	}

	public class Class1
	{
		public static void TestMethod([ParameterAttribute(Min = 100)] int x)
		{
			ParameterInfo pi = MethodInfo.GetCurrentMethod().GetParameters()[0];
			ParameterAttribute a = ParameterAttribute.GetCustomAttribute(pi, typeof(ParameterAttribute)) as ParameterAttribute;
			if (a.Min > x)
			{
				throw new Exception();
			}
		}
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());

			Class1.TestMethod(99);
		}
	}
}

#T=await async AccessTheWebAsync simple
namespace ConsoleApplication
{
	using System;
	using System.Net.Http;
	using System.Threading;
	using System.Threading.Tasks;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			var s = AccessTheWebAsync
						(
							"http://www.google.com"
							, () =>
							{
								Thread.Sleep(1000 * 5);
							}
						).Result;
			Console.WriteLine(s);
			Console.WriteLine(Environment.Version.ToString());
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine()))
			{
				Console.WriteLine(s);
			}
		}
		static async Task<string> AccessTheWebAsync
									(
										string url
										, Action independentWorkAction
									)
		{
			// You need to add a reference to System.Net.Http to declare client.
			HttpClient client = new HttpClient();
			// GetStringAsync returns a Task<string>. That means that when you await the
			// task you'll get a string (urlContents).
			Task<string> task = client.GetStringAsync(url);
			// You can do work here that doesn't rely on the string from GetStringAsync.
			independentWorkAction();
			// The await operator suspends AccessTheWebAsync.
			//  - AccessTheWebAsync can't continue until getStringTask is complete.
			//  - Meanwhile, control returns to the caller of AccessTheWebAsync.
			//  - Control resumes here when getStringTask is complete. 
			//  - The await operator then retrieves the string result from getStringTask.
			string content = await task;
			// The return statement specifies an integer result.
			// Any methods that are awaiting AccessTheWebAsync retrieve the length value.
			return content;
		}
	}
}

#T=Await Async Test
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class AsyncAwaitTest
	{
		static void Main(string[] args)
		{
			Console.WriteLine("in Main before Test Thread Id :{0}", Thread.CurrentThread.ManagedThreadId);
			TestAwaitAsync(); // 这个方法其实是多余的, 本来可以直接写下面的方法

			Test();
			//await GetName();
			// 但是由于控制台的入口方法不支持async,所有我们在入口方法里面不能 用 await
			Console.WriteLine("in Main after Test Thread Id :{0}", Thread.CurrentThread.ManagedThreadId);
			Console.ReadLine();
		}
		static async void TestAwaitAsync()
		{
			// 方法打上async关键字，就可以用await调用同样打上async的方法
			// await 后面的方法将在另外一个线程中执行
			string testName = "await";
			DateTime result = DateTime.Now;
			Console.WriteLine("[{0}] begin: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", testName);
			Console.WriteLine("in TestMethod before [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("Now: {0}", DateTime.Now);
			result = await GetNowAsync();
			Console.WriteLine("Result: {0}", result);
			Console.WriteLine("in TestMethod after [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("in TestMethod before [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("in TestMethod after [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("{0} end: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<", testName);
			Console.WriteLine("Press any key to continue next test ... ");
			Console.ReadLine();
		}
		
		static void Test()
		{
			var testName = "XxxAsync().Result";
			Console.WriteLine("[{0}] begin: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", testName);
			Console.WriteLine("in TestMethod before [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			var result = DateTime.Now;
			Console.WriteLine("Now: {0}", result);
			Console.WriteLine("Result: {0}", GetNowAsync().Result);
			Console.WriteLine("Result: {0}", result);
			Console.WriteLine("in TestMethod after [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("in TestMethod before [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("in TestMethod after [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("{0} end: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<", testName);

			Console.WriteLine("Press any key to continue next test ... ");
			Console.ReadLine();

			testName = "Task.WhenAny";
			Console.WriteLine("[{0}] begin: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", testName);
			Console.WriteLine("in TestMethod before [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			//var task = GetNowAsync();
			result = DateTime.Now;
			Console.WriteLine("Now: {0}", result);
			result = Task.WhenAny(GetNowAsync()).Result.Result;

			Console.WriteLine("Result: {0}", result);
			Console.WriteLine("in TestMethod after [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("in TestMethod before [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("in TestMethod after [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("{0} end: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<", testName);

			Console.WriteLine("Press any key to continue next test ... ");
			Console.ReadLine();

			testName = "TaskAwaiter";
			Console.WriteLine("[{0}] begin: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", testName);
			Console.WriteLine("in TestMethod before [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			result = DateTime.Now;
			Console.WriteLine("Now: {0}", result);
			var taskAwaiter = GetNowAsync().GetAwaiter();
			taskAwaiter.OnCompleted
						(
							() =>
							{
								Console.WriteLine("in taskAwaiter.OnCompleted Thread Id :{0}", Thread.CurrentThread.ManagedThreadId);
								result = taskAwaiter.GetResult();
								Console.WriteLine("Result: {0}", result);
							}
						);

			Console.WriteLine("Result: {0}", result);
			Console.WriteLine("in TestMethod after [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("in TestMethod before [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("in TestMethod after [{1}] GetNowAsync Thread Id :{0}", Thread.CurrentThread.ManagedThreadId, testName);
			Console.WriteLine("{0} end: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<", testName);


			Console.WriteLine("Press any key to quit!");
			Console.ReadLine();

		}

		static async Task<DateTime> GetNowAsync()
		{
			// Delay 方法来自于.net 4.5
			Console.WriteLine("in GetNowAsync before await Delay Thread Id :{0}", Thread.CurrentThread.ManagedThreadId);
			var r = await
						Task
							.Run
								(
									() =>
									{
										Console.WriteLine("in Task.Run Thread Id :{0}", Thread.CurrentThread.ManagedThreadId);
										Thread.Sleep(1000);
										return DateTime.Now;
									}
								);
			Console.WriteLine("in GetNowAsync after await Delay Thread Id :{0}", Thread.CurrentThread.ManagedThreadId);
			return r;
		}
	}
}

#T=BackgroundWorker
namespace CrossThreadDemo
{
	using System;
	using System.ComponentModel;
	using System.Threading;
	using System.Windows.Forms;
	public class Form1 : Form
	{
		// This delegate enables asynchronous calls for setting
		// the text property on a TextBox control.
		delegate void SetTextCallback(string text);
		// This thread is used to demonstrate both thread-safe and
		// unsafe ways to call a Windows Forms control.
		private Thread demoThread = null;
		// This BackgroundWorker is used to demonstrate the 
		// preferred way of performing asynchronous operations.
		private BackgroundWorker backgroundWorker1;
		private TextBox textBox1;
		private Button setTextUnsafeBtn;
		private Button setTextSafeBtn;
		private Button setTextBackgroundWorkerBtn;
		private System.ComponentModel.IContainer components = null;
		public Form1()
		{
			InitializeComponent();
		}
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		// This event handler creates a thread that calls a 
		// Windows Forms control in an unsafe way.
		private void setTextUnsafeBtn_Click(
			object sender, 
			EventArgs e)
		{
			this.demoThread = 
				new Thread(new ThreadStart(this.ThreadProcUnsafe));
			this.demoThread.Start();
		}
		// This method is executed on the worker thread and makes
		// an unsafe call on the TextBox control.
		private void ThreadProcUnsafe()
		{
			this.textBox1.Text = "This text was set unsafely.";
		}
		// This event handler creates a thread that calls a 
		// Windows Forms control in a thread-safe way.
		private void setTextSafeBtn_Click(
			object sender, 
			EventArgs e)
		{
			this.demoThread = 
				new Thread(new ThreadStart(this.ThreadProcSafe));
			this.demoThread.Start();
		}
		// This method is executed on the worker thread and makes
		// a thread-safe call on the TextBox control.
		private void ThreadProcSafe()
		{
			this.SetText("This text was set safely.");
		}
		// This method demonstrates a pattern for making thread-safe
		// calls on a Windows Forms control. 
		//
		// If the calling thread is different from the thread that
		// created the TextBox control, this method creates a
		// SetTextCallback and calls itself asynchronously using the
		// Invoke method.
		//
		// If the calling thread is the same as the thread that created
		// the TextBox control, the Text property is set directly. 
		private void SetText(string text)
		{
			// InvokeRequired required compares the thread ID of the
			// calling thread to the thread ID of the creating thread.
			// If these threads are different, it returns true.
			if (this.textBox1.InvokeRequired)
			{	
				SetTextCallback d = new SetTextCallback(SetText);
				this.Invoke(d, new object[] { text });
			}
			else
			{
				this.textBox1.Text = text;
			}
			throw new Exception();
		}
		// This event handler starts the form's 
		// BackgroundWorker by calling RunWorkerAsync.
		//
		// The Text property of the TextBox control is set
		// when the BackgroundWorker raises the RunWorkerCompleted
		// event.
		private void setTextBackgroundWorkerBtn_Click(
			object sender, 
			EventArgs e)
		{
			this.backgroundWorker1.RunWorkerAsync();
		}
		
		// This event handler sets the Text property of the TextBox
		// control. It is called on the thread that created the 
		// TextBox control, so the call is thread-safe.
		//
		// BackgroundWorker is the preferred way to perform asynchronous
		// operations.
		private void backgroundWorker1_RunWorkerCompleted(
			object sender, 
			RunWorkerCompletedEventArgs e)
		{
			this.textBox1.Text = 
				"This text was set safely by BackgroundWorker.";
			throw new Exception();
		}
		#region Windows Form Designer generated code
		private void InitializeComponent()
		{
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.setTextUnsafeBtn = new System.Windows.Forms.Button();
			this.setTextSafeBtn = new System.Windows.Forms.Button();
			this.setTextBackgroundWorkerBtn = new System.Windows.Forms.Button();
			this.backgroundWorker1 = new System.ComponentModel.BackgroundWorker();
			this.SuspendLayout();
			// 
			// textBox1
			// 
			this.textBox1.Location = new System.Drawing.Point(12, 12);
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(240, 20);
			this.textBox1.TabIndex = 0;
			// 
			// setTextUnsafeBtn
			// 
			this.setTextUnsafeBtn.Location = new System.Drawing.Point(15, 55);
			this.setTextUnsafeBtn.Name = "setTextUnsafeBtn";
			this.setTextUnsafeBtn.TabIndex = 1;
			this.setTextUnsafeBtn.Text = "Unsafe Call";
			this.setTextUnsafeBtn.Click += new System.EventHandler(this.setTextUnsafeBtn_Click);
			// 
			// setTextSafeBtn
			// 
			this.setTextSafeBtn.Location = new System.Drawing.Point(96, 55);
			this.setTextSafeBtn.Name = "setTextSafeBtn";
			this.setTextSafeBtn.TabIndex = 2;
			this.setTextSafeBtn.Text = "Safe Call";
			this.setTextSafeBtn.Click += new System.EventHandler(this.setTextSafeBtn_Click);
			// 
			// setTextBackgroundWorkerBtn
			// 
			this.setTextBackgroundWorkerBtn.Location = new System.Drawing.Point(177, 55);
			this.setTextBackgroundWorkerBtn.Name = "setTextBackgroundWorkerBtn";
			this.setTextBackgroundWorkerBtn.TabIndex = 3;
			this.setTextBackgroundWorkerBtn.Text = "Safe BW Call";
			this.setTextBackgroundWorkerBtn.Click += new System.EventHandler(this.setTextBackgroundWorkerBtn_Click);
			// 
			// backgroundWorker1
			// 
			this.backgroundWorker1.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.backgroundWorker1_RunWorkerCompleted);
			// 
			// Form1
			// 
			this.ClientSize = new System.Drawing.Size(268, 96);
			this.Controls.Add(this.setTextBackgroundWorkerBtn);
			this.Controls.Add(this.setTextSafeBtn);
			this.Controls.Add(this.setTextUnsafeBtn);
			this.Controls.Add(this.textBox1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		#endregion
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.Run(new Form1());
		}
	}
}
#T=BackgroundWorker download
namespace Mciroshaoft
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Drawing;
	using System.Threading;
	using System.Windows.Forms;
	using System.Xml;

	public class Form1 : Form
	{
		private BackgroundWorker backgroundWorker1;
		private Button dowloadButton;
		private XmlDocument document = null;

		public Form1()
		{
			InitializeComponent();
		}

		private void dowloadButton_Click(object sender, EventArgs e)
		{
			// Start the download operation in the background.
			this.backgroundWorker1.RunWorkerAsync();

			// Disable the button for the duration of the download.
			this.dowloadButton.Enabled = false;

			// Wait for the BackgroundWorker to finish the download.
			while (this.backgroundWorker1.IsBusy)
			{
				// Keep UI messages moving, so the form remains 
				// responsive during the asynchronous operation.
				//Application.DoEvents();
			}

			// The download is done, so enable the button.
			//this.dowloadButton.Enabled = true;
		}

		private void backgroundWorker1_DoWork(
			object sender, 
			DoWorkEventArgs e)
		{
			document = new XmlDocument();

			// Replace this file name with a valid file name.
			document.Load(@"http://www.tailspintoys.com/sample.xml");

			// Uncomment the following line to
			// simulate a noticeable latency.
			//Thread.Sleep(5000);
		}

		private void backgroundWorker1_RunWorkerCompleted(
			object sender, 
			RunWorkerCompletedEventArgs e)
		{
			if (e.Error == null)
			{
				MessageBox.Show(document.InnerXml, "Download Complete");
			}
			else
			{
				MessageBox.Show(
					"Failed to download file", 
					"Download failed", 
					MessageBoxButtons.OK, 
					MessageBoxIcon.Error );
			}
		}

		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.backgroundWorker1 = new System.ComponentModel.BackgroundWorker();
			this.dowloadButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// backgroundWorker1
			// 
			this.backgroundWorker1.DoWork += new System.ComponentModel.DoWorkEventHandler(this.backgroundWorker1_DoWork);
			this.backgroundWorker1.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.backgroundWorker1_RunWorkerCompleted);
			// 
			// dowloadButton
			// 
			this.dowloadButton.Location = new System.Drawing.Point(12, 12);
			this.dowloadButton.Name = "dowloadButton";
			this.dowloadButton.Size = new System.Drawing.Size(75, 23);
			this.dowloadButton.TabIndex = 0;
			this.dowloadButton.Text = "Download file";
			this.dowloadButton.UseVisualStyleBackColor = true;
			this.dowloadButton.Click += new System.EventHandler(this.dowloadButton_Click);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(104, 54);
			this.Controls.Add(this.dowloadButton);
			this.Name = "Form1";
			this.Text = "Form1";
			this.ResumeLayout(false);

		}

		#endregion
	}

	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.Run(new Form1());
		}
	}

}
#T=BigInteger
// /r:C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Numerics.dll
namespace Test
{
	using System;
	using System.Text;
	using System.Security.Cryptography;
	using System.Numerics;
	class Class1
	{
		static void Main()
		{
			UTF8Encoding e = new UTF8Encoding();
			byte[] data = e.GetBytes
								(
										@"测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com
										测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com"
								);
			HashAlgorithm md5 = new MD5CryptoServiceProvider();
			data = md5.ComputeHash
								(
									data
								);
			BigInteger dividend = new BigInteger(data);
			int divisor = 1000;
			BigInteger quotient;
			BigInteger remainder = 0;
			do
			{
				quotient = BigInteger.DivRem(dividend, divisor, out remainder);
				Console.WriteLine
								(
									"被除数 {0}, 除数 {1}, 商 {2}, 余数 {3}"
									, dividend
									, divisor
									, quotient
									, remainder
								);
				dividend = quotient;
			} while ((quotient.CompareTo(divisor) >= 0)); 
		}
	}
}
#T=BigInteger GUID 62进制
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using System.Threading;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;
	using System.Numerics;
	class Class1
	{
		static void Main()
		{
			short a = short.MaxValue;
			byte[] buffer = BitConverter.GetBytes(a);
			Console.WriteLine(BytesArrayToHexString(buffer));
			a = short.MinValue;
			buffer = BitConverter.GetBytes(a);
			Console.WriteLine(BytesArrayToHexString(buffer));
			string digits = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
			string s = "0";
			byte[] data = HexStringToBytesArray("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7F");
			BigInteger dividend = new BigInteger(data);
			int divisor = digits.Length;
			int i = 0;
			BigInteger quotient = 0;
			BigInteger remainder = 0;
			do
			{
				quotient = BigInteger.DivRem(dividend, divisor, out remainder);
				Console.WriteLine	("{1} | {0} | 余数 {2}", dividend, divisor, remainder);
				string s1 = new string(' ', divisor.ToString().Length);
				string s2 = new string('-', dividend.ToString().Length);
				Console.WriteLine	 ("{0}{1}{2}", "   |",s2,"---");
				//Console.WriteLine("商 {0}", quotient);
				s += digits.Substring((int) remainder,1);
				dividend = quotient;
				i ++;
				//Console.WriteLine("dividend {0}", dividend.ToString());
			} while (quotient > divisor);
			if (quotient > 0)
			{
				s += digits.Substring((int) remainder,1);
			}
			Console.WriteLine("{0}", i);
		}
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}

	}

}

#T=Bin Bit BytesArrayToBinString
namespace ConsoleApplication
{
	using System;
	using System.Collections ;
	using System.Text;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1S
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			byte[] data = BitConverter.GetBytes(0x32);
			Console.WriteLine(BytesArrayToBinString(data));
			data[0] <<= 30;
			Console.WriteLine(BytesArrayToBinString(data));
			Console.WriteLine(Environment.Version.ToString());
		}
		static string BytesArrayToBinString(byte[] data)
		{
			BitArray bits = new BitArray(data);
			StringBuilder sb = new StringBuilder();
			int l = bits.Length;
			for (int i = 0; i < l; i++)
			{
				sb.Append(bits[l - i - 1] ? '1' : '0');
				if ((i + 1) % 8 == 0)
				{
					sb.Append(' ');
				}
				else if ((i + 1) % 4 == 0)
				{
					sb.Append('-');
				}
			}
			return sb.ToString();
		}
	}
}
#T=BinaryTree 非递归遍历
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			TreeNode root = TreeNode.CreateTree();
			TreeNode.NonrecursiveInOrderTraverse(root);
			Console.WriteLine();
			TreeNode.NonrecursiveInOrderTraverse(root);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	public class TreeNode
	{
		public TreeNode LChild
		{
			get;
			set;
		}
	 
		public TreeNode RChild
		{
			get;
			set;
		}
		public string Data
		{
			get;
			set;
		}
	 
		//构造一颗简单的二叉树
		public static TreeNode CreateTree()
		{
			TreeNode root = new TreeNode() { Data = "-" };
			root.LChild = new TreeNode() { Data = "+" };
			root.RChild = new TreeNode() { Data = "/" };
			root.LChild.LChild = new TreeNode() { Data = "a" };
			root.LChild.RChild = new TreeNode() { Data = "*" };
			root.LChild.RChild.LChild = new TreeNode() { Data = "b" };
			root.LChild.RChild.RChild = new TreeNode() { Data = "-" };
			root.LChild.RChild.RChild.LChild = new TreeNode() { Data = "c" };
			root.LChild.RChild.RChild.RChild = new TreeNode() { Data = "d" };
			root.RChild.LChild = new TreeNode() { Data = "e" };
			root.RChild.RChild = new TreeNode() { Data = "f" };
	 
			return root;
		}
	 
		//递归先序遍历
		public static void PreOrderTranverse(TreeNode root)
		{
			if (root != null)
			{
				PrintNode(root);
				PreOrderTranverse(root.LChild);
				PreOrderTranverse(root.RChild);
			}
		}
	 
		//递归中序遍历
		public static void InOrderTransverse(TreeNode root)
		{
			if (root != null)
			{
				InOrderTransverse(root.LChild);
				PrintNode(root);
				InOrderTransverse(root.RChild);
			}
		}
	 
		//递归后续遍历
		public static void PostOrderTransverse(TreeNode root)
		{
			if (root != null)
			{
				PostOrderTransverse(root.LChild);
				PostOrderTransverse(root.RChild);
				PrintNode(root);
			}
		}
	 
		//非递归中序遍历
		public static void NonrecursiveInOrderTraverse(TreeNode root)
		{
			Stack<TreeNode> nodeStack = new Stack<TreeNode>();
	 
			if (root == null)
			{
				return;
			}
	 
			var node = root;
			while (node != null || nodeStack.Count != 0)
			{
				while (node != null)
				{
					nodeStack.Push(node);
					node = node.LChild;
				}
				node = nodeStack.Pop();
	 
				PrintNode(node);
				node = node.RChild;
			}
		}
	 
		//非递归后续遍历
		public static void NonrecursivePostOrderTraverse(TreeNode root)
		{
			Stack<TreeNode> nodeStack = new Stack<TreeNode>();
	 
			if (root == null)
			{
				return;
			}
	 
			var node = root;
			while (node != null || nodeStack.Count != 0)
			{
				while (node != null)
				{
					nodeStack.Push(node);
					if (node.LChild == null)
					{
						node = node.RChild;
					}
					else
					{
						node = node.LChild;
					}
				}
	 
				node = nodeStack.Pop();
	 
				PrintNode(node);
				if (nodeStack.Count != 0 && node == nodeStack.Peek().LChild)
				{
					node = nodeStack.Peek().RChild;
				}
				else
				{
					node = null;
				}
			}
		}
	 
		//打印树节点
		public static void PrintNode(TreeNode node)
		{
			System.Console.Write(node.Data);
		}
	}
}
#T=bitblt CopyFromScreen 抓屏
private void Form1_Paint(System.Object sender,
    System.Windows.Forms.PaintEventArgs e)
        {
        e.Graphics.FillEllipse(Brushes.DarkBlue, new
            Rectangle(10,10,60,60));
        e.Graphics.FillRectangle(Brushes.Khaki, new
            Rectangle(20,30,60,10));
        e.Graphics.CopyFromScreen(new Point(10, 10), new Point(100, 100), 
            new Size(70, 70));
}

#T=bytes array handling compare
//bytes array handling compare
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;
	class Program
	{
		static int[] bufsizes = 
							{
								256,
								320 * 240 * 3,
								1024 * 768 * 3
							};
		static int bufsize;
		const long duration = 10 * 1000 * 1000 * 10;	// 10 seconds
		static void Main(string[] args)
		{
			foreach (var b in bufsizes)
			{
				bufsize = b;
				Console.WriteLine("allocs of size " + bufsize);
				newbyte();
				marshallallochglobal();
				marshallAllocCoTaskMem();
				stackallocate();
				sharedmem();
				Console.WriteLine("memcopies of size " + bufsize);
				arraycopy();
				BufferBlockCopy();
				marshalcopy();
				kernelcopy();
				OwnMemCopyInt();
				OwnMemCopyLong();
				Console.WriteLine();
			}
			Console.WriteLine("done");
			Console.ReadLine();
		}
		private static void BufferBlockCopy()
		{
			byte[] buf1 = new byte[bufsize];
			byte[] buf2 = new byte[bufsize];
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			while ((start + duration) > DateTime.UtcNow.Ticks)
			{
				Buffer.BlockCopy(buf1, 0, buf2, 0, bufsize);
				i++;
			}
			Console.WriteLine("Buffer.BlockCopy: " + i);
		}
		unsafe private static void marshalcopy()
		{
			byte[] buf1 = new byte[bufsize];
			byte[] buf2 = new byte[bufsize];
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			fixed (byte* b1 = &buf1[0])
			fixed (byte* b2 = &buf2[0])
			{
				IntPtr ab2 = new IntPtr(b2);
				while ((start + duration) > DateTime.UtcNow.Ticks)
				{
					Marshal.Copy(buf1, 0, ab2, buf1.Length);
					i++;
				}
			}
			Console.WriteLine("Marshal.Copy: " + i);
		}
		[DllImport("Kernel32.dll", EntryPoint = "RtlMoveMemory")]
		public unsafe static extern void CopyMemory(byte* Destination, byte* Source, [MarshalAs(UnmanagedType.U4)] uint Length);
		unsafe private static void kernelcopy()
		{
			Console.Write("Kernel32NativeMethods.CopyMemory: ");
			byte[] buf1 = new byte[bufsize];
			byte[] buf2 = new byte[bufsize];
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			fixed (byte* b1 = &buf1[0])
			fixed (byte* b2 = &buf2[0])
			{
				while ((start + duration) > DateTime.UtcNow.Ticks)
				{
					CopyMemory(b2, b1, (uint)buf1.Length);
					i++;
				}
			}
			Console.WriteLine(i);
		}
		unsafe private static void OwnMemCopyInt()
		{
			Console.Write("OwnMemCopyInt: ");
			byte[] buf1 = new byte[bufsize];
			byte[] buf2 = new byte[bufsize];
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			fixed (byte* b1 = &buf1[0])
			fixed (byte* b2 = &buf2[0])
			{
				IntPtr ab1 = new IntPtr(b1);
				IntPtr ab2 = new IntPtr(b2);
				while ((start + duration) > DateTime.UtcNow.Ticks)
				{
					MemCopyInt(ab1, ab2, buf1.Length);
					i++;
				}
			}
			Console.WriteLine(i);
		}
		unsafe private static void OwnMemCopyLong()
		{
			Console.Write("OwnMemCopyLong: ");
			byte[] buf1 = new byte[bufsize];
			byte[] buf2 = new byte[bufsize];
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			fixed (byte * b1 = &buf1[0])
			fixed (byte * b2 = &buf2[0])
			{
				IntPtr ab1 = new IntPtr(b1);
				IntPtr ab2 = new IntPtr(b2);
				while ((start + duration) > DateTime.UtcNow.Ticks)
				{
					MemCopyLong(ab1, ab2, buf1.Length);
					i++;
				}
			}
			Console.WriteLine(i);
		}
		private static void arraycopy()
		{
			Console.Write("Array.Copy: ");
			byte[] buf1 = new byte[bufsize];
			byte[] buf2 = new byte[bufsize];
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			while ((start + duration) > DateTime.UtcNow.Ticks)
			{
				Array.Copy(buf1, buf2, buf1.Length);
				i++;
			}
			Console.WriteLine(i);
		}
		private static void newbyte()
		{
			Console.Write("new byte[]: ");
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			while ((start + duration) > DateTime.UtcNow.Ticks)
			{
				byte[] buf = new byte[bufsize];
				i++;
			}
			//GC.Collect();
			Console.WriteLine(i);
		}
		private static void marshallallochglobal()
		{
			Console.Write("Marshal.AllocHGlobal: ");
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			while ((start + duration) > DateTime.UtcNow.Ticks)
			{
				IntPtr p = Marshal.AllocHGlobal(bufsize);
				Marshal.FreeHGlobal(p);
				i++;
			}
			Console.WriteLine(i);
		}
		private static void marshallAllocCoTaskMem()
		{
			Console.Write("Marshal.AllocCoTaskMem: ");
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			while ((start + duration) > DateTime.UtcNow.Ticks)
			{
				IntPtr p = Marshal.AllocCoTaskMem(bufsize);
				Marshal.FreeCoTaskMem(p);
				i++;
			}
			Console.WriteLine(i);
		}
		private static void sharedmem()
		{
			try
			{
				Console.Write("SharedMemory: ");
				long start = DateTime.UtcNow.Ticks;
				int i = 0;
				while ((start + duration) > DateTime.UtcNow.Ticks)
				{
					using (SharedMemory m = new SharedMemory("abc", bufsize, true))
					{
						i++;
					}
				}
				Console.WriteLine(i);
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
			}
		}
		private static void stackallocate()
		{
			Console.Write("stackalloc: ");
			long start = DateTime.UtcNow.Ticks;
			int i = 0;
			while ((start + duration) > DateTime.UtcNow.Ticks)
			{
				stack();
				i++;
			}
			Console.WriteLine(i);
		}
		unsafe static void stack()
		{
			byte* buf = stackalloc byte[bufsize];
		}
		static public unsafe void MemCopyInt(IntPtr pSource, IntPtr pDest, int Len)
		{
			unchecked
			{
				int count = Len / Marshal.SizeOf(typeof(int));
				int rest = Len % count;
				int* ps = (int*) pSource.ToPointer(), pd = (int*) pDest.ToPointer();
				// Loop over the cnt in blocks of 4 bytes, copying an integer (4 bytes) at a time:
				for (int n = 0; n < count; n++)
				{
					* pd++ = * ps++;
				}
				// Complete the copy by moving any bytes that weren't moved in blocks of 4:
				if (rest > 0)
				{
					byte * ps1 = (byte*)ps;
					byte * pd1 = (byte*)pd;
					for (int n = 0; n < rest; n++)
					{
						*pd1++ = *ps1++;
					}
				}
			}
		}
		static public unsafe void MemCopyLong(IntPtr pSource, IntPtr pDest, int Len)
		{
			unchecked
			{
				int count = Len / Marshal.SizeOf(typeof(long));
				int rest = Len % count;
				long* ps = (long*)pSource.ToPointer(), pd = (long*)pDest.ToPointer();
				// Loop over the cnt in blocks of n bytes, copying an long (n bytes) at a time:
				for (int n = 0; n < count; n++)
				{
					*pd++ = *ps++;
				}
				// Complete the copy by moving any bytes that weren't moved in blocks of n:
				if (rest > 0)
				{
					byte* ps1 = (byte*) ps;
					byte* pd1 = (byte*) pd;
					for (int n = 0; n < rest; n++)
					{
						* pd1 = * ps1;
						pd1++;
						ps1++;
					}
				}
			}
		}
	}
	unsafe public class SharedMemory : IDisposable
	{
		[DllImport("kernel32.dll", SetLastError = true)]
		static extern IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpFileMappingAttributes, PageProtection flProtect, uint dwMaximumSizeHigh, uint dwMaximumSizeLow, string lpName);
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool CloseHandle(IntPtr hObject);
		[DllImport("kernel32.dll", SetLastError = true)]
		static extern bool UnmapViewOfFile(IntPtr lpBaseAddress);
		[DllImport("kernel32.dll", SetLastError = true)]
		static extern IntPtr MapViewOfFile(IntPtr hFileMappingObject, uint dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
		[DllImport("kernel32.dll", SetLastError = true)]
		static extern IntPtr OpenFileMapping(uint dwDesiredAccess, bool bInheritHandle, string lpName);
		const UInt32 STANDARD_RIGHTS_REQUIRED = 0x000F0000;
		const UInt32 SECTION_QUERY = 0x0001;
		const UInt32 SECTION_MAP_WRITE = 0x0002;
		const UInt32 SECTION_MAP_READ = 0x0004;
		const UInt32 SECTION_MAP_EXECUTE = 0x0008;
		const UInt32 SECTION_EXTEND_SIZE = 0x0010;
		const UInt32 SECTION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_WRITE | SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_EXTEND_SIZE);
		const UInt32 FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS;
		[Flags]
		enum PageProtection : uint
		{
			NoAccess = 0x01,
			Readonly = 0x02,
			ReadWrite = 0x04,
			WriteCopy = 0x08,
			Execute = 0x10,
			ExecuteRead = 0x20,
			ExecuteReadWrite = 0x40,
			ExecuteWriteCopy = 0x80,
			Guard = 0x100,
			NoCache = 0x200,
			WriteCombine = 0x400,
		}
		private IntPtr hHandle;
		public void * Buffer
						{
							get;
							private set;
						}
		public int Length { get; private set; }
		public SharedMemory(string name, int size, bool create)
		{
			if (create)
			{
				Create(name, size);
			}
			else
			{
				Attach(name);
			}
		}
		~SharedMemory()
		{
			Detach();
		}
		private void Create(string SharedMemoryName, int NumBytes)
		{
			hHandle = CreateFileMapping(new IntPtr(-1), IntPtr.Zero, PageProtection.ReadWrite, 0, (uint)NumBytes, SharedMemoryName);
			if (IntPtr.Zero == hHandle)
			{
				throw new InvalidOperationException(String.Format("Failed to create FileMapping with given name '{0}'.", SharedMemoryName));
			}
			Buffer = MapViewOfFile(hHandle, FILE_MAP_ALL_ACCESS, 0, 0, IntPtr.Zero).ToPointer();
			Length = NumBytes;
		}
		private void Attach(string SharedMemoryName)
		{
			hHandle = OpenFileMapping(FILE_MAP_ALL_ACCESS, false, SharedMemoryName);
			if (IntPtr.Zero == hHandle)
			{
				throw new InvalidOperationException(String.Format("Failed to open FileMapping with given name '{0}'.", SharedMemoryName));
			}
			Buffer = MapViewOfFile(hHandle, FILE_MAP_ALL_ACCESS, 0, 0, IntPtr.Zero).ToPointer();
		}
		private void Detach()
		{
			if (IntPtr.Zero != hHandle)
			{
				UnmapViewOfFile(new IntPtr(Buffer));
				CloseHandle(hHandle); //fair to leak if can't close
				hHandle = IntPtr.Zero;
			}
			Buffer = IntPtr.Zero.ToPointer();
		}
		#region IDisposable Members
		public void Dispose()
		{
			Detach();
		}
		#endregion
	}
}

#T=BytesHelper
namespace ConsoleApplication
{
	using System;
	using System.Text;
	using System.Linq;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Encoding.GetEncodings().ToList().ForEach
							(
								(x) =>
								{
									var e = x.GetEncoding();
									var buffer = e.GetPreamble();
									if (buffer.Length > 0)
									{
										Console.WriteLine
													(
														"{1}{0}{2}"
														, ":"
														, e.EncodingName
														, BytesHelper.BytesArrayToHexString(buffer)
													);
									}
								}
							);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	public static class BytesHelper
	{
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}

#T=BytesHelper ObjectToBytes
namespace ConsoleApplication
{
	using System;
	using System.Text;
	using Microshaoft;
	using Test;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			//ObjectBytesHelper.GetPropertyOrFieldBytesBlocks<TLV>
			TLV1 x = new TLV1(100, "0123456789简繁体中文");
			byte[] buffer = x.ToBytes();
			TLV y = new TLV(buffer);
			Console.WriteLine(y.Tag);
			Console.WriteLine(y.Length);
			Console.WriteLine(Encoding.UTF8.GetString(y.ValueBytes));
			x = new TLV1(101, "简繁体中文98765");
			buffer = x.ToBytes();
			y = new TLV(buffer);
			Console.WriteLine(y.Tag);
			Console.WriteLine(y.Length);
			Console.WriteLine(Encoding.UTF8.GetString(y.ValueBytes));
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Reflection;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)]
	public class PropertyOrFieldSequenceBytesLengthAttribute : Attribute
	{
		public int MemberSequence
		{
			get;
			set;
		}
		public int AttributeSequence
		{
			get;
			set;
		}
		public int BytesLength
		{
			get;
			set;
		}
	}
	public static class ObjectBytesHelper
	{
		private static ConcurrentDictionary
									<
										Type
										, List
											<
												Tuple
													<
														MemberInfo
														, Type				//Member Data Type
														, PropertyOrFieldSequenceBytesLengthAttribute
													>
											>
									> _cacheDictionary = new ConcurrentDictionary
																		<
																			Type
																			, List<
																					Tuple
																						<
																							MemberInfo
																							, Type			  //Member Data Type
																							, PropertyOrFieldSequenceBytesLengthAttribute
																						>
																				  >
																		>();
		public static byte[] ObjectToBytes<T>
										(
											T Object
											, Func
												<
													MemberInfo
													, Type					//Member Data Type
													, PropertyOrFieldSequenceBytesLengthAttribute
													, byte[]				// 空buffer
													, byte[]				// return
												> processObjectPropertyOrFieldBytesBlockFunc
										)
		{
			Type type = typeof(T);
			List
				<
					Tuple
						<
							MemberInfo
							, Type		//Member Data Type
							, PropertyOrFieldSequenceBytesLengthAttribute>> list =
																		_cacheDictionary.GetOrAdd
																					(
																						type
																						, (x) =>
																							GetAllMembersInfosWithPropertyOrFieldSequenceBytesLengthAttributesList(type)
																					 );
			int L = 0;
			List<byte[]> buffersList = new List<byte[]>();
			list.ForEach
					(
							(x) =>
							{
								var l = x.Item3.BytesLength;
								l = (l < 0 ? 0:l);
								var buffer = new byte[l];
								if (l >= 0)
								{
									buffer = processObjectPropertyOrFieldBytesBlockFunc
															(
																x.Item1
																, x.Item2
																, x.Item3
																, buffer
															);
									L += buffer.Length;
									buffersList.Add(buffer);
								}
							}
					);
			int p = 0;
			byte[] bytes = new byte[L];
			buffersList.ForEach
							(
								(x) =>
								{
									Buffer.BlockCopy
												(
													x
													, 0
													, bytes
													, p
													, x.Length
												);
									p += x.Length;
								}
							);
			return bytes;
		}
		public static void BytesToObjectPropertyOrFieldBytesBlock<T>
														(
															byte[] bytes
															, Func
																<
																	MemberInfo
																	, Type				//Member Data Type
																	, PropertyOrFieldSequenceBytesLengthAttribute
																	, byte[]			//实buffer
																	, int				//position
																	, int				//remain
																	, int				//return: next
																> processObjectPropertyOrFieldBytesBlockFunc
														)
		{
			Type t = typeof(T);
			List
				<
					Tuple
						<
							MemberInfo
							, Type			  //Member Data Type
							, PropertyOrFieldSequenceBytesLengthAttribute
						>
				> list =
						_cacheDictionary.GetOrAdd
									(
										t
										,(x) => 
											GetAllMembersInfosWithPropertyOrFieldSequenceBytesLengthAttributesList(t)
									 );
			int p = 0;
			int l = -1;
			int L = bytes.Length;
			int r = L;
			list.ForEach
					(
						(x) =>
						{
							byte[] buffer;
							if (x.Item3.BytesLength > 0)
							{
								l = x.Item3.BytesLength; 
							}
							buffer = new byte[l];
							Buffer.BlockCopy
										(
											bytes
											, p
											, buffer
											, 0
											, buffer.Length
										);
							p += buffer.Length;
							r -= p;
							l = processObjectPropertyOrFieldBytesBlockFunc
																	(
																		x.Item1
																		, x.Item2
																		, x.Item3
																		, buffer
																		, p
																		, r
																	);
						}
					);
		}
		private static List
						<
							Tuple
								<
									MemberInfo
									, Type			//Member Data Type
									, PropertyOrFieldSequenceBytesLengthAttribute
								>
						> GetAllMembersInfosWithPropertyOrFieldSequenceBytesLengthAttributesList(Type t)
		{
			List
				<
					Tuple
						<
							MemberInfo
							, Type					//Member Data Type
							, PropertyOrFieldSequenceBytesLengthAttribute
						>
				> list = null; 
			t.GetMembers().ToList().Where
											(
												(mi) =>
												{
													var r = false;
													if (mi.MemberType == MemberTypes.Field || mi.MemberType == MemberTypes.Property)
													{
														var attributes =
																		(
																			(PropertyOrFieldSequenceBytesLengthAttribute[])mi.GetCustomAttributes
																									(
																										typeof(PropertyOrFieldSequenceBytesLengthAttribute)
																										, false
																									)
																		 ).OrderBy
																										(
																											(x) =>
																											{
																												return x.AttributeSequence;
																											}
																										).ToList();
														if (attributes.Count > 0)
														{
															var attribute = attributes.First();
															if (list == null)
															{ 
																list = new List
																			<
																				Tuple
																					<
																						MemberInfo
																						, Type				//Member Data Type
																						, PropertyOrFieldSequenceBytesLengthAttribute
																					 >
																			>();
															}
															Type type = null;
															if (mi.MemberType == MemberTypes.Field)
															{
																type = ((FieldInfo)mi).FieldType;
															}
															else if (mi.MemberType == MemberTypes.Property)
															{
																type = ((PropertyInfo)mi).PropertyType;
															}
															Tuple
																<
																	MemberInfo
																	, Type				//Member Data Type
																	, PropertyOrFieldSequenceBytesLengthAttribute> entry = new Tuple
																																<
																																	MemberInfo
																																	, Type				//Member Data Type
																																	, PropertyOrFieldSequenceBytesLengthAttribute>
																																	(mi,type,attribute);
															list.Add(entry);
															r = true;
														}
													}
													return r;
												}
											).ToList();
			var result = list.OrderBy
								(
									(entry) =>
									{
										return entry.Item3.MemberSequence;
									}
								).ToList();
			return result;
		}
	}
}
namespace Test
{
	using System;
	using System.Text;
	using System.Reflection;
	
	using Microshaoft;
	public class TLV
	{
		public TLV(byte[] bytes)
		{
			ObjectBytesHelper.BytesToObjectPropertyOrFieldBytesBlock<TLV>
											(
												bytes
												, (mi, type, attribute, data, position, remain) =>
													{
														int r = -1;
														if (type == typeof(ushort))
														{ 
															byte[] buffer = new byte[2];
															Array.Reverse(buffer);
															Buffer.BlockCopy
																		(
																			data
																			, 0
																			, buffer
																			, 0
																			, buffer.Length
																			);
															
															Array.Reverse(buffer);
															if (mi.Name == "Tag")
															{
																Tag = BitConverter.ToUInt16(buffer, 0);
																r = Length;
															}
															else if (mi.Name == "Length")
															{
																Length = BitConverter.ToUInt16(buffer, 0);
																r = Length;
															}
														}
														else if (type == typeof(byte[]))
														{
															if (mi.Name == "ValueBytes")
															{
																ValueBytes = data;
															}
														
														
														}
														return r;
													}
											);
		}
		[PropertyOrFieldSequenceBytesLength(MemberSequence = 1, BytesLength = 8)]
		public ushort Tag;
		[PropertyOrFieldSequenceBytesLength(MemberSequence = 0, BytesLength = 3)]
		public ushort Length;
		[PropertyOrFieldSequenceBytesLength(MemberSequence = 3, BytesLength = -1)]
		public byte[] ValueBytes;
	}
	interface IObjectToTLVBytes<T>
	{
		ushort Tag
		{
			get;
		}
		ushort Length
		{
			get;
		}
		byte[] ValueBytes
		{
			get;
		}
		T Value
		{
			get;
		}
		byte[] ToBytes();
	}
	public class TLV1 : IObjectToTLVBytes<string>
	{
		public TLV1(ushort tag, string value)
		{
			Tag = tag;
			Value = value;
			ValueBytes = Encoding.UTF8.GetBytes(Value);
			Length = (ushort) ValueBytes.Length;
		}
		[PropertyOrFieldSequenceBytesLength(MemberSequence = 1, BytesLength = 8)]
		public ushort Tag
		{
			get;
			private set;
		}
		[PropertyOrFieldSequenceBytesLength(MemberSequence = 0, BytesLength = 3)]
		public ushort Length
		{
			get;
			private set;
		}
		[PropertyOrFieldSequenceBytesLength(MemberSequence = 1, BytesLength = -1)]
		public string Value
		{
			get;
			private set;
		}
		public byte[] ValueBytes
		{
			get;
			private set;
		}
		public byte[] ToBytes()
		{
			byte[] bytes = ObjectBytesHelper.ObjectToBytes<TLV1>
											(
												this
												, (mi,type, attribute, buffer) =>
													{
														if (attribute.BytesLength <= 0)
														{
															if (mi.Name == "Value")
															{
																buffer = Encoding.UTF8.GetBytes(Value);
															}
														}
														else
														{ 
															byte[] buf = null;
															int count = buffer.Length;
															if (mi.Name == "Tag")
															{
																buf = BitConverter.GetBytes(Tag);
																Array.Reverse(buf);
															}
															else if (mi.Name == "Length")
															{
																buf = BitConverter.GetBytes(Length);
																Array.Reverse(buf);
															}
															count = (count <= buf.Length ? count : buf.Length);
															Buffer.BlockCopy
																	(
																		buf
																		, 0
																		, buffer
																		, 0
																		, count
																	);
														}
														return buffer;
													}
											);
			return bytes;
		}
	}
}

#T=C# Forms-Based/Cookie Authentication
<%@ Import Namespace="System.Web.Security " %>

<html>

  <script language="C#" runat=server>

    void Login_Click(Object sender, EventArgs E) {

      // authenticate user: this samples accepts only one user with
      // a name of someone@www.contoso.com and a password of 'password'

      if ((UserEmail.Value == "someone@www.contoso.com") && (UserPass.Value == "password")) {
        FormsAuthentication.RedirectFromLoginPage(UserEmail.Value, PersistCookie.Checked);
      }
      else {
        Msg.Text = "Invalid Credentials: Please try again";
      }
    }

  </script>

  <body>

    <form runat=server>

      <h3><font face="Verdana">Login Page</font></h3>

      <table>
        <tr>
          <td>Email:</td>
          <td><input id="UserEmail" type="text" runat=server/></td>
          <td><ASP:RequiredFieldValidator ControlToValidate="UserEmail" Display="Static" ErrorMessage="*" runat=server/></td>
        </tr>
        <tr>
          <td>Password:</td>
          <td><input id="UserPass" type=password runat=server/></td>
          <td><ASP:RequiredFieldValidator ControlToValidate="UserPass" Display="Static" ErrorMessage="*" runat=server/></td>
        </tr>
        <tr>
          <td>Persistent Cookie:</td>
          <td><ASP:CheckBox id=PersistCookie runat="server" /> </td>
          <td></td>
        </tr>
      </table>

      <asp:button text="Login" OnClick="Login_Click" runat=server/>

      <p>

      <asp:Label id="Msg" ForeColor="red" Font-Name="Verdana" Font-Size="10" runat=server />

    </form>
  </body>

</html>


#T=C#/CLR 知识点
1: .net framework 由两个部分组成：CLR 和 FCL。
2：在CLR中，所有错误都是通过异常来报告的。
3：智能感知功能主要是靠解析元数据实现的。
4：允许在不同语言之间方便的切换，并对各种语言进行紧密集成是CLR的出色特性。
5：一个方法只有在首次运行时才会由于jit造成一定的性能损失，以后对该方法的调用都以本地代码的形式全速运行。
 
6：方法签名指定了参数的数量(及其顺序),参数的类型；方法是否有返回值，如果有返回值，还要指定返回值的类型。
7：无论使用哪一种语言，类型的行为是完全一致的，因为类型的行为最终由CLR的CTS来定义。
8：使用[assembly:CLSCompliant(true)] 来检查CLS的相容性。
9：在同一程序集中，类型默认是internal,有一个原则是微软总是选择公开程度最低的关键字，比如默认的private。
10：在CLR中一个类型的每个成员要么是一个字段，要么是一个方法。
 
11：应答文件csc.rsp 的作用，使用/noconfig 开关忽略局部和全局csc.rsp.
12：元数据：二进制数据块，由几张表构成：分为3类：a:定义表，b：清单表，c：引用表。
13：一个托管的PE文件由4个部分构成，PE32(+)头，CLR头，元数据，IL。
14：程序集是一个或多个类型定义文件及资源文件的集合。
15：程序集允许我们分离可重用类型的逻辑和物理表示，如果一个程序集没有用到，那么它将永远不会下载。
 
16：为了生成一个新的程序集，来自一个引用程序集的所有文件都必须存在，但运行一个应用程序时，引用的程序集的所有文件不一定要全部存在。
17：程序集的版本号格式：主版本号,副版本号，Build号，Revision号。
18：[assembly:AssemblyCulture(“de-ch”)] 将程序集的语言文化设置为瑞士德语。
19：使用msi文件可以实现“即需安装”。
20：弱命名程序集之所有会成为问题，是因为几个不同的程序集可能具有相同的弱名称。
 
21：“Dll Hell” 根源：共享的Dll全部被复制到System32 目录中，弱命名的名称可能相同，最后安装的会覆盖前面的程序集。
22：之所以能将程序集拖放进GAC 依靠的是windows explorer shell (扩展) shFusion.dll.
23：在命令窗口cmd下，进入gac目录 查看gac的结构。
24：在安装.net framework 时，会安装两套副本，一套编译器/CLR目录，另一套:GAC 子目录。
25：ToString 方法默认反悔this.GetType().FullName.
 
26：GetType方法是非虚方法，这样就可以防止一个类重写该方法，隐瞒其类型，破坏安全性。
27：命名空间和程序集没什么关系。
28：堆上的所有对象都包含两个额外的成员：类型对象指针和同步块索引。
29：System.Object 的GetType方法返回的是存储在指定对象的“类型对象指针”成员中的地址。
30：GetType方法返回的是指向对象的类型对象的一个指针。
 
31：编译器直接支持的任何数据类型称为基元类型。
32：在代表值类型实例的一个变量中，并不包含一个指向实例的指针，相反变量中包含实例本身的字段。
33：文档将所有值类型都称为一个结构 或一个枚举。
34：假如知道自己写的代码会造成编译器反复对一个值类型进行装箱，那么换用手动方式对值类型进行装箱，代码会更小更快。
35：总结第34条：降低调用浪费资源耗费时间多的步骤的次数。
 
36：使用接口的方式可以允许我们更改一个已装箱对象的字段，在C#中，不使用接口的方法是达到这个目的的。因为这个方式有点绕，所以不推荐使用需要修改字段的值类型，在设计模式中，值类型是不变的类型。
37：在内部，ValueType的Equals 方法使用反射技术来完成字段的比较，因为反射比较慢，所以在定义自己的值类型时，应重写Equals方法，不要调用base.Equals.具体的重写步骤如下：
a：如果obj == null C> false;
b: 参数引用不同对象  -> false;
c：每个字段都相等 C>check ->不相等(false)
d：true.
因为正确的重写Equals 方法比较复杂，在性能要求不是很严重的地方，可以不重写。
38：在需要修改一个哈希表的健值对时，正确的做法是 先移除再添加。
39：不要对哈希码 进行持久化 ，因为哈希码很容易改变，例如一个未来的版本可能使用一个不同的算法来计算对象的哈希码。
40：元数据的格式与源代码所使用的编程语言无关，因此元数据的格式都是相同的，元数据是所有语言都可以生成和使用的公共信息，是.net framework 开发平台的关键，它允许编程语言，类型和对象之间无缝集成。
 
41：对于任何可访问的成员，都必须定义在一个可见的类型内。
PS：类如果都看不到，你还能看到类里面的东西吗？
42：类型的可见性：public    internal(默认)
成员的可见性：public protected private (默认)
43：CLR要求接口的所有成员都是公开的， 接口是个契约，是个合同，所以成员都公开才有意义。
44：C# 编译器要求原始成员和重写成员必须具有相同的可访问性，CLR 允许成员的可访问性约束更低，而不允许更高。如果父类的某个方法是protected，那么子类重写这个方法的时候，可以选择约束更低的
public ，但是不能选择约束更强的private。
44：关键字 static 仅仅可以应用于类，不能应用于值类型(结构，枚举),因为值类型必须实例化，并且没有办法停止和阻止该过程。
45：静态类必须直接继承 System.Object ，因为继承性仅仅适用于对象。
 
46：静态类不能实现任何接口，因为只有使用类的实例才能调用接口的方法，可是静态类不能实例化。
47：只能定义静态成员，因为静态类不能实例化。
48：编译器不会在静态类 类型中生成实例构造器方法。
49：C# 编译器 完全支持部分类(partial type) 特征，但是CLR 却完全不支持，甚至CLR根本就没有
partial关键字。
50：对于类型字段：CLR 会在首次引用类型时才创建动态内存，也即jit 编译。
对于实例字段，创建类型实例时才分配存放字段的动态内存。
 
51：如果一个字段属于引用类型，并且被标记为readonly ，不可改变的是这个引用本身，而不是它所引用的对象。
52：构造器是允许将类型实例初始化为有效状态的特殊方法。
53：如果有多个实例构造器，最好通过this关键字先调用默认无参构造函数，然后再赋值。
public SomeType(int x,int y):this(){}
54：所有值类型的构造器必须初始化值类型的所有字段，因为值类型的任何字段必须在读取之前进行初始化。
55：类型构造器 最多只有一个，并且永远没有参数。
 
56：因为CLR保证每个应用程序域的类型构造器只执行一次，而且是线程安全的，所以最适合构造
singleton 模式
57：如果希望应用程序域关闭时能执行某些代码，我们可以在System.AppDomain的DomainUnload事件中注册一个回调方法。
58：当编译器查找FCL 中的核心数值(Int32,Int64)等基元类型的操作符时，会生成直接操作的IL指令，所以核心FCL 类型不能定义任何操作符重载方法的原因，因为方法调用会影响效率。
59：CLR规范将转换操作符重载方法定义为public 和static 方法。
60：只有方法的最后一个参数才可以使用params 关键字。
 
61：属性不能作为out 或ref 参数传递给方法，字段则可以。因为属性的本质是getter 和 setter.
62：C# 编译器 只允许接口定义方法，因为 事件，属性，索引器 本质上都是方法，所以也允许在接口中定义他们。
#T=C#程序的50种改善方法
改善C#程序的50种方法（Effective C# 中文版，原书由人民邮电出版社出版）
从去年找工作以来，都没什么时间写博客［找工作的体会：建议以后有自己开公司的ＩＴ人一定要找ＩＴ专业人员做ＨＲ，好多的公司的ＨＲ并不能真正发掘人才，他们形成了太多的偏见，如在学校期间学不了什么东西、只看学校有多少奖励等。真正钻研技术的人才不会追求虚无的东西］，其实这本书我都借了好久，一直没有系统的看，所以趁这两天好好看看，顺便总结了一些要点，给那些需要这方面知识而又没有太多时间的ＩＴ人一个快速的学习机会。。。。如果要深入学习，请购买该书。
一、用属性代替可访问的字段
1、.NET数据绑定只支持数据绑定，使用属性可以获得数据绑定的好处；
2、在属性的get和set访问器重可使用lock添加多线程的支持。
二、readonly（运行时常量）和const（编译时常量）
1、const只可用于基元类型、枚举、字符串，而readonly则可以是任何的类型；
2、const在编译时将替换成具体的常量，这样如果在引用中同时使用了const和readonly两种值，则对readonly的再次改变将会改变设计的初衷，这是需要重新编译所更改的程序集，以重新引用新的常量值。
3、const比readonly效率高，但失去了应用的灵活性。
三、is与as
1、两者都是在运行时进行类型的转换，as操作符只能使用在引用类型，而is可以使用值和引用类型；
2、通常的做法是用is判断类型，然后选择使用as或强类型转换操作符（用operater定义的转换）有选择地进行。
四、ConditionalAttribute代替#if #endif条件编译
1、ConditionalAttribute只用于方法级，对其他的如类型、属性等的添加都是无效的；而#if #endif则不受此限制；
2、ConditionalAttribute可以添加多个编译条件的或（OR）操作，而#if #endif则可以添加与（AND）[这里可以完全定义为另一个单独的符号]；
3、ConditioanlAttribute定义可以放在一个单独的方法中，使得程序更为灵活。
五、提供ToString（）方法
1、可以更友好的方式提供用户详细的信息；
2、使用IFormatter.ToString（）方法提供更灵活的定制，如果添加IFormatProvider 和ICustomFormatter接口则更有意义的定制消息输出。
六、值和引用类型的区别
1、值类型不支持多态，适合存储应用程序操作的数据，而引用则支持多态，适用于定义应用程序的行为；
2、对于数组定义为值类型可以显著提高程序的性能；
3、值类型具有较少的堆内存碎片、内存垃圾和间接访问时间，其在方法中的返回是以复制的方式进行，避免暴露内部结构到外界；
4、值类型应用在如下的场景中：类型的职责主要是用于数据存储；公共接口完全由一些数据成员存取属性定义；永远没有子类；永远没有多态行为。
七、值类型尽可能实现为常量性和原子性的类型
1、使我们的代码更易于编写和维护；
2、初始化常量的三种策略：在构造中；工厂方法；构造一个可变的辅助类（如StringBuilder）。
八、确保0为值得有效状态
1、值类型的默认状态应为0；
2、枚举类型的0不应为“无效的状态”；在FlagsAttribute是应确保0值为有效地状态；
3、在字符串为为空时可以返回一个string.Empty的空字符串；
九、相等判断的多种表示关系
1、ReferenceEquals（）判断引用相等，需要两个是引用同一个对象时方可返回true；
2、静态的Equals（）方法先进性引用判断再进行值类型判断的；
3、对于引用类型的判断可以在使用“值语义”时使用重写Equals（）方法；
4、重写Equals（）方法时也应当重写GetHashCode（）方法，同时提供operater==（）操作。
十、理解GetHashCode（）方法的缺陷
1、GetHashCode（）仅应用在基于散列的集合定义键的散列值，如HashTable或Dictionary；
2、GetHashCode（）应当遵循相应的三条规则：两个相等对象应当返回相同的散列码；应当是一个实例不变式；散列函数应该在所有的整数中产生一个随机的分布；
十一、优先使用foreach循环语句
1、foreach可以消除编译器对for循环对数组边界的检查；
2、foreach的循环变量是只读的，且存在一个显式的转换，在集合对象的对象类型不正确时抛出异常；
3、foreach使用的集合需要有：具备公有的GetEnumberator（）方法；显式实现了IEnumberable接口；实现了IEnumerator接口；
4、foreach可以带来资源管理的好处，因为如果编译器可以确定IDisposable接口时可以使用优化的try…finally块；
十二、默认字段的初始化优于赋值语句
1、字段生命默认会将值类型初始化为0，引用类型初始化为null；
2、对同一个对象进行多次初始化会降低代码的执行效率；
3、将字段的初始化放到构造器中有利于进行异常处理。
十三、使用静态构造器初始化静态成员
1、静态构造器会在一个类的任何方法、变量或者属性访问之前执行；
2、静态字段同样会在静态构造器之前运行，同时静态构造器有利于异常处理。
十四、利用构造器链（在.NET 4.0已经用可选参数解决了这个问题）
1、用this将初始化工作交给另一个构造器，用base调用基类的构造器；
2、类型实例的操作顺序是：将所有的静态字段都设置为0；执行静态字段初始化器；执行基类的静态构造器；执行当前类型的静态构造器；
将所有的实例字段设置为0；执行实例字段初始化器；执行合适的基类实例构造器；执行当前类型的实例构造器。
十五、利用using和try/finally语句来清理资源
在IDisposable接口的Dispose（）方法中用GC.SuppressFinalize()可通知垃圾收集器不再执行终结操作。
十六、尽量减少内存垃圾
1、分配和销毁一个对上的对象都要花费额外的处理器时间；
2、减少分配对象数量的技巧：经常使用的局部变量提升为字段；提供一个类，用于存储Singleton对象来表达特定类型的常用实例。
3、用StringBuilder进行复杂的字符串操作。
十七、尽量减少装箱和拆箱
1、关注一个类型到System.Object的隐式转换，同时值类型不应该被替换为System.Object类型；
2、使用接口而不是使用类型可以避免装箱，即将值类型从接口实现，然后通过接口调用成员。
十八、实现标准Dispose模式
1、使用非内存资源，它必须有一个终结器，垃圾收集器在完成没有终结其的内存对象后会将实现了终结器对象的添加到终结队列中，然后垃圾收集器会启动一个新的线程来运行这些对象上的终结器，这种防御性的变成方式是因为如果用户忘记了调用Dispose（）方法，垃圾回收器总是会调用终结器方法的，这样可以避免出现非托管的内存资源不被释放引起内存泄漏的问题；l
2、使用IDisposable.Dispose()方法需要做四个方面的工作：释放所有的非托管资源；释放所有的托管资源；设置一个状态标记来表示是否已经执行了Dispose（）；调用GC.SuppressFinalize（this）取消对象的终结操作；
3、为需要多态的类型添加一个受保护的虚方法Dispose（），派生类通过重写这个方法来释放自己的任务；
4、在需要IDisoposable接口的类型中，即使我们不需要一个终结器也应该实现一个终结器。
十九、定义并实现接口优于继承类型
1、不相关的类型可以共同实现一个共同的接口，而且实现接口比继承更容易；
2、接口比较稳定，他将一组功能封装在一个接口中，作为其他类型的实现合同，而基类则可以随着时间的推移进行扩展。
二十、明辨接口实现和虚方法重写
1、在基类中实现一个接口时，派生类需要使用new来隐藏对基类方法的使用；
2、可以将基类接口的方法申明为虚方法，然后再派生类中实现。
二十一、使用委托表达回调
1、委托对象本身不提供任何异常捕获，所以任何的多播委托调用都会结束整个调用链；
2、通过显示调用委托链上的每个委托目标可以避免多播委托仅返回最后一个委托的输出。
二十二、使用事件定义外部接口
1、应当声明为共有的事件，让编译器为我们创建add和renmove方法；
2、使用System.ComponentModel.EventHandlerList容器来存储各个事件处理器，在类型中包含大量事件时可以使用他来隐藏所有事件的复杂性。
二十三、避免返回内部类对象的引用
1、由于值类型对象的访问会创建一个该对象的副本，所以定义一个值类型的的属性完全不会改变类型对象内部的状态；
2、常量类型可以避免改变对象的状态；
3、定义接口将访问限制在一个子集中从而最小化对对象内部状态的破坏；
4、定义一个包装器对象来限制另一个对象的访问；
5、希望客户代码更改内部数据元素时可以实现Observer模式，以使对象可以对更改进行校验或相应。
二十四、声明式编程优于命令式编程
可以避免在多个类似的手工编写的算法中犯错误的可能性，并提供清晰和可读的代码。
二十五、尽可能将类型实现为可序列化的类型
1、类型表示的不是UI控件、窗口或者表单，都应使类型支持序列化；
2、在添加了NonSerializedAttribute的反序列化的属性时可以通过实现IDeserializationCallback的OnDeserialization（）方法装入默认值；
3、在版本控制中可以使用ISerializable接口来进行灵活的控制，同时提供一个序列化的构造器来根据流中的数据初始化对象，在实现时还要求SerializationFormatter异常的许可。
4、如果需要创建派生类则需要提供一个挂钩方法供派生类使用。
二十六、使用IComparable和IComparer接口实现排序关系
1、IComparable接口用于为类型实现最自然的排序关系，重载四个比较操作符，可以提供一个重载版的CompareTo（）方法，让其接受具体类型作为参数；
2、IComparer用于提供有别于IComparable的排序关系，或者为我们提供类型本身说没有实现的排序关系。
二十七、避免ICloneable接口
1、对于值类型永远不需要支持ICloneable接口使用默认的赋值操作即可；
2、对于可能需要支持ICloneable接口的基类，应该为其创造一个受保护的复制构造器，并应当避免支持IConeable接口。
二十八、避免强制转换操作符
通过使用构造器来代替转换操作符可以使转换工作变得更清晰，由于在转换后使用的临时对象，容易导致一些诡异的BUG。
二十九、只有当新版积累导致问题是才考虑使用new修饰符
三十、尽可能实现CLS兼容的程序集
1、创建一个兼容的程序集需要遵循两条规则：程序集中所有公有和受保护成员所使用的参数和返回值类型都必须与CLS兼容；任何与CLS不兼容的公有和受保护成员都必须有一个与CLS兼容的替代品；
2、可以通过显式实现接口来避开CLS兼容类型检查，及CLSCompliantAttribute不会检查私有的成员的CLS兼容性。
三十一、尽可能实现短小简洁的方法
1、JIT编译器以方法为单位进行编译，没有被调用的方法不会被JIT编译；
2、如果将较长的Switch中的Case语句的代码替换成一个一个的方法，则JIT编译器所节省的时间将成倍增加；
3、短小精悍的方法并选择较少的局部变量可以获得优化的寄存器使用；
4、方法内的控制分支越少，JIT编译器越容易将变量放入寄存器。
三十二、尽可能实现小尺寸、高内聚的程序集
1、将所有的公有类以及共用的基类放到一些程序集中，把“为公有类提供功能的工具类”也放入同样的程序集中，把相关的公有接口打包到他们自己的程序集中，最后处理遍布应用程序中“水平”位置的类；
2、原则上创建两种组件：一种为小而聚合、具有某项特定功能的程序集，另一种为大而宽、包含共用功能的程序集。
三十三、限制类型的可见性
1、使用接口来暴露类型的功能，可以使我们更方便地创建内部类，同时又不会限制他们在程序集外的可用性；
2、向外暴露的公有类型越少，未来扩展和更改实现所拥有的选择就越多。
三十四、创建大粒度的Web API
这是在机器之间的交易的频率和载荷都降到最低，将大的操作和细粒度的执行放到服务器执行。
三十五、重写优于事件处理器
1、一个事件处理器抛出异常，则事件链上的其他处理器将不会被调用，而重写的虚方法则不会出现这种情况；
2、重写要比关联事件处理器高效得多，事件处理器需要迭代整个请求列表，这样占用了更多的CPU时间；
3、事件能在运行时响应，具有更多的灵活性，可以对同一个事件关联多个响应；
4、通行的规则是处理一个派生类的事件是，重写方式较好。
三十六、合理使用.NET运行时诊断
1、System.Diagnostics.Debug\Trace\EventLog为运行时提供了程序添加诊断信息所需要的所有工具，EventLog提供入口时的应用程序能写到系统事件日志中；
2、最后不要写自己的诊断库，.NET FCL 已经拥有了我们需要的核心库。
三十七、使用标准配置机制
1、.NET框架的System.Windows.Application类为我们定义了建立通用配置路径的属性；
2、Application.LocalAppDataPath和Application.userDataPath 会生成本地数据目录和用户数据的路径名；
3、不要在ProgramFiles和Windows系统目录中写入数据，这些位置需要更高的安全权限，不要指望用户拥有写入的权限。
三十八、定制和支持数据绑定
1、BindingMananger和CurrencyManager这两个对象实现了控件和数据源之间的数据传输；
2、数据绑定的优势：使用数据绑定要比编写自己的代码简单得多；应该将它用于文本数据项之外的范围-其他显示属性也可以被绑定；对于Windowos Forms 数据绑定能够处理多个控件同步的检查相关数据源；
3、在对象不支持所需的属性时可以通过屏蔽当前的对象然后添加一个想要的对象来支持数据绑定。
三十九、使用.NET验证
1、ASP.NET中有五种控件来验证有效性，可以用CustomValidator派生一个新类来增加自己的认证器；
2、Windows验证需要子System.Windows.Forms.Control.Validating些一个事件处理器。
四十、根据需要选用恰当的集合
1、数组有两个比较明显的缺陷：不能动态的调整大小；调整大小非常耗时；
2、ArrayList混合了一维数组和链表的特征，Queue和Stack是建立在Array基础上的特殊数组；
3、当程序更加灵活的添加和删除项时，可以使更加健壮的集合类型，当创建一个模拟集合的类时，应当为其实现索引器和IEnumberable接口。
四十一、DataSet优于自定义结构
1、DataSet有两个缺点个：使用XML序列化机制的DataSet与非.NET 代码之间的交互不是很好；DataSet是一个非常通用的容器；
2、强类型的DataSet打破了更多的设计规则，其获得的开发效率要远远高于自己编写的看上去更为优雅的设计。
四十二、利用特性简化反射
通过设计和实现特性类，强制开发人员用他们来声明可被动态使用的类型、方法和属性，可以减少应用程序的运行时错误，提高软件的用户满意度。
四十三、避免过度使用反射
1、Invoke成员使用的参数和返回值都是System.Object，在运行时进行类型的转换，但出现问题的可能性也变得更多了；
2、接口使我们可以得到一个更为清晰、也更具可维护性的系统，反射式一个很强大的晚期绑定机制.NET框架使用它来实现Windows控件和Web控件的数据绑定。
四十四、为应用程序创建特定的异常类
1、需要不同的异常类的唯一原因是让用户在编写catch处理器时能够方便地对不同的错误采取不同的做法；
2、可能有不同的修复行为时我们才应该创建多种不同的异常类，通过提供异常基类所支持的所有构造器，可以为应用程序创建功能完整的异常类，使用InnerException属性可以保存更低级别错误条件所产生的所有错误信息。
四十五、优先选择异常安全保证
1、”强异常保证”在“从异常中恢复”和“简化异常处理”之间提供了最好的平衡，在操作因为异常而中断，程序的状态保留不变；
2、对将要修改的数据做“防御性的复制”，对这些数据的“防御性复制”进行修改，这中间的操作可能会引发异常，将临时的副本和原对象进行交换；
3、终结器、Dispose（）方法和委托对象所绑定的目标方法在任何情况下都应当确保他们不会抛出异常。
四十六、最小化互操作
1、互操作有三个方面的代价：数据在托管堆和非托管堆之间的列举成本，托管代码和非托管代码之间切换的成本，对开发人员来说与混合环境打交道的开发工作；
2、在interop中使用blittable类型可以有效地在托管和非托管环境中来回复制，而不受对象内部结构的影响；
3、使用In/Out特性来确保最贴切的不必要的多次复制，通过声明数据如何被列举来提高性能；
4、使用COM Interop用最简单的方式实现和COM组件的互操作，使用P/Invoke调用Win32 API,或者使用C++编译器的/CLR开关来混合托管和非托管的代码；
四十七、优先选择安全代码
1、尽可能的避免访问非托管内存，隔离存储不能防止来自托管代码和受信用户的访问；
2、程序集在Web上运行时可以考虑使用隔离存储，当某些算法确实需要更高的安全许可时，应该将那些代码隔离在一个单独的程序集中。
四十八、掌握相关工具与资源
1、使用NUnit建立自动单元测试（集成在VS2010 中了）；
2、FXCop工具会获取程序集中的IL代码，并将其与异族编码规则和最佳实践对照分析，最后报告违例情况；
3、ILDasm是一个IL反汇编工具，可以帮助我们洞察细节；
4、Shared Source CLI是一个包含.NET框架内核和C#编译器的实现源码。
四十九、为C#2.0做准备（这个规则现在已经没什么意义了，毕竟现在已经到了4.0 ）
五十、了解ＥＣＭＡ标准

#T=CacheEntryRemoved 4.0 Callback CacheHelper
^#define cs4 //C# 4.0+
//#define cs2 //C# 2.0+
// /r:C:\Windows\Microsoft.NET\Framework\v4.0.30319\System.Runtime.Caching.dll
namespace Test
{
	using System;
^#if cs4
	using System.Runtime.Caching;
^#endif
	using System.Web;
	using System.Web.Caching;
	using System.Threading;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			CacheItemEntryRemovedNotifier x = new CacheItemEntryRemovedNotifier("key1", 5);
			x.CacheItemEntryRemoved += new CacheItemEntryRemovedNotifier.CacheItemEntryRemovedEventHandler(x_CacheItemEntryRemoved);
			CacheItemEntryRemovedNotifier y = new CacheItemEntryRemovedNotifier("key2", 5);
			y.CacheItemEntryRemoved += new CacheItemEntryRemovedNotifier.CacheItemEntryRemovedEventHandler(x_CacheItemEntryRemoved);
			Thread.Sleep(2 * 1000);
			x.Remove();
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		static void x_CacheItemEntryRemoved(CacheItemEntryRemovedNotifier sender, Enum reason)
		{
			
			if (reason is CacheItemRemovedReason)
			{
				Console.WriteLine(Enum.GetName(typeof(CacheItemRemovedReason), (CacheItemRemovedReason) reason));
			}
^#if cs4
			else if (reason is CacheEntryRemovedReason)
			{
				Console.WriteLine(Enum.GetName(typeof(CacheEntryRemovedReason), (CacheEntryRemovedReason) reason));
			}
^#endif
			Console.WriteLine(sender.Key);
			sender.ExpireSeconds = 10;
		}
	}
}
namespace Microshaoft
{
	using System;
^#if cs4
	using System.Runtime.Caching;
^#elif cs2
	using System.Web;
	using System.Web.Caching;
^#endif
	using System.Threading;
	public class CacheItemEntryRemovedNotifier
	{
		public delegate void CacheItemEntryRemovedEventHandler
										(
												CacheItemEntryRemovedNotifier sender
												,
///#if cs4
///													CacheEntryRemovedReason
///#elif cs2
///													CacheItemRemovedReason
///#endif
													Enum
													removedReason
										 );
		public event CacheItemEntryRemovedEventHandler CacheItemEntryRemoved;
		private
^#if cs4
					MemoryCache
^#elif cs2
					Cache
^#endif
									_cache = null;
		private string _key;
		public string Key
		{
			get
			{
				return _key;
			}
		}
		private uint _expireSeconds = 0;
		public uint ExpireSeconds
		{
			get
			{
				return _expireSeconds;
			}
			set
			{
				_expireSeconds = value;
			}
		}
		public CacheItemEntryRemovedNotifier(string key, uint expireSeconds)
		{
			_key = key;
^#if cs4
			_cache = MemoryCache.Default;
^#elif cs2
			HttpContext context = HttpContext.Current;
			if (context != null)
			{
				_cache = context.Cache;
			}
			else
			{
				_cache = HttpRuntime.Cache;
			}
^#endif
			Add(key, expireSeconds);
		}
		private void Add(string key, uint expireSeconds)
		{
^#if cs4
			CacheItem item = null;
			CacheItemPolicy cip = null;
			CacheEntryRemovedCallback removedCallback = null;
			_expireSeconds = expireSeconds;
			if (!_cache.Contains(key))
			{
				//实例化一个CacheItem缓存项
				item = new CacheItem(key, new object());
				//实例化CacheItemPolicy 并关联缓存项的一组逐出和过期详细信息
				cip = new CacheItemPolicy();
				removedCallback = new CacheEntryRemovedCallback(CacheEntryRemovedCallbackProcess);
				cip.RemovedCallback = removedCallback;
				DateTime expire = DateTime.Now.AddSeconds(_expireSeconds);
				cip.AbsoluteExpiration = new DateTimeOffset(expire);
				//将缓存实例添加到系统缓存
				_cache.Add(item, cip);
			}
^#elif cs2
			CacheItemRemovedCallback removedCallback = new CacheItemRemovedCallback(CacheItemRemovedCallbackProcess);
			_cache.Insert
						(
							key
							, new object()
							, null
							, Cache.NoAbsoluteExpiration
							, TimeSpan.FromSeconds(expireSeconds)
							, CacheItemPriority.Normal
							, removedCallback
						 );
^#endif
		}
		public void Start(uint expireSeconds)
		{
			_expireSeconds = expireSeconds;
			Add(_key, _expireSeconds);
		}
		public void Remove()
		{
			_cache.Remove(_key);
			//_expireSeconds = 0;
		}
		public void Stop()
		{
			_cache.Remove(_key);
			_expireSeconds = 0;
		}
^#if cs4
		private void CacheEntryRemovedCallbackProcess(CacheEntryRemovedArguments cera)
		{
			if (CacheItemEntryRemoved != null)
			{
				CacheItemEntryRemoved(this, cera.RemovedReason);
			}
			if (_expireSeconds > 0)
			{
				Add(_key, _expireSeconds);
			}
		}
^#elif cs2
		private void CacheItemRemovedCallbackProcess(string key, object cacheItem, CacheItemRemovedReason removedReason)
		{
			if (CacheItemEntryRemoved != null)
			{
				CacheItemEntryRemoved(this, removedReason);
			}
			if (_expireSeconds > 0)
			{
				Add(_key, _expireSeconds);
			}
		}
^#endif
	}
}

#T=CacheItemRemovedCallback CacheHelper
namespace ConsoleApplication
{
	using System;
	using System.Web;
	using System.Threading;
	using System.Web.Caching;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		static Cache _cache;
		static CacheItemRemovedCallback cacheCallback;
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			HttpContext context = HttpContext.Current;
			if (context != null)
			{
				_cache = context.Cache;
			}
			else
			{
				_cache = HttpRuntime.Cache;
			}
			cacheCallback = new CacheItemRemovedCallback(RemoveCallBack);
			_cache.Insert("TestCache", 1, null, DateTime.Now.AddSeconds(1), TimeSpan.Zero, CacheItemPriority.Normal, cacheCallback);
			while(true)
			{
				Console.WriteLine(_cache.Get("TestCache").ToString());
				Thread.Sleep(1000);
			}
		}
		static void RemoveCallBack(string key,Object value,CacheItemRemovedReason reason)
		{
			int i = Int32.Parse(value.ToString()) + 1;
			_cache.Insert(key, i, null, DateTime.Now.AddSeconds(1), TimeSpan.Zero, CacheItemPriority.Normal, cacheCallback);
			Console.WriteLine("{0}, timeout" , key);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Web;
	using System.Collections.Generic;
	using System.Threading;
	using System.Web.Caching;
	class CacheHelper
	{
		private static CacheItemRemovedCallback _callback = new CacheItemRemovedCallback(RemoveCallBack);
		public delegate void CacheItemRemovedEventHandler(string cacheItemKey, object cacheItemValue, CacheItemRemovedReason removedReason);
		public static event CacheItemRemovedEventHandler CacheItemRemoved;
		private static void RemoveCallBack(string cacheItemKey, object cacheItemValue, CacheItemRemovedReason removedReason)
		{
			if (CacheItemRemoved != null)
			{
				CacheItemRemoved(cacheItemKey, cacheItemValue, removedReason);
			}
		}
	}
}
#T=CacheManager.aspx
<%@
	Page
	language="c#"
	AutoEventWireup="true"
	EnableSessionState="False"
%>
<%@ Import Namespace="System.Data" %>
<%@ Import Namespace="System.Data.SqlClient" %>
<%@ Import Namespace="System.Security.Principal" %>
<%@ Import Namespace="System.Collections" %>
<%@ Import Namespace="System.Web.Caching" %>
<script language="C#" runat="server">
	protected void Page_Load(object sender, EventArgs ea) 
	{
		var CacheEnum = Cache.GetEnumerator();
		while (CacheEnum.MoveNext())
		{
			var cacheItem = (DictionaryEntry) CacheEnum.Current;
			Response.Write(cacheItem.Key + "<br>");
		}
	}
	protected void Button1_Click(object sender, EventArgs e)
	{
		Cache.Remove(TextBox1.Text);
	}
</script>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
	<title></title>
</head>
<body>
	<form id="form1" runat="server">
		<div>
			<asp:TextBox ID="TextBox1" runat="server" />
			<asp:Button ID="Button1" runat="server" Text="Button"  OnClick="Button1_Click" />
		</div>
	</form>
</body>
</html>
#T=Calller Information Attribute
namespace Microshaoft
{
	using System;
	using System.Runtime.CompilerServices;
	//StackTrace
	//Reflection
	class Program
	{
		static void Main(string[] args)
		{
			TraceMessage("Hello World.");
			Console.WriteLine("Pass any key to exit.");
			Console.ReadLine();
		}
		private static void TraceMessage
								(
									string message,
									[CallerMemberName] string callerMembername = "",
									[CallerFilePath] string callerFilePath = "",
									[CallerLineNumber] int callerLineNumber = 0
								)
		{
			Console.WriteLine(message);
			Console.WriteLine("Caller member name is " + callerMembername);
			Console.WriteLine("Caller file path is " + callerFilePath);
			Console.WriteLine("Caller line number is " + callerLineNumber.ToString());
		}
	}
}
#T=CAS code access security
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
/*=====================================================================
  File:	  Permissions.cs

  Summary:   Demonstrates how use code access security.

=====================================================================*/


///////////////////////////////////////////////////////////////////////////////
namespace Microsoft.Samples.CAS.Permissions
{
	// Add the classes in the following namespaces to our namespace
	using System;
	using System.IO;
	using System.Security.Permissions;
	using System.Security;

	// This class represents the application itself
	class App 
	{
		public static void Main() 
		{

			// Try to access resources using the permissions currently available.
			AttemptAccess("Default permissions");

			// Create a permission set that allows read access to the TEMP 
			// environment variable and read, write, and append access to SomeFile
			PermissionSet ps = new PermissionSet(PermissionState.None);
			ps.AddPermission(
				new EnvironmentPermission(EnvironmentPermissionAccess.Read, "TEMP"));
			ps.AddPermission(
				new FileIOPermission(FileIOPermissionAccess.Read | 
				FileIOPermissionAccess.Write | FileIOPermissionAccess.Append, 
				Path.GetFullPath("SomeFile")));

			// Use caution in asserting permissions in publicly callable code without
			// any kind of check on the caller.  There is a danger of the assert being
			// used to exploit a downstream caller by stopping its security check, 
			// allowing the malicious code access to unauthorized resources.
			// Stop security checks at this point in the stack walk
			// for the specified permissions
			ps.Assert();

			// Try to access resources using the permissions we've just asserted.
			AttemptAccess("Assert permissions");

			// Remove this stack frame's Assert
			CodeAccessPermission.RevertAssert();

			// Deny access to the resources we specify
			ps.Deny();

			// Try to access resources using the permissions we've just denied.
			AttemptAccess("Deny permissions");

			// Remove this stack frame's Deny so we're back to default permissions.
			CodeAccessPermission.RevertDeny();

			// Make the permissions indicate the only things that we're allowed to do.
			ps.PermitOnly();

			// Try to access resources using only the permissions we've just permitted.
			AttemptAccess("PermitOnly permissions");

			// Remove this stack frame's PermitOnly so we're back to default permissions.
			CodeAccessPermission.RevertPermitOnly();

			// Remove the FileIOPermissions from the permission set
			ps.RemovePermission(typeof(FileIOPermission));

			// Try to access resources using only the Environment permissions.
			ps.PermitOnly();
			AttemptAccess("PermitOnly without FileIOPermission permissions");
			CodeAccessPermission.RevertPermitOnly();

			// Remove the EnvironmentPermission from the permission set
			ps.RemovePermission(typeof(EnvironmentPermission));

			// Try to access resources using no permissions.
			ps.PermitOnly();
			AttemptAccess("PermitOnly without any permissions");
			CodeAccessPermission.RevertPermitOnly();

			// Show how to use Demand/Assert to improve performance
			CopyFile(".\\Permissions.exe", ".\\Permissions.copy.exe");

			// Delete .exe copy
			File.Delete(".\\Permissions.copy.exe");
		}


		static public void AttemptAccess(String s) 
		{
			FileStream fs = null;
			String ev = null;
			String attemptResult = s + " test: ";

			// Try to access a file
			try 
			{
				fs = new FileStream("SomeFile", FileMode.OpenOrCreate); 
			}
			catch (SecurityException)
			{ 
				// Handle exception appropriately - for this sample, we will
				// simply ignore the exception
			}
			finally
			{
				if (fs != null)
				{
					attemptResult += "File opened, ";
					fs.Close();
					File.Delete("SomeFile");
				}
				else
					attemptResult += "File NOT opened, ";
			}

			// Try to read an environment variable
			try
			{
				ev = Environment.GetEnvironmentVariable("TEMP");
			}
			catch (SecurityException)
			{
				// Handle exception appropriately - for this sample, we will
				// simply ignore the exception
			}
			finally
			{
				if (ev != null)
					attemptResult += "Environment variable read";
				else
					attemptResult += "Environment variable NOT read";
			}

			Console.WriteLine(attemptResult);
		}


		public static void CopyFile(String srcPath, String dstPath) 
		{

			// Create a file permission set indicating all of this method's intentions.
			FileIOPermission fp = new FileIOPermission(FileIOPermissionAccess.Read, Path.GetFullPath(srcPath));
			fp.AddPathList(FileIOPermissionAccess.Write | FileIOPermissionAccess.Append, Path.GetFullPath(dstPath));

			// Verify that we can be granted all the permissions we'll need.
			fp.Demand();

			// Assert the desired permissions here.
			fp.Assert();

			// For the remainder of this method, demands for source file read access
			// and demands for destination file write/append access will be granted
			// immediately; walking the remainder of the stack will not be necessary.
			FileInfo srcFile = new FileInfo(srcPath);
			FileInfo dstFile = new FileInfo(dstPath);
			Stream src = srcFile.Open(FileMode.Open, FileAccess.Read, FileShare.Read);
			Stream dst = dstFile.Open(FileMode.Create, FileAccess.Write, FileShare.None);

			// Note: FileInfo.Length is a Int64, but the Stream.Read and .Write
			// take Int32 counts - hence the casting/throttling necessary below
			if (srcFile.Length > Int32.MaxValue)
				throw new ArgumentOutOfRangeException("CopyFile requires that the source file be less than 2GB.");
			Byte[] buffer = new Byte[(Int32) srcFile.Length];
			src.Read(buffer, 0, (Int32) srcFile.Length);
			dst.Write(buffer, 0, (Int32) srcFile.Length);

			src.Close();
			dst.Close();

			// We do not need a RevertAssert here because we are going out of scope
		}
	}
}
///////////////////////////////// End of File /////////////////////////////////

#T=CDATA 序列化
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using Test.Share;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			ServiceBusXmlMessage message = new ServiceBusXmlMessage();
			MessageSecurityHeader security = new MessageSecurityHeader();
			security.SenderID = "sender001";
			security.Signature = "asdasdsadsa";
			security.SignTimeStamp = "asdasdsa";
			Router router = new Router();
			router.Topic = "Topic01";
			router.From = "From01";
			router.FromReferenceID = "11111111111111";
			router.To = new string[] { "to01", "to02", "to03" };
			Encoding e = Encoding.UTF8;
			e = Encoding.GetEncoding("gb2312");
			MemoryStream stream = new MemoryStream();
			XmlTextWriter writer = new XmlTextWriter(stream, e);
			XmlSerializer serializer = new XmlSerializer(router.GetType());
			string xml = SerializerHelper.ObjectToXml<Router>
													(
														router
														, writer
														, serializer
													);
			message.RoutersHeader = new CDATA(xml);
			message.SecurityHeader = security;
			SampleBody sampleBody = new SampleBody();
			sampleBody.TimeStamp = "sadadsad";
			sampleBody.AreaNo = "Area1";
			sampleBody.ChannelNo = "CH1";
			stream = new MemoryStream();
			writer = new XmlTextWriter(stream, e);
			serializer = new XmlSerializer(sampleBody.GetType());
			xml = SerializerHelper.ObjectToXml<SampleBody>
													(
														sampleBody
														, writer
														, serializer
													);
			message.Body = new CDATA(xml);
			stream = new MemoryStream();
			writer = new XmlTextWriter(stream, e);
			serializer = new XmlSerializer(message.GetType());
			xml = SerializerHelper.ObjectToXml<ServiceBusXmlMessage>
													(
														message
														, writer
														, serializer
													);
			Console.WriteLine("Xml序列化:");
			//xml =
			//	"<?xml version=\"1.0\" encoding=\"gb2312\"?>" + "\r\n" +
			//	"<ServiceBusXmlMessage>" + "\r\n" +
			//	"	<MessageSecurityHeader SenderID=\"sender001\" Signature=\"asdasdsadsa\" SignTimeStamp=\"asdasdsa\" />" + "\r\n" +
			//	"	<RouteHeader>" + "\r\n" +
			//	"		<![CDATA[" + "\r\n" +
			//	"			<?xml version=\"1.0\" encoding=\"gb2312\"?>" + "\r\n" +
			//	"			<MessageRouteHeader>" + "\r\n" +
			//	"				<Topic>topic1</Topic>" + "\r\n" +
			//	"				<FromRoleID>from01</FromRoleID>" + "\r\n" +
			//	"				<ToRoleIDList>" + "\r\n" +
			//	"					<ToRoleID>to01</ToRoleID>" + "\r\n" +
			//	"					<ToRoleID>to02</ToRoleID>" + "\r\n" +
			//	"					<ToRoleID>to03</ToRoleID>" + "\r\n" +
			//	"				</ToRoleIDList>" + "\r\n" +
			//	"			</MessageRouteHeader>" + "\r\n" +
			//	"		]]>" + "\r\n" +
			//	"	</RouteHeader>" + "\r\n" +
			//	"	<Body>" + "\r\n" +
			//	"		<![CDATA[" + "\r\n" +
			//	"			<?xml version=\"1.0\" encoding=\"gb2312\"?>" + "\r\n" +
			//	"			<SampleBody TimeStamp=\"sadadsad\">" + "\r\n" +
			//	"				<AreaNo>Area1</AreaNo>" + "\r\n" +
			//	"				<ChannelNo>CH1</ChannelNo>" + "\r\n" +
			//	"			</SampleBody>" + "\r\n" +
			//	"		]]>" + "\r\n" +
			//	"	</Body>" + "\r\n" +
			//	"</ServiceBusXmlMessage>" + "\r\n";
			Console.WriteLine(xml);
			Console.WriteLine("Xml反序列化:");
			ServiceBusXmlMessage message2 = SerializerHelper.XmlToObject<ServiceBusXmlMessage>(xml);
			Console.WriteLine(message2.SecurityHeader.SenderID);
			Console.WriteLine("hi: " + message2.RoutersHeader.Text);
			Console.WriteLine("body: " + message2.Body.Text);
			Router router2 = SerializerHelper.XmlToObject<Router>(message2.RoutersHeader.Text.Trim(new char[] { '\r', '\n', '\t' }));
			Console.WriteLine(router2.To[0]);
			SampleBody sampleBody2 = SerializerHelper.XmlToObject<SampleBody>(message2.Body.Text.Trim(new char[] { '\r', '\n', '\t' }));
			Console.WriteLine(sampleBody2.AreaNo);
			//Console.WriteLine("Hello World");
			//Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}
}
namespace Test.Share
{
	using System;
	using System.Xml;
	using System.Xml.Schema;
	using System.Xml.Serialization;
	[XmlRoot("ServiceBusXmlMessage")]
	[Serializable]
	public class ServiceBusXmlMessage
	{
		[XmlElement("Security", typeof(MessageSecurityHeader))]
		public MessageSecurityHeader SecurityHeader;
		[XmlElement("Routers", typeof(CDATA))]
		public CDATA RoutersHeader;
		[XmlElement("Body", typeof(CDATA))]
		public CDATA Body;
	}
	[Serializable]
	public class MessageSecurityHeader
	{
		[XmlAttribute("SenderID")]
		public string SenderID;
		[XmlAttribute("Signature")]
		public string Signature;
		[XmlAttribute("SignTimeStamp")]
		public string SignTimeStamp;
	}
	[Serializable]
	public class Router
	{
		[XmlAttribute("Topic")]
		public string Topic;
		[XmlAttribute("From")]
		public string From;
		[XmlAttribute("FromReferenceID")]
		public string FromReferenceID;
		[XmlElement("To", typeof(string))]
		public string[] To;
	}
	[Serializable]
	public class SampleBody
	{
		[XmlAttribute("TimeStamp")]
		public string TimeStamp;
		[XmlElement("AreaNo")]
		public string AreaNo;
		[XmlElement("ChannelNo")]
		public string ChannelNo;
	}
	public class CDATA : IXmlSerializable
	{
		private string _text;
		public CDATA()
		{
		}
		public CDATA(string text)
		{
			this._text = text;
		}
		public string Text
		{
			get
			{
				return _text;
			}
		}
		XmlSchema IXmlSerializable.GetSchema()
		{
			return null;
		}
		void IXmlSerializable.ReadXml(XmlReader reader)
		{
			string s = reader.ReadInnerXml();
			string startTag = "<![CDATA[";
			string endTag = "]]>";
			s = s.Trim(new char[] { '\r', '\n', '\t', ' ' });
			if (s.StartsWith(startTag) && s.EndsWith(endTag))
			{
				s = s.Substring(startTag.Length, s.LastIndexOf(endTag) - startTag.Length);
			}
			this._text = s;
		}
		void IXmlSerializable.WriteXml(XmlWriter writer)
		{
			writer.WriteCData(this._text);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using System.Runtime.Serialization.Formatters.Binary;
	public static class SerializerHelper
	{
		public static T XmlToObject<T>(string Xml)
		{
			StringReader stringReader = new StringReader(Xml);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			return (T)serializer.Deserialize(xmlReader);
		}
		public static string ObjectToXml<T>
									(
										T Object
										, XmlTextWriter writer
										, XmlSerializer serializer
									)
		{
			serializer.Serialize(writer, Object, null);
			MemoryStream stream = writer.BaseStream as MemoryStream;
			byte[] bytes = stream.ToArray();
			Encoding e = EncodingHelper.IdentifyEncoding
											(
												bytes
												, Encoding.GetEncoding("gb2312")
				///												, new Encoding[]
				///														{
				///															Encoding.UTF8
				///															, Encoding.Unicode
				///														}
											);
			byte[] buffer = e.GetPreamble();
			int offset = buffer.Length;
			buffer = new byte[bytes.Length - offset];
			Buffer.BlockCopy(bytes, offset, buffer, 0, buffer.Length);
			string s = e.GetString(buffer);
			return s;
		}
		public static string ObjectToXml<T>(T Object, Encoding e)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			using (MemoryStream stream = new MemoryStream())
			{
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = ObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static byte[] ObjectToBinary<T>
									(
										T Object
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				formater.Serialize(stream, Object);
				byte[] buffer = stream.ToArray();
				return buffer;
			}
		}
		public static T BinaryToObject<T>
									(
										byte[] data
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T Object = (T)formater.Deserialize(stream);
				return Object;
			}
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	using System.Text;
	using System.Collections.Generic;
	public static class EncodingHelper
	{
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, identifyEncodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
									)
		{
			EncodingInfo[] encodingInfos = Encoding.GetEncodings();
			List<Encoding> list = new List<Encoding>();
			foreach (EncodingInfo info in encodingInfos)
			{
				Encoding e = info.GetEncoding();
				if (e.GetPreamble().Length > 0)
				{
					list.Add(e);
					//System.Console.WriteLine(e.EncodingName);
				}
			}
			Encoding[] encodings = new Encoding[list.Count];
			list.CopyTo(encodings);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, encodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			Encoding encoding = defaultEncoding;
			foreach (Encoding e in identifyEncodings)
			{
				byte[] buffer = e.GetPreamble();
				int l = buffer.Length;
				if (l == 0)
				{
					continue;
				}
				bool flag = false;
				for (int i = 0; i < l; i++)
				{
					if (buffer[i] != data[i])
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				else
				{
					encoding = e;
				}
			}
			return encoding;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}
/*
<?xml version="1.0" encoding="gb2312"?>
<ServiceBusXmlMessage xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
	<Security SenderID="sender001" Signature="asdasdsadsa" SignTimeStamp="asdasdsa"/>
	<Routers>
		<![CDATA[<?xml version="1.0" encoding="gb2312"?>
			<Router xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Topic="Topic01" From="From01" FromReferenceID="11111111111111">
				<To>
					to01
				</To>
				<To>
					to02
				</To>
				<To>
					to03
				</To>
			</Router>
		]]>
	</Routers>
	<Body>
		<![CDATA[
					<?xml version="1.0" encoding="gb2312"?>
					<SampleBody xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" TimeStamp="sadadsad">
						<AreaNo>
							Area1
						</AreaNo>
						<ChannelNo>
							CH1
						</ChannelNo>
					</SampleBody>
		]]>
	</Body>
</ServiceBusXmlMessage>
*/
#T=CI BOC Test Client/Server
//Client.cs
namespace Client
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	using System.Diagnostics;
	using Microshaoft;
	public class Program
	{
		static void Main1111()
		{
			Console.Title = "CI Client";
			var ipa = IPAddress.Parse("22.188.155.131");
			//ipa = IPAddress.Parse("127.0.0.1");
			var req = "2030313330202020202020202020202020202020202020202A2A20202020202020202020202020202020202020203030333130303031303438303031303030314535343030313035303030303030303030202020202020202020202030203030303030303020203030303034313233313233202020202020202020202037363830302020202020";
			var buffer = HexStringToBytesArray(req);
			var ipep = new IPEndPoint(ipa, 10003);
			long count = 0;
			long all = 0;
			for (int i = 0; i < 100; i++)
			{
				new Thread
						(
							new ThreadStart
									(
										() =>
										{
											Stopwatch watch = new Stopwatch();
											for (int j = 0; j < 50000; j++)
											{
												watch.Start();
												Run(ipep, buffer);
												watch.Stop();
												var ms = watch.ElapsedMilliseconds;
												Interlocked.Increment(ref count);
												Interlocked.Add(ref all, ms);
												watch.Reset();
											}
										}
									)
						).Start();
			}
			var input = string.Empty;
			while ("q" != (input = Console.ReadLine()))
			{
				var avgSecondsPerCall = (1.0 * all / count) / 1000;
				Console.WriteLine("avg: {0}/ count: {1} ", avgSecondsPerCall, count);
			}
		}
		private static Encoding _e = Encoding.GetEncoding("gb18030");
		static void Run(IPEndPoint ipep, byte[] data)
		{
			var socket = new Socket
								(
									AddressFamily.InterNetwork
									, SocketType.Stream
									, ProtocolType.Tcp
								);
			//SocketAsyncDataHandler<int> handler = new SocketAsyncDataHandler<int>(socket, 0);
			socket.Connect(ipep);
			//handler.SendDataSync(data);
			socket.Send(data);
			var buffer = SocketDataHelper.ReadDataToBytes(5, socket);
			var buf = new byte[4];
			Buffer.BlockCopy
						(
							buffer
							, 1
							, buf
							, 0
							, buf.Length
						);
			
			//Array.Reverse(intBytes);
			//bodyLength = BitConverter.ToInt32(intBytes, 0);
			var ss = Encoding.ASCII.GetString(buf);
			int bodyLength = int.Parse(ss);
			buffer = SocketDataHelper.ReadDataToBytes(bodyLength, socket);
			ss = _e.GetString(buffer);
			Console.WriteLine(ss.Trim());
			socket.Shutdown(SocketShutdown.Both);
			socket.Disconnect(false);
			socket.Close();
			socket = null;
		}
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}

namespace Server
{
	using System;
	using System.Net;
	using System.Text;
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			IPAddress ipa = IPAddress.Any;
			Console.Title = "CI Server";
			IPAddress.TryParse("127.0.0.1", out ipa);
			var receiveEncoding = Encoding.Default;
			var ss = "2035353639202020353436342020202020202020202020202A2A20202020202020202020202020202020202020203030333130303031303438303031303030314535343030313035303030303030303030202020202020202020322030202020202020202020202020202020303357303031424A474E4A5330313032CEAFCDD0CAD5BFEE20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020B7A2B3F6BBF2CAD5B5BDCEAFCDD0CAD5BFEEBBF2CDD0CAD5B3D0B8B6CCE1CABE202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020";
			var buffer = HexStringToBytesArray(ss);
			var e = Encoding.GetEncoding("gb18030");
			var es = new EchoServer<string>
							(
								new IPEndPoint(ipa, 10003)
								, (x, y) =>
								{
									var sss = e.GetString(y);
									Console.Write(sss);
									try
									{
										x.SendDataSync(buffer);
									}
									catch (Exception ex)
									{
										Console.WriteLine(ex.ToString());
									}
									
								}
							);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}











//===========================================================================================
//Share.cs
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Text;
	using System.Net.Sockets;
	public class SocketAsyncDataHandler<T>
	{
		private Socket _socket;
		public Socket WorkingSocket
		{
			get
			{
				return _socket;
			}
		}
		public int ReceiveDataBufferLength
		{
			get;
			private set;
		}
		public T ConnectionToken
		{
			get;
			set;
		}
		public IPAddress RemoteIPAddress
		{
			get
			{
				return ((IPEndPoint)_socket.RemoteEndPoint).Address;
			}
		}
		public IPAddress LocalIPAddress
		{
			get
			{
				return ((IPEndPoint)_socket.LocalEndPoint).Address;
			}
		}
		public int SocketID
		{
			get;
			private set;
		}
		public SocketAsyncDataHandler
							(
								Socket socket
								, int socketID
							)
		{
			_socket = socket;
			_sendSocketAsyncEventArgs = new SocketAsyncEventArgs();
			SocketID = socketID;
		}
		private SocketAsyncEventArgs _sendSocketAsyncEventArgs;
		public int HeaderBytesLength
		{
			get;
			private set;
		}
		public int HeaderBytesOffset
		{
			get;
			private set;
		}
		public int HeaderBytesCount
		{
			get;
			private set;
		}
		private bool _isStartedReceiveData = false;
		private bool _isHeader = true;
		public bool StartReceiveWholeDataPackets
							(
								int receiveBufferLength
								, int headerBytesLength
								, int headerBytesOffset
								, int headerBytesCount
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onOneWholeDataPacketReceivedProcessFunc
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onDataPacketReceivedErrorProcessFunc //= null
								, Action
									<
										SocketAsyncDataHandler<T>
										, bool
									> onAfterDestoryWorkingSocketProcessAction //= null
							)
		{
			if (!_isStartedReceiveData)
			{
				HeaderBytesLength = headerBytesLength;
				HeaderBytesOffset = headerBytesOffset;
				HeaderBytesCount = headerBytesCount;
				var saeaReceive = new SocketAsyncEventArgs();
				ReceiveDataBufferLength = receiveBufferLength;
				saeaReceive.SetBuffer
								(
									new byte[ReceiveDataBufferLength]
									, 0
									, HeaderBytesLength
								);
				int bodyLength = 0;
				saeaReceive.Completed += new EventHandler<SocketAsyncEventArgs>
								(
									(sender, e) =>
									{
										var socket = sender as Socket;
										if (e.BytesTransferred >= 0)
										{
											byte[] buffer = e.Buffer;
											int r = e.BytesTransferred;
											int p = e.Offset;
											int l = e.Count;
											if (r < l)
											{
												p += r;
												e.SetBuffer(p, l - r);
											}
											else if (r == l)
											{
												if (_isHeader)
												{
													byte[] data = new byte[headerBytesCount];
													Buffer.BlockCopy
																(
																	buffer
																	, HeaderBytesOffset
																	, data
																	, 0
																	, data.Length
																);
													byte[] intBytes = new byte[4];
													l = (intBytes.Length < HeaderBytesCount ? intBytes.Length : HeaderBytesCount);
													Buffer.BlockCopy
																(
																	data
																	, 0
																	, intBytes
																	, 0
																	, l
																);
													//Array.Reverse(intBytes);
													//bodyLength = BitConverter.ToInt32(intBytes, 0);
													var ss = Encoding.ASCII.GetString(intBytes);
													bodyLength = int.Parse(ss);
													p += r;
													e.SetBuffer(p, bodyLength);
													//Console.WriteLine(bodyLength);
													_isHeader = false;
												}
												else
												{
													byte[] data = new byte[bodyLength + HeaderBytesLength];
													bodyLength = 0;
													Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
													_isHeader = true;
													e.SetBuffer(0, HeaderBytesLength);
													if (onOneWholeDataPacketReceivedProcessFunc != null)
													{
														onOneWholeDataPacketReceivedProcessFunc
																						(
																							this
																							, data
																							, e
																						);
													}
												}
											}
											else
											{
												if (onDataPacketReceivedErrorProcessFunc != null)
												{
													byte[] data = new byte[p + r + HeaderBytesLength];
													Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
													bool b = onDataPacketReceivedErrorProcessFunc
																					(
																						this
																						, data
																						, e
																					);
													if (b)
													{
														bool i = DestoryWorkingSocket();
														if (onAfterDestoryWorkingSocketProcessAction != null)
														{
															onAfterDestoryWorkingSocketProcessAction(this, i);
														}
													}
													else
													{
														_isHeader = true;
														e.SetBuffer(0, HeaderBytesLength);
													}
												}
											}
										}
										try
										{
											socket.ReceiveAsync(e);
										}
										catch (Exception exception)
										{
											Console.WriteLine(exception.ToString());
											DestoryWorkingSocket();
										}
									}
								);
				_socket.ReceiveAsync(saeaReceive);
				_isStartedReceiveData = true;
			}
			return _isStartedReceiveData;
		}
		public bool DestoryWorkingSocket()
		{
			bool r = false;
			try
			{
				//if (_socket.Connected)
				//{
				//	_socket.Disconnect(false);
				//}
				_socket.Shutdown(SocketShutdown.Both);
				_socket.Close();
				//_socket.Dispose();
				_socket = null;
				r = true;
			}
			catch (Exception e)
			{
				Console.WriteLine(e.ToString());
				//r = false;
			}
			return r;
		}
		public bool StartReceiveData
							(
								int receiveBufferLength
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onDataReceivedProcessFunc
							)
		{
			if (!_isStartedReceiveData)
			{
				var saeaReceive = new SocketAsyncEventArgs();
				saeaReceive.Completed += new EventHandler<SocketAsyncEventArgs>
												(
													(sender, e) =>
													{
														var socket = sender as Socket;
														int l = e.BytesTransferred;
														if (l > 0)
														{
															byte[] data = new byte[l];
															var buffer = e.Buffer;
															Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
															if (onDataReceivedProcessFunc != null)
															{
																onDataReceivedProcessFunc(this, data, e);
															}
														}
														try
														{
															socket.ReceiveAsync(e);
														}
														catch (Exception exception)
														{
															Console.WriteLine(exception.ToString());
														}
													}
												);
				ReceiveDataBufferLength = receiveBufferLength;
				saeaReceive.SetBuffer
								(
									new byte[ReceiveDataBufferLength]
									, 0
									, ReceiveDataBufferLength
								);
				_socket.ReceiveAsync(saeaReceive);
				_isStartedReceiveData = true;
			}
			return _isStartedReceiveData;
		}
		private object _sendSyncLockObject = new object();
		public int SendDataSync(byte[] data)
		{
			lock (_sendSyncLockObject)
			{
				return _socket.Send(data);
			}
		}
	}
}
//=======================================================================================================
//Server.cs
namespace Server
{
	using System;
	using System.Net;
	using System.Text;
	using System.Net.Sockets;
	using System.Threading;
	using Microshaoft;
	class EchoServer<T>
	{
		//Socket _socketListener;
		private Action<SocketAsyncDataHandler<T>, byte[]> _onReceivedDataProcessAction;
		public EchoServer
					(
						IPEndPoint localPoint
						, Action
							<
								SocketAsyncDataHandler<T>
								, byte[]
							>
							onReceivedDataProcessAction
					)
		{
			_onReceivedDataProcessAction = onReceivedDataProcessAction;
			var listener = new Socket
							(
								localPoint.AddressFamily
								, SocketType.Stream
								, ProtocolType.Tcp
							);
			listener.Bind(localPoint);
			listener.Listen(5);
			AcceptSocketAsyc(listener);
		}
		private void AcceptSocketAsyc(Socket listener)
		{
			var acceptSocketAsyncEventArgs = new SocketAsyncEventArgs();
			acceptSocketAsyncEventArgs.Completed += acceptSocketAsyncEventArgs_AcceptOneCompleted;
			listener.AcceptAsync(acceptSocketAsyncEventArgs);
		}
		private int _socketID = 0;
		void acceptSocketAsyncEventArgs_AcceptOneCompleted(object sender, SocketAsyncEventArgs e)
		{
			e.Completed -= acceptSocketAsyncEventArgs_AcceptOneCompleted;
			var client = e.AcceptSocket;
			var listener = sender as Socket;
			AcceptSocketAsyc(listener);
			var handler = new SocketAsyncDataHandler<T>
														(
															client
															, _socketID++
														);
			///			handler.StartReceiveData
			///						(
			///							1024
			///							, (x, y, z) =>
			///							{
			///								//var s = Encoding.UTF8.GetString(y);
			///								////Console.WriteLine("SocketID: {1}{0}Length: {2}{0}Data: {2}", "\r\n", x.SocketID, y.Length ,s);
			///								//Console.Write(s);
			///								if (_onReceivedDataProcessAction != null)
			///								{
			///									_onReceivedDataProcessAction(x, y);
			///								}
			///								return true;
			///							}
			///						);
			handler.StartReceiveWholeDataPackets
								(
									1024 * 1024
									, 5
									, 1
									, 4
									, (x, y, z) =>
									{
										if (y.Length > 0)
										{
											if (_onReceivedDataProcessAction != null)
											{
												_onReceivedDataProcessAction(x, y);
											}
										}
										else
										{
											Thread.Sleep(100);
										}
										return true;
									}
									, null
									, null
								);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Net.Sockets;
	public static class SocketDataHelper
	{
		public static void ReadDataToFixedLengthBytes
								(
									Socket socket,
									ref byte[] buffer
								)
		{
			int p = 0;
			int l = buffer.Length;
			while (p < l)
			{
				int r = socket.Receive
									(
										buffer
										, p
										, l - p
										, SocketFlags.None
									);
				p += r;
			}
		}
		public static byte[] ReadDataToFixedLengthBytes
									(
										int length,
										Socket socket
									)
		{
			int p = 0;
			byte[] data = new byte[length];
			while (p < length)
			{
				int r = socket.Receive
									(
										data
										, p
										, length - p
										, SocketFlags.None
									);
				p += r;
			}
			return data;
		}
		public static byte[] ReadDataToBytes
									(
										int length,
										Socket socket
									)
		{
			byte[] data = new byte[length];
			int r = 0;
			//SocketError error;
			r = socket.Receive
								(
									data
									, 0
									, length
									, SocketFlags.None
				//, out error
								);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref data, r);
			}
			else
			{
				data = null;
			}
			return data;
		}
		public static int ReadDataToBytes
								(
									Socket socket,
									ref byte[] buffer
								)
		{
			int r = 0;
			//SocketError error;
			int l = buffer.Length;
			r = socket.Receive
							(
								buffer
								, 0
								, l
								, SocketFlags.None
				//, out error
							);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref buffer, r);
			}
			else
			{
				buffer = null;
			}
			return r;
		}
	}
	public static class StreamDataHelper
	{
		private static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=CodeDom .Net 4.0
namespace SampleCodeDom
{
	using System;
	using System.Reflection;
	using System.IO;
	using System.CodeDom;
	using System.CodeDom.Compiler;
	using Microsoft.CSharp;
	/// <summary>
	/// This code example creates a graph using a CodeCompileUnit and  
	/// generates source code for the graph using the CSharpCodeProvider.
	/// </summary>
	class Sample
	{
		/// <summary>
		/// Define the compile unit to use for code generation. 
		/// </summary>
		CodeCompileUnit targetUnit;
		/// <summary>
		/// The only class in the compile unit. This class contains 2 fields,
		/// 3 properties, a constructor, an entry point, and 1 simple method. 
		/// </summary>
		CodeTypeDeclaration targetClass;
		/// <summary>
		/// The name of the file to contain the source code.
		/// </summary>
		private const string outputFileName = "SampleCode.cs";
		/// <summary>
		/// Define the class.
		/// </summary>
		public Sample()
		{
			targetUnit = new CodeCompileUnit();
			CodeNamespace samples = new CodeNamespace("CodeDOMSample");
			samples.Imports.Add(new CodeNamespaceImport("System"));
			targetClass = new CodeTypeDeclaration("CodeDOMCreatedClass");
			targetClass.IsClass = true;
			targetClass.TypeAttributes =
				TypeAttributes.Public | TypeAttributes.Sealed;
			samples.Types.Add(targetClass);
			targetUnit.Namespaces.Add(samples);
		}
		/// <summary>
		/// Adds two fields to the class.
		/// </summary>
		public void AddFields()
		{
			// Declare the widthValue field.
			CodeMemberField widthValueField = new CodeMemberField();
			widthValueField.Attributes = MemberAttributes.Private;
			widthValueField.Name = "widthValue";
			widthValueField.Type = new CodeTypeReference(typeof(System.Double));
			widthValueField.Comments.Add(new CodeCommentStatement(
				"The width of the object."));
			targetClass.Members.Add(widthValueField);
			// Declare the heightValue field
			CodeMemberField heightValueField = new CodeMemberField();
			heightValueField.Attributes = MemberAttributes.Private;
			heightValueField.Name = "heightValue";
			heightValueField.Type =
				new CodeTypeReference(typeof(System.Double));
			heightValueField.Comments.Add(new CodeCommentStatement(
				"The height of the object."));
			targetClass.Members.Add(heightValueField);
		}
		/// <summary>
		/// Add three properties to the class.
		/// </summary>
		public void AddProperties()
		{
			// Declare the read-only Width property.
			CodeMemberProperty widthProperty = new CodeMemberProperty();
			widthProperty.Attributes =
				MemberAttributes.Public | MemberAttributes.Final;
			widthProperty.Name = "Width";
			widthProperty.HasGet = true;
			widthProperty.Type = new CodeTypeReference(typeof(System.Double));
			widthProperty.Comments.Add(new CodeCommentStatement(
				"The Width property for the object."));
			widthProperty.GetStatements.Add(new CodeMethodReturnStatement(
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "widthValue")));
			targetClass.Members.Add(widthProperty);
			// Declare the read-only Height property.
			CodeMemberProperty heightProperty = new CodeMemberProperty();
			heightProperty.Attributes =
				MemberAttributes.Public | MemberAttributes.Final;
			heightProperty.Name = "Height";
			heightProperty.HasGet = true;
			heightProperty.Type = new CodeTypeReference(typeof(System.Double));
			heightProperty.Comments.Add(new CodeCommentStatement(
				"The Height property for the object."));
			heightProperty.GetStatements.Add(new CodeMethodReturnStatement(
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "heightValue")));
			targetClass.Members.Add(heightProperty);
			// Declare the read only Area property.
			CodeMemberProperty areaProperty = new CodeMemberProperty();
			areaProperty.Attributes =
				MemberAttributes.Public | MemberAttributes.Final;
			areaProperty.Name = "Area";
			areaProperty.HasGet = true;
			areaProperty.Type = new CodeTypeReference(typeof(System.Double));
			areaProperty.Comments.Add(new CodeCommentStatement(
				"The Area property for the object."));
			// Create an expression to calculate the area for the get accessor 
			// of the Area property.
			CodeBinaryOperatorExpression areaExpression =
				new CodeBinaryOperatorExpression(
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "widthValue"),
				CodeBinaryOperatorType.Multiply,
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "heightValue"));
			areaProperty.GetStatements.Add(
				new CodeMethodReturnStatement(areaExpression));
			targetClass.Members.Add(areaProperty);
		}
		/// <summary>
		/// Adds a method to the class. This method multiplies values stored 
		/// in both fields.
		/// </summary>
		public void AddMethod()
		{
			// Declaring a ToString method
			CodeMemberMethod toStringMethod = new CodeMemberMethod();
			toStringMethod.Attributes =
				MemberAttributes.Public | MemberAttributes.Override;
			toStringMethod.Name = "ToString";
			toStringMethod.ReturnType =
				new CodeTypeReference(typeof(System.String));
			CodeFieldReferenceExpression widthReference =
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "Width");
			CodeFieldReferenceExpression heightReference =
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "Height");
			CodeFieldReferenceExpression areaReference =
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "Area");
			// Declaring a return statement for method ToString.
			CodeMethodReturnStatement returnStatement =
				new CodeMethodReturnStatement();
			// This statement returns a string representation of the width,
			// height, and area.
			string formattedOutput = "The object:" + Environment.NewLine +
				" width = {0}," + Environment.NewLine +
				" height = {1}," + Environment.NewLine +
				" area = {2}";
			returnStatement.Expression =
				new CodeMethodInvokeExpression(
				new CodeTypeReferenceExpression("System.String"), "Format",
				new CodePrimitiveExpression(formattedOutput),
				widthReference, heightReference, areaReference);
			toStringMethod.Statements.Add(returnStatement);
			targetClass.Members.Add(toStringMethod);
		}
		/// <summary>
		/// Add a constructor to the class.
		/// </summary>
		public void AddConstructor()
		{
			// Declare the constructor
			CodeConstructor constructor = new CodeConstructor();
			constructor.Attributes =
				MemberAttributes.Public | MemberAttributes.Final;
			// Add parameters.
			constructor.Parameters.Add(new CodeParameterDeclarationExpression(
				typeof(System.Double), "width"));
			constructor.Parameters.Add(new CodeParameterDeclarationExpression(
				typeof(System.Double), "height"));
			// Add field initialization logic
			CodeFieldReferenceExpression widthReference =
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "widthValue");
			constructor.Statements.Add(new CodeAssignStatement(widthReference,
				new CodeArgumentReferenceExpression("width")));
			CodeFieldReferenceExpression heightReference =
				new CodeFieldReferenceExpression(
				new CodeThisReferenceExpression(), "heightValue");
			constructor.Statements.Add(new CodeAssignStatement(heightReference,
				new CodeArgumentReferenceExpression("height")));
			targetClass.Members.Add(constructor);
		}
		/// <summary>
		/// Add an entry point to the class.
		/// </summary>
		public void AddEntryPoint()
		{
			CodeEntryPointMethod start = new CodeEntryPointMethod();
			CodeObjectCreateExpression objectCreate =
				new CodeObjectCreateExpression(
				new CodeTypeReference("CodeDOMCreatedClass"),
				new CodePrimitiveExpression(5.3),
				new CodePrimitiveExpression(6.9));
			// Add the statement:
			// "CodeDOMCreatedClass testClass = 
			//	 new CodeDOMCreatedClass(5.3, 6.9);"
			start.Statements.Add(new CodeVariableDeclarationStatement(
				new CodeTypeReference("CodeDOMCreatedClass"), "testClass",
				objectCreate));
			// Creat the expression:
			// "testClass.ToString()"
			CodeMethodInvokeExpression toStringInvoke =
				new CodeMethodInvokeExpression(
				new CodeVariableReferenceExpression("testClass"), "ToString");
			// Add a System.Console.WriteLine statement with the previous 
			// expression as a parameter.
			start.Statements.Add(new CodeMethodInvokeExpression(
				new CodeTypeReferenceExpression("System.Console"),
				"WriteLine", toStringInvoke));
			targetClass.Members.Add(start);
		}
		/// <summary>
		/// Generate CSharp source code from the compile unit.
		/// </summary>
		/// <param name="filename">Output file name</param>
		public void GenerateCSharpCode(string fileName)
		{
			CodeDomProvider provider = CodeDomProvider.CreateProvider("CSharp");
			CodeGeneratorOptions options = new CodeGeneratorOptions();
			options.BracingStyle = "C";
			using (StreamWriter sourceWriter = new StreamWriter(fileName))
			{
				provider.GenerateCodeFromCompileUnit(
					targetUnit, sourceWriter, options);
			}
		}
		/// <summary>
		/// Create the CodeDOM graph and generate the code.
		/// </summary>
		static void Main()
		{
			Sample sample = new Sample();
			sample.AddFields();
			sample.AddProperties();
			sample.AddMethod();
			sample.AddConstructor();
			sample.AddEntryPoint();
			sample.GenerateCSharpCode(outputFileName);
		}
	}
}

#T=CodeDom Basic
namespace BasicCodeDomApp
{
	using System;
	using System.CodeDom;
	using System.CodeDom.Compiler;
	using System.IO;
	using System.Text.RegularExpressions;
	class Program
	{
		static string providerName = "cs";
		static string sourceFileName = "test.cs";
		static void Main(string[] args)
		{
			CodeDomProvider provider = 
				CodeDomProvider.CreateProvider(providerName);
			LogMessage("Building CodeDOM graph...");
			CodeCompileUnit cu = new CodeCompileUnit();
			cu = BuildHelloWorldGraph();
			StreamWriter sourceFile = new StreamWriter(sourceFileName);
			provider.GenerateCodeFromCompileUnit(cu, sourceFile, null);
			sourceFile.Close();
			CompilerParameters opt = new CompilerParameters(new string[]{
									  "System.dll" });
			opt.GenerateExecutable = true;
			opt.OutputAssembly = "HelloWorld.exe";
			opt.TreatWarningsAsErrors = true;
			opt.IncludeDebugInformation = true;
			opt.GenerateInMemory = true;
			opt.CompilerOptions = "/doc:HelloWorldDoc.xml";
			CompilerResults results;
			LogMessage("Compiling with " + providerName);
			results = provider.CompileAssemblyFromFile(opt, sourceFileName);
			OutputResults(results);
			if (results.NativeCompilerReturnValue != 0)
			{
				LogMessage("");
				LogMessage("Compilation failed.");
			}
			else
			{
				LogMessage("");
				LogMessage("Demo completed successfully.");
			}
			File.Delete(sourceFileName);
		}
		// Build a Hello World program graph using 
		// System.CodeDom types.
		public static CodeCompileUnit BuildHelloWorldGraph()
		{
			// Create a new CodeCompileUnit to contain 
			// the program graph.
			CodeCompileUnit compileUnit = new CodeCompileUnit();
			// Declare a new namespace called Samples.
			CodeNamespace samples = new CodeNamespace("Samples");
			// Add the new namespace to the compile unit.
			compileUnit.Namespaces.Add(samples);
			// Add the new namespace import for the System namespace.
			samples.Imports.Add(new CodeNamespaceImport("System"));
			// Declare a new type called Class1.
			CodeTypeDeclaration class1 = new CodeTypeDeclaration("Class1");
			class1.Comments.Add(new CodeCommentStatement("<summary>", true));
			class1.Comments.Add(new CodeCommentStatement(
				"Create a Hello World application.", true));
			class1.Comments.Add(new CodeCommentStatement(
				@"<seealso cref=" + '"' + "Class1.Main" + '"' + "/>", true));
			class1.Comments.Add(new CodeCommentStatement("</summary>", true));
			// Add the new type to the namespace type collection.
			samples.Types.Add(class1);
			// Declare a new code entry point method.
			CodeEntryPointMethod start = new CodeEntryPointMethod();
			start.Comments.Add(new CodeCommentStatement("<summary>", true));
			start.Comments.Add(new CodeCommentStatement(
				"Main method for HelloWorld application.", true));
			start.Comments.Add(new CodeCommentStatement(
				@"<para>Add a new paragraph to the description.</para>", true));
			start.Comments.Add(new CodeCommentStatement("</summary>", true));
			// Create a type reference for the System.Console class.
			CodeTypeReferenceExpression csSystemConsoleType = 
				new CodeTypeReferenceExpression("System.Console");
			// Build a Console.WriteLine statement.
			CodeMethodInvokeExpression cs1 = new CodeMethodInvokeExpression(
				csSystemConsoleType, "WriteLine",
				new CodePrimitiveExpression("Hello World!"));
			// Add the WriteLine call to the statement collection.
			start.Statements.Add(cs1);
			// Build another Console.WriteLine statement.
			CodeMethodInvokeExpression cs2 = new CodeMethodInvokeExpression(
				csSystemConsoleType, "WriteLine", new CodePrimitiveExpression(
				"Press the ENTER key to continue."));
			// Add the WriteLine call to the statement collection.
			start.Statements.Add(cs2);
			// Build a call to System.Console.ReadLine.
			CodeMethodInvokeExpression csReadLine = 
				new CodeMethodInvokeExpression(csSystemConsoleType, "ReadLine");
			// Add the ReadLine statement.
			start.Statements.Add(csReadLine);
			// Add the code entry point method to
			// the Members collection of the type.
			class1.Members.Add(start);
			return compileUnit;
		}
		static void LogMessage(string text)
		{
			Console.WriteLine(text);
		}
		static void OutputResults(CompilerResults results)
		{
			LogMessage("NativeCompilerReturnValue=" +
				results.NativeCompilerReturnValue.ToString());
			foreach (string s in results.Output)
			{
				LogMessage(s);
			}
		}
	}
}

#T=CodeDomProvider dynamic 动态编译执行代码 
namespace Test
{
	using System;
	using Microsoft.CSharp;
	using System.CodeDom.Compiler;
	using System.Reflection;
	using Microshaoft;
	public class ContextInfo
	{
		public string F1;
	}
	class Program
	{
		static void Main(string[] args)
		{
			string codeSnippet1 = @"
Console.WriteLine(x);
Console.WriteLine(y.F1);
//TResult r;
return true;
";
			string codeSnippet2 = @"
Console.WriteLine(x);
Console.WriteLine(y.F1);
Console.WriteLine(z);
//TResult r;
//return true;
";
			string codeSnippet3 = @"
//Console.WriteLine(x);
//Console.WriteLine(y.F1);
Console.WriteLine(""Action()"");
//TResult r;
//return true;
";
			SourceCodeDynamicCompilerInvokers invokers = new SourceCodeDynamicCompilerInvokers();
			invokers
				.Add
					(
						new string[] { "System.dll", @"Noname3.exe" }
						, new string[] { "System", "System", "Test" }
						, "Func<string, ContextInfo, bool>"
						, "Call"
						, new string[] { "x", "y" }
						, codeSnippet1
					);
			invokers
				.Add
					(
						new string[] { "System.dll", "System.dll", @"Noname3.exe" }
						, new string[] { "System", "System.Text", "Test" }
						, "Action<int, ContextInfo, bool>"
						, "Call2"
						, new string[] { "x", "y", "z" }
						, codeSnippet2
					);
			invokers
				.Add
					(
						new string[] { "System.dll", "System.dll", @"Noname3.exe" }
						, new string[] { "System", "System.Text", "Test" }
						, "Action"
						, "Call3"
						, null //new string[] { "x", "y", "z" }
						, codeSnippet3
					);
			invokers.Build();
			//Func<string, ContextInfo, bool> func = (Func<string, ContextInfo, bool>) cr["Call"];
			dynamic func = invokers["Call"];
			var r = func("xxxx", new ContextInfo() { F1 = "FF1" });
			Console.WriteLine(r);
			//Action<int, ContextInfo, bool> action = (Action<int, ContextInfo, bool>) cr["Call2"];
			dynamic action = invokers["Call2"];
			action(999, new ContextInfo() { F1 = "FFF1" }, false);
			//Action action = (Action) cr["Call3"];
			dynamic action2 = invokers["Call3"];
			action2();
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.CodeDom.Compiler;
	using System.Collections.Concurrent;
	using System.Linq;
	using System.Reflection;
	using System.Text;
	public class SourceCodeDynamicCompilerInvokers
	{
		private string _codeTemplate = @"
namespace Microshaoft.Temp
{{
	{0}
	public static partial class InvokersManager
	{{
		public static
						{1}						//方法签名定义,如: Func<string, string, bool>
						{2}						//方法名称
							()
		{{
			var invoker = new {1}				//方法签名定义,如: Func<string, string, bool>
								(
									(
										{3}		//参数列表
									) =>
									{{
										{4}		//代码
									}}
								);
			return invoker;
		}}
	}}
}}
";
		private class CodeTemplatePlaceHolder
		{
			public string[] ReferencedAssemblies;
			public string[] UsingsTargets;
			public string MethodDefinitionStatment;
			public string MethodName;
			public string[] MethodArgs;
			public string EmbedInlineCodeSnippet;
			public Delegate MethodInvoker;
		}
		public Delegate this[string key]
		{
			get
			{
				return
					_sourceCodes[key].MethodInvoker;
			}
		}
		private ConcurrentDictionary<string, CodeTemplatePlaceHolder> _sourceCodes
						= new ConcurrentDictionary<string, CodeTemplatePlaceHolder>();
		private void Compile
					(
						string[] referencedAssemblies
						, string sourceCode
					)
		{
			CodeDomProvider codeDomProvider = CodeDomProvider.CreateProvider("CSharp");
			var compilerParameters = new CompilerParameters();
			Array
				.ForEach
					(
						referencedAssemblies
						, (x) =>
						{
							compilerParameters
								.ReferencedAssemblies
								.Add(x);
						}
					);
			compilerParameters.GenerateExecutable = false;
			compilerParameters.GenerateInMemory = true;
			//Console.WriteLine(code);
			var compilerResults = codeDomProvider
										.CompileAssemblyFromSource
											(
												compilerParameters
												, sourceCode
											);
			var assembly = compilerResults.CompiledAssembly;
			var codes = _sourceCodes.AsEnumerable();
			var stringBuilder = new StringBuilder();
			foreach (var kvp in codes)
			{
				MethodInfo mi = assembly
									.GetType("Microshaoft.Temp.InvokersManager")
									.GetMethod(kvp.Key);
				Delegate invoker = (Delegate) mi.Invoke(null, null);
				kvp.Value.MethodInvoker = invoker;
			}
		}
		public void Add
						(
							string[] referencedAssemblies
							, string[] usingsTargets
							, string methodSignatureDefinition
							, string methodName
							, string[] methodArgs
							, string embedInlineCodeSnippet
						)
		{
			_sourceCodes
				.TryAdd
					(
							methodName
							, new CodeTemplatePlaceHolder()
								{
									ReferencedAssemblies = referencedAssemblies
									 ,
									UsingsTargets = usingsTargets
									 ,
									MethodDefinitionStatment = methodSignatureDefinition
									 ,
									MethodName = methodName
									 ,
									MethodArgs = methodArgs
									 ,
									EmbedInlineCodeSnippet = embedInlineCodeSnippet
								}
					);
		}
		public void Build()
		{
			string[] referencedAssemblies
						= _sourceCodes
							.SelectMany
								(
									(x) =>
									{
										return
											x
												.Value
												.ReferencedAssemblies;
									}
								).Distinct()
								 .ToArray();

			var sourceCodes = _sourceCodes.AsEnumerable();
			var stringBuilder = new StringBuilder();
			foreach (var kvp in sourceCodes)
			{
				var usingStatement = "using {0};";
				var usingsTargets = kvp
										.Value
										.UsingsTargets
										.Distinct();
				var usingsStatementsItems
							= usingsTargets
								.Select
									(
										(xx) =>
										{
											var rr = string.Format(usingStatement, xx);
											return rr;
										}
									);
				var usingsStatements = string.Join("\r\n", usingsStatementsItems);
				var methodArgs = kvp
									.Value
									.MethodArgs;
				var methodArgsStatement = string.Empty;
				if
					(
						methodArgs != null
						&&
						methodArgs.Length > 0
					)
				{
					methodArgsStatement = string.Join(", ", methodArgs);
				}
				var sourceCode = string
									.Format
										(
											_codeTemplate
											, usingsStatements
											, kvp.Value.MethodDefinitionStatment
											, kvp.Value.MethodName
											, methodArgsStatement
											, kvp.Value.EmbedInlineCodeSnippet
										);
				stringBuilder
					.AppendLine(sourceCode);
			}
			Compile(referencedAssemblies, stringBuilder.ToString());
		}
	}
}

#T=CodeTimer
namespace ConsoleApplication
{
	using System;
	using System.Text;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			int iteration = 100 * 1000;
			string noises = "`~!@#$%&*()_+-=\t{}|[]\\:\";'<>?,./\0\r\n ";
			noises += "～！＃￥％……＆×（）――＋・－＝｛｝｜【】＼：“”；‘’＇＜＞？，．／　";
			string s = "asdasdsadasdsad";
			CodeTimer.Time
						(
							"1",
							iteration,
							() =>
								{
									StringHelper.FilterNoises(s, noises);
								}
						);
			CodeTimer.Time
						(
							"2",
							iteration,
							() =>
								{
									StringHelper.FilterNoises(s, noises);
								}
						);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Runtime.InteropServices;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void Time(string name, int iteration, Action action)
		{
			if (String.IsNullOrEmpty(name))
			{
				return;
			}
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCycleCount();
			for (int i = 0; i < iteration; i++)
			{
				action();
			}
			ulong cpuCycles = GetCycleCount() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine("\tTime Elapsed:\t{0:N0}{1}", watch.ElapsedMilliseconds, "ms");
			Console.WriteLine("\tCPU Cycles:\t{0:N0}", cpuCycles);
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine("\tGen {0}:\t\t{1}", i, count);
			}
			Console.WriteLine();
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			//Windows Vista
			//QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
	}
}

//csc.exe /r:C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\microsoft.visualbasic.dll noname1.cs
namespace ConsoleApplication
{
	using System;
	using Microsoft.VisualBasic;
	public class StringHelper
	{
		public static string FilterNoises(string text, string noises)
		{
			text = Strings.StrConv(text, VbStrConv.Narrow, 0);
			//Console.WriteLine("[{0}]", text);
			//char[] a = noises.ToCharArray();
			int l = noises.Length;
			for (int i = 0; i < noises.Length; i++)
			{
				string r = noises.Substring(i, 1);
				text = text.Replace(r, "");
			}
///			foreach (char c in a)
///			{
///				string s = new string(new char[] {c});
///				text = text.Replace(s, "");
///			}
			return text;
		}
		public static string FilterNoises2(string text, string noises)
		{
			text = Strings.StrConv(text, VbStrConv.Narrow, 0);
			//Console.WriteLine("[{0}]", text);
			char[] a = noises.ToCharArray();
			int l = noises.Length;
///			for (int i = 0; i < noises.Length; i++)
///			{
///				string r = noises.Substring(i, 1);
///				text = text.Replace(r, "");
///			}
			foreach (char c in a)
			{
				string s = new string(new char[] {c});
				text = text.Replace(s, "");
			}
			return text;
		}
	}
}

#T=CodeTimer Win7 + .NET 4.0
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Runtime.InteropServices;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void ParallelTime(string name, int iteration, int maxDegreeOfParallelism, Action action)
		{
			InternalIterationProcess
					(
						name
						, iteration
						, () =>
							{
								Parallel.For
											(
												0
												, iteration
												, new ParallelOptions()
															{
																MaxDegreeOfParallelism = maxDegreeOfParallelism
																//, TaskScheduler = null
															}
												, i =>
													{
														action();
													}
											);
							}
					);
		}
		private static void InternalIterationProcess(string name, int iteration, Action action)
		{
			if (string.IsNullOrEmpty(name))
			{
				return;
			}
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCycleCount();
			action();
			ulong cpuCycles = GetCycleCount() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine
							(
								"{0}Time Elapsed:{0}{1}ms"
								, "\t"
								, watch.ElapsedMilliseconds.ToString("N0")
							);
			Console.WriteLine
							(
								"{0}CPU Cycles:{0}{1}"
								, "\t"
								, cpuCycles.ToString("N0")
							);
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine
							(
								"{0}Gen{1}:{0}{0}{2}"
								, "\t"
								, i
								, count
							);
			}
			Console.WriteLine();
		}
		public static void Time(string name, int iteration, Action action)
		{
			InternalIterationProcess
								(
									name
									, iteration
									, () =>
										{
											for (int i = 0; i < iteration; i++)
											{
												action();
											}
										}
									);
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
	}
}
#T=Comet Async Handler
//Server Side
namespace Server.CometAsync
{
	using System;
	using System.Web;
	using System.Threading;
	using System.Diagnostics;
	using System.Runtime.Serialization.Json;
	using System.Collections.Generic;
	public class CometSyncHandler : IHttpHandler
	{
		public bool IsReusable
		{
			get
			{
				return true;
			}
		}
		public void ProcessRequest(HttpContext context)
		{
			int workerAvailable = 0;
			int completionPortAvailable = 0;
			ThreadPool.GetAvailableThreads(out workerAvailable, out completionPortAvailable);
			Debug.WriteLine("CometSyncHandler.ProcessRequest Start");
			Debug.WriteLine(string.Format("Worker Threads Available: {0}</br>", workerAvailable));
			Debug.WriteLine(string.Format("Completion Port Threads Available: {0}</br>", completionPortAvailable));
			DateTime now = DateTime.Now;
			while (true)
			{
				Thread.Sleep(50);
				if (DateTime.Now.Subtract(now).TotalSeconds >= 5)
				{
					break;
				}
			}
			Debug.WriteLine("CometSyncHandler.ProcessRequest End");
		}
	}
	public class CometAsyncHandler : IHttpAsyncHandler
	{
		#region IHttpAsyncHandler Members
		public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object extraData)
		{
			int workerAvailable = 0;
			int completionPortAvailable = 0;
			ThreadPool.GetAvailableThreads(out workerAvailable, out completionPortAvailable);
			Debug.WriteLine(string.Format("BeginProcessRequest: {0} {1} out of {2}/{3} ({4} Requests Active)", Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.ManagedThreadId, workerAvailable, completionPortAvailable, CometWaitRequest.RequestCount));
			//  get the result here
			CometAsyncResult result = new CometAsyncResult(context, cb, extraData);
			result.BeginWaitRequest();
			//  ok, return it
			return result;
		}
		public void EndProcessRequest(IAsyncResult result)
		{
			int workerAvailable = 0;
			int completionPortAvailable = 0;
			ThreadPool.GetAvailableThreads(out workerAvailable, out completionPortAvailable);
			Debug.WriteLine(string.Format("EndProcessRequest: {0} {1} out of {2}/{3} ({4} Requests Active)", Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.ManagedThreadId, workerAvailable, completionPortAvailable, CometWaitRequest.RequestCount));
			CometAsyncResult cometAsyncResult = result as CometAsyncResult;
			if (cometAsyncResult != null && cometAsyncResult.ResponseObject != null)
			{
				DataContractJsonSerializer serializer = new DataContractJsonSerializer(cometAsyncResult.ResponseObject.GetType());
				serializer.WriteObject(cometAsyncResult.HttpContext.Response.OutputStream, cometAsyncResult.ResponseObject);
			}
			cometAsyncResult.HttpContext.Response.End();
		}
		#endregion
		#region IHttpHandler Members
		public bool IsReusable
		{
			get
			{
				return true;
			}
		}
		public void ProcessRequest(HttpContext context)
		{
			throw new InvalidOperationException("ASP.NET Should never use this property");
		}
		#endregion
	}
	public class CometWaitRequest
	{
		private CometAsyncResult result;
		private DateTime dateTimeAdded = DateTime.Now;
		public static int RequestCount = 0;
		public CometWaitRequest(CometAsyncResult result)
		{
			this.result = result;
		}
		public CometAsyncResult Result
		{
			get
			{
				return this.result;
			}
		}
		public DateTime DateTimeAdded
		{
			get
			{
				return this.dateTimeAdded;
			}
		}
	}
	public class CometAsyncResult : IAsyncResult
	{
		private HttpContext context;
		private AsyncCallback callback;
		private object asyncState;
		private bool isCompleted = false;
		private object responseObject;
		public CometAsyncResult(HttpContext context, AsyncCallback callback, object asyncState)
		{
			this.callback = callback;
			this.context = context;
			this.asyncState = asyncState;
		}
		#region IAsyncResult Members
		public object AsyncState
		{
			get
			{
				return this.asyncState;
			}
		}
		public WaitHandle AsyncWaitHandle
		{
			get
			{
				throw new InvalidOperationException("ASP.NET Should never use this property");
			}
		}
		public bool CompletedSynchronously
		{
			get
			{
				return false;
			}
		}
		public bool IsCompleted
		{
			get
			{
				return this.isCompleted;
			}
		}
		#endregion
		public HttpContext HttpContext
		{
			get
			{
				return this.context;
			}
		}
		public object ResponseObject
		{
			get
			{
				return this.responseObject;
			}
			set
			{
				this.responseObject = value;
			}
		}
		public void BeginWaitRequest()
		{
			CometThreadPool.QueueCometWaitRequest(new CometWaitRequest(this));
		}
		internal void SetCompleted()
		{
			this.isCompleted = true;
			if (callback != null)
			{
				callback(this);
			}
		}
	}
	public static class CometThreadPool
	{
		private static object state = new object();
		private static List<CometWaitThread> waitThreads = new List<CometWaitThread>();
		private static int nextWaitThread = 0;
		private static int maxWaitThreads = 0;
		internal static void QueueCometWaitRequest(CometWaitRequest request)
		{
			CometWaitThread waitThread;
			lock (state)
			{
				//  else, get the next wait thread
				waitThread = waitThreads[nextWaitThread];
				//  cycle the thread that we want
				nextWaitThread++;
				if (nextWaitThread == maxWaitThreads)
				{
					nextWaitThread = 0;
				}
				CometWaitRequest.RequestCount++;
			}
			//  queue the wait request
			waitThread.QueueCometWaitRequest(request);
		}
		public static void CreateThreads(int count)
		{
			for (int i = 0; i < count; i++)
			{
				CometWaitThread waitThread = new CometWaitThread();
				waitThreads.Add(waitThread);
			}
			maxWaitThreads = count;
		}
	}
	public class CometWaitThread
	{
		private object state = new object();
		private List<CometWaitRequest> waitRequests = new List<CometWaitRequest>();
		private bool started = false;
		public List<CometWaitRequest> WaitRequests
		{
			get
			{
				return this.waitRequests;
			}
		}
		public CometWaitThread()
		{
			if (!started)
			{
				started = true;
				Thread t = new Thread(new ThreadStart(QueueCometWaitRequest_WaitCallback));
				t.IsBackground = false;
				t.Start();
			}
		}
		internal void QueueCometWaitRequest(CometWaitRequest request)
		{
			lock (this.state)
			{
				waitRequests.Add(request);
			}
		}
		internal void DequeueCometWaitRequest(CometWaitRequest request)
		{
			lock (state)
			{
				this.waitRequests.Remove(request);
				CometWaitRequest.RequestCount--;
			}
		}
		private void QueueCometWaitRequest_Finished(object target)
		{
			CometWaitRequest request = target as CometWaitRequest;
			request.Result.SetCompleted();
		}
		private void QueueCometWaitRequest_WaitCallback()
		{
			//  here we are...
			//  in a loop
			while (true)
			{
				//Debug.WriteLine(string.Format("QueueCometWaitRequest_WaitCallback Tick: {0} {1} ", Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.ManagedThreadId));
				CometWaitRequest[] processRequest;
				lock (this.state)
				{
					processRequest = waitRequests.ToArray();
				}
				//  we have no more wait requests left, so we want exis
				/*if (processRequest.Length == 0)
					break;*/
				Thread.Sleep(100);
				for (int i = 0; i < processRequest.Length; i++)
				{
					//  timed out so remove from the queue
					if (DateTime.Now.Subtract(processRequest[i].DateTimeAdded).TotalSeconds >= 5)
					{
						Debug.WriteLine(string.Format("QueueCometWaitRequest_WaitCallback Timeout: {0} {1} ", Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.ManagedThreadId));
						//  dequeue the request 
						DequeueCometWaitRequest(processRequest[i]);
						//
						//  queue anotehr wait callback, so
						//  we tell close handler down
						//  the endRequest will exist on a different thread to this
						//  one and not tear down this thread
						processRequest[i].Result.ResponseObject = this.CheckForServerPushEvent(processRequest[i], true);
						this.QueueCometWaitRequest_Finished(processRequest[i]);
					}
					else
					{
						object serverPushEvent = this.CheckForServerPushEvent(processRequest[i], false);
						if (serverPushEvent != null)
						{
							//  we have our event, which is good
							//  it means we can serialize it back to the client
							processRequest[i].Result.ResponseObject = serverPushEvent;
							//  queue the response on another ASP.NET Worker thread
							this.QueueCometWaitRequest_Finished(processRequest[i]);
							//  dequeue the request
							DequeueCometWaitRequest(processRequest[i]);
						}
					}
					Thread.Sleep(100);
				}
			}
		}
		private object CheckForServerPushEvent(CometWaitRequest request, bool timeout)
		{
			if (timeout)
			{
				//  this is returned when the wait request timesout
				return "Response from: " + Thread.CurrentThread.ManagedThreadId.ToString();
			}
			else
			{
				//  this is returned when the server wants to check for a message
				return null;
			}
		}
	}
}
namespace CometAsync.Web
{
	using System;
	using System.Web;
	using System.Threading;
	public partial class _Default : System.Web.UI.Page
	{
		protected void Page_Load(object sender, EventArgs e)
		{
			int workerAvailable = 0;
			int completionPortAvailable = 0;
			ThreadPool.GetAvailableThreads(out workerAvailable, out completionPortAvailable);
			Response.Write(string.Format("Worker Threads Available: {0}</br>", workerAvailable));
			Response.Write(string.Format("Completion Port Threads Available: {0}</br>", completionPortAvailable));
		}
	}
	public partial class _Default
	{
		/// <summary>
		/// form1 control.
		/// </summary>
		/// <remarks>
		/// Auto-generated field.
		/// To modify move field declaration from designer file to code-behind file.
		/// </remarks>
		protected global::System.Web.UI.HtmlControls.HtmlForm form1;
	}
}
namespace Server.CometAsync.Web
{
	using System;
	using System.Web;
	using System.Web.Security;
	using System.Web.SessionState;
	using System.Collections;
	using Server.CometAsync;
	public class Global : System.Web.HttpApplication
	{
		protected void Application_Start(object sender, EventArgs e)
		{
			//
			//  queue 5 threads to run
			//  the comet requests
			CometThreadPool.CreateThreads(5);
		}
		protected void Session_Start(object sender, EventArgs e)
		{
		}
		protected void Application_BeginRequest(object sender, EventArgs e)
		{
		}
		protected void Application_AuthenticateRequest(object sender, EventArgs e)
		{
		}
		protected void Application_Error(object sender, EventArgs e)
		{
		}
		protected void Session_End(object sender, EventArgs e)
		{
		}
		protected void Application_End(object sender, EventArgs e)
		{
		}
	}
}
//Client Side
namespace Client.CometClientSimulator
{
	using System;
	using System.Threading;
	using System.Net;
	using System.Web;
	using System.IO;
	using System.Collections.Generic;
	using System.Runtime.Serialization.Json;
	using System.Text;
	class Program
	{
		static void Main(string[] args)
		{
			bool loop = true;
			List<CometAsyncRequest> asyncRequest = new List<CometAsyncRequest>();
			string host = "http://localhost:2251";
			if (args != null && args.Length > 0)
			{
				host = args[0].TrimEnd('/');
			}
			while (loop)
			{
				string s = Console.ReadLine();
				switch (s.ToLower())
				{
					case "addsyncclients":
						for (int i = 0; i < 25; i++)
						{
							Console.WriteLine("Creating Sync Client: {0}", i);
							CometSyncRequest csr = new CometSyncRequest(host);
							csr.SendCometRequest();
							Thread.Sleep(2000);
						}
						break;
					case "addasyncclients":
						for (int i = 0; i < 25; i++)
						{
							Console.WriteLine("Creating Async Client: {0}", i);
							CometAsyncRequest csr = new CometAsyncRequest(host);
							asyncRequest.Add(csr);
							csr.SendCometRequest();
							Thread.Sleep(2000);
						}
						break;
					case "stop":
						foreach (CometAsyncRequest car in asyncRequest)
						{
							car.Stop = true;
						}
						//  wait 6 seconds
						Thread.Sleep(6000);
						int tid = 0;
						foreach (CometAsyncRequest car in asyncRequest)
						{
							Console.WriteLine("Client {0} - Requests: {1}/{2} Responses", tid, car.Requests, car.Responses);
							tid++;
						}
						break;
				}
			}
		}
	}
	public class CometSyncRequest : CometRequest
	{
		private string host;
		public CometSyncRequest(string host)
		{
			this.host = host;
		}
		public void SendCometRequest()
		{
			this.BeginWaitRequest<object>(this.host + "/CometSyncHandler.ashx", null, null);
		}
		protected override void EndWaitRequest(object response)
		{
			this.SendCometRequest();
		}
	}
	public class CometAsyncRequest : CometRequest
	{
		private string host;
		private bool stop = false;
		private int requests = 0;
		private int responses = 0;
		public CometAsyncRequest(string host)
		{
			this.host = host;
		}
		public void SendCometRequest()
		{
			if (!this.stop)
			{
				this.BeginWaitRequest<object>(this.host + "/CometAsyncHandler.ashx", null, null);
				requests++;
			}
		}
		protected override void EndWaitRequest(object response)
		{
			Console.WriteLine(response);
			if (response != null)
			{
				responses++;
			}
			this.SendCometRequest();
		}
		public bool Stop
		{
			get
			{
				return this.stop;
			}
			set
			{
				this.stop = value;
			}
		}
		public int Requests
		{
			get
			{
				return this.requests;
			}
		}
		public int Responses
		{
			get
			{
				return this.responses;
			}
		}
	}
	public abstract class CometRequest
	{
		private class RequestState
		{
			public const int BUFFER_SIZE = 1024;
			public byte[] BufferRead;
			public HttpWebRequest Request;
			public HttpWebResponse Response;
			public Stream StreamResponse;
			public Type ResponseType;
			public MemoryStream RequestData;
			public RequestState()
			{
				this.BufferRead = new byte[BUFFER_SIZE];
				this.Request = null;
				this.Response = null;
				this.StreamResponse = null;
				this.ResponseType = null;
				this.RequestData = new MemoryStream();
			}
		}
		private RequestState requestState = null;
		private string httpUsername;
		private string httpPassword;
		protected T SendCommand<T>(string url, string[] parameters, string[] values)
		{
			T responseObject;
			using (WebResponse response = this.SendCommand(url, parameters, values))
			{
				using (Stream stream = response.GetResponseStream())
				{
					//  here is the response stream, time to parse it into an array
					//  ok, we need to JSON Deserialize this method
					DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
					responseObject = (T)serializer.ReadObject(stream);
				}
			}
			return responseObject;
		}
		protected void SetAuthenticationDetails(string username, string password)
		{
			this.httpUsername = username;
			this.httpPassword = password;
		}
		/// <summary>
		/// Send a command to the specific handler
		/// </summary>
		/// <param name="url"></param>
		/// <param name="parameters"></param>
		/// <param name="values"></param>
		/// <returns></returns>
		protected WebResponse SendCommand(string url, string[] parameters, string[] values)
		{
			//  ok, create the request object that is going to perform this
			//  request
			HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(url);
			//  and create the post data
			request.Method = "POST";
			request.ContentType = "application/x-www-form-urlencoded";
			if (this.httpUsername != null)
			{
				request.Credentials = new NetworkCredential(this.httpUsername, this.httpPassword);
			}
			//
			//  ok, parse the data from the parameters into 
			//  the content data
			if (parameters != null && values != null && parameters.Length == values.Length)
			{
				//  ok, everything is ok, so craete the post data
				StringBuilder postData = new StringBuilder();
				for (int i = 0; i < parameters.Length; i++)
				{
					if (i != 0)
					{
						postData.Append("&");
					}
					//  append for values
					postData.AppendFormat("{0}={1}", parameters[i], HttpUtility.UrlEncode(values[i]));
				}
				//  and now create a postdata array
				byte[] content = ASCIIEncoding.ASCII.GetBytes(postData.ToString());
				//  and the content length
				request.ContentLength = content.Length;
				//
				//  ok, sorted, so lets get the request strema and write the content
				using (Stream requestStream = request.GetRequestStream())
				{
					//  write the content
					requestStream.Write(content, 0, content.Length);
				}
			}
			//
			//  ok, now get the response
			return request.GetResponse();
		}
		/// <summary>
		/// Send a command to the specific handler
		/// </summary>
		/// <param name="url"></param>
		/// <param name="parameters"></param>
		/// <param name="values"></param>
		/// <returns></returns>
		protected void BeginWaitRequest<T>(string url, string[] parameters, string[] values)
		{
			if (this.requestState == null)
			{
				//  ok, create the request object that is going to perform this
				//  request
				HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(url);
				//  and create the post data
				request.Method = "POST";
				request.ContentType = "application/x-www-form-urlencoded";
				if (this.httpUsername != null)
				{
					request.Credentials = new NetworkCredential(this.httpUsername, this.httpPassword);
				}
				//
				//  ok, parse the data from the parameters into 
				//  the content data
				if (parameters != null && values != null && parameters.Length == values.Length)
				{
					//  ok, everything is ok, so craete the post data
					StringBuilder postData = new StringBuilder("");
					for (int i = 0; i < parameters.Length; i++)
					{
						//  append for values
						postData.AppendFormat("&{0}={1}", parameters[i], HttpUtility.UrlEncode(values[i]));
					}
					//  and now create a postdata array
					byte[] content = ASCIIEncoding.ASCII.GetBytes(postData.ToString());
					//  and the content length
					request.ContentLength = content.Length;
					//
					//  ok, sorted, so lets get the request strema and write the content
					using (Stream requestStream = request.GetRequestStream())
					{
						//  write the content
						requestStream.Write(content, 0, content.Length);
					}
				}
				this.requestState = new RequestState();
				//  get the request
				this.requestState.Request = request;
				this.requestState.ResponseType = typeof(T);
				//  and start the async request
				request.BeginGetResponse(new AsyncCallback(BeginGetResponse_Completed), this.requestState);
			}
		}
		private void BeginGetResponse_Completed(IAsyncResult result)
		{
			RequestState requestState = (RequestState)result.AsyncState;
			HttpWebRequest request = requestState.Request;
			//  and end it
			requestState.Response = (HttpWebResponse)request.EndGetResponse(result);
			//  and now get the stream object
			requestState.StreamResponse = requestState.Response.GetResponseStream();
			//  and begin reading the content
			requestState.StreamResponse.BeginRead(requestState.BufferRead, 0, RequestState.BUFFER_SIZE, new AsyncCallback(BeginRead_Completed), requestState);
		}
		private void BeginRead_Completed(IAsyncResult result)
		{
			RequestState requestState = (RequestState)result.AsyncState;
			Stream responseStream = requestState.StreamResponse;
			int read = responseStream.EndRead(result);
			if (read > 0)
			{
				//  stick it in the other buffer
				requestState.RequestData.Write(requestState.BufferRead, 0, read);
				//  and begin reading the content
				requestState.StreamResponse.BeginRead(requestState.BufferRead, 0, RequestState.BUFFER_SIZE, new AsyncCallback(BeginRead_Completed), requestState);
			}
			else
			{
				DataContractJsonSerializer serializer = new DataContractJsonSerializer(requestState.ResponseType);
				requestState.RequestData.Seek(0, SeekOrigin.Begin);
				object response = null;
				try
				{
					response = serializer.ReadObject(requestState.RequestData);
				}
				catch//(Exception ex)
				{
				}
				//
				//  completed here
				responseStream.Close();
				//  close the response
				requestState.Response.Close();
				requestState.RequestData.Close();
				this.requestState = null;
				//  call the end wait request
				this.EndWaitRequest(response);
			}
		}
		protected virtual void EndWaitRequest(object response)
		{
		}
	}
}
#T=Comet Async Process Handler (Microshaoft)
//=================================================
^#define c4 //C# 4.0+
//#define c2
namespace Microshaoft
{
	using System;
	using System.Web;
	using System.Threading;
	public class AsyncProcessHandler : IHttpAsyncHandler
	{
		private HttpContext _httpContext;
		public IAsyncResult BeginProcessRequest
									(
										HttpContext context
										, AsyncCallback cb
										, object extraData
									)
		{
			_httpContext = context;
			HttpResponse response = _httpContext.Response;
			response.Buffer = false;
			response.Headers.Add("Transfer-Encoding", "chunked");
			response.ContentType = "text/x-javascript";
			AsycRequestResult result = new AsycRequestResult(context, cb, extraData);
			AsycRequestResultAsycQueueProcessor.Enqueue(result);
			response.Flush();
			return result;
		}
		public void EndProcessRequest(IAsyncResult result)
		{
			//AsycRequestResult asyncRequestResult = result as AsycRequestResult;
			_httpContext.Response.End();
		}
		public bool IsReusable
		{
			get
			{
				throw new NotImplementedException();
			}
		}
		public void ProcessRequest(HttpContext context)
		{
			throw new NotImplementedException();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Threading;
	public class AsycRequestResult : IAsyncResult
	{
		private HttpContext _httpContext;
		private AsyncCallback _asyncCallback;
		private object _asyncState;
		private DateTime _beginTime;
		public DateTime BeginTime
		{
			get
			{
				return _beginTime;
			}
		}
		public AsycRequestResult
						(
							HttpContext context
							, AsyncCallback callback
							, object state
						)
		{
			_httpContext = context;
			_asyncCallback = callback;
			_asyncState = state;
			_beginTime = DateTime.Now;
		}
		public HttpContext Context
		{
			get
			{
				return _httpContext;
			}
		}
		public void SetCompleted()
		{
			if (_asyncCallback != null)
			{
				_asyncCallback(this);
			}
		}
		public object AsyncState
		{
			get
			{
				return _asyncState;
			}
		}
		private WaitHandle _waitHandle;
		public WaitHandle AsyncWaitHandle
		{
			get
			{
				return _waitHandle;
			}
			set
			{
				_waitHandle = value;
			}
		}
		public bool CompletedSynchronously
		{
			get
			{
				return false;
			}
		}
		public bool IsCompleted
		{
			get
			{
				throw new NotImplementedException();
			}
		}
	}
}
//========================================================
namespace Microshaoft
{
	using System;
	//using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Threading;
	using System.Collections.Concurrent;
	public static class SessionsManager
	{
		private static ConcurrentDictionary<string, UserSession> _sessions = new ConcurrentDictionary<string, UserSession>();
		public static ConcurrentDictionary<string, UserSession> Sessions
		{
			get
			{
				return _sessions;
			}
		}
		public static void WaitOneCompleteSession(string sessionID)
		{
			UserSession session = null;
			bool r = _sessions.TryGetValue(sessionID, out session);
			if (r)
			{
				(session.AsyncWaitHandle as AutoResetEvent).Set();
			}
		}
	}
	public class UserSession
	{
		private string _sessionID;
		public string SessionID
		{
			get
			{
				return _sessionID;
			}
		}
		private string _userID;
		public string UserID
		{
			get
			{
				return _userID;
			}
		}
		private WaitHandle _waitHandle;
		public WaitHandle AsyncWaitHandle
		{
			get
			{
				return _waitHandle;
			}
			set
			{
				_waitHandle = value;
			}
		}
		public UserSession(string sessionID, string userID)
		{
			_sessionID = sessionID;
			_userID = userID;
			//_waitHandle = waitHandle;
		}
	}
}
//========================================================
//AsyncQueue.cs
namespace Microshaoft
{
	using System;
	using System.Web;
	using System.Threading;
	using System.Collections.Concurrent;
	public static class AsycRequestResultAsycQueueProcessor
	{
		private static AsyncQueue<AsycRequestResult> _queue = new AsyncQueue<AsycRequestResult>();
		static AsycRequestResultAsycQueueProcessor()
		{
			_queue.OnDequeue += new AsyncQueue<AsycRequestResult>.QueueEventHandler(_queue_OnDequeue);
		}
		static void _queue_OnDequeue(AsycRequestResult element)
		{
			//=========================================================
			//如果有影响可以移到 BeginProcessRequest
			HttpContext context = element.Context;
			HttpRequest request = context.Request;
			string sessionID = request.QueryString["id"];
			string userID = request.QueryString["uid"];
			//=========================================================
			UserSession session = null;
			ConcurrentDictionary<string, UserSession> sessions = SessionsManager.Sessions;
			bool r = sessions.TryGetValue(sessionID, out session);
			if (r == false)
			{
				session = new UserSession(sessionID, userID);
				sessions.TryAdd(session.SessionID, session);
			}
			AutoResetEvent are = null;
			if (session.AsyncWaitHandle == null)
			{
				are = new AutoResetEvent(false);
				session.AsyncWaitHandle = are;
			}
			else
			{
				are = session.AsyncWaitHandle as AutoResetEvent;
			}
			element.AsyncWaitHandle = are;
			DateTime beginTime = element.BeginTime;
			
			while (DateTime.Now.Subtract(beginTime).TotalSeconds <= 1 * 60)
			{
				string text = string.Empty;
				r = are.WaitOne(10 * 1000);
				if (r)
				{
					text =
							@"
								alert('ok');
							";
					//to do: 推送数据
				}
				else
				{
					//heart beat
					text =
							@"
								alert('timeout');
							";
				}
				text = GetChunkText(text);
				//=========================================================
				//如果有影响可以移到 EndProcessRequest
				HttpResponse response = context.Response;
				response.Write(text);
				response.Flush();
				//=========================================================
				if (r)
				{
					break;
				}
			}
			element.SetCompleted();
		}
		private static string GetChunkText(string text)
		{
			return string.Format
								(
									"{1:X}{0}{2}"
									, "\r\n"
									, text.Length
									, text
								 );
		}
		public static void Enqueue(AsycRequestResult element)
		{
			_queue.Enqueue(element);
		}
	}
}
//====================================================================
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Diagnostics;
	using System.Collections.Generic;
^#if c4
	using System.Collections.Concurrent;
^#endif
	using Microshaoft;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		//public event QueueLogEventHandler OnQueueLog;
		public event QueueLogEventHandler OnQueueRunningThreadStart;
		public event QueueLogEventHandler OnQueueRunningThreadEnd;
		public event QueueLogEventHandler OnDequeueThreadStart;
		public event QueueLogEventHandler OnDequeueThreadEnd;
		public event QueueLogEventHandler OnDequeueAllThreadsEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
^#if c2
		private Queue<T> _queue = new Queue<T>();
^#elif c4
		private ConcurrentQueue<T> _queue = new ConcurrentQueue<T>();
^#endif
		private object _syncQueueLockObject = new object();
		//private object _syncQueueRunningLockObject = new object();
		private long _isQueueRunning = 0;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private PerformanceCounter _enqueuePerformanceCounter;
		private PerformanceCounter _dequeuePerformanceCounter;
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		private PerformanceCounter _queueLengthPerformanceCounter;
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		private PerformanceCounter _queueRunningThreadStartPerformanceCounter;
		private PerformanceCounter _queueRunningThreadEndPerformanceCounter;
		private PerformanceCounter _queueRunningThreadsCountPerformanceCounter;
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCounters(string instanceNamePrefix)
		{
			string category = "Microshaoft AsyncConurrentQueue Counters";
			string counter = string.Empty;
			Process process = Process.GetCurrentProcess();
			//int processID = 0;//process.Id;
			string processName = process.ProcessName;
			//string processStartTime = "";//process.StartTime;
			string instanceName = string.Empty;
			instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
				//, processID
				//, processStartTime.ToString("yyyy-MM-dd HH:mm:ss.fff")
									);
			CounterCreationDataCollection ccdc = new CounterCreationDataCollection();
			if (PerformanceCounterCategory.Exists(category))
			{
				PerformanceCounterCategory.Delete(category);
			}
			CounterCreationData ccd = null;
			counter = "EnqueueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueLengthCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueProcessedCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			PerformanceCounterCategory.Create
											(
												category,
												string.Format("{0} Category Help.", category),
												PerformanceCounterCategoryType.MultiInstance,
												ccdc
											);
			counter = "EnqueueCounter";
			_enqueuePerformanceCounter = new PerformanceCounter();
			_enqueuePerformanceCounter.CategoryName = category;
			_enqueuePerformanceCounter.CounterName = counter;
			_enqueuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_enqueuePerformanceCounter.InstanceName = instanceName;
			_enqueuePerformanceCounter.ReadOnly = false;
			_enqueuePerformanceCounter.RawValue = 0;
			counter = "DequeueCounter";
			_dequeuePerformanceCounter = new PerformanceCounter();
			_dequeuePerformanceCounter.CategoryName = category;
			_dequeuePerformanceCounter.CounterName = counter;
			_dequeuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeuePerformanceCounter.InstanceName = instanceName;
			_dequeuePerformanceCounter.ReadOnly = false;
			_dequeuePerformanceCounter.RawValue = 0;
			counter = "DequeueProcessedCounter";
			_dequeueProcessedPerformanceCounter = new PerformanceCounter();
			_dequeueProcessedPerformanceCounter.CategoryName = category;
			_dequeueProcessedPerformanceCounter.CounterName = counter;
			_dequeueProcessedPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueProcessedPerformanceCounter.InstanceName = instanceName;
			_dequeueProcessedPerformanceCounter.ReadOnly = false;
			_dequeueProcessedPerformanceCounter.RawValue = 0;
			counter = "QueueLengthCounter";
			_queueLengthPerformanceCounter = new PerformanceCounter();
			_queueLengthPerformanceCounter.CategoryName = category;
			_queueLengthPerformanceCounter.CounterName = counter;
			_queueLengthPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueLengthPerformanceCounter.InstanceName = instanceName;
			_queueLengthPerformanceCounter.ReadOnly = false;
			_queueLengthPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadStartCounter";
			_dequeueThreadStartPerformanceCounter = new PerformanceCounter();
			_dequeueThreadStartPerformanceCounter.CategoryName = category;
			_dequeueThreadStartPerformanceCounter.CounterName = counter;
			_dequeueThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadStartPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadStartPerformanceCounter.ReadOnly = false;
			_dequeueThreadStartPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadEndCounter";
			_dequeueThreadEndPerformanceCounter = new PerformanceCounter();
			_dequeueThreadEndPerformanceCounter.CategoryName = category;
			_dequeueThreadEndPerformanceCounter.CounterName = counter;
			_dequeueThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadEndPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadEndPerformanceCounter.ReadOnly = false;
			_dequeueThreadEndPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadsCountCounter";
			_dequeueThreadsCountPerformanceCounter = new PerformanceCounter();
			_dequeueThreadsCountPerformanceCounter.CategoryName = category;
			_dequeueThreadsCountPerformanceCounter.CounterName = counter;
			_dequeueThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadsCountPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadsCountPerformanceCounter.ReadOnly = false;
			_dequeueThreadsCountPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadStartCounter";
			_queueRunningThreadStartPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadStartPerformanceCounter.CategoryName = category;
			_queueRunningThreadStartPerformanceCounter.CounterName = counter;
			_queueRunningThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadStartPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadStartPerformanceCounter.ReadOnly = false;
			_queueRunningThreadStartPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadEndCounter";
			_queueRunningThreadEndPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadEndPerformanceCounter.CategoryName = category;
			_queueRunningThreadEndPerformanceCounter.CounterName = counter;
			_queueRunningThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadEndPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadEndPerformanceCounter.ReadOnly = false;
			_queueRunningThreadEndPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadsCountCounter";
			_queueRunningThreadsCountPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadsCountPerformanceCounter.CategoryName = category;
			_queueRunningThreadsCountPerformanceCounter.CounterName = counter;
			_queueRunningThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadsCountPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadsCountPerformanceCounter.ReadOnly = false;
			_queueRunningThreadsCountPerformanceCounter.RawValue = 0;
			_isAttachedPerformanceCounters = true;
		}
		private int _maxConcurrentThreadsCount = 100; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (Interlocked.Read(ref _concurrentDequeueThreadsCount) < _maxConcurrentThreadsCount)
			{
				if (Interlocked.CompareExchange(ref _isQueueRunning, 0, 1) == 0)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunningThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadStartPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Increment();
			}
			if (OnQueueRunningThreadStart != null)
			{
				OnQueueRunningThreadStart
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}({4}) at {5}"
									, "Queue Running Start ..."
									, _concurrentDequeueThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
									, Thread.CurrentThread.ManagedThreadId
									, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
								)
					);
			}
^#if c2
			while ((_queue.Count > 0)) //Microshaoft 死循环
^#elif c4
			while (!_queue.IsEmpty) //Microshaoft 死循环
^#endif
			{
				int threadID = -1;
				{
					int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
					if (r < _maxConcurrentThreadsCount)
					{
						//if (_queue.Count > 0)
						{
							r = (int)Interlocked.Increment(ref _concurrentDequeueThreadsCount);
							threadID = (int)_concurrentDequeueThreadsCount;
							//ThreadProcessState tps = new ThreadProcessState();
							//tps.element = element;
							//tps.Sender = this;
							Thread t = new Thread(new ThreadStart(DequeueThreadProcess));
							t.Name = string.Format("ConcurrentDequeueProcessThread[{0}]", threadID);
							t.Start();
						}
						///						else
						///						{
						///							break;
						///						}
					}
					else
					{
						break;
					}
				}
			}
			//Interlocked.CompareExchange(ref _queueRuning, 0, 1);
			if (OnQueueRunningThreadEnd != null)
			{
				int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnQueueRunningThreadEnd
							(
								string.Format
										(
											"{0} Threads Count {1}, Queue Count {2}, Current Thread: {3}({4}) at {5}"
											, "Queue Running Stop ..."
											, r
											, _queue.Count
											, Thread.CurrentThread.Name
											, Thread.CurrentThread.ManagedThreadId
											, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
										)
							);
			}
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadEndPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Decrement();
			}
			Interlocked.Exchange(ref _isQueueRunning, 0);
		}
		public void Enqueue(T element)
		{
			try
			{
^#if c2
				lock (_syncQueueLockObject) //还算并发吗?
^#endif
				{
					_queue.Enqueue(element);
				}
				if (_isAttachedPerformanceCounters)
				{
					_enqueuePerformanceCounter.Increment();
					_queueLengthPerformanceCounter.Increment();
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			//int r = Interlocked.CompareExchange(ref _queueRuning, 1, 0))
			//if (r == 1)
			//{
			QueueRun();
			//}
		}
		private void DequeueThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_dequeueThreadStartPerformanceCounter.Increment();
				_dequeueThreadsCountPerformanceCounter.Increment();
			}
			if (OnDequeueThreadStart != null)
			{
				int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnDequeueThreadStart
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads ++ !"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
			}
			bool queueWasNotEmpty = false;
			try
			{
^#if c2
				while (true)
^#elif c4
				while (!_queue.IsEmpty)
^#endif
				{
					T element = null;
^#if c2
					lock (_syncQueueLockObject)
					{
						if (_queue.Count > 0)
						{
							element = _queue.Dequeue();
						}
						else
						{
							//避免QueueRun 死循环
							break;
						}
					}
^#elif c4
					if (_queue.TryDequeue(out element))
					{
^#elif c2
						if (element != null)
						{
^#endif
						if (!queueWasNotEmpty)
						{
							queueWasNotEmpty = true;
						}
						if (_isAttachedPerformanceCounters)
						{
							_dequeuePerformanceCounter.Increment();
							_queueLengthPerformanceCounter.Decrement();
						}
						if (OnDequeue != null)
						{
							OnDequeue(element);
						}
						if (_isAttachedPerformanceCounters)
						{
							_dequeueProcessedPerformanceCounter.Increment();
						}
^#if c2
						}
^#elif c4
					}
				}
^#endif
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				int r = (int)Interlocked.Decrement(ref _concurrentDequeueThreadsCount);
				if (OnDequeueThreadEnd != null)
				{
					OnDequeueThreadEnd
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads--"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
				}
				if (r == 0)
				{
					if (OnDequeueAllThreadsEnd != null)
					{
						OnDequeueAllThreadsEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
													, "All Threads End"
													, r
													, _queue.Count
													, Thread.CurrentThread.Name
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
												)
									);
					}
				}
				if (_isAttachedPerformanceCounters)
				{
					_dequeueThreadEndPerformanceCounter.Increment();
					_dequeueThreadsCountPerformanceCounter.Decrement();
				}
				if (queueWasNotEmpty)
				{
					QueueRun(); //死循环???
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			CounterCreationData ccd = new CounterCreationData();
			ccd.CounterName = counterName;
			ccd.CounterHelp = string.Format("{0} Help", counterName);
			ccd.CounterType = performanceCounterType;
			return ccd;
		}
	}
}
//========================================================================================================================================

#T=CompressHelper
namespace Microshaoft
{
	using System;
	using System.Text;
	using System.IO;
	using System.IO.Compression;
	public class CompressHelper
	{
		public static byte[] ReadStreamToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			MemoryStream ms = new MemoryStream();
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
		public static byte[] GZipCompress(byte[] DATA)
		{
			MemoryStream ms = new MemoryStream();
			GZipStream stream = new GZipStream(ms, CompressionMode.Compress, true);
			stream.Write(DATA, 0, DATA.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			byte[] buffer = ReadStreamToBytes(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return buffer;
		}
		public static byte[] GZipDecompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream(data);
			GZipStream stream = new GZipStream(ms, CompressionMode.Decompress);
			byte[] buffer = ReadStreamToBytes(stream);
			ms.Close();
			ms.Dispose();
			ms = null;
			stream.Close();
			stream.Dispose();
			stream = null;
			return buffer;
		}
		public static Stream GZipCompress(Stream DATA)
		{
			byte[] buffer = ReadStreamToBytes(DATA);
			MemoryStream ms = new MemoryStream();
			GZipStream stream = new GZipStream(ms, CompressionMode.Compress, true);
			stream.Write(buffer, 0, buffer.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			if (ms.CanSeek)
			{
				ms.Position = 0;
			}
			return ms;
		}
		public static Stream GZipDecompress(Stream data)
		{
			byte[] buffer = ReadStreamToBytes(data);
			MemoryStream ms = new MemoryStream(buffer);
			GZipStream stream = new GZipStream(ms, CompressionMode.Decompress);
			if (stream.CanSeek)
			{
				stream.Position = 0;
			}
			return stream;
		}
		public static byte[] DeflateCompress(byte[] DATA)
		{
			MemoryStream ms = new MemoryStream();
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true);
			stream.Write(DATA, 0, DATA.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			byte[] buffer = ReadStreamToBytes(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return buffer;
		}
		public static byte[] DeflateDecompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream(data);
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Decompress);
			byte[] buffer = ReadStreamToBytes(stream);
			ms.Close();
			ms.Dispose();
			ms = null;
			stream.Close();
			stream.Dispose();
			stream = null;
			return buffer;
		}
		public static Stream DeflateCompress(Stream DATA)
		{
			byte[] buffer = ReadStreamToBytes(DATA);
			MemoryStream ms = new MemoryStream();
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true);
			stream.Write(buffer, 0, buffer.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			if (ms.CanSeek)
			{
				ms.Position = 0;
			}
			return ms;
		}
		public static Stream DeflateDecompress(Stream data)
		{
			byte[] buffer = ReadStreamToBytes(data);
			MemoryStream ms = new MemoryStream(buffer);
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Decompress);
			if (stream.CanSeek)
			{
				stream.Position = 0;
			}
			return stream;
		}
	}
}
namespace TestConsoleApplication
{
	using System.Text;
	using System;
	using System.IO;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			string s = "阿斯个贷哈根室电话个撒谎干大事个贷伽师将阿斯个贷哈根室电话个撒谎干大事个贷伽师将事个贷伽师将事个贷伽师将事个贷伽师将事个贷伽师将事个贷伽师将事个贷伽师将事个贷伽师将";
			byte[] buffer = Encoding.UTF8.GetBytes(s);
			byte[] bytes;
			bytes = CompressHelper.GZipCompress
									(
										buffer
									);
			Console.WriteLine
						(
							"{0},GZip: {1}; {2}"
							, buffer.Length
							, bytes.Length
							, s.Length
						);

			//bytes = CompressHelper.ReadStreamToBytes(ms);
			//string ss = Encoding.UTF8.GetString(bytes);
			Stream ms = new MemoryStream(bytes);
			//ms.Write(bytes, 0, bytes.Length);
			ms.Position = 0;
			ms = CompressHelper.GZipDecompress
						(
							ms
						);
			bytes = CompressHelper.ReadStreamToBytes(ms);
			string ss = Encoding.UTF8.GetString(bytes);
			Console.WriteLine(ss);
			bytes = CompressHelper.DeflateCompress
								(
									buffer
								);
			Console.WriteLine
						(
							"{0},Deflate: {1}; {2}"
							, buffer.Length
							, bytes.Length
							, s.Length
						);
			//Console.WriteLine("{0},Deflate: {1}", buffer.Length, bytes.Length);
			ss = Encoding.UTF8.GetString
								(
									(
										CompressHelper.DeflateDecompress
											(
												bytes
											)
									)
								);
			Console.WriteLine(ss);
		}
	}
}

#T=ConcurrentAsyncQueue 2012-02-23
//#define c4 //C# 4.0+
^#define c4
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Diagnostics;
	using System.Collections.Generic;
^#if c4
	using System.Collections.Concurrent;
^#endif
	using Microshaoft;
	public class ConcurrentAsyncQueue<T>
^#if c2
								where T : class
^#endif
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		//public event QueueLogEventHandler OnQueueLog;
		public event QueueLogEventHandler OnQueueRunningThreadStart;
		public event QueueLogEventHandler OnQueueRunningThreadEnd;
		public event QueueLogEventHandler OnDequeueThreadStart;
		public event QueueLogEventHandler OnDequeueThreadEnd;
		public event QueueLogEventHandler OnDequeueAllThreadsEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
^#if c2
		private Queue<T> _queue = new Queue<T>();
		private object _syncQueueLockObject = new object();
^#elif c4
		private ConcurrentQueue<T> _queue = new ConcurrentQueue<T>();
^#endif
		//private object _syncQueueRunningLockObject = new object();
		private long _isQueueRunning = 0;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private PerformanceCounter _enqueuePerformanceCounter;
		private PerformanceCounter _dequeuePerformanceCounter;
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		private PerformanceCounter _queueLengthPerformanceCounter;
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		private PerformanceCounter _queueRunningThreadStartPerformanceCounter;
		private PerformanceCounter _queueRunningThreadEndPerformanceCounter;
		private PerformanceCounter _queueRunningThreadsCountPerformanceCounter;
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCounters(string instanceNamePrefix)
		{
			string category = "Microshaoft AsyncConurrentQueue Counters";
			string counter = string.Empty;
			Process process = Process.GetCurrentProcess();
			//int processID = 0;//process.Id;
			string processName = process.ProcessName;
			//string processStartTime = "";//process.StartTime;
			string instanceName = string.Empty;
			instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
				//, processID
				//, processStartTime.ToString("yyyy-MM-dd HH:mm:ss.fff")
									);
			CounterCreationDataCollection ccdc = new CounterCreationDataCollection();
			if (PerformanceCounterCategory.Exists(category))
			{
				PerformanceCounterCategory.Delete(category);
			}
			CounterCreationData ccd = null;
			counter = "EnqueueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueLengthCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueProcessedCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			PerformanceCounterCategory.Create
											(
												category,
												string.Format("{0} Category Help.", category),
												PerformanceCounterCategoryType.MultiInstance,
												ccdc
											);
			counter = "EnqueueCounter";
			_enqueuePerformanceCounter = new PerformanceCounter();
			_enqueuePerformanceCounter.CategoryName = category;
			_enqueuePerformanceCounter.CounterName = counter;
			_enqueuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_enqueuePerformanceCounter.InstanceName = instanceName;
			_enqueuePerformanceCounter.ReadOnly = false;
			_enqueuePerformanceCounter.RawValue = 0;
			counter = "DequeueCounter";
			_dequeuePerformanceCounter = new PerformanceCounter();
			_dequeuePerformanceCounter.CategoryName = category;
			_dequeuePerformanceCounter.CounterName = counter;
			_dequeuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeuePerformanceCounter.InstanceName = instanceName;
			_dequeuePerformanceCounter.ReadOnly = false;
			_dequeuePerformanceCounter.RawValue = 0;
			counter = "DequeueProcessedCounter";
			_dequeueProcessedPerformanceCounter = new PerformanceCounter();
			_dequeueProcessedPerformanceCounter.CategoryName = category;
			_dequeueProcessedPerformanceCounter.CounterName = counter;
			_dequeueProcessedPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueProcessedPerformanceCounter.InstanceName = instanceName;
			_dequeueProcessedPerformanceCounter.ReadOnly = false;
			_dequeueProcessedPerformanceCounter.RawValue = 0;
			counter = "QueueLengthCounter";
			_queueLengthPerformanceCounter = new PerformanceCounter();
			_queueLengthPerformanceCounter.CategoryName = category;
			_queueLengthPerformanceCounter.CounterName = counter;
			_queueLengthPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueLengthPerformanceCounter.InstanceName = instanceName;
			_queueLengthPerformanceCounter.ReadOnly = false;
			_queueLengthPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadStartCounter";
			_dequeueThreadStartPerformanceCounter = new PerformanceCounter();
			_dequeueThreadStartPerformanceCounter.CategoryName = category;
			_dequeueThreadStartPerformanceCounter.CounterName = counter;
			_dequeueThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadStartPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadStartPerformanceCounter.ReadOnly = false;
			_dequeueThreadStartPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadEndCounter";
			_dequeueThreadEndPerformanceCounter = new PerformanceCounter();
			_dequeueThreadEndPerformanceCounter.CategoryName = category;
			_dequeueThreadEndPerformanceCounter.CounterName = counter;
			_dequeueThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadEndPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadEndPerformanceCounter.ReadOnly = false;
			_dequeueThreadEndPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadsCountCounter";
			_dequeueThreadsCountPerformanceCounter = new PerformanceCounter();
			_dequeueThreadsCountPerformanceCounter.CategoryName = category;
			_dequeueThreadsCountPerformanceCounter.CounterName = counter;
			_dequeueThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadsCountPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadsCountPerformanceCounter.ReadOnly = false;
			_dequeueThreadsCountPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadStartCounter";
			_queueRunningThreadStartPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadStartPerformanceCounter.CategoryName = category;
			_queueRunningThreadStartPerformanceCounter.CounterName = counter;
			_queueRunningThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadStartPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadStartPerformanceCounter.ReadOnly = false;
			_queueRunningThreadStartPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadEndCounter";
			_queueRunningThreadEndPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadEndPerformanceCounter.CategoryName = category;
			_queueRunningThreadEndPerformanceCounter.CounterName = counter;
			_queueRunningThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadEndPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadEndPerformanceCounter.ReadOnly = false;
			_queueRunningThreadEndPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadsCountCounter";
			_queueRunningThreadsCountPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadsCountPerformanceCounter.CategoryName = category;
			_queueRunningThreadsCountPerformanceCounter.CounterName = counter;
			_queueRunningThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadsCountPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadsCountPerformanceCounter.ReadOnly = false;
			_queueRunningThreadsCountPerformanceCounter.RawValue = 0;
			_isAttachedPerformanceCounters = true;
		}
		private int _maxConcurrentDequeueThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentDequeueThreadsCount
		{
			set
			{
				_maxConcurrentDequeueThreadsCount = value;
			}
			get
			{
				return _maxConcurrentDequeueThreadsCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (Interlocked.Read(ref _concurrentDequeueThreadsCount) < _maxConcurrentDequeueThreadsCount)
			{
				if (Interlocked.CompareExchange(ref _isQueueRunning, 0, 1) == 0)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunningThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadStartPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Increment();
			}
			if (OnQueueRunningThreadStart != null)
			{
				OnQueueRunningThreadStart
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}({4}) at {5}"
									, "Queue Running Start ..."
									, _concurrentDequeueThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
									, Thread.CurrentThread.ManagedThreadId
									, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
								)
					);
			}
^#if c2
			while ((_queue.Count > 0)) //Microshaoft 死循环
^#elif c4
			while (!_queue.IsEmpty) //Microshaoft 死循环
^#endif
			{
				int threadID = -1;
				{
					int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
					if (r < _maxConcurrentDequeueThreadsCount)
					{
						//if (_queue.Count > 0)
						{
							r = (int)Interlocked.Increment(ref _concurrentDequeueThreadsCount);
							threadID = (int)_concurrentDequeueThreadsCount;
							//ThreadProcessState tps = new ThreadProcessState();
							//tps.element = element;
							//tps.Sender = this;
							Thread t = new Thread(new ThreadStart(DequeueThreadProcess));
							t.TrySetApartmentState(ApartmentState.STA);
							t.Name = string.Format("ConcurrentDequeueProcessThread[{0}]", threadID);
							t.Start();
						}
						///						else
						///						{
						///							break;
						///						}
					}
					else
					{
						break;
					}
				}
			}
			//Interlocked.CompareExchange(ref _queueRuning, 0, 1);
			if (OnQueueRunningThreadEnd != null)
			{
				int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnQueueRunningThreadEnd
							(
								string.Format
										(
											"{0} Threads Count {1}, Queue Count {2}, Current Thread: {3}({4}) at {5}"
											, "Queue Running Stop ..."
											, r
											, _queue.Count
											, Thread.CurrentThread.Name
											, Thread.CurrentThread.ManagedThreadId
											, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
										)
							);
			}
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadEndPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Decrement();
			}
			Interlocked.Exchange(ref _isQueueRunning, 0);
		}
		public void Enqueue(T element)
		{
			try
			{
^#if c2
				lock (_syncQueueLockObject) //还算并发吗?
^#endif
				{
					_queue.Enqueue(element);
				}
				if (_isAttachedPerformanceCounters)
				{
					_enqueuePerformanceCounter.Increment();
					_queueLengthPerformanceCounter.Increment();
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			//int r = Interlocked.CompareExchange(ref _queueRuning, 1, 0))
			//if (r == 1)
			//{
			QueueRun();
			//}
		}
		private void DequeueThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_dequeueThreadStartPerformanceCounter.Increment();
				_dequeueThreadsCountPerformanceCounter.Increment();
			}
			if (OnDequeueThreadStart != null)
			{
				int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnDequeueThreadStart
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads ++ !"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
			}
			bool queueWasNotEmpty = false;
			try
			{
^#if c2
				while (true)
^#elif c4
				while (!_queue.IsEmpty)
^#endif
				{
					T element
^#if c2
							= null
^#endif
							;
^#if c2
					lock (_syncQueueLockObject)
					{
						if (_queue.Count > 0)
						{
							element = _queue.Dequeue();
						}
						else
						{
							//避免QueueRun 死循环
							break;
						}
					}
^#elif c4
					if (_queue.TryDequeue(out element))
					{
^#elif c2
						if (element != null)
						{
^#endif
						if (!queueWasNotEmpty)
						{
							queueWasNotEmpty = true;
						}
						if (_isAttachedPerformanceCounters)
						{
							_dequeuePerformanceCounter.Increment();
							_queueLengthPerformanceCounter.Decrement();
						}
						if (OnDequeue != null)
						{
							OnDequeue(element);
						}
						if (_isAttachedPerformanceCounters)
						{
							_dequeueProcessedPerformanceCounter.Increment();
						}
^#if c2
						}
^#elif c4
					}
				}
^#endif
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				int r = (int)Interlocked.Decrement(ref _concurrentDequeueThreadsCount);
				if (OnDequeueThreadEnd != null)
				{
					OnDequeueThreadEnd
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads--"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
				}
				if (r == 0)
				{
					if (OnDequeueAllThreadsEnd != null)
					{
						OnDequeueAllThreadsEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
													, "All Threads End"
													, r
													, _queue.Count
													, Thread.CurrentThread.Name
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
												)
									);
					}
				}
				if (_isAttachedPerformanceCounters)
				{
					_dequeueThreadEndPerformanceCounter.Increment();
					_dequeueThreadsCountPerformanceCounter.Decrement();
				}
				if (queueWasNotEmpty)
				{
					QueueRun(); //死循环???
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			CounterCreationData ccd = new CounterCreationData();
			ccd.CounterName = counterName;
			ccd.CounterHelp = string.Format("{0} Help", counterName);
			ccd.CounterType = performanceCounterType;
			return ccd;
		}
	}
}

#T=ConcurrentAsyncQueue 2012-07-20 新版 add stop
namespace Test
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	using Microshaoft;
	class Program
	{
		static void Main()
		{
			var q = new ConcurrentAsyncQueue<int>();
			q.AttachPerformanceCounters("new");
			Random random = new Random();
			q.OnDequeue += new ConcurrentAsyncQueue<int>.QueueEventHandler
													(
														(x) =>
														{
															int sleep = random.Next(0, 9) * 500;
															Console.WriteLine(sleep);
															Thread.Sleep(sleep);
															//Console.WriteLine(x);
														}
													);
			q.OnException += new ConcurrentAsyncQueue<int>.ExceptionEventHandler
																	(
																		(x) =>
																		{
																			Console.WriteLine(x.ToString());
																		}
																	);
			Console.WriteLine("begin ...");
			//q.StartAdd(10);

			string r = string.Empty;
			while ((r = Console.ReadLine()) != "q")
			{
				int i;
				if (int.TryParse(r, out i))
				{
					Console.WriteLine("Parallel Enqueue {0} begin ...", i);
					new Thread
							(
								new ParameterizedThreadStart
											(
												(x) =>
												{
													Parallel.For
																(
																	0
																	, i
																	, (xx) =>
																	{
																		q.Enqueue(xx);
																	}
																);
													Console.WriteLine("Parallel Enqueue {0} end ...", i);
												}
											)
							).Start();
				}
				else if (r.ToLower() == "stop")
				{
					q.StartStop(10);
				}
				else if (r.ToLower() == "add")
				{
					q.StartAdd(20);
				}
				//else if (r.ToLower() == "count")
				//{
				//	q.EnablePerformanceCountersCount = true;
				//}
				//else if (r.ToLower() == "uncount")
				//{
				//	q.EnablePerformanceCountersCount = false;
				//}
				else
				{
					Console.WriteLine("please input Number!");
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Diagnostics;
	using System.Linq;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	using System.Threading.Tasks;
	using System.Reflection;
	using Microshaoft;
	public class ConcurrentAsyncQueue<T>
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public QueueLogEventHandler
								OnQueueLog
								, OnDequeueThreadStart
								, OnDequeueThreadEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private ConcurrentQueue<T> _queue = new ConcurrentQueue<T>();
		private ConcurrentQueue<Action> _callbackProcessBreaksActions;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private ConcurrentQueue<ThreadProcessor> _dequeueThreadsProcessorsPool;
		private int _dequeueIdleSleepSeconds = 10;
		public int DequeueIdleSleepSeconds
		{
			set
			{
				_dequeueIdleSleepSeconds = value;
			}
			get
			{
				return _dequeueIdleSleepSeconds;
			}
		}
		private PerformanceCounter _enqueuePerformanceCounter;
		public PerformanceCounter EnqueuePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _enqueuePerformanceCounter, value, 2);
			}
			get
			{
				return _enqueuePerformanceCounter;
			}
		}
		private PerformanceCounter _enqueueRateOfCountsPerSecondPerformanceCounter;
		public PerformanceCounter EnqueueRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _enqueueRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _enqueueRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeuePerformanceCounter;
		public PerformanceCounter DequeuePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeuePerformanceCounter, value, 2);
			}
			get
			{
				return _dequeuePerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedRateOfCountsPerSecondPerformanceCounter;
		public PerformanceCounter DequeueProcessedRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		public PerformanceCounter DequeueProcessedPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedPerformanceCounter;
			}
		}
		private PerformanceCounter _queueLengthPerformanceCounter;
		public PerformanceCounter QueueLengthPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _queueLengthPerformanceCounter, value, 2);
			}
			get
			{
				return _queueLengthPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		public PerformanceCounter DequeueThreadStartPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadStartPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadStartPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		public PerformanceCounter DequeueThreadEndPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadEndPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadEndPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		public PerformanceCounter DequeueThreadsCountPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadsCountPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadsCountPerformanceCounter;
			}
		}
		private bool _isAttachedPerformanceCounters = false;
		private class ThreadProcessor
		{
			public bool Break
			{
				set;
				get;
			}
			public EventWaitHandle Wait
			{
				private set;
				get;
			}
			public ConcurrentAsyncQueue<T> Sender
			{
				private set;
				get;
			}
			public void StopOne()
			{
				Break = true;
			}
			public ThreadProcessor
							(
								ConcurrentAsyncQueue<T> queue
								, EventWaitHandle wait
							)
			{
				Wait = wait;
				Sender = queue;
			}
			public void ThreadProcess()
			{
				Interlocked.Increment(ref Sender._concurrentDequeueThreadsCount);
				if (Sender._isAttachedPerformanceCounters)
				{
					Sender.DequeueThreadStartPerformanceCounter.Increment();
					Sender.DequeueThreadsCountPerformanceCounter.Increment();
				}
				long r = 0;
				try
				{
					if (Sender.OnDequeueThreadStart != null)
					{
						r = Interlocked.Read(ref Sender._concurrentDequeueThreadsCount);
						Sender.OnDequeueThreadStart
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
														, "Threads ++ !"
														, r
														, Sender._queue.Count
														, Thread.CurrentThread.Name
														, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
													)
										);
					}
					while (true)
					{
						#region while true
						if (Break)
						{
							break;
						}
						while (!Sender._queue.IsEmpty)
						{
							#region while queue.IsEmpty
							if (Break)
							{
								break;
							}
							T element;
							if (Sender._queue.TryDequeue(out element))
							{
								if (Sender._isAttachedPerformanceCounters)
								{
									Sender.DequeuePerformanceCounter.Increment();
									Sender.QueueLengthPerformanceCounter.Decrement();
								}
								if (Sender.OnDequeue != null)
								{
									Sender.OnDequeue(element);
								}
								if (Sender._isAttachedPerformanceCounters)
								{
									Sender.DequeueProcessedPerformanceCounter.Increment();
									Sender.DequeueProcessedRateOfCountsPerSecondPerformanceCounter.Increment();
								}
							}
							#endregion while queue.IsEmpty
						}
						#region wait
						Sender._dequeueThreadsProcessorsPool.Enqueue(this);
						if (Break)
						{
						}
						if (!Wait.WaitOne(Sender.DequeueIdleSleepSeconds * 1000))
						{
						}
						#endregion wait
						#endregion while 1 == 1
					}
				}
				catch (Exception e)
				{
					if (Sender.OnException != null)
					{
						Sender.OnException(e);
					}
				}
				finally
				{
					r = Interlocked.Decrement(ref Sender._concurrentDequeueThreadsCount);
					if (r < 0)
					{
						Interlocked.Exchange(ref Sender._concurrentDequeueThreadsCount, 0);

						if (Sender._isAttachedPerformanceCounters)
						{
							if (Sender.DequeueThreadsCountPerformanceCounter.RawValue < 0)
							{
								Sender.DequeueThreadsCountPerformanceCounter.RawValue = Sender._concurrentDequeueThreadsCount;
							}
						}
					}
					if (Sender.OnDequeueThreadEnd != null)
					{
						Sender.OnDequeueThreadEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
													, "Threads--"
													, r
													, Sender._queue.Count
													, Thread.CurrentThread.Name
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
												)
									);
					}
					if (Sender._isAttachedPerformanceCounters)
					{
						Sender.DequeueThreadEndPerformanceCounter.Increment();
						Sender.DequeueThreadsCountPerformanceCounter.Decrement();
					}
					if (!Break)
					{
						Sender.StartAdd(1);
					}
					Break = false;
				}
			}
		}
		public void AttachPerformanceCounters(string instanceNamePrefix)
		{
			var category = "Microshaoft AsyncConurrentQueue Counters";
			var process = Process.GetCurrentProcess();
			var processName = process.ProcessName;
			var instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
				//, processID
				//, processStartTime.ToString("yyyy-MM-dd HH:mm:ss.fff")
									);
			var type = this.GetType();
			PerformanceCountersHelper.AttachPerformanceCountersToProperties<ConcurrentAsyncQueue<T>>(instanceName, category, this);
			_isAttachedPerformanceCounters = true;
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void Stop(int count)
		{
			Action action;
			for (var i = 0; i < count; i++)
			{
				if (_callbackProcessBreaksActions.TryDequeue(out action))
				{
					action();
				}
			}
		}
		public void StartStop(int count)
		{
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										Stop(count);
									}
								)
					).Start();
		}
		public void StartAdd(int count)
		{
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										Add(count);
									}
								)
					).Start();
		}
		private void Add(int count)
		{
			for (int i = 0; i < count; i++)
			{
				Interlocked.Increment(ref _concurrentDequeueThreadsCount);
				if (_dequeueThreadsProcessorsPool == null)
				{
					_dequeueThreadsProcessorsPool = new ConcurrentQueue<ThreadProcessor>();
				}
				var processor = new ThreadProcessor
												(
													this
													, new AutoResetEvent(false)
												);
				var thread = new Thread
									(
										new ThreadStart
													(
														processor.ThreadProcess
													)
									);
				if (_callbackProcessBreaksActions == null)
				{
					_callbackProcessBreaksActions = new ConcurrentQueue<Action>();
				}
				var callbackProcessBreakAction = new Action
												(
													processor.StopOne
												);
				_callbackProcessBreaksActions.Enqueue(callbackProcessBreakAction);
				_dequeueThreadsProcessorsPool.Enqueue(processor);
				thread.Start();
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				_queue.Enqueue(element);
				if (_isAttachedPerformanceCounters)
				{
					EnqueuePerformanceCounter.Increment();
					EnqueueRateOfCountsPerSecondPerformanceCounter.Increment();
					QueueLengthPerformanceCounter.Increment();
				}
				if
					(
						_dequeueThreadsProcessorsPool != null
						&& !_dequeueThreadsProcessorsPool.IsEmpty
					)
				{
					ThreadProcessor processor;
					if (_dequeueThreadsProcessorsPool.TryDequeue(out processor))
					{
						processor.Wait.Set();
					}
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class ReaderWriterLockSlimHelper
	{
		public static bool TryEnterWriterLockSlimWrite<T>
												 (
													 ref T target
													, T newValue
													, int enterTimeOutSeconds
												 )
													where T : class
		{
			bool r = false;
			var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutSeconds >= 0)
			{
				timeOut = enterTimeOutSeconds * 1000;
			}
			try
			{
				r = (rwls.TryEnterWriteLock(timeOut));
				if (r)
				{
					Interlocked.Exchange<T>(ref target, newValue);
					r = true;
				}
			}
			finally
			{
				if (r)
				{
					rwls.ExitWriteLock();
				}
			}
			return r;
		}
		public static bool TryEnterWriterLockSlim
								(
									Action action
									, int enterTimeOutSeconds
								)
		{
			bool r = false;
			if (action != null)
			{
				var rwls = new ReaderWriterLockSlim();
				int timeOut = Timeout.Infinite;
				if (enterTimeOutSeconds >= 0)
				{
					timeOut = enterTimeOutSeconds * 1000;
				}
				try
				{
					r = (rwls.TryEnterWriteLock(timeOut));
					if (r)
					{
						action();
						r = true;
					}
				}
				finally
				{
					if (r)
					{
						rwls.ExitWriteLock();
					}
				}
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	public class DynamicPropertyAccessor
	{
		public static Func<object, object> CreateGetPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName, typeof(TProperty));
			var getPropertyValue = Expression.Property(null, property);
			var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var getPropertyValue = Expression.Property(null, property);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object));
			var propertyValue = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, object> CreateSetPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object));
			var propertyValue = Expression.Parameter(typeof(TProperty));
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			return Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue).Compile();
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(object));
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<object> CreateSetStaticPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(TProperty));
			//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, propertyValue);
			var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Diagnostics;
	using System.Reflection;
	using System.Collections.Generic;
	public static class PerformanceCountersHelper
	{
		public static void AttachPerformanceCountersToProperties<T>
									(
										string performanceCounterInstanceName
										, string category
										, T target = default(T)
									)
		{
			var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList.Where
												(
													(pi) =>
													{
														return (pi.PropertyType == typeof(PerformanceCounter));
													}
												).ToList();
			if (PerformanceCounterCategory.Exists(category))
			{
				propertiesList.ForEach
									(
										(pi) =>
										{
											if (PerformanceCounterCategory.CounterExists(pi.Name, category))
											{
												if (PerformanceCounterCategory.InstanceExists(performanceCounterInstanceName, category))
												{
													//var pc = new PerformanceCounter(category, pi.Name, instanceName, false);
													//pc.InstanceName = instanceName;
													//pc.RemoveInstance();
												}
											}
										}
									);
				PerformanceCounterCategory.Delete(category);
			}
			var ccdc = new CounterCreationDataCollection();
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									PerformanceCounterType?  performanceCounterType;
									if (propertyName.ToLower().IndexOf("RateOfCountsPerSecond".ToLower()) > 0)
									{
										performanceCounterType = PerformanceCounterType.RateOfCountsPerSecond64;
									}
									else
									{
										performanceCounterType = PerformanceCounterType.NumberOfItems64;
									}
									var ccd = PerformanceCounterHelper.GetCounterCreationData
									(
										propertyName
										, performanceCounterType.Value
									);
									ccdc.Add(ccd);
								}
							);
			PerformanceCounterCategory.Create
							(
								category,
								string.Format("{0} Category Help.", category),
								PerformanceCounterCategoryType.MultiInstance,
								ccdc
							);
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var pc = new PerformanceCounter()
									{
										CategoryName = category
										,
										CounterName = propertyName
										,
										InstanceLifetime = PerformanceCounterInstanceLifetime.Process
										,
										InstanceName = performanceCounterInstanceName
										,
										ReadOnly = false
										,
										RawValue = 0
									};
									if (pi.GetGetMethod().IsStatic)
									{
										var setter = DynamicPropertyAccessor.CreateSetStaticPropertyValueAction<PerformanceCounter>(type, propertyName);
										setter(pc);
									}
									else
									{
										if (target != null)
										{
											var setter = DynamicPropertyAccessor.CreateSetPropertyValueAction<PerformanceCounter>(type, propertyName);
											setter(target, pc);
										}
									}
								}
							);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			return new CounterCreationData()
			{
				CounterName = counterName
				,
				CounterHelp = string.Format("{0} Help", counterName)
				,
				CounterType = performanceCounterType
			};
		}
	}
}
#T=ConcurrentAsyncQueue 2012-08-22 (1)
^# define stopwatch
//# define datetime
//# define long
namespace Test
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	using Microshaoft;
	class Program
	{
		static void Main()
		{
			GCNotifier.RegisterForFullGCNotification
								(
									99
									, 99
									, 10
									, (x) =>
									{
										//if (x != GCNotificationStatus.Timeout)
										{
											Console.WriteLine("FullGCApproach {0}", x);
										}
									}
									, (x) =>
									{
										//if (x != GCNotificationStatus.Timeout)
										{
											Console.WriteLine("FullGCComplete {0}", x);
										}
									}
								);
			var q = new ConcurrentAsyncQueue<int>();
			q.AttachPerformanceCounters
								(
									"new"
									, "Microshaoft ConcurrentAsyncQueue Performance Counters"
									, new PerformanceCountersContainer()
								 );
			Random random = new Random();
			q.OnDequeue += new ConcurrentAsyncQueue<int>.QueueEventHandler
													(
														(x) =>
														{
															int sleep = random.Next(0, 9) * 50;
															//Console.WriteLine(sleep);
															//Thread.Sleep(sleep);
															if (sleep > 400)
															{
																Console.WriteLine(x);
															}
														}
													);
			q.OnException += new ConcurrentAsyncQueue<int>.ExceptionEventHandler
																	(
																		(x) =>
																		{
																			Console.WriteLine(x.ToString());
																		}
																	);
			Console.WriteLine("begin ...");
			//q.StartAdd(10);
			string r = string.Empty;
			while ((r = Console.ReadLine()) != "q")
			{
				int i;
				if (int.TryParse(r, out i))
				{
					Console.WriteLine("Parallel Enqueue {0} begin ...", i);
					new Thread
							(
								new ParameterizedThreadStart
											(
												(x) =>
												{
													Parallel.For
																(
																	0
																	, i
																	, (xx) =>
																	{
																		q.Enqueue(xx);
																	}
																);
													Console.WriteLine("Parallel Enqueue {0} end ...", i);
												}
											)
							).Start();
				}
				else if (r.ToLower() == "stop")
				{
					q.StartStop(10);
				}
				else if (r.ToLower() == "add")
				{
					q.StartAdd(20);
				}
				else
				{
					Console.WriteLine("please input Number!");
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Concurrent;
	using System.Diagnostics;
	using System.Threading;
	public class ConcurrentAsyncQueue<T>
	{
		public delegate void QueueEventHandler(T item);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public QueueLogEventHandler
								OnQueueLog
								, OnDequeueThreadStart
								, OnDequeueThreadEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private ConcurrentQueue
							<
								Tuple
									<
^#if stopwatch
										Stopwatch
^#elif datetime
										DateTime?
^#elif long
										long
^#endif
										, T
									>
							> _queue =
									new ConcurrentQueue
												<
													Tuple
														<
^#if stopwatch
															Stopwatch
^#elif datetime
															DateTime?
^#elif long
															long
^#endif
, T
														>
												>();
		private ConcurrentQueue<Action> _callbackProcessBreaksActions;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private ConcurrentQueue<ThreadProcessor> _dequeueThreadsProcessorsPool;
		private int _dequeueIdleSleepSeconds = 10;
		public PerformanceCountersContainer PerformanceCounters
		{
			get;
			private set;
		}
		public int DequeueIdleSleepSeconds
		{
			set
			{
				_dequeueIdleSleepSeconds = value;
			}
			get
			{
				return _dequeueIdleSleepSeconds;
			}
		}
		private bool _isAttachedPerformanceCounters = false;
		private class ThreadProcessor
		{
			public bool Break
			{
				set;
				get;
			}
			public EventWaitHandle Wait
			{
				private set;
				get;
			}
			public ConcurrentAsyncQueue<T> Sender
			{
				private set;
				get;
			}
			public void StopOne()
			{
				Break = true;
			}
			public ThreadProcessor
							(
								ConcurrentAsyncQueue<T> queue
								, EventWaitHandle wait
							)
			{
				Wait = wait;
				Sender = queue;
			}
			public void ThreadProcess()
			{
				Interlocked.Increment(ref Sender._concurrentDequeueThreadsCount);
				bool counterEnabled = Sender._isAttachedPerformanceCounters;
				if (counterEnabled)
				{
					Sender.PerformanceCounters.DequeueThreadStartPerformanceCounter.ChangeCounterValueWithTryCatchExceptionFinally<long>
												(
													counterEnabled
													, (x) =>
													{
														return x.Increment();
													}
												);
					Sender.PerformanceCounters.DequeueThreadsCountPerformanceCounter.Increment();
				}
				long r = 0;
				try
				{
					if (Sender.OnDequeueThreadStart != null)
					{
						r = Interlocked.Read(ref Sender._concurrentDequeueThreadsCount);
						Sender.OnDequeueThreadStart
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
														, "Threads ++ !"
														, r
														, Sender._queue.Count
														, Thread.CurrentThread.Name
														, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
													)
										);
					}
					while (true)
					{
						#region while true loop
						if (Break)
						{
							break;
						}
						while (!Sender._queue.IsEmpty)
						{
							#region while queue.IsEmpty loop
							if (Break)
							{
								break;
							}
^#if stopwatch
							Tuple<Stopwatch, T>
^#elif datetime
							Tuple<DateTime?,T>
^#elif long
							Tuple<long,T>
^#endif
							item = null;
							if (Sender._queue.TryDequeue(out item))
							{
								if (counterEnabled)
								{
									Sender.PerformanceCounters.DequeuePerformanceCounter.Increment();
									Sender.PerformanceCounters.QueueLengthPerformanceCounter.Decrement();
								}
								if (Sender.OnDequeue != null)
								{
									if (counterEnabled)
									{
										var beginTimeStopwatch = item.Item1;
										if
											(
^#if stopwatch
												beginTimeStopwatch != null
^#elif datetime
												beginTimeStopwatch != null
^#elif long
												beginTimeStopwatch != 0
^#endif
											)
										{
^#if stopwatch
											beginTimeStopwatch.Stop();
^#endif
											long elapsedTicks =
^#if stopwatch
											beginTimeStopwatch.ElapsedTicks;
											beginTimeStopwatch = null;
^#elif datetime
											DateTime.Now.Ticks - beginTimeStopwatch.Value.Ticks;
											beginTimeStopwatch = null;
^#elif long
											DateTime.Now.Ticks - beginTimeStopwatch;
^#endif
											Sender.PerformanceCounters.QueuedWaitAverageTimerPerformanceCounter.IncrementBy(elapsedTicks);
											Sender.PerformanceCounters.QueuedWaitAverageBasePerformanceCounter.Increment();
										}
									}
									var element = item.Item2;
									item = null;
									Sender.PerformanceCounters.DequeueProcessedAverageTimerPerformanceCounter.ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
											(
												counterEnabled
												, Sender.PerformanceCounters.DequeueProcessedAverageBasePerformanceCounter
												, () =>
												{
													Sender.OnDequeue(element);
												}
											);
								}
								if (Sender._isAttachedPerformanceCounters)
								{
									Sender.PerformanceCounters.DequeueProcessedPerformanceCounter.Increment();
									Sender.PerformanceCounters.DequeueProcessedRateOfCountsPerSecondPerformanceCounter.Increment();
								}
							}
							#endregion while queue.IsEmpty loop
						}
						#region wait
						Sender._dequeueThreadsProcessorsPool.Enqueue(this);
						if (Break)
						{
						}
						if (!Wait.WaitOne(Sender.DequeueIdleSleepSeconds * 1000))
						{
						}
						#endregion wait
						#endregion while true loop
					}
				}
				catch (Exception e)
				{
					if (Sender.OnException != null)
					{
						Sender.OnException(e);
					}
				}
				finally
				{
					r = Interlocked.Decrement(ref Sender._concurrentDequeueThreadsCount);
					if (r < 0)
					{
						Interlocked.Exchange(ref Sender._concurrentDequeueThreadsCount, 0);
						if (Sender._isAttachedPerformanceCounters)
						{
							if (Sender.PerformanceCounters.DequeueThreadsCountPerformanceCounter.RawValue < 0)
							{
								Sender.PerformanceCounters.DequeueThreadsCountPerformanceCounter.RawValue = Sender._concurrentDequeueThreadsCount;
							}
						}
					}
					if (Sender.OnDequeueThreadEnd != null)
					{
						Sender.OnDequeueThreadEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
													, "Threads--"
													, r
													, Sender._queue.Count
													, Thread.CurrentThread.Name
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
												)
									);
					}
					if (Sender._isAttachedPerformanceCounters)
					{
						Sender.PerformanceCounters.DequeueThreadEndPerformanceCounter.Increment();
						Sender.PerformanceCounters.DequeueThreadsCountPerformanceCounter.Decrement();
					}
					if (!Break)
					{
						Sender.StartAdd(1);
					}
					Break = false;
				}
			}
		}
		public void AttachPerformanceCounters
							(
								string instanceNamePrefix
								, string categoryName
								, PerformanceCountersContainer performanceCounters
							)
		{
			var process = Process.GetCurrentProcess();
			var processName = process.ProcessName;
			var instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
									);
			PerformanceCounters = performanceCounters;
			PerformanceCounters.AttachPerformanceCountersToProperties(instanceName, categoryName);
			_isAttachedPerformanceCounters = true;
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void Stop(int count)
		{
			Action action;
			for (var i = 0; i < count; i++)
			{
				if (_callbackProcessBreaksActions.TryDequeue(out action))
				{
					action();
					action = null;
				}
			}
		}
		public void StartStop(int count)
		{
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										Stop(count);
									}
								)
					).Start();
		}
		public void StartAdd(int count)
		{
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										Add(count);
									}
								)
					).Start();
		}
		private void Add(int count)
		{
			for (int i = 0; i < count; i++)
			{
				Interlocked.Increment(ref _concurrentDequeueThreadsCount);
				if (_dequeueThreadsProcessorsPool == null)
				{
					_dequeueThreadsProcessorsPool = new ConcurrentQueue<ThreadProcessor>();
				}
				var processor = new ThreadProcessor
												(
													this
													, new AutoResetEvent(false)
												);
				var thread = new Thread
									(
										new ThreadStart
													(
														processor.ThreadProcess
													)
									);
				if (_callbackProcessBreaksActions == null)
				{
					_callbackProcessBreaksActions = new ConcurrentQueue<Action>();
				}
				var callbackProcessBreakAction = new Action
														(
															processor.StopOne
														);
				_callbackProcessBreaksActions.Enqueue(callbackProcessBreakAction);
				_dequeueThreadsProcessorsPool.Enqueue(processor);
				thread.Start();
			}
		}
		public void Enqueue(T item)
		{
			try
			{

^#if stopwatch
				Stopwatch stopwatch = null;
^#elif datetime
				DateTime? stopwatch = null;
^#elif long
				long stopwatch = 0;
^#endif
				if (_isAttachedPerformanceCounters)
				{
^#if stopwatch
					stopwatch = Stopwatch.StartNew();
^#elif datetime
					stopwatch  = DateTime.Now;
^#elif long
					stopwatch  = DateTime.Now.Ticks;
^#endif
				}
				var element = Tuple.Create
										<
^#if stopwatch
											Stopwatch
^#elif datetime
											DateTime?
^#elif long
											long
^#endif
											, T
										>(stopwatch, item);
				_queue.Enqueue(element);
				if (_isAttachedPerformanceCounters)
				{
					PerformanceCounters.EnqueuePerformanceCounter.Increment();
					PerformanceCounters.EnqueueRateOfCountsPerSecondPerformanceCounter.Increment();
					PerformanceCounters.QueueLengthPerformanceCounter.Increment();
				}
				if
					(
						_dequeueThreadsProcessorsPool != null
						&& !_dequeueThreadsProcessorsPool.IsEmpty
					)
				{
					ThreadProcessor processor;
					if (_dequeueThreadsProcessorsPool.TryDequeue(out processor))
					{
						processor.Wait.Set();
						processor = null;
						//Console.WriteLine("processor = null;");
					}
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			return new CounterCreationData()
			{
				CounterName = counterName
				,
				CounterHelp = string.Format("{0} Help", counterName)
				,
				CounterType = performanceCounterType
			};
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterExtensionMethodsManager
	{
		public static T ChangeCounterValueWithTryCatchExceptionFinally<T>
								(
									this PerformanceCounter performanceCounter
									, bool enabled
									, Func<PerformanceCounter, T> OnCounterChangeProcessFunc = null
									, Action<PerformanceCounter> OnCounterChangedProcessAction = null
									, Func<PerformanceCounter, Exception, bool> OnCatchedExceptionProcessFunc = null
									, Action<PerformanceCounter> OnCatchedExceptionFinallyProcessAction = null
								)
		{
			T r = default(T);
			if (enabled)
			{
				if (OnCounterChangeProcessFunc != null)
				{
					var catchedException = false;
					try
					{
						r = OnCounterChangeProcessFunc(performanceCounter);
					}
					catch (Exception e)
					{
						catchedException = true;
						if (OnCatchedExceptionProcessFunc != null)
						{
							var b = OnCatchedExceptionProcessFunc(performanceCounter, e);
							if (b)
							{
								throw new Exception("OnCounterChangeProcessFunc InnerExcepion", e);
							}
						}
					}
					finally
					{
						if (catchedException)
						{
							if (OnCatchedExceptionFinallyProcessAction != null)
							{
								OnCatchedExceptionFinallyProcessAction(performanceCounter);
							}
						}
					}
				}
			}
			if (OnCounterChangedProcessAction != null)
			{
				var catchedException = false;
				try
				{
					OnCounterChangedProcessAction(performanceCounter);
				}
				catch (Exception e)
				{
					catchedException = true;
					if (OnCatchedExceptionProcessFunc != null)
					{
						var b = OnCatchedExceptionProcessFunc(performanceCounter, e);
						if (b)
						{
							throw new Exception("OnCounterChangedProcessAction InnerExcepion", e);
						}
					}
				}
				finally
				{
					if (catchedException)
					{
						if (OnCatchedExceptionFinallyProcessAction != null)
						{
							OnCatchedExceptionFinallyProcessAction(performanceCounter);
						}
					}
				}
			}
			return r;
		}
		public static void ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
														(
															this PerformanceCounter performanceCounter
															, bool enabled
															, PerformanceCounter basePerformanceCounter
															, Action OnCounterInnerProcessAction = null
															, Func<PerformanceCounter, Exception, bool> OnCatchedExceptionProcessFunc = null
															, Action<PerformanceCounter, PerformanceCounter> OnCatchedExceptionFinallyProcessAction = null
														)
		{
			if (enabled)
			{
				var stopwatch = Stopwatch.StartNew();
				if (OnCounterInnerProcessAction != null)
				{
					var catchedException = false;
					try
					{
						OnCounterInnerProcessAction();
					}
					catch (Exception e)
					{
						catchedException = true;
						if (OnCatchedExceptionProcessFunc != null)
						{
							var b = OnCatchedExceptionProcessFunc(performanceCounter, e);
							if (b)
							{
								throw new Exception("OnCounterInnerProcessAction InnerExcepion", e);
							}
						}
					}
					finally
					{
						stopwatch.Stop();
						performanceCounter.IncrementBy(stopwatch.ElapsedTicks);
						stopwatch = null;
						basePerformanceCounter.Increment();
						if (catchedException)
						{
							if (OnCatchedExceptionFinallyProcessAction != null)
							{
								OnCatchedExceptionFinallyProcessAction(performanceCounter, basePerformanceCounter);
							}
						}
					}
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Linq;
	using System.Collections.Concurrent;
	public class PerformanceCountersContainer
	{
		#region PerformanceCounters
		private PerformanceCounter _enqueuePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter EnqueuePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _enqueuePerformanceCounter, value, 2);
			}
			get
			{
				return _enqueuePerformanceCounter;
			}
		}
		private PerformanceCounter _enqueueRateOfCountsPerSecondPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.RateOfCountsPerSecond64)]
		public PerformanceCounter EnqueueRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _enqueueRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _enqueueRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeuePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeuePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeuePerformanceCounter, value, 2);
			}
			get
			{
				return _dequeuePerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedRateOfCountsPerSecondPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.RateOfCountsPerSecond64)]
		public PerformanceCounter DequeueProcessedRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeueProcessedPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedAverageTimerPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter DequeueProcessedAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedAverageTimerPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedAverageBasePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageBase)]
		public PerformanceCounter DequeueProcessedAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedAverageBasePerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedAverageBasePerformanceCounter;
			}
		}
		private PerformanceCounter _queuedWaitAverageTimerPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter QueuedWaitAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _queuedWaitAverageTimerPerformanceCounter, value, 2);
			}
			get
			{
				return _queuedWaitAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _queuedWaitAverageBasePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageBase)]
		public PerformanceCounter QueuedWaitAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _queuedWaitAverageBasePerformanceCounter, value, 2);
			}
			get
			{
				return _queuedWaitAverageBasePerformanceCounter;
			}
		}
		private PerformanceCounter _queueLengthPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter QueueLengthPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _queueLengthPerformanceCounter, value, 2);
			}
			get
			{
				return _queueLengthPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeueThreadStartPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadStartPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadStartPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeueThreadEndPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadEndPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadEndPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeueThreadsCountPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadsCountPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadsCountPerformanceCounter;
			}
		}
		#endregion
		// indexer declaration
		public PerformanceCounter this[string name]
		{
			get
			{
				throw new NotImplementedException();
				//return null;
			}
		}
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCountersToProperties
							(
								string instanceName
								, string categoryName
							)
		{
			if (!_isAttachedPerformanceCounters)
			{
				var type = this.GetType();
				PerformanceCountersHelper.AttachPerformanceCountersToProperties<PerformanceCountersContainer>(instanceName, categoryName, this);
			}
			_isAttachedPerformanceCounters = true;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
	public class PerformanceCounterTypeAttribute : Attribute
	{
		public PerformanceCounterType CounterType;
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	using System.Linq;
	public static class PerformanceCountersHelper
	{
		public static void AttachPerformanceCountersToProperties<T>
									(
										string performanceCounterInstanceName
										, string category
										, T target = default(T)
									)
		{
			var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList.Where
												(
													(pi) =>
													{
														var parameters = pi.GetIndexParameters();
														return
															(
																pi.PropertyType == typeof(PerformanceCounter)
																&& (parameters == null ? 0 : parameters.Length) <= 0
															);
													}
												).ToList();
			if (PerformanceCounterCategory.Exists(category))
			{
				propertiesList.ForEach
									(
										(pi) =>
										{
											if (PerformanceCounterCategory.CounterExists(pi.Name, category))
											{
												if (PerformanceCounterCategory.InstanceExists(performanceCounterInstanceName, category))
												{
													//var pc = new PerformanceCounter(category, pi.Name, instanceName, false);
													//pc.InstanceName = instanceName;
													//pc.RemoveInstance();
												}
											}
										}
									);
				PerformanceCounterCategory.Delete(category);
			}
			var ccdc = new CounterCreationDataCollection();
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									PerformanceCounterTypeAttribute attribute = pi.GetCustomAttributes(false).FirstOrDefault
																				(
																					(x) =>
																					{
																						return x as PerformanceCounterTypeAttribute != null;
																					}
																				) as PerformanceCounterTypeAttribute;
									PerformanceCounterType performanceCounterType = (attribute == null ? PerformanceCounterType.NumberOfItems64 : attribute.CounterType);
									var ccd = PerformanceCounterHelper.GetCounterCreationData
									(
										propertyName
										, performanceCounterType
									);
									ccdc.Add(ccd);
								}
							);
			PerformanceCounterCategory.Create
							(
								category,
								string.Format("{0} Category Help.", category),
								PerformanceCounterCategoryType.MultiInstance,
								ccdc
							);
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var pc = new PerformanceCounter()
									{
										CategoryName = category
										,
										CounterName = propertyName
										,
										InstanceLifetime = PerformanceCounterInstanceLifetime.Process
										,
										InstanceName = performanceCounterInstanceName
										,
										ReadOnly = false
										,
										RawValue = 0
									};
									if (pi.GetGetMethod().IsStatic)
									{
										var setter = DynamicPropertyAccessor.CreateSetStaticPropertyValueAction<PerformanceCounter>(type, propertyName);
										setter(pc);
									}
									else
									{
										if (target != null)
										{
											var setter = DynamicPropertyAccessor.CreateSetPropertyValueAction<PerformanceCounter>(type, propertyName);
											setter(target, pc);
										}
									}
								}
							);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class ReaderWriterLockSlimHelper
	{
		public static bool TryEnterWriterLockSlimWrite<T>
												(
													 ref T target
													, T newValue
													, int enterTimeOutSeconds
												)
													where T : class
		{
			bool r = false;
			var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutSeconds >= 0)
			{
				timeOut = enterTimeOutSeconds * 1000;
			}
			try
			{
				r = (rwls.TryEnterWriteLock(timeOut));
				if (r)
				{
					Interlocked.Exchange<T>(ref target, newValue);
					r = true;
				}
			}
			finally
			{
				if (r)
				{
					rwls.ExitWriteLock();
				}
			}
			return r;
		}
		public static bool TryEnterWriterLockSlim
								(
									Action action
									, int enterTimeOutSeconds
								)
		{
			bool r = false;
			if (action != null)
			{
				var rwls = new ReaderWriterLockSlim();
				int timeOut = Timeout.Infinite;
				if (enterTimeOutSeconds >= 0)
				{
					timeOut = enterTimeOutSeconds * 1000;
				}
				try
				{
					r = (rwls.TryEnterWriteLock(timeOut));
					if (r)
					{
						action();
						r = true;
					}
				}
				finally
				{
					if (r)
					{
						rwls.ExitWriteLock();
					}
				}
			}
			return r;
		}
	}
}

#T=ConcurrentAsyncQueue 2012-08-22 (2)
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class GCNotifier
	{
		public static void CancelForFullGCNotification()
		{
			GC.CancelFullGCNotification();
		}
		public static void RegisterForFullGCNotification
									(
										int maxGenerationThreshold
										, int maxLargeObjectHeapThreshold
										, int waitOnceSecondsTimeout
										, Action<GCNotificationStatus> waitForFullGCApproachProcessAction
										, Action<GCNotificationStatus> waitForFullGCCompleteProcessAction
									)
		{
			GC.RegisterForFullGCNotification(maxGenerationThreshold, maxLargeObjectHeapThreshold);
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										while (true)
										{
											if (waitForFullGCApproachProcessAction != null)
											{
												var gcNotificationStatus = GC.WaitForFullGCApproach(1000 * waitOnceSecondsTimeout);
												if (gcNotificationStatus != GCNotificationStatus.Timeout)
												{
													waitForFullGCApproachProcessAction(gcNotificationStatus);
												}
											}
											if (waitForFullGCApproachProcessAction != null)
											{
												var gcNotificationStatus = GC.WaitForFullGCComplete(1000 * waitOnceSecondsTimeout);
												if (gcNotificationStatus != GCNotificationStatus.Timeout)
												{
													waitForFullGCCompleteProcessAction(gcNotificationStatus);
												}
											}
											Thread.Sleep(1000);
										}
									}
								)
						).Start();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	public class DynamicPropertyAccessor
	{
		public static Func<object, object> CreateGetPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName, typeof(TProperty));
			var getPropertyValue = Expression.Property(null, property);
			var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var getPropertyValue = Expression.Property(null, property);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object));
			var propertyValue = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, object> CreateSetPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object));
			var propertyValue = Expression.Parameter(typeof(TProperty));
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			return Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue).Compile();
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(object));
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<object> CreateSetStaticPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(TProperty));
			//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, propertyValue);
			var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}

#T=ConcurrentAsyncQueue 2013-06-03 (1)
namespace Test
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	using Microshaoft;
	class Program
	{
		static void Main()
		{
			GCNotifier.RegisterForFullGCNotification
								(
									99
									, 99
									, 10
									, (x) =>
									{
										//if (x != GCNotificationStatus.Timeout)
										{
											Console.WriteLine("FullGCApproach {0}", x);
										}
									}
									, (x) =>
									{
										//if (x != GCNotificationStatus.Timeout)
										{
											Console.WriteLine("FullGCComplete {0}", x);
										}
									}
								);
			var q = new ConcurrentAsyncQueue<int>();
			q.AttachPerformanceCounters
								(
									"new"
									, "Microshaoft ConcurrentAsyncQueue Performance Counters"
									, new PerformanceCountersContainer()
								 );
			Random random = new Random();
			q.OnDequeue += new ConcurrentAsyncQueue<int>.QueueEventHandler
													(
														(x) =>
														{
															int sleep = random.Next(0, 9) * 50;
															//Console.WriteLine(sleep);
															//Thread.Sleep(sleep);
															if (sleep > 400)
															{
																Console.WriteLine(x);
															}
														}
													);
			q.OnException += new ConcurrentAsyncQueue<int>.ExceptionEventHandler
																	(
																		(x) =>
																		{
																			Console.WriteLine(x.ToString());
																		}
																	);
			Console.WriteLine("begin ...");
			//q.StartAdd(10);
			string r = string.Empty;
			while ((r = Console.ReadLine()) != "q")
			{
				int i;
				if (int.TryParse(r, out i))
				{
					Console.WriteLine("Parallel Enqueue {0} begin ...", i);
					new Thread
							(
								new ParameterizedThreadStart
											(
												(x) =>
												{
													Parallel.For
																(
																	0
																	, i
																	, (xx) =>
																	{
																		q.Enqueue(xx);
																	}
																);
													Console.WriteLine("Parallel Enqueue {0} end ...", i);
												}
											)
							).Start();
				}
				else if (r.ToLower() == "stop")
				{
					q.StartStop(10);
				}
				else if (r.ToLower() == "add")
				{
					q.StartAdd(20);
				}
				else
				{
					Console.WriteLine("please input Number!");
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Concurrent;
	using System.Diagnostics;
	using System.Threading;
	public class ConcurrentAsyncQueue<T>
	{
		public delegate void QueueEventHandler(T item);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public QueueLogEventHandler
								OnQueueLog
								, OnDequeueThreadStart
								, OnDequeueThreadEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private ConcurrentQueue<Tuple<Stopwatch, T>> _queue =
									new ConcurrentQueue<Tuple<Stopwatch, T>>();
		private ConcurrentQueue<Action> _callbackProcessBreaksActions;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private ConcurrentQueue<ThreadProcessor> _dequeueThreadsProcessorsPool;
		private int _dequeueIdleSleepSeconds = 10;
		public PerformanceCountersContainer PerformanceCounters
		{
			get;
			private set;
		}
		public int DequeueIdleSleepSeconds
		{
			set
			{
				_dequeueIdleSleepSeconds = value;
			}
			get
			{
				return _dequeueIdleSleepSeconds;
			}
		}
		private bool _isAttachedPerformanceCounters = false;
		private class ThreadProcessor
		{
			public bool Break
			{
				set;
				get;
			}
			public EventWaitHandle Wait
			{
				private set;
				get;
			}
			public ConcurrentAsyncQueue<T> Sender
			{
				private set;
				get;
			}
			public void StopOne()
			{
				Break = true;
			}
			public ThreadProcessor
							(
								ConcurrentAsyncQueue<T> queue
								, EventWaitHandle wait
							)
			{
				Wait = wait;
				Sender = queue;
			}
			public void ThreadProcess()
			{
				Interlocked.Increment(ref Sender._concurrentDequeueThreadsCount);
				bool counterEnabled = Sender._isAttachedPerformanceCounters;
				if (counterEnabled)
				{
					Sender.PerformanceCounters.DequeueThreadStartPerformanceCounter.ChangeCounterValueWithTryCatchExceptionFinally<long>
												(
													counterEnabled
													, (x) =>
													{
														return x.Increment();
													}
												);
					Sender.PerformanceCounters.DequeueThreadsCountPerformanceCounter.Increment();
				}
				long r = 0;
				try
				{
					if (Sender.OnDequeueThreadStart != null)
					{
						r = Interlocked.Read(ref Sender._concurrentDequeueThreadsCount);
						Sender.OnDequeueThreadStart
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
														, "Threads ++ !"
														, r
														, Sender._queue.Count
														, Thread.CurrentThread.Name
														, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
													)
										);
					}
					while (true)
					{
						#region while true loop
						if (Break)
						{
							break;
						}
						while (!Sender._queue.IsEmpty)
						{
							#region while queue.IsEmpty loop
							if (Break)
							{
								break;
							}
							Tuple<Stopwatch, T> item = null;
							if (Sender._queue.TryDequeue(out item))
							{
								if (counterEnabled)
								{
									Sender.PerformanceCounters.DequeuePerformanceCounter.Increment();
									Sender.PerformanceCounters.QueueLengthPerformanceCounter.Decrement();
								}
								if (Sender.OnDequeue != null)
								{
									if (counterEnabled)
									{
										var beginTimeStopwatch = item.Item1;
										if
											(
												beginTimeStopwatch != null
											)
										{
											beginTimeStopwatch.Stop();
											long elapsedTicks = beginTimeStopwatch.ElapsedTicks;
											Sender.PerformanceCounters.QueuedWaitAverageTimerPerformanceCounter.IncrementBy(elapsedTicks);
											Sender.PerformanceCounters.QueuedWaitAverageBasePerformanceCounter.Increment();
										}
									}
									var element = item.Item2;
									item = null;
									Sender.PerformanceCounters.DequeueProcessedAverageTimerPerformanceCounter.ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
											(
												counterEnabled
												, Sender.PerformanceCounters.DequeueProcessedAverageBasePerformanceCounter
												, () =>
												{
													Sender.OnDequeue(element);
												}
											);
								}
								if (Sender._isAttachedPerformanceCounters)
								{
									Sender.PerformanceCounters.DequeueProcessedPerformanceCounter.Increment();
									Sender.PerformanceCounters.DequeueProcessedRateOfCountsPerSecondPerformanceCounter.Increment();
								}
							}
							#endregion while queue.IsEmpty loop
						}
						#region wait
						Sender._dequeueThreadsProcessorsPool.Enqueue(this);
						if (Break)
						{
						}
						if (!Wait.WaitOne(Sender.DequeueIdleSleepSeconds * 1000))
						{
						}
						#endregion wait
						#endregion while true loop
					}
				}
				catch (Exception e)
				{
					if (Sender.OnException != null)
					{
						Sender.OnException(e);
					}
				}
				finally
				{
					r = Interlocked.Decrement(ref Sender._concurrentDequeueThreadsCount);
					if (r < 0)
					{
						Interlocked.Exchange(ref Sender._concurrentDequeueThreadsCount, 0);
						if (Sender._isAttachedPerformanceCounters)
						{
							if (Sender.PerformanceCounters.DequeueThreadsCountPerformanceCounter.RawValue < 0)
							{
								Sender.PerformanceCounters.DequeueThreadsCountPerformanceCounter.RawValue = Sender._concurrentDequeueThreadsCount;
							}
						}
					}
					if (Sender.OnDequeueThreadEnd != null)
					{
						Sender.OnDequeueThreadEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
													, "Threads--"
													, r
													, Sender._queue.Count
													, Thread.CurrentThread.Name
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
												)
									);
					}
					if (Sender._isAttachedPerformanceCounters)
					{
						Sender.PerformanceCounters.DequeueThreadEndPerformanceCounter.Increment();
						Sender.PerformanceCounters.DequeueThreadsCountPerformanceCounter.Decrement();
					}
					if (!Break)
					{
						Sender.StartAdd(1);
					}
					Break = false;
				}
			}
		}
		public void AttachPerformanceCounters
							(
								string instanceNamePrefix
								, string categoryName
								, PerformanceCountersContainer performanceCounters
							)
		{
			var process = Process.GetCurrentProcess();
			var processName = process.ProcessName;
			var instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
									);
			PerformanceCounters = performanceCounters;
			PerformanceCounters.AttachPerformanceCountersToProperties(instanceName, categoryName);
			_isAttachedPerformanceCounters = true;
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void Stop(int count)
		{
			Action action;
			for (var i = 0; i < count; i++)
			{
				if (_callbackProcessBreaksActions.TryDequeue(out action))
				{
					action();
					action = null;
				}
			}
		}
		public void StartStop(int count)
		{
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										Stop(count);
									}
								)
					).Start();
		}
		public void StartAdd(int count)
		{
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										Add(count);
									}
								)
					).Start();
		}
		private void Add(int count)
		{
			for (int i = 0; i < count; i++)
			{
				Interlocked.Increment(ref _concurrentDequeueThreadsCount);
				if (_dequeueThreadsProcessorsPool == null)
				{
					_dequeueThreadsProcessorsPool = new ConcurrentQueue<ThreadProcessor>();
				}
				var processor = new ThreadProcessor
												(
													this
													, new AutoResetEvent(false)
												);
				var thread = new Thread
									(
										new ThreadStart
													(
														processor.ThreadProcess
													)
									);
				if (_callbackProcessBreaksActions == null)
				{
					_callbackProcessBreaksActions = new ConcurrentQueue<Action>();
				}
				var callbackProcessBreakAction = new Action
														(
															processor.StopOne
														);
				_callbackProcessBreaksActions.Enqueue(callbackProcessBreakAction);
				_dequeueThreadsProcessorsPool.Enqueue(processor);
				thread.Start();
			}
		}
		public void Enqueue(T item)
		{
			try
			{
				Stopwatch stopwatch = null;
				if (_isAttachedPerformanceCounters)
				{
					stopwatch = Stopwatch.StartNew();
				}
				var element = Tuple.Create<Stopwatch, T>(stopwatch, item);
				_queue.Enqueue(element);
				if (_isAttachedPerformanceCounters)
				{
					PerformanceCounters.EnqueuePerformanceCounter.Increment();
					PerformanceCounters.EnqueueRateOfCountsPerSecondPerformanceCounter.Increment();
					PerformanceCounters.QueueLengthPerformanceCounter.Increment();
				}
				if
					(
						_dequeueThreadsProcessorsPool != null
						&& !_dequeueThreadsProcessorsPool.IsEmpty
					)
				{
					ThreadProcessor processor;
					if (_dequeueThreadsProcessorsPool.TryDequeue(out processor))
					{
						processor.Wait.Set();
						processor = null;
						//Console.WriteLine("processor = null;");
					}
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			return new CounterCreationData()
			{
				CounterName = counterName
				,
				CounterHelp = string.Format("{0} Help", counterName)
				,
				CounterType = performanceCounterType
			};
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterExtensionMethodsManager
	{
		public static T ChangeCounterValueWithTryCatchExceptionFinally<T>
								(
									this PerformanceCounter performanceCounter
									, bool enabled
									, Func<PerformanceCounter, T> OnCounterChangeProcessFunc = null
									, Action<PerformanceCounter> OnCounterChangedProcessAction = null
									, Func<PerformanceCounter, Exception, bool> OnCaughtExceptionProcessFunc = null
									, Action<PerformanceCounter> OnCaughtExceptionFinallyProcessAction = null
								)
		{
			T r = default(T);
			if (enabled)
			{
				if (OnCounterChangeProcessFunc != null)
				{
					var catchedException = false;
					try
					{
						r = OnCounterChangeProcessFunc(performanceCounter);
					}
					catch (Exception e)
					{
						catchedException = true;
						if (OnCaughtExceptionProcessFunc != null)
						{
							var b = OnCaughtExceptionProcessFunc(performanceCounter, e);
							if (b)
							{
								throw new Exception("OnCounterChangeProcessFunc InnerExcepion", e);
							}
						}
					}
					finally
					{
						if (catchedException)
						{
							if (OnCaughtExceptionFinallyProcessAction != null)
							{
								OnCaughtExceptionFinallyProcessAction(performanceCounter);
							}
						}
					}
				}
			}
			if (OnCounterChangedProcessAction != null)
			{
				var catchedException = false;
				try
				{
					OnCounterChangedProcessAction(performanceCounter);
				}
				catch (Exception e)
				{
					catchedException = true;
					if (OnCaughtExceptionProcessFunc != null)
					{
						var b = OnCaughtExceptionProcessFunc(performanceCounter, e);
						if (b)
						{
							throw new Exception("OnCounterChangedProcessAction InnerExcepion", e);
						}
					}
				}
				finally
				{
					if (catchedException)
					{
						if (OnCaughtExceptionFinallyProcessAction != null)
						{
							OnCaughtExceptionFinallyProcessAction(performanceCounter);
						}
					}
				}
			}
			return r;
		}
		public static void ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
														(
															this PerformanceCounter performanceCounter
															, bool enabled
															, PerformanceCounter basePerformanceCounter
															, Action OnCounterInnerProcessAction = null
															, Func<PerformanceCounter, Exception, bool> OnCaughtExceptionProcessFunc = null
															, Action<PerformanceCounter, PerformanceCounter> OnCaughtExceptionFinallyProcessAction = null
														)
		{
			if (enabled)
			{
				var stopwatch = Stopwatch.StartNew();
				if (OnCounterInnerProcessAction != null)
				{
					var catchedException = false;
					try
					{
						OnCounterInnerProcessAction();
					}
					catch (Exception e)
					{
						catchedException = true;
						if (OnCaughtExceptionProcessFunc != null)
						{
							var b = OnCaughtExceptionProcessFunc(performanceCounter, e);
							if (b)
							{
								throw new Exception("OnCounterInnerProcessAction InnerExcepion", e);
							}
						}
					}
					finally
					{
						stopwatch.Stop();
						performanceCounter.IncrementBy(stopwatch.ElapsedTicks);
						stopwatch = null;
						basePerformanceCounter.Increment();
						if (catchedException)
						{
							if (OnCaughtExceptionFinallyProcessAction != null)
							{
								OnCaughtExceptionFinallyProcessAction(performanceCounter, basePerformanceCounter);
							}
						}
					}
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Linq;
	using System.Collections.Concurrent;
	public class PerformanceCountersContainer
	{
		#region PerformanceCounters
		private PerformanceCounter _enqueuePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter EnqueuePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _enqueuePerformanceCounter, value, 2);
			}
			get
			{
				return _enqueuePerformanceCounter;
			}
		}
		private PerformanceCounter _enqueueRateOfCountsPerSecondPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.RateOfCountsPerSecond64)]
		public PerformanceCounter EnqueueRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _enqueueRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _enqueueRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeuePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeuePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeuePerformanceCounter, value, 2);
			}
			get
			{
				return _dequeuePerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedRateOfCountsPerSecondPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.RateOfCountsPerSecond64)]
		public PerformanceCounter DequeueProcessedRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeueProcessedPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedAverageTimerPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter DequeueProcessedAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedAverageTimerPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedAverageBasePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageBase)]
		public PerformanceCounter DequeueProcessedAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueProcessedAverageBasePerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedAverageBasePerformanceCounter;
			}
		}
		private PerformanceCounter _queuedWaitAverageTimerPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter QueuedWaitAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _queuedWaitAverageTimerPerformanceCounter, value, 2);
			}
			get
			{
				return _queuedWaitAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _queuedWaitAverageBasePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageBase)]
		public PerformanceCounter QueuedWaitAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _queuedWaitAverageBasePerformanceCounter, value, 2);
			}
			get
			{
				return _queuedWaitAverageBasePerformanceCounter;
			}
		}
		private PerformanceCounter _queueLengthPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter QueueLengthPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _queueLengthPerformanceCounter, value, 2);
			}
			get
			{
				return _queueLengthPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeueThreadStartPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadStartPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadStartPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeueThreadEndPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadEndPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadEndPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter DequeueThreadsCountPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _dequeueThreadsCountPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadsCountPerformanceCounter;
			}
		}
		#endregion
		// indexer declaration
		public PerformanceCounter this[string name]
		{
			get
			{
				throw new NotImplementedException();
				//return null;
			}
		}
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCountersToProperties
							(
								string instanceName
								, string categoryName
							)
		{
			if (!_isAttachedPerformanceCounters)
			{
				var type = this.GetType();
				PerformanceCountersHelper.AttachPerformanceCountersToProperties<PerformanceCountersContainer>(instanceName, categoryName, this);
			}
			_isAttachedPerformanceCounters = true;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
	public class PerformanceCounterTypeAttribute : Attribute
	{
		public PerformanceCounterType CounterType;
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	using System.Linq;
	public static class PerformanceCountersHelper
	{
		public static void AttachPerformanceCountersToProperties<T>
									(
										string performanceCounterInstanceName
										, string category
										, T target = default(T)
									)
		{
			var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList.Where
												(
													(pi) =>
													{
														var parameters = pi.GetIndexParameters();
														return
															(
																pi.PropertyType == typeof(PerformanceCounter)
																&& (parameters == null ? 0 : parameters.Length) <= 0
															);
													}
												).ToList();
			if (PerformanceCounterCategory.Exists(category))
			{
				propertiesList.ForEach
									(
										(pi) =>
										{
											if (PerformanceCounterCategory.CounterExists(pi.Name, category))
											{
												if (PerformanceCounterCategory.InstanceExists(performanceCounterInstanceName, category))
												{
													//var pc = new PerformanceCounter(category, pi.Name, instanceName, false);
													//pc.InstanceName = instanceName;
													//pc.RemoveInstance();
												}
											}
										}
									);
				PerformanceCounterCategory.Delete(category);
			}
			var ccdc = new CounterCreationDataCollection();
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									PerformanceCounterTypeAttribute attribute = pi.GetCustomAttributes(false).FirstOrDefault
																				(
																					(x) =>
																					{
																						return x as PerformanceCounterTypeAttribute != null;
																					}
																				) as PerformanceCounterTypeAttribute;
									PerformanceCounterType performanceCounterType = (attribute == null ? PerformanceCounterType.NumberOfItems64 : attribute.CounterType);
									var ccd = PerformanceCounterHelper.GetCounterCreationData
									(
										propertyName
										, performanceCounterType
									);
									ccdc.Add(ccd);
								}
							);
			PerformanceCounterCategory.Create
							(
								category,
								string.Format("{0} Category Help.", category),
								PerformanceCounterCategoryType.MultiInstance,
								ccdc
							);
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var pc = new PerformanceCounter()
									{
										CategoryName = category
										,
										CounterName = propertyName
										,
										InstanceLifetime = PerformanceCounterInstanceLifetime.Process
										,
										InstanceName = performanceCounterInstanceName
										,
										ReadOnly = false
										,
										RawValue = 0
									};
									if (pi.GetGetMethod().IsStatic)
									{
										var setter = DynamicPropertyAccessor.CreateSetStaticPropertyValueAction<PerformanceCounter>(type, propertyName);
										setter(pc);
									}
									else
									{
										if (target != null)
										{
											var setter = DynamicPropertyAccessor.CreateSetPropertyValueAction<PerformanceCounter>(type, propertyName);
											setter(target, pc);
										}
									}
								}
							);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class ReaderWriterLockSlimHelper
	{
		public static bool TryEnterWriterLockSlimWrite<T>
												(
													 ref T target
													, T newValue
													, int enterTimeOutSeconds
												)
													where T : class
		{
			bool r = false;
			var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutSeconds >= 0)
			{
				timeOut = enterTimeOutSeconds * 1000;
			}
			try
			{
				r = (rwls.TryEnterWriteLock(timeOut));
				if (r)
				{
					Interlocked.Exchange<T>(ref target, newValue);
					r = true;
				}
			}
			finally
			{
				if (r)
				{
					rwls.ExitWriteLock();
				}
			}
			return r;
		}
		public static bool TryEnterWriterLockSlim
								(
									Action action
									, int enterTimeOutSeconds
								)
		{
			bool r = false;
			if (action != null)
			{
				var rwls = new ReaderWriterLockSlim();
				int timeOut = Timeout.Infinite;
				if (enterTimeOutSeconds >= 0)
				{
					timeOut = enterTimeOutSeconds * 1000;
				}
				try
				{
					r = (rwls.TryEnterWriteLock(timeOut));
					if (r)
					{
						action();
						r = true;
					}
				}
				finally
				{
					if (r)
					{
						rwls.ExitWriteLock();
					}
				}
			}
			return r;
		}
	}
}
//=======================================================================================================

#T=ConcurrentAsyncQueue 2013-06-03 (2)
//=======================================================================================================
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class GCNotifier
	{
		public static void CancelForFullGCNotification()
		{
			GC.CancelFullGCNotification();
		}
		public static void RegisterForFullGCNotification
									(
										int maxGenerationThreshold
										, int maxLargeObjectHeapThreshold
										, int waitOnceSecondsTimeout
										, Action<GCNotificationStatus> waitForFullGCApproachProcessAction
										, Action<GCNotificationStatus> waitForFullGCCompleteProcessAction
									)
		{
			GC.RegisterForFullGCNotification(maxGenerationThreshold, maxLargeObjectHeapThreshold);
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										while (true)
										{
											if (waitForFullGCApproachProcessAction != null)
											{
												var gcNotificationStatus = GC.WaitForFullGCApproach(1000 * waitOnceSecondsTimeout);
												if (gcNotificationStatus != GCNotificationStatus.Timeout)
												{
													waitForFullGCApproachProcessAction(gcNotificationStatus);
												}
											}
											if (waitForFullGCApproachProcessAction != null)
											{
												var gcNotificationStatus = GC.WaitForFullGCComplete(1000 * waitOnceSecondsTimeout);
												if (gcNotificationStatus != GCNotificationStatus.Timeout)
												{
													waitForFullGCCompleteProcessAction(gcNotificationStatus);
												}
											}
											Thread.Sleep(1000);
										}
									}
								)
						).Start();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	public class DynamicPropertyAccessor
	{
		public static Func<object, object> CreateGetPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName, typeof(TProperty));
			var getPropertyValue = Expression.Property(null, property);
			var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var getPropertyValue = Expression.Property(null, property);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object));
			var propertyValue = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, object> CreateSetPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object));
			var propertyValue = Expression.Parameter(typeof(TProperty));
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			return Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue).Compile();
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(object));
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<object> CreateSetStaticPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(TProperty));
			//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, propertyValue);
			var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}

#T=ConcurrentAsyncQueue 2013-11-16 (1)
/*
	PowerShell:
	[System.Diagnostics.PerformanceCounterCategory]::Delete("Microshaoft ConcurrentAsyncQueue Performance Counters")
	[System.Diagnostics.PerformanceCounterCategory]::GetCategories() | Format-Table -auto
	[System.Diagnostics.PerformanceCounterCategory]::GetCategories() | Where {$_.CategoryName -like "*microshaoft*" } | Format-Table -auto
	[Diagnostics.PerformanceCounterCategory]::Delete( "Your Category Name" )
	[Diagnostics.PerformanceCounterCategory]::GetCategories() | Format-Table -auto
	[Diagnostics.PerformanceCounterCategory]::GetCategories() | Where {$_.CategoryName -like "*microshaoft*" } | Format-Table -auto
	[Diagnostics.PerformanceCounterCategory]::GetCategories() | Where {$_.CategoryName -like "*network*" } | Format-Table -auto
	[Diagnostics.PerformanceCounterCategory]::GetCategories() | Where {$_.CategoryName -match "SQL.*Stat.*" } | Format-Table -auto

	$categoryName = "Microshaoft ConcurrentAsyncQueue Performance Counters"
	$counterName = ""
	$instanceName = ""
	if ([System.Diagnostics.PerformanceCounterCategory]::Exists($categoryName))
	{
		#if ([System.Diagnostics.PerformanceCounterCategory]::CounterExists($counterName,$categoryName))
		{
	
		}
		if ([System.Diagnostics.PerformanceCounterCategory]::InstanceExists($instanceName, $categoryName))
		{
			$pc = New-Object [System.Diagnostics.PerformanceCounter]  ($categoryName, $counterName, $instanceName)
			$pc.RemoveInstance()
			[System.Console]::WriteLine("RemoveInstance")
		}
		[System.Diagnostics.PerformanceCounterCategory]::Delete($categoryName)
		[System.Console]::WriteLine("Delete")
	}

*/
namespace Test
{
	using Microshaoft;
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	class Program
	{
		static void Main()
		{
			GCNotifier
				.RegisterForFullGCNotification
					(
						99
						, 99
						, 10
						, (x) =>
						{
							//if (x != GCNotificationStatus.Timeout)
							{
								Console.WriteLine("FullGCApproach {0}", x);
							}
						}
						, (x) =>
						{
							//if (x != GCNotificationStatus.Timeout)
							{
								Console.WriteLine("FullGCComplete {0}", x);
							}
						}
					);
			var q = new ConcurrentAsyncQueue<int>();
			q.AttachPerformanceCounters
					(
						"new"
						, "Microshaoft ConcurrentAsyncQueue Performance Counters"
						, new QueuePerformanceCountersContainer()
					);
			Random random = new Random();
			q.OnDequeue += //new ConcurrentAsyncQueue<int>.QueueEventHandler
							(
								(x) =>
								{
									int sleep = random.Next(0, 9) * 50;
									//Console.WriteLine(sleep);
									Thread.Sleep(sleep);
									if (sleep > 400)
									{
										Console.WriteLine(x);
									}
								}
							);
			q.OnCaughtException += //new ConcurrentAsyncQueue<int>.ExceptionEventHandler
									(
										(x, y) =>
										{
											Console.WriteLine(y.ToString());
											return false;
										}
									);
			Console.WriteLine("begin ...");
			//q.StartAdd(10);
			string r = string.Empty;
			while ((r = Console.ReadLine()) != "q")
			{
				int i;
				if (int.TryParse(r, out i))
				{
					Console.WriteLine("Parallel Enqueue {0} begin ...", i);
					new Thread
							(
								new ParameterizedThreadStart
											(
												(x) =>
												{
													Parallel.For
																(
																	0
																	, i
																	, (xx) =>
																	{
																		q.Enqueue(xx);
																	}
																);
													Console.WriteLine("Parallel Enqueue {0} end ...", i);
												}
											)
							).Start();
				}
				else if (r.ToLower() == "stop")
				{
					q.StartDecreaseDequeueProcessThreads(10);
				}
				else if (r.ToLower() == "add")
				{
					q.StartIncreaseDequeueProcessThreads(20);
				}
				else
				{
					Console.WriteLine("please input Number!");
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Concurrent;
	using System.Diagnostics;
	using System.Threading;
	public class ConcurrentAsyncQueue<T>
	{
		public delegate void QueueEventHandler(T item);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public QueueLogEventHandler
								OnQueueLog
								, OnDequeueThreadStart
								, OnDequeueThreadEnd;
		public delegate bool ExceptionEventHandler(ConcurrentAsyncQueue<T> sender, Exception exception);
		public event ExceptionEventHandler OnCaughtException;
		private ConcurrentQueue<Tuple<Stopwatch, T>> _queue =
									new ConcurrentQueue<Tuple<Stopwatch, T>>();
		private ConcurrentQueue<Action> _callbackProcessBreaksActions;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private ConcurrentQueue<ThreadProcessor> _dequeueThreadsProcessorsPool;
		private int _dequeueIdleSleepSeconds = 10;
		public QueuePerformanceCountersContainer PerformanceCounters
		{
			get;
			private set;
		}
		public int DequeueIdleSleepSeconds
		{
			set
			{
				_dequeueIdleSleepSeconds = value;
			}
			get
			{
				return _dequeueIdleSleepSeconds;
			}
		}
		private bool _isAttachedPerformanceCounters = false;
		private class ThreadProcessor
		{
			public bool Break
			{
				set;
				get;
			}
			public EventWaitHandle Wait
			{
				private set;
				get;
			}
			public ConcurrentAsyncQueue<T> Sender
			{
				private set;
				get;
			}
			public void StopOne()
			{
				Break = true;
			}
			public ThreadProcessor
							(
								ConcurrentAsyncQueue<T> queue
								, EventWaitHandle wait
							)
			{
				Wait = wait;
				Sender = queue;
			}
			public void ThreadProcess()
			{
				long l = 0;
				Interlocked.Increment(ref Sender._concurrentDequeueThreadsCount);
				bool counterEnabled = Sender._isAttachedPerformanceCounters;
				QueuePerformanceCountersContainer qpcc = Sender.PerformanceCounters;
				var queue = Sender._queue;
				var reThrowException = false;
				PerformanceCountersHelper
					.TryCountPerformance
						(
							counterEnabled
							, reThrowException
							, //IncrementCountersBeforeCountPerformance:
								new PerformanceCounter[]
									{
										qpcc
											.DequeueThreadStartPerformanceCounter
										, qpcc
											.DequeueThreadsCountPerformanceCounter
									}
							, //DecrementCountersBeforeCountPerformance:
								null
							,	null
							, () =>
							{
								#region Try Process
								if (Sender.OnDequeueThreadStart != null)
								{
									l = Interlocked.Read(ref Sender._concurrentDequeueThreadsCount);
									Sender
										.OnDequeueThreadStart
											(
												string
													.Format
														(
															"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
															, "Threads ++ !"
															, l
															, queue.Count
															, Thread.CurrentThread.Name
															, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
														)
											);
								}
								while (true)
								{
									#region while true loop
									if (Break)
									{
										break;
									}
									while (!queue.IsEmpty)
									{
										#region while queue.IsEmpty loop
										if (Break)
										{
											break;
										}
										Tuple<Stopwatch, T> item = null;
										if (queue.TryDequeue(out item))
										{
											PerformanceCountersHelper
												.TryCountPerformance
													(
														counterEnabled
														, reThrowException
														, new PerformanceCounter[]
																{
																	qpcc
																		.DequeuePerformanceCounter
																}
														, new PerformanceCounter[]
																{
																	qpcc
																		.QueueLengthPerformanceCounter
																}
														, new Tuple
																<
																	bool
																	, Stopwatch
																	, PerformanceCounter
																	, PerformanceCounter
																>[]
																{
																	Tuple.Create
																			<
																				bool					//before 时是否需要启动		
																				, Stopwatch
																				, PerformanceCounter
																				, PerformanceCounter	//base
																			>
																		(
																			false
																			, item.Item1
																			, qpcc
																				.QueuedWaitAverageTimerPerformanceCounter
																			, qpcc
																				.QueuedWaitAverageBasePerformanceCounter
																		)
																	, Tuple.Create
																			<
																				bool
																				, Stopwatch
																				, PerformanceCounter
																				, PerformanceCounter
																			>
																		(
																			true
																			, new Stopwatch()
																			, qpcc
																				.DequeueProcessedAverageTimerPerformanceCounter
																			, qpcc
																				.DequeueProcessedAverageBasePerformanceCounter
																		)
																}
														, () =>			//try
														{
															if (Sender.OnDequeue != null)
															{
																var element = item.Item2;
																item = null;
																Sender.OnDequeue(element);
															}
														}
														, (x) =>		//catch
														{
															reThrowException = false;
															return reThrowException;
														}
														, null			//finally
														, null
														, new PerformanceCounter[]
																{
																	qpcc
																		.DequeueProcessedPerformanceCounter
																	, qpcc
																		.DequeueProcessedRateOfCountsPerSecondPerformanceCounter
																}
													);
										}
										#endregion while queue.IsEmpty loop
									}
									#region wait
									Sender._dequeueThreadsProcessorsPool.Enqueue(this);
									if (Break)
									{
									}
									if (!Wait.WaitOne(Sender.DequeueIdleSleepSeconds * 1000))
									{
									}
									#endregion wait
									#endregion while true loop
								}
								#endregion
							}
							, (x) =>			//catch
							{
								#region Catch Process
								if (Sender.OnCaughtException != null)
								{
									reThrowException = Sender.OnCaughtException(Sender, x);
								}
								return reThrowException;
								#endregion
							}
							, (x, y) =>		//finally
							{
								#region Finally Process
								l = Interlocked.Decrement(ref Sender._concurrentDequeueThreadsCount);
								if (l < 0)
								{
									Interlocked.Exchange(ref Sender._concurrentDequeueThreadsCount, 0);
								}
								if (Sender.OnDequeueThreadEnd != null)
								{
									Sender
										.OnDequeueThreadEnd
											(
												string.Format
														(
															"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
															, "Threads--"
															, l
															, Sender._queue.Count
															, Thread.CurrentThread.Name
															, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
														)
											);
								}
								if (!Break)
								{
									Sender.StartIncreaseDequeueProcessThreads(1);
								}
								Break = false;
								#endregion
							}
							, //DecrementCountersAfterCountPerformance:
								new PerformanceCounter[]
									{
										qpcc.DequeueThreadsCountPerformanceCounter
									}
							, //IncrementCountersAfterCountPerformance:
								new PerformanceCounter[]
									{
										qpcc.DequeueThreadEndPerformanceCounter	
									}
						);
			}
		}
		public void AttachPerformanceCounters
							(
								string instanceNamePrefix
								, string categoryName
								, QueuePerformanceCountersContainer performanceCounters
							)
		{
			var process = Process.GetCurrentProcess();
			var processName = process.ProcessName;
			var instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
									);
			PerformanceCounters = performanceCounters;
			PerformanceCounters
				.AttachPerformanceCountersToProperties(instanceName, categoryName);
			_isAttachedPerformanceCounters = true;
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void DecreaseDequeueProcessThreads(int count)
		{
			Action action;
			for (var i = 0; i < count; i++)
			{
				if (_callbackProcessBreaksActions.TryDequeue(out action))
				{
					action();
					action = null;
				}
			}
		}
		public void StartDecreaseDequeueProcessThreads(int count)
		{
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										DecreaseDequeueProcessThreads(count);
									}
								)
					).Start();
		}
		public void StartIncreaseDequeueProcessThreads(int count)
		{
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										IncreaseDequeueProcessThreads(count);
									}
								)
					).Start();
		}
		private void IncreaseDequeueProcessThreads(int count)
		{
			for (int i = 0; i < count; i++)
			{
				Interlocked.Increment(ref _concurrentDequeueThreadsCount);
				if (_dequeueThreadsProcessorsPool == null)
				{
					_dequeueThreadsProcessorsPool = new ConcurrentQueue<ThreadProcessor>();
				}
				var processor = new ThreadProcessor
												(
													this
													, new AutoResetEvent(false)
												);
				var thread = new Thread
									(
										new ThreadStart
													(
														processor.ThreadProcess
													)
									);
				if (_callbackProcessBreaksActions == null)
				{
					_callbackProcessBreaksActions = new ConcurrentQueue<Action>();
				}
				var callbackProcessBreakAction = new Action
														(
															processor.StopOne
														);
				_callbackProcessBreaksActions.Enqueue(callbackProcessBreakAction);
				_dequeueThreadsProcessorsPool.Enqueue(processor);
				thread.Start();
			}
		}
		public bool Enqueue(T item)
		{
			var r = false;
			var reThrowException = false;
			var enableCount = _isAttachedPerformanceCounters;
			PerformanceCountersHelper
				.TryCountPerformance
					(
						enableCount
						, reThrowException
						, new PerformanceCounter[]
							{
								PerformanceCounters
									.EnqueuePerformanceCounter
								, PerformanceCounters
									.EnqueueRateOfCountsPerSecondPerformanceCounter
								, PerformanceCounters
									.QueueLengthPerformanceCounter
							}
						, null
						, null
						, () =>
						{
							Stopwatch stopwatch = null;
							if (_isAttachedPerformanceCounters)
							{
								stopwatch = Stopwatch.StartNew();
							}
							var element = Tuple.Create<Stopwatch, T>(stopwatch, item);
							_queue.Enqueue(element);
							r = true;
						}
						, (x) =>
						{
							if (OnCaughtException != null)
							{
								reThrowException = OnCaughtException(this, x);
							}
							return reThrowException;
						}
						, (x, y) =>
						{
							if
								(
									_dequeueThreadsProcessorsPool != null
									&& !_dequeueThreadsProcessorsPool.IsEmpty
								)
							{
								ThreadProcessor processor;
								if (_dequeueThreadsProcessorsPool.TryDequeue(out processor))
								{
									processor.Wait.Set();
									processor = null;
									//Console.WriteLine("processor = null;");
								}
							}
						}
					);
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public class QueuePerformanceCountersContainer
	{
		#region PerformanceCounters
		private PerformanceCounter _enqueuePerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "01.入队列累计总数(笔)"
				)
		]
		public PerformanceCounter EnqueuePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _enqueuePerformanceCounter, value, 2);
			}
			get
			{
				return _enqueuePerformanceCounter;
			}
		}
		private PerformanceCounter _enqueueRateOfCountsPerSecondPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.RateOfCountsPerSecond64
					, CounterName = "02.每秒入队列笔数(笔/秒)"
				)
		]
		public PerformanceCounter EnqueueRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _enqueueRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _enqueueRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _queueLengthPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "03.队列当前长度(笔)"
				)
		]
		public PerformanceCounter QueueLengthPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _queueLengthPerformanceCounter, value, 2);
			}
			get
			{
				return _queueLengthPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeuePerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "04.出队列累计总数(笔)"
				)
		]
		public PerformanceCounter DequeuePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _dequeuePerformanceCounter, value, 2);
			}
			get
			{
				return _dequeuePerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedRateOfCountsPerSecondPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.RateOfCountsPerSecond64
					, CounterName = "05.每秒出队列并完成处理笔数(笔/秒)"
				)
		]
		public PerformanceCounter DequeueProcessedRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _dequeueProcessedRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "06.已出队列并完成处理累计总笔数(笔)"
				)
		]
		public PerformanceCounter DequeueProcessedPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _dequeueProcessedPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedAverageTimerPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.AverageTimer32
					, CounterName = "07.每笔已出队列并完成处理平均耗时秒数(秒/笔)"
				)
		]
		public PerformanceCounter DequeueProcessedAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _dequeueProcessedAverageTimerPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueProcessedAverageBasePerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.AverageBase
				)
		]
		public PerformanceCounter DequeueProcessedAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _dequeueProcessedAverageBasePerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueProcessedAverageBasePerformanceCounter;
			}
		}
		private PerformanceCounter _queuedWaitAverageTimerPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.AverageTimer32
					, CounterName = "08.每笔入出队列并完成处理平均耗时秒数(秒/笔)"
				)
		]
		public PerformanceCounter QueuedWaitAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _queuedWaitAverageTimerPerformanceCounter, value, 2);
			}
			get
			{
				return _queuedWaitAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _queuedWaitAverageBasePerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.AverageBase
				)
		]
		public PerformanceCounter QueuedWaitAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _queuedWaitAverageBasePerformanceCounter, value, 2);
			}
			get
			{
				return _queuedWaitAverageBasePerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "09.新建出队列处理线程启动次数(次)"
				)
		]
		public PerformanceCounter DequeueThreadStartPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _dequeueThreadStartPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadStartPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "10.当前出队列并发处理线程数(个)"
				)
		]
		public PerformanceCounter DequeueThreadsCountPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _dequeueThreadsCountPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadsCountPerformanceCounter;
			}
		}
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "11.出队列处理线程退出次数(次)"
				)
		]
		public PerformanceCounter DequeueThreadEndPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(ref _dequeueThreadEndPerformanceCounter, value, 2);
			}
			get
			{
				return _dequeueThreadEndPerformanceCounter;
			}
		}
		#endregion
		// indexer declaration
		public PerformanceCounter this[string name]
		{
			get
			{
				throw new NotImplementedException();
				//return null;
			}
		}
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCountersToProperties
							(
								string instanceName
								, string categoryName
							)
		{
			if (!_isAttachedPerformanceCounters)
			{
				var type = this.GetType();
				PerformanceCountersHelper
					.AttachPerformanceCountersToProperties<QueuePerformanceCountersContainer>
						(instanceName, categoryName, this);
			}
			_isAttachedPerformanceCounters = true;
		}
	}
}
//=======================================================================================================

#T=ConcurrentAsyncQueue 2013-11-16 (2)
//=======================================================================================================
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
	public class PerformanceCounterDefinitionAttribute : Attribute
	{
		public PerformanceCounterType CounterType;
		public string CounterName;
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Linq;
	public static class PerformanceCountersHelper
	{
		public static void TryCountPerformance
							(
								bool enableCount
								, bool reThrowException = false
								, PerformanceCounter[] IncrementCountersBeforeCountPerformance = null
								, PerformanceCounter[] DecrementCountersBeforeCountPerformance = null
								, Tuple
										<
											bool						//before时是否已经启动
											, Stopwatch
											, PerformanceCounter
											, PerformanceCounter		//base计数器
										>[] timerCounters = null
								, Action onTryCountPerformanceProcessAction = null
								, Func<Exception, bool> onCaughtExceptionCountPerformanceProcessFunc = null
								, Action<bool, Exception> onFinallyCountPerformanceProcessAction = null
								, PerformanceCounter[] DecrementCountersAfterCountPerformance = null
								, PerformanceCounter[] IncrementCountersAfterCountPerformance = null
							)
		{
			if (onTryCountPerformanceProcessAction != null)
			{
				if (enableCount)
				{
					#region before
					if (IncrementCountersBeforeCountPerformance != null)
					{
						Array.ForEach
								(
									IncrementCountersBeforeCountPerformance
									, (x) =>
									{
										var l = x.Increment();
									}
								);
					}
					if (DecrementCountersBeforeCountPerformance != null)
					{
						Array.ForEach
								(
									DecrementCountersBeforeCountPerformance
									, (x) =>
									{
										var l = x.Decrement();
										if (l < 0)
										{
											x.RawValue = 0;
										}
									}
								);
					}
					if (timerCounters != null)
					{
						Array.ForEach
						(
							timerCounters
							, (x) =>
							{
								if
									(
										x.Item1
										&& x.Item2 != null
									)
								{
									x.Item2.Start();
								}
							}
						);
					}
					#endregion
				}
				var needTry = true;
				TryCatchFinallyProcessHelper
					.TryProcessCatchFinally
						(
							needTry
							, () =>
							{
								onTryCountPerformanceProcessAction();
							}
							, reThrowException
							, (x) =>
							{
								if (onCaughtExceptionCountPerformanceProcessFunc != null)
								{
									reThrowException = onCaughtExceptionCountPerformanceProcessFunc(x);
								}
								return reThrowException;
							}
							, (x, y) =>
							{
								if (enableCount)
								{
									#region after
									if (timerCounters != null)
									{
										Array.ForEach
										(
											timerCounters
											, (xx) =>
											{
												if (xx.Item2 != null)
												{
													Stopwatch stopwatch = xx.Item2;
													stopwatch.Stop();
													long elapsedTicks = stopwatch.ElapsedTicks;
													var counter = xx.Item3;
													counter.IncrementBy(elapsedTicks);
													stopwatch = null;
													counter = xx.Item4;  //base
													counter.Increment();
												}
											}
										);
									}
									if (IncrementCountersAfterCountPerformance != null)
									{
										Array.ForEach
												(
													IncrementCountersAfterCountPerformance
													, (xx) =>
													{
														var l = xx.Increment();
													}
												);
									}
									if (DecrementCountersAfterCountPerformance != null)
									{
										Array.ForEach
												(
													DecrementCountersAfterCountPerformance
													, (xx) =>
													{
														var l = xx.Decrement();
														if (l < 0)
														{
															xx.RawValue = 0;
														}
													}
												);
									}
									#endregion
								}
								if (onFinallyCountPerformanceProcessAction != null)
								{
									onFinallyCountPerformanceProcessAction(x, y);
								}
							}
						);
			}
		}
		public static void AttachPerformanceCountersToProperties<T>
									(
										string performanceCounterInstanceName
										, string category
										, T target //= default(T)
									)
		{
			var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList
								.Where
									(
										(pi) =>
										{
											var parameters = pi.GetIndexParameters();
											return
												(
													pi.PropertyType == typeof(PerformanceCounter)
													&& (parameters == null ? 0 : parameters.Length) <= 0
												);
										}
									).ToList();
			if (PerformanceCounterCategory.Exists(category))
			{
				propertiesList
					.ForEach
						(
							(pi) =>
							{
								if (PerformanceCounterCategory.CounterExists(pi.Name, category))
								{
									if (PerformanceCounterCategory.InstanceExists(performanceCounterInstanceName, category))
									{
										//var pc = new PerformanceCounter(category, pi.Name, instanceName, false);
										//pc.InstanceName = instanceName;
										//pc.RemoveInstance();
									}
								}
							}
						);
				//PerformanceCounterCategory.Delete(category);
			}
			if (!PerformanceCounterCategory.Exists(category))
			{
				var ccdc = new CounterCreationDataCollection();
				propertiesList
					.ForEach
						(
							(pi) =>
							{
								var propertyName = pi.Name;
								var performanceCounterType = PerformanceCounterType.NumberOfItems64;
								var performanceCounterName = propertyName;
								var attribute
										= pi
											.GetCustomAttributes(false)
												.FirstOrDefault
													(
														(x) =>
														{
															return
																x as PerformanceCounterDefinitionAttribute
																!= null;
														}
													) as PerformanceCounterDefinitionAttribute;
								if (attribute != null)
								{
									var counterName = attribute.CounterName;
									if (!string.IsNullOrEmpty(counterName))
									{
										performanceCounterName = counterName;
									}
									var counterType = attribute.CounterType;
									//if (counterType != null)
									{
										performanceCounterType = counterType;
									}
								}
								var ccd = PerformanceCountersHelper
											.GetCounterCreationData
												(
													performanceCounterName
													, performanceCounterType
												);
								ccdc.Add(ccd);
							}
						);
				PerformanceCounterCategory
					.Create
						(
							category
							, string.Format("{0} Category Help.", category)
							, PerformanceCounterCategoryType.MultiInstance
							, ccdc
						);
			}
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var performanceCounterType = PerformanceCounterType.NumberOfItems64;
									var performanceCounterName = propertyName;
									var attribute
											= pi
												.GetCustomAttributes(false)
													.FirstOrDefault
														(
															(x) =>
															{
																return
																	x as PerformanceCounterDefinitionAttribute
																	!= null;
															}
														) as PerformanceCounterDefinitionAttribute;
									if (attribute != null)
									{
										var counterName = attribute.CounterName;
										if (!string.IsNullOrEmpty(counterName))
										{
											performanceCounterName = counterName;
										}
										var counterType = attribute.CounterType;
										//if (counterType != null)
										{
											performanceCounterType = counterType;
										}
									}
									var pc = new PerformanceCounter()
									{
										CategoryName = category
										, CounterName = performanceCounterName
										, InstanceLifetime = PerformanceCounterInstanceLifetime.Process
										, InstanceName = performanceCounterInstanceName
										, ReadOnly = false
										, RawValue = 0
									};
									if (pi.GetGetMethod().IsStatic)
									{
										var setter = DynamicPropertyAccessor
														.CreateSetStaticPropertyValueAction<PerformanceCounter>
															(
																type
																, propertyName
															);
										setter(pc);
									}
									else
									{
										if (target != null)
										{
											var setter = DynamicPropertyAccessor
															.CreateSetPropertyValueAction<PerformanceCounter>
																(
																	type
																	, propertyName
																);
											setter(target, pc);
										}
									}
								}
							);
		}
		public static CounterCreationData GetCounterCreationData
					(
						string counterName
						, PerformanceCounterType performanceCounterType
					)
		{
			return
				new CounterCreationData()
				{
					CounterName = counterName
					, CounterHelp = string.Format("{0} Help", counterName)
					, CounterType = performanceCounterType
				};
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class ReaderWriterLockSlimHelper
	{
		public static bool TryEnterWriterLockSlimWrite<T>
								(
									ref T target
									, T newTarget
									, int enterTimeOutSeconds
								)
									where T : class
		{
			bool r = false;
			var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutSeconds >= 0)
			{
				timeOut = enterTimeOutSeconds * 1000;
			}
			try
			{
				r = (rwls.TryEnterWriteLock(timeOut));
				if (r)
				{
					Interlocked.Exchange<T>(ref target, newTarget);
					r = true;
				}
			}
			finally
			{
				if (r)
				{
					rwls.ExitWriteLock();
				}
			}
			return r;
		}
		public static bool TryEnterWriterLockSlim
								(
									Action action
									, int enterTimeOutSeconds
								)
		{
			bool r = false;
			if (action != null)
			{
				var rwls = new ReaderWriterLockSlim();
				int timeOut = Timeout.Infinite;
				if (enterTimeOutSeconds >= 0)
				{
					timeOut = enterTimeOutSeconds * 1000;
				}
				try
				{
					r = (rwls.TryEnterWriteLock(timeOut));
					if (r)
					{
						action();
						r = true;
					}
				}
				finally
				{
					if (r)
					{
						rwls.ExitWriteLock();
					}
				}
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public class DynamicPropertyAccessor
	{
		private static Assembly GetAssemblyByTypeName(string typeName)
		{
			return
				AppDomain
					.CurrentDomain
						.GetAssemblies()
							.First
								(
									(a) =>
									{
										return
											a
												.GetTypes()
													.Any
														(
															(t) =>
															{
																return
																	(
																		t.FullName
																		== typeName
																	);
															}
														);
									}
								);
		}
		public static Func<object, object> CreateGetPropertyValueFunc
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc
						(
							Type type
							, string propertyName
						)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Func<TProperty> func = null;
			var property = type.GetProperty(propertyName, typeof(TProperty));
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var getPropertyValue = Expression.Property(null, property);
				var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
				func = lambda.Compile();
			}
			return func;
		}
		public static Func<object> CreateGetStaticPropertyValueFunc
						(
							Type type
							, string propertyName
						)
		{
			Func<object> func = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var getPropertyValue = Expression.Property(null, property);
				var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
				var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
				func = lambda.Compile();
			}
			return func;
		}
		public static Func<object> CreateGetStaticPropertyValueFunc
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction
						(
							Type type
							, string propertyName
						)
		{
			Action<object, object> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var target = Expression.Parameter(typeof(object));
				var propertyValue = Expression.Parameter(typeof(object));
				var castTarget = Expression.Convert(target, type);
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object, object> CreateSetPropertyValueAction
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Action<object, TProperty> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var target = Expression.Parameter(typeof(object));
				var propertyValue = Expression.Parameter(typeof(TProperty));
				var castTarget = Expression.Convert(target, type);
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction
						(
							Type type
							, string propertyName
						)
		{
			Action<object> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var propertyValue = Expression.Parameter(typeof(object));
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(null, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object> CreateSetStaticPropertyValueAction
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Action<TProperty> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var propertyValue = Expression.Parameter(typeof(TProperty));
				//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(null, getSetMethod, propertyValue);
				var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class GCNotifier
	{
		public static void CancelForFullGCNotification()
		{
			GC.CancelFullGCNotification();
		}
		public static void RegisterForFullGCNotification
							(
								int maxGenerationThreshold
								, int maxLargeObjectHeapThreshold
								, int waitOnceSecondsTimeout
								, Action<GCNotificationStatus> waitForFullGCApproachProcessAction
								, Action<GCNotificationStatus> waitForFullGCCompleteProcessAction
							)
		{
			GC.RegisterForFullGCNotification(maxGenerationThreshold, maxLargeObjectHeapThreshold);
			new Thread
				(
					new ThreadStart
						(
							() =>
							{
								while (true)
								{
									if (waitForFullGCApproachProcessAction != null)
									{
										var gcNotificationStatus
												= GC.WaitForFullGCApproach(1000 * waitOnceSecondsTimeout);
										if (gcNotificationStatus != GCNotificationStatus.Timeout)
										{
											waitForFullGCApproachProcessAction(gcNotificationStatus);
										}
									}
									if (waitForFullGCApproachProcessAction != null)
									{
										var gcNotificationStatus
												= GC.WaitForFullGCComplete(1000 * waitOnceSecondsTimeout);
										if (gcNotificationStatus != GCNotificationStatus.Timeout)
										{
											waitForFullGCCompleteProcessAction(gcNotificationStatus);
										}
									}
									Thread.Sleep(1000);
								}
							}
						)
					).Start();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Reflection;
	using System.Threading.Tasks;
	public static class TryCatchFinallyProcessHelper
	{
		public static async Task<T> TryProcessCatchFinallyAsync<T>
									(
										bool needTry
										, Func<Task<T>> onTryProcessFunc
										, bool reThrowException = false
										, Func<Exception, bool> onCaughtExceptionProcessFunc = null
										, Action<bool, Exception> onFinallyProcessAction = null
									)
		{
			T r = default(T);
			//if (onTryProcessAction != null)
			{
				if (needTry)
				{
					Exception exception = null;
					var caughtException = false;
					try
					{
						r = await onTryProcessFunc();
						return r;
					}
					catch (Exception e)
					{
						caughtException = true;
						exception = e;
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrowException = onCaughtExceptionProcessFunc(e);
						}
						if (reThrowException)
						{
							var currentCalleeMethod = MethodInfo.GetCurrentMethod();
							var currentCalleeType = currentCalleeMethod.DeclaringType;
							StackTrace stackTrace = new StackTrace();
							var callerMethod = stackTrace.GetFrame(1).GetMethod();
							var callerType = callerMethod.DeclaringType;
							var innerExceptionMessage = string.Format
									(
										"[{1}]{0}Caught Exception in Caller's [{2}]{0}Rethrow Exception on [{3}]"
										, "\r\n\t"
										, string.Format("{1}{0}{2}", "::", currentCalleeType, currentCalleeMethod)
										, string.Format("{1}{0}{2}", "::", callerType, callerMethod)
										, "Catch Exception"
									);
							throw
								new Exception
										(
											innerExceptionMessage
											, e
										);
						}
						return r;
					}
					finally
					{
						if (onFinallyProcessAction != null)
						{
							onFinallyProcessAction(caughtException, exception);
						}
					}
				}
				else
				{
					return await onTryProcessFunc();
				}
			}
		}
		public static void TryProcessCatchFinally
									(
										bool needTry
										, Action onTryProcessAction
										, bool reThrowException = false
										, Func<Exception, bool> onCaughtExceptionProcessFunc = null
										, Action<bool, Exception> onFinallyProcessAction = null
									)
		{
			if (onTryProcessAction != null)
			{
				if (needTry)
				{
					Exception exception = null;
					var caughtException = false;
					try
					{
						onTryProcessAction();
					}
					catch (Exception e)
					{
						caughtException = true;
						exception = e;
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrowException = onCaughtExceptionProcessFunc(e);
						}
						if (reThrowException)
						{
							var currentCalleeMethod = MethodInfo.GetCurrentMethod();
							var currentCalleeType = currentCalleeMethod.DeclaringType;
							StackTrace stackTrace = new StackTrace();
							var callerMethod = stackTrace.GetFrame(1).GetMethod();
							var callerType = callerMethod.DeclaringType;
							var innerExceptionMessage = string.Format
									(
										"[{1}]{0}Caught Exception in Caller's [{2}]{0}Rethrow Exception on [{3}]"
										, "\r\n\t"
										, string.Format("{1}{0}{2}", "::", currentCalleeType, currentCalleeMethod)
										, string.Format("{1}{0}{2}", "::", callerType, callerMethod)
										, "Catch Exception"
									);
							throw
								new Exception
										(
											innerExceptionMessage
											, e
										);
						}
					}
					finally
					{
						if (onFinallyProcessAction != null)
						{
							onFinallyProcessAction(caughtException, exception);
						}
					}
				}
				else
				{
					onTryProcessAction();
				}
			}
		}
	}
}

#T=ConcurrentAsyncQueue PerfCounter 终极性能测试版
/*
Remoting 异步队列实现,流程如下
1.并发若干客户端程序通过调用 Remoting CocurrentQueue Server 提供的公开远程方法 Enqueue 将数据元素入队尾
2.Remoting CocurrentQueue Server 发现队列不为空,则并发若干线程陆续 Dequeue 队首数据元素并处理
注意:
1.队列的数据元素定义需自行实现
2.对出列数据元素的处理程序需自行实现
不受 Remoting 生命周期租约过期的约束
*/
//AsyncQueue.cs
^#define c4 //C# 4.0+
//#define c2

namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Diagnostics;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	using Microshaoft;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		//public event QueueLogEventHandler OnQueueLog;
		public event QueueLogEventHandler OnQueueRunningThreadStart;
		public event QueueLogEventHandler OnQueueRunningThreadEnd;
		public event QueueLogEventHandler OnDequeueThreadStart;
		public event QueueLogEventHandler OnDequeueThreadEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
^#if c2
		private Queue<T> _queue = new Queue<T>();
^#elif c4
		private ConcurrentQueue<T> _queue = new ConcurrentQueue<T>();
^#endif
		private object _syncQueueLockObject = new object();
		//private object _syncQueueRunningLockObject = new object();
		private long _isQueueRunning = 0;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private PerformanceCounter _enqueuePerformanceCounter;
		private PerformanceCounter _dequeuePerformanceCounter;
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		private PerformanceCounter _queueLengthPerformanceCounter;
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		private PerformanceCounter _queueRunningThreadStartPerformanceCounter;
		private PerformanceCounter _queueRunningThreadEndPerformanceCounter;
		private PerformanceCounter _queueRunningThreadsCountPerformanceCounter;
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCounters(string instanceNamePrefix)
		{
			string category = "Microshaoft AsyncConurrentQueue Counters";
			string counter = string.Empty;
			Process process = Process.GetCurrentProcess();
			//int processID = 0;//process.Id;
			string processName = process.ProcessName;
			//string processStartTime = "";//process.StartTime;
			string instanceName = string.Empty;
			instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
										//, processID
										//, processStartTime.ToString("yyyy-MM-dd HH:mm:ss.fff")
									);
			CounterCreationDataCollection ccdc = new CounterCreationDataCollection();
			if (PerformanceCounterCategory.Exists(category))
			{
				PerformanceCounterCategory.Delete(category);
			}
			CounterCreationData ccd = null;
			counter = "EnqueueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueLengthCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueProcessedCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			PerformanceCounterCategory.Create
											(
												category,
												string.Format("{0} Category Help.", category),
												PerformanceCounterCategoryType.MultiInstance,
												ccdc
											);
			counter = "EnqueueCounter";
			_enqueuePerformanceCounter = new PerformanceCounter();
			_enqueuePerformanceCounter.CategoryName = category;
			_enqueuePerformanceCounter.CounterName = counter;
			_enqueuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_enqueuePerformanceCounter.InstanceName = instanceName;
			_enqueuePerformanceCounter.ReadOnly = false;
			_enqueuePerformanceCounter.RawValue = 0;
			counter = "DequeueCounter";
			_dequeuePerformanceCounter = new PerformanceCounter();
			_dequeuePerformanceCounter.CategoryName = category;
			_dequeuePerformanceCounter.CounterName = counter;
			_dequeuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeuePerformanceCounter.InstanceName = instanceName;
			_dequeuePerformanceCounter.ReadOnly = false;
			_dequeuePerformanceCounter.RawValue = 0;
			counter = "DequeueProcessedCounter";
			_dequeueProcessedPerformanceCounter = new PerformanceCounter();
			_dequeueProcessedPerformanceCounter.CategoryName = category;
			_dequeueProcessedPerformanceCounter.CounterName = counter;
			_dequeueProcessedPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueProcessedPerformanceCounter.InstanceName = instanceName;
			_dequeueProcessedPerformanceCounter.ReadOnly = false;
			_dequeueProcessedPerformanceCounter.RawValue = 0;
			counter = "QueueLengthCounter";
			_queueLengthPerformanceCounter = new PerformanceCounter();
			_queueLengthPerformanceCounter.CategoryName = category;
			_queueLengthPerformanceCounter.CounterName = counter;
			_queueLengthPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueLengthPerformanceCounter.InstanceName = instanceName;
			_queueLengthPerformanceCounter.ReadOnly = false;
			_queueLengthPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadStartCounter";
			_dequeueThreadStartPerformanceCounter = new PerformanceCounter();
			_dequeueThreadStartPerformanceCounter.CategoryName = category;
			_dequeueThreadStartPerformanceCounter.CounterName = counter;
			_dequeueThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadStartPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadStartPerformanceCounter.ReadOnly = false;
			_dequeueThreadStartPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadEndCounter";
			_dequeueThreadEndPerformanceCounter = new PerformanceCounter();
			_dequeueThreadEndPerformanceCounter.CategoryName = category;
			_dequeueThreadEndPerformanceCounter.CounterName = counter;
			_dequeueThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadEndPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadEndPerformanceCounter.ReadOnly = false;
			_dequeueThreadEndPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadsCountCounter";
			_dequeueThreadsCountPerformanceCounter = new PerformanceCounter();
			_dequeueThreadsCountPerformanceCounter.CategoryName = category;
			_dequeueThreadsCountPerformanceCounter.CounterName = counter;
			_dequeueThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadsCountPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadsCountPerformanceCounter.ReadOnly = false;
			_dequeueThreadsCountPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadStartCounter";
			_queueRunningThreadStartPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadStartPerformanceCounter.CategoryName = category;
			_queueRunningThreadStartPerformanceCounter.CounterName = counter;
			_queueRunningThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadStartPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadStartPerformanceCounter.ReadOnly = false;
			_queueRunningThreadStartPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadEndCounter";
			_queueRunningThreadEndPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadEndPerformanceCounter.CategoryName = category;
			_queueRunningThreadEndPerformanceCounter.CounterName = counter;
			_queueRunningThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadEndPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadEndPerformanceCounter.ReadOnly = false;
			_queueRunningThreadEndPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadsCountCounter";
			_queueRunningThreadsCountPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadsCountPerformanceCounter.CategoryName = category;
			_queueRunningThreadsCountPerformanceCounter.CounterName = counter;
			_queueRunningThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadsCountPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadsCountPerformanceCounter.ReadOnly = false;
			_queueRunningThreadsCountPerformanceCounter.RawValue = 0;
			_isAttachedPerformanceCounters = true;
		}
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (Interlocked.Read(ref _concurrentDequeueThreadsCount) < _maxConcurrentThreadsCount)
			{
				if (Interlocked.CompareExchange(ref _isQueueRunning, 0, 1) == 0)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunningThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadStartPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Increment();
			}
			if (OnQueueRunningThreadStart != null)
			{
				OnQueueRunningThreadStart
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}({4})"
									, "Queue Running Start ..."
									, _concurrentDequeueThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
									, Thread.CurrentThread.ManagedThreadId
								)
					);
			}
^#if c2
			while ((_queue.Count > 0)) //Microshaoft 死循环
^#elif c4
			while (!_queue.IsEmpty) //Microshaoft 死循环
^#endif
			{
				int threadID = -1;
				{
					int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
					if (r < _maxConcurrentThreadsCount)
					{
						//if (_queue.Count > 0)
						{
							r = (int) Interlocked.Increment(ref _concurrentDequeueThreadsCount);
							threadID = (int) _concurrentDequeueThreadsCount;
							//ThreadProcessState tps = new ThreadProcessState();
							//tps.element = element;
							//tps.Sender = this;
							Thread t = new Thread(new ThreadStart(DequeueThreadProcess));
							t.Name = string.Format("ConcurrentThread[{0}]", threadID);
							t.Start();
						}
///						else
///						{
///							break;
///						}
					}
					else
					{
						break;
					}
				}
			}
			//Interlocked.CompareExchange(ref _queueRuning, 0, 1);
			if (OnQueueRunningThreadEnd != null)
			{
				int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnQueueRunningThreadEnd
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}({4})"
											, "Queue Running Stop ..."
											, r
											, _queue.Count
											, Thread.CurrentThread.Name
											, Thread.CurrentThread.ManagedThreadId
										)
							);
			}
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadEndPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Decrement();
			}
			Interlocked.Exchange(ref _isQueueRunning, 0);
		}
		public void Enqueue(T element)
		{
			try
			{
^#if c2
				lock (_syncQueueLockObject) //还算并发吗?
^#endif
				{

					_queue.Enqueue(element);
				}
				if (_isAttachedPerformanceCounters)
				{
					_enqueuePerformanceCounter.Increment();
					_queueLengthPerformanceCounter.Increment();
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			//int r = Interlocked.CompareExchange(ref _queueRuning, 1, 0))
			//if (r == 1)
			//{
			QueueRun();
			//}
		}
		private void DequeueThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_dequeueThreadStartPerformanceCounter.Increment();
				_dequeueThreadsCountPerformanceCounter.Increment();
			}
			if (OnDequeueThreadStart != null)
			{
				int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnDequeueThreadStart
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
												, "Threads ++ !"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
											)
								);
			}
			try
			{
^#if c2
				while (true)
^#elif c4
				while (!_queue.IsEmpty)
^#endif
				{
					T element = null;
^#if c2
					lock (_syncQueueLockObject)
					{

						if (_queue.Count > 0)
						{
							element = _queue.Dequeue();
						}
						else
						{
							break;
						}
					}
^#elif c4
					if (_queue.TryDequeue(out element))
					{
^#elif c2
						if (element != null)
						{
^#endif
							if (_isAttachedPerformanceCounters)
							{
								_dequeuePerformanceCounter.Increment();
								_queueLengthPerformanceCounter.Decrement();
							}
							if (OnDequeue != null)
							{
								OnDequeue(element);
							}
							if (_isAttachedPerformanceCounters)
							{
								_dequeueProcessedPerformanceCounter.Increment();
							}
^#if c2
						}
^#elif c4
					}

				}
^#endif
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				int r = (int) Interlocked.Decrement(ref _concurrentDequeueThreadsCount);
				if (OnDequeueThreadEnd != null)
				{
					OnDequeueThreadEnd
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
												, "Threads--"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
											)
								);
				}
				if (r == 0)
				{
					if (OnDequeueThreadEnd != null)
					{
						OnDequeueThreadEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "All Threads End"
													, r
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
					}
				}
				if (_isAttachedPerformanceCounters)
				{
					_dequeueThreadEndPerformanceCounter.Increment();
					_dequeueThreadsCountPerformanceCounter.Decrement();
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;

	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			CounterCreationData ccd = new CounterCreationData();
			ccd.CounterName = counterName;
			ccd.CounterHelp = string.Format("{0} Help", counterName);
			ccd.CounterType = performanceCounterType;
			return ccd;
		}

	}
}
//Server.cs
namespace Microshaoft
{
	using System;
	using System.Threading;
	using Microshaoft.RemotingObjects.Share;
	public class AsyncQueueProcessor
	{
		private AsyncQueue<Item> _queue;
		public AsyncQueue<Item> Queue
		{
			get
			{
				return _queue;
			}
		}
		public AsyncQueueProcessor(AsyncQueue<Item> queue)
		{
			_queue = queue;
			_queue.OnDequeue += new AsyncQueue<Item>.QueueEventHandler(_queue_OnDequeue);
			_queue.OnDequeueThreadStart += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnDequeueThreadEnd += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnQueueRunningThreadStart += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnQueueRunningThreadEnd += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnException += new AsyncQueue<Item>.ExceptionEventHandler(_queue_OnException);
			_queue.MaxConcurrentThreadsCount = 64;
		}
		public void Enqueue(Item item)
		{
			_queue.Enqueue(item);
		}
		void _queue_OnQueueLog(string logMessage)
		{
			Console.WriteLine(logMessage);
		}
		void _queue_OnDequeue(Item item)
		{
			DateTime DequeueBeginTime = DateTime.Now;
			Thread.Sleep(2*100);
			DateTime DequeueEndTime = DateTime.Now;
			Console.WriteLine
						(
							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
							, _queue.Count
							, item.EnqueueTime
							, DequeueBeginTime
							, (DequeueBeginTime.Ticks - item.EnqueueTime.Ticks) / 10000 / 1000
							, DequeueEndTime
							, (DequeueEndTime.Ticks - DequeueBeginTime.Ticks) / 10000 / 1000
							, _queue.ConcurrentThreadsCount
						);
		}
		void _queue_OnException(Exception e)
		{
			Console.WriteLine(e.ToString());
		}
	}
}
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Configuration.Install;
	using System.Security.Principal;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.Win32;
	using Microshaoft;
	//using eHome.UserProfile;
	public class ServiceHost : ServiceBase
	{
		///// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		public static readonly string serviceName = "RemotingAsyncConcurrentQueueService";
		private static AsyncQueueProcessor _asyncQueueProcessor;
		public static AsyncQueueProcessor AsyncQueueProcessor
		{
			get
			{
				return _asyncQueueProcessor;
			}
		}
		static void Main(string[] args)
		{
			//Microshaoft
			//Microshaoft TODO: 在此处添加代码以启动应用程序
			//Microshaoft 
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
					Console.Title = "Server"; //不能以服务运行
					Console.WriteLine("Console");
					service.OnStart(null);
					Console.ReadLine();
					return;
				}
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			AsyncQueue<Item> queue = new AsyncQueue<Item>();
			queue.AttachPerformanceCounters("Q1");
			_asyncQueueProcessor = new AsyncQueueProcessor(queue);
			RemotingHelper.StartRemoting<RemotingAsyncQueue>
								(
									"queueurl"
									, 8080
								);
			Console.WriteLine("Server . , Press Enter key to exit.");
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}
namespace Microshaoft.RemotingObjects
{
	using System;
	using System.IO;
	using System.Net;
	using System.Web;
	using System.Text;
	using System.Threading;
	using System.Configuration;
	using System.Collections.Generic;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.RemotingObjects.Server;
	public class RemotingAsyncQueue : MarshalByRefObject
	{
		public void Enqueue(Item item)
		{
			//Microshaoft 队列的数据元素定义需自行实现 Item
			ServiceHost.AsyncQueueProcessor.Enqueue(item);
		}
	}
}
//=============================================================
//===============================================
// Share.cs
//Server、Client 均需引用此 share.dll
//C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc.exe /t:library share.cs
//TO DO
//队列的数据元素定义需自行实现,示例如下:
namespace Microshaoft.RemotingObjects.Share
{
	using System;
	[Serializable]
	public class Item
	{
		private string _Name;
		public string Name
		{
			get
			{
				return _Name;
			}
			set
			{
				_Name = value; 
			}
		}
			private DateTime _EnqueueTime;
			public DateTime EnqueueTime
			{
				get
				{
					return _EnqueueTime;
				}
				set
				{
					_EnqueueTime = value; 
				}
			}
	}
}
// remoting helper
//Share.cs
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Text;
	public static class RemotingHelper
	{
			public static void StartRemoting
						(
							Type RemotingType
							, string Url
							, int Port
						)
			{
				BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
				provider.TypeFilterLevel = TypeFilterLevel.Full;
				IDictionary ht = new Hashtable();
				ht["port"] = Port;
				TcpChannel tc = new TcpChannel(ht, null, provider);
				ChannelServices.RegisterChannel(tc, false);
				RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, WellKnownObjectMode.Singleton);
				Console.WriteLine("Remoting Object Started ...");
			}
			public static void StartRemoting<T>
										(
											string Url
											, int Port
										)
			{
				StartRemoting(typeof(T), Url, Port);
			}
			public static T GetRemotingLocalClientProxyObject<T>
						(
							string Url
						)
			{
				return (T) Activator.GetObject
										(
											typeof(T)
											, Url
											//, "tcp://127.0.0.1:8080/queueUrl"
										);
			}
	}
}
//============================================================================
//============================================
// Client.cs
//C:\WINDOWS\Microsoft.NET\Framework\v1.1.4322\csc.exe client.cs /r:share.dll
namespace Microshaoft.RemotingObjects.Client
{
	using System;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Threading;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static RemotingAsyncQueue _queue;
		public static void Main()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
		}
		public void Run()
		{
			_queue = RemotingHelper.GetRemotingLocalClientProxyObject<RemotingAsyncQueue>("tcp://127.0.0.1:8080/queueUrl");
			//Microshaoft 以下是耗时的主程序
			for (int i = 0; i < 20; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public void ThreadProcess()
		{
			for (int i = 0; i < 1800; i++)
			{
				Item x = new Item();
				DateTime EnqueueTime = DateTime.Now;
				x.Name = EnqueueTime.ToString();
				x.EnqueueTime = EnqueueTime;
				_queue.Enqueue(x);
				Console.WriteLine
							(
								"Enqueue: {0},[{1}]"
								, EnqueueTime
								, (DateTime.Now.Ticks - EnqueueTime.Ticks)/10000
							);
			}
		}
	}
}
//Microshaoft =========================================
//Microshaoft Remoting Object Client Local Proxy
namespace Microshaoft.RemotingObjects
{
	using System;
	using Microshaoft.RemotingObjects.Share;
	public interface RemotingAsyncQueue
	{
		void Enqueue(Item item);
	}
}

#T=ConcurrentAsyncQueue WebService Concurrent Invoker
//AsyncQueue.cs
//#define c4 //C# 4.0+
^#define c4
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Diagnostics;
	using System.Collections.Generic;
^#if c4
	using System.Collections.Concurrent;
^#endif
	using Microshaoft;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		//public event QueueLogEventHandler OnQueueLog;
		public event QueueLogEventHandler OnQueueRunningThreadStart;
		public event QueueLogEventHandler OnQueueRunningThreadEnd;
		public event QueueLogEventHandler OnDequeueThreadStart;
		public event QueueLogEventHandler OnDequeueThreadEnd;
		public event QueueLogEventHandler OnDequeueAllThreadsEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
^#if c2
		private Queue<T> _queue = new Queue<T>();
^#elif c4
		private ConcurrentQueue<T> _queue = new ConcurrentQueue<T>();
^#endif
		private object _syncQueueLockObject = new object();
		//private object _syncQueueRunningLockObject = new object();
		private long _isQueueRunning = 0;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private PerformanceCounter _enqueuePerformanceCounter;
		private PerformanceCounter _dequeuePerformanceCounter;
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		private PerformanceCounter _queueLengthPerformanceCounter;
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		private PerformanceCounter _queueRunningThreadStartPerformanceCounter;
		private PerformanceCounter _queueRunningThreadEndPerformanceCounter;
		private PerformanceCounter _queueRunningThreadsCountPerformanceCounter;
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCounters(string instanceNamePrefix)
		{
			string category = "Microshaoft AsyncConurrentQueue Counters";
			string counter = string.Empty;
			Process process = Process.GetCurrentProcess();
			//int processID = 0;//process.Id;
			string processName = process.ProcessName;
			//string processStartTime = "";//process.StartTime;
			string instanceName = string.Empty;
			instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
										//, processID
										//, processStartTime.ToString("yyyy-MM-dd HH:mm:ss.fff")
									);
			CounterCreationDataCollection ccdc = new CounterCreationDataCollection();
			if (PerformanceCounterCategory.Exists(category))
			{
				PerformanceCounterCategory.Delete(category);
			}
			CounterCreationData ccd = null;
			counter = "EnqueueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueLengthCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueProcessedCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			PerformanceCounterCategory.Create
											(
												category,
												string.Format("{0} Category Help.", category),
												PerformanceCounterCategoryType.MultiInstance,
												ccdc
											);
			counter = "EnqueueCounter";
			_enqueuePerformanceCounter = new PerformanceCounter();
			_enqueuePerformanceCounter.CategoryName = category;
			_enqueuePerformanceCounter.CounterName = counter;
			_enqueuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_enqueuePerformanceCounter.InstanceName = instanceName;
			_enqueuePerformanceCounter.ReadOnly = false;
			_enqueuePerformanceCounter.RawValue = 0;
			counter = "DequeueCounter";
			_dequeuePerformanceCounter = new PerformanceCounter();
			_dequeuePerformanceCounter.CategoryName = category;
			_dequeuePerformanceCounter.CounterName = counter;
			_dequeuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeuePerformanceCounter.InstanceName = instanceName;
			_dequeuePerformanceCounter.ReadOnly = false;
			_dequeuePerformanceCounter.RawValue = 0;
			counter = "DequeueProcessedCounter";
			_dequeueProcessedPerformanceCounter = new PerformanceCounter();
			_dequeueProcessedPerformanceCounter.CategoryName = category;
			_dequeueProcessedPerformanceCounter.CounterName = counter;
			_dequeueProcessedPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueProcessedPerformanceCounter.InstanceName = instanceName;
			_dequeueProcessedPerformanceCounter.ReadOnly = false;
			_dequeueProcessedPerformanceCounter.RawValue = 0;
			counter = "QueueLengthCounter";
			_queueLengthPerformanceCounter = new PerformanceCounter();
			_queueLengthPerformanceCounter.CategoryName = category;
			_queueLengthPerformanceCounter.CounterName = counter;
			_queueLengthPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueLengthPerformanceCounter.InstanceName = instanceName;
			_queueLengthPerformanceCounter.ReadOnly = false;
			_queueLengthPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadStartCounter";
			_dequeueThreadStartPerformanceCounter = new PerformanceCounter();
			_dequeueThreadStartPerformanceCounter.CategoryName = category;
			_dequeueThreadStartPerformanceCounter.CounterName = counter;
			_dequeueThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadStartPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadStartPerformanceCounter.ReadOnly = false;
			_dequeueThreadStartPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadEndCounter";
			_dequeueThreadEndPerformanceCounter = new PerformanceCounter();
			_dequeueThreadEndPerformanceCounter.CategoryName = category;
			_dequeueThreadEndPerformanceCounter.CounterName = counter;
			_dequeueThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadEndPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadEndPerformanceCounter.ReadOnly = false;
			_dequeueThreadEndPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadsCountCounter";
			_dequeueThreadsCountPerformanceCounter = new PerformanceCounter();
			_dequeueThreadsCountPerformanceCounter.CategoryName = category;
			_dequeueThreadsCountPerformanceCounter.CounterName = counter;
			_dequeueThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadsCountPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadsCountPerformanceCounter.ReadOnly = false;
			_dequeueThreadsCountPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadStartCounter";
			_queueRunningThreadStartPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadStartPerformanceCounter.CategoryName = category;
			_queueRunningThreadStartPerformanceCounter.CounterName = counter;
			_queueRunningThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadStartPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadStartPerformanceCounter.ReadOnly = false;
			_queueRunningThreadStartPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadEndCounter";
			_queueRunningThreadEndPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadEndPerformanceCounter.CategoryName = category;
			_queueRunningThreadEndPerformanceCounter.CounterName = counter;
			_queueRunningThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadEndPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadEndPerformanceCounter.ReadOnly = false;
			_queueRunningThreadEndPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadsCountCounter";
			_queueRunningThreadsCountPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadsCountPerformanceCounter.CategoryName = category;
			_queueRunningThreadsCountPerformanceCounter.CounterName = counter;
			_queueRunningThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadsCountPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadsCountPerformanceCounter.ReadOnly = false;
			_queueRunningThreadsCountPerformanceCounter.RawValue = 0;
			_isAttachedPerformanceCounters = true;
		}
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (Interlocked.Read(ref _concurrentDequeueThreadsCount) < _maxConcurrentThreadsCount)
			{
				if (Interlocked.CompareExchange(ref _isQueueRunning, 0, 1) == 0)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunningThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadStartPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Increment();
			}
			if (OnQueueRunningThreadStart != null)
			{
				OnQueueRunningThreadStart
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}({4}) at {5}"
									, "Queue Running Start ..."
									, _concurrentDequeueThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
									, Thread.CurrentThread.ManagedThreadId
									, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
								)
					);
			}
^#if c2
			while ((_queue.Count > 0)) //Microshaoft 死循环
^#elif c4
			while (!_queue.IsEmpty) //Microshaoft 死循环
^#endif
			{
				int threadID = -1;
				{
					int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
					if (r < _maxConcurrentThreadsCount)
					{
						//if (_queue.Count > 0)
						{
							r = (int) Interlocked.Increment(ref _concurrentDequeueThreadsCount);
							threadID = (int) _concurrentDequeueThreadsCount;
							//ThreadProcessState tps = new ThreadProcessState();
							//tps.element = element;
							//tps.Sender = this;
							Thread t = new Thread(new ThreadStart(DequeueThreadProcess));
							t.TrySetApartmentState(ApartmentState.STA);
							t.Name = string.Format("ConcurrentDequeueProcessThread[{0}]", threadID);
							t.Start();
						}
///						else
///						{
///							break;
///						}
					}
					else
					{
						break;
					}
				}
			}
			//Interlocked.CompareExchange(ref _queueRuning, 0, 1);
			if (OnQueueRunningThreadEnd != null)
			{
				int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnQueueRunningThreadEnd
							(
								string.Format
										(
											"{0} Threads Count {1}, Queue Count {2}, Current Thread: {3}({4}) at {5}"
											, "Queue Running Stop ..."
											, r
											, _queue.Count
											, Thread.CurrentThread.Name
											, Thread.CurrentThread.ManagedThreadId
											, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
										)
							);
			}
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadEndPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Decrement();
			}
			Interlocked.Exchange(ref _isQueueRunning, 0);
		}
		public void Enqueue(T element)
		{
			try
			{
^#if c2
				lock (_syncQueueLockObject) //还算并发吗?
^#endif
				{
					_queue.Enqueue(element);
				}
				if (_isAttachedPerformanceCounters)
				{
					_enqueuePerformanceCounter.Increment();
					_queueLengthPerformanceCounter.Increment();
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			//int r = Interlocked.CompareExchange(ref _queueRuning, 1, 0))
			//if (r == 1)
			//{
			QueueRun();
			//}
		}
		private void DequeueThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_dequeueThreadStartPerformanceCounter.Increment();
				_dequeueThreadsCountPerformanceCounter.Increment();
			}
			if (OnDequeueThreadStart != null)
			{
				int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnDequeueThreadStart
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads ++ !"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
			}
			bool queueWasNotEmpty = false;
			try
			{
^#if c2
				while (true)
^#elif c4
				while (!_queue.IsEmpty)
^#endif
				{
					T element = null;
^#if c2
					lock (_syncQueueLockObject)
					{
						if (_queue.Count > 0)
						{
							element = _queue.Dequeue();
						}
						else
						{
							//避免QueueRun 死循环
							break;
						}
					}
^#elif c4
					if (_queue.TryDequeue(out element))
					{
^#elif c2
						if (element != null)
						{
^#endif
							if (!queueWasNotEmpty)
							{
								queueWasNotEmpty = true;
							}
							if (_isAttachedPerformanceCounters)
							{
								_dequeuePerformanceCounter.Increment();
								_queueLengthPerformanceCounter.Decrement();
							}
							if (OnDequeue != null)
							{
								OnDequeue(element);
							}
							if (_isAttachedPerformanceCounters)
							{
								_dequeueProcessedPerformanceCounter.Increment();
							}
^#if c2
						}
^#elif c4
					}
				}
^#endif
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				int r = (int) Interlocked.Decrement(ref _concurrentDequeueThreadsCount);
				if (OnDequeueThreadEnd != null)
				{
					OnDequeueThreadEnd
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads--"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
				}
				if (r == 0)
				{
					if (OnDequeueAllThreadsEnd != null)
					{
						OnDequeueAllThreadsEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
													, "All Threads End"
													, r
													, _queue.Count
													, Thread.CurrentThread.Name
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
												)
									);
					}
				}
				if (_isAttachedPerformanceCounters)
				{
					_dequeueThreadEndPerformanceCounter.Increment();
					_dequeueThreadsCountPerformanceCounter.Decrement();
				}
				if (queueWasNotEmpty)
				{
					QueueRun(); //死循环???
				}
				
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			CounterCreationData ccd = new CounterCreationData();
			ccd.CounterName = counterName;
			ccd.CounterHelp = string.Format("{0} Help", counterName);
			ccd.CounterType = performanceCounterType;
			return ccd;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Data;
	using System.Data.SqlClient;
	using System.Net;
	using Microshaoft.AsynQueue.Server;
	//using Microshaoft.RemotingObjects.Share;
	using Proxy;
	//using System.Windows.Forms;
	//using System.Drawing;
	public class AsyncQueueProcessor
	{
		private AsyncQueue<HelloWorldRequest> _queue;
		public AsyncQueue<HelloWorldRequest> Queue
		{
			get
			{
				return _queue;
			}
		}
		public AsyncQueueProcessor(AsyncQueue<HelloWorldRequest> queue)
		{
			_service.Url = ServiceHost._proxyServiceUrl;
			_queue = queue;
			_queue.OnDequeue += new AsyncQueue<HelloWorldRequest>.QueueEventHandler(_queue_OnDequeue);
			_queue.OnDequeueThreadStart += new AsyncQueue<HelloWorldRequest>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnDequeueAllThreadsEnd += new AsyncQueue<HelloWorldRequest>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnDequeueThreadEnd += new AsyncQueue<HelloWorldRequest>.QueueLogEventHandler(_queue_OnQueueLog);
			//_queue.OnQueueRunningThreadStart += new AsyncQueue<HelloWorldRequest>.QueueLogEventHandler(_queue_OnQueueLog);
			//_queue.OnQueueRunningThreadEnd += new AsyncQueue<HelloWorldRequest>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnException += new AsyncQueue<HelloWorldRequest>.ExceptionEventHandler(_queue_OnException);
			//_queue.MaxConcurrentThreadsCount = 100;
		}
		public void Enqueue(HelloWorldRequest item)
		{
			_queue.Enqueue(item);
		}
		void _queue_OnQueueLog(string logMessage)
		{
			Console.WriteLine(logMessage);
		}
		private Service1Class _service = new Service1Class();
		void _queue_OnDequeue(HelloWorldRequest item)
		{
			string s = _service.HelloWorld(item);
			Console.WriteLine(s);
		}
		void _queue_OnException(Exception e)
		{
			//Console.WriteLine(e.ToString());
		}
	}
}
//Server.cs
namespace Microshaoft.AsynQueue.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.Configuration;
	//using System.Runtime.Remoting;
	//using System.Runtime.Remoting.Channels;
	//using System.Runtime.Remoting.Channels.Tcp;
	//using System.Runtime.Serialization.Formatters;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Configuration.Install;
	using System.Security.Principal;
	using System.Net;
	//using Microshaoft.RemotingObjects;
	//using Microshaoft.RemotingObjects.Share;
	using Microshaoft.Win32;
	using Microshaoft;
	using Proxy;
	//using eHome.UserProfile;
	public class ServiceHost : ServiceBase
	{
		///// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		public static int _servicePointManagerDefaultConnectionLimit = 99; //int.Parse(ConfigurationManager.AppSettings["ConcurrentHttpConnectionsLimit"]);
		public static int _concurrentRequestsLimit = 88; //int.Parse(ConfigurationManager.AppSettings["ConcurrentRequestsLimit"]);
		public static int _outerLoops = 50; //int.Parse(ConfigurationManager.AppSettings["OuterLoops"]);
		public static int _innerLoops = 1000; //int.Parse(ConfigurationManager.AppSettings["InnerLoops"]);
		public static string _proxyServiceUrl = "http://local.v40.asp.net/smsplatform/test.asmx";//ConfigurationManager.AppSettings["ProxyServiceUrl"];
		public static readonly string serviceName = "AsyncConcurrentQueueService";
		private static AsyncQueueProcessor _asyncQueueProcessor;
		public static AsyncQueueProcessor AsyncQueueProcessor
		{
			get
			{
				return _asyncQueueProcessor;
			}
		}
		static void Main(string[] args)
		{
			//Microshaoft
			//Microshaoft TODO: 在此处添加代码以启动应用程序
			//Microshaoft 
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
					Console.Title = "Server"; //不能以服务运行
					Console.WriteLine("Console");
					service.OnStart(null);
					string input = string.Empty;
					while ("q" != (input = Console.ReadLine()))
					{
						Run();
					}
					Console.ReadLine();
					return;
				}
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public static void Run()
		{
			ServicePointManager.DefaultConnectionLimit = _servicePointManagerDefaultConnectionLimit;
			//Microshaoft 以下是耗时的主程序
			for (int i = 0; i < _outerLoops; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public static void ThreadProcess()
		{
			for (int i = 0; i < _innerLoops; i++)
			{
				HelloWorldRequest request = new HelloWorldRequest();
				AsyncQueueProcessor.Enqueue(request);
			 }
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			AsyncQueue<HelloWorldRequest> queue = new AsyncQueue<HelloWorldRequest>();
			queue.AttachPerformanceCounters("HelloWorldRequestQueue");
			_asyncQueueProcessor = new AsyncQueueProcessor(queue);
			queue.MaxConcurrentThreadsCount = _concurrentRequestsLimit;
			Console.WriteLine("Server . , Press Enter key to exit.");
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}
namespace Proxy
{
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 此代码由工具生成。
	//	 运行时版本:4.0.30319.225
	//
	//	 对此文件的更改可能会导致不正确的行为，并且如果
	//	 重新生成代码，这些更改将会丢失。
	// </auto-generated>
	//------------------------------------------------------------------------------
	using System;
	using System.ComponentModel;
	using System.Diagnostics;
	using System.Web.Services;
	using System.Web.Services.Protocols;
	using System.Xml.Serialization;
	// 
	// This source code was auto-generated by wsdl, Version=4.0.30319.1.
	// 
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[System.Web.Services.WebServiceBindingAttribute(Name="Service1ClassSoap", Namespace="http://www.microshaoft.com/")]
	public partial class Service1Class : System.Web.Services.Protocols.SoapHttpClientProtocol {
		private System.Threading.SendOrPostCallback HelloWorldOperationCompleted;
		/// <remarks/>
		public Service1Class() {
			this.Url = "http://local.v40.asp.net/smsplatform/test.asmx";
		}
		/// <remarks/>
		public event HelloWorldCompletedEventHandler HelloWorldCompleted;
		/// <remarks/>
		[System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microshaoft.com/HelloWorld", RequestNamespace="http://www.microshaoft.com/", ResponseNamespace="http://www.microshaoft.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
		public string HelloWorld(HelloWorldRequest request) {
			object[] results = this.Invoke("HelloWorld", new object[] {
						request});
			return ((string)(results[0]));
		}
		/// <remarks/>
		public System.IAsyncResult BeginHelloWorld(HelloWorldRequest request, System.AsyncCallback callback, object asyncState) {
			return this.BeginInvoke("HelloWorld", new object[] {
						request}, callback, asyncState);
		}
		/// <remarks/>
		public string EndHelloWorld(System.IAsyncResult asyncResult) {
			object[] results = this.EndInvoke(asyncResult);
			return ((string)(results[0]));
		}
		/// <remarks/>
		public void HelloWorldAsync(HelloWorldRequest request) {
			this.HelloWorldAsync(request, null);
		}
		/// <remarks/>
		public void HelloWorldAsync(HelloWorldRequest request, object userState) {
			if ((this.HelloWorldOperationCompleted == null)) {
				this.HelloWorldOperationCompleted = new System.Threading.SendOrPostCallback(this.OnHelloWorldOperationCompleted);
			}
			this.InvokeAsync("HelloWorld", new object[] {
						request}, this.HelloWorldOperationCompleted, userState);
		}
		
		private void OnHelloWorldOperationCompleted(object arg) {
			if ((this.HelloWorldCompleted != null)) {
				System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
				this.HelloWorldCompleted(this, new HelloWorldCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
			}
		}
		/// <remarks/>
		public new void CancelAsync(object userState) {
			base.CancelAsync(userState);
		}
	}
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
	[System.SerializableAttribute()]
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microshaoft.com/")]
	public partial class HelloWorldRequest {
	}
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
	public delegate void HelloWorldCompletedEventHandler(object sender, HelloWorldCompletedEventArgs e);
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	public partial class HelloWorldCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
		private object[] results;
		internal HelloWorldCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
				base(exception, cancelled, userState) {
			this.results = results;
		}
		/// <remarks/>
		public string Result {
			get {
				this.RaiseExceptionIfNecessary();
				return ((string)(this.results[0]));
			}
		}
	}
}
#T=ConcurrentAsyncQueue 异步队列
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		private long _EnqueueCount = 0; //入列计数器
		public long EnqueueCount
		{
			get
			{
				return _EnqueueCount;
			}
		}
		private long _DequeueCount = 0; //出列计数器
		public long DequeueCount
		{
			get
			{
				return _DequeueCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}
namespace Test
{
	using System;
	using System.Threading;
	using Microshaoft;
	public class Class1
	{
		static AsyncQueue<Item> _queue;
		public static void Main()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
			Console.ReadLine();
		}
		public void Run()
		{
			_queue = new AsyncQueue<Item>();
			_queue.OnDequeue += new AsyncQueue<Item>.QueueEventHandler(_queue_OnDequeue);
			_queue.OnQueueLog += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnException += new AsyncQueue<Item>.ExceptionEventHandler(_queue_OnException);
			_queue.MaxConcurrentThreadsCount = 200;
			Thread t = new Thread(new ThreadStart(ConsoleMonitor));
			t.Start();
			//Microshaoft 以下是耗时的主程序
			for (int i = 0; i < 1000; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public void ConsoleMonitor()
		{
			Console.WriteLine("press any key to check queue status ...");
			while (Console.ReadLine() != "q")
			{
				Console.WriteLine
							(
								"Queue elements: {0},Threads count: {1},{2},{3}"
								, _queue.Count
								, _queue.ConcurrentThreadsCount
								, _queue.EnqueueCount
								, _queue.DequeueCount
							);
			}
		}
		void _queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		void _queue_OnQueueLog(string logMessage)
		{
///			Console.WriteLine(logMessage);
		}
		void _queue_OnDequeue(Item element)
		{
///			DateTime DequeueBeginTime = DateTime.Now;
///			DateTime DequeueEndTime = DateTime.Now;
///			Console.WriteLine
///						(
///							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
///							, _queue.Count
///							, element.EnqueueTime
///							, DequeueBeginTime
///							, (DequeueBeginTime.Ticks - element.EnqueueTime.Ticks) / 10000 /1000
///							, DequeueEndTime
///							, (DequeueEndTime.Ticks - DequeueBeginTime.Ticks) / 10000 /1000
///							, _queue.ConcurrentThreadsCount
///						);
///			Console.WriteLine(element.EnqueueTime);
			   Thread.Sleep(1);
		}
		public void ThreadProcess()
		{
			for (int i = 0; i < 1000; i++)
			{
				Item x = new Item();
				DateTime EnqueueTime = DateTime.Now;
				x.Name = EnqueueTime.ToString();
				x.EnqueueTime = EnqueueTime;
				_queue.Enqueue(x);
///				Console.WriteLine
///							(
///								"Enqueue: {0},[{1}]"
///								, EnqueueTime
///								, (DateTime.Now.Ticks - EnqueueTime.Ticks) / 10000 / 1000
///							);
			}
		}
	}
}
namespace Test
{
	using System;
	public class Item
	{
		private string _Name;
		public string Name
		{
			get
			{
				return _Name;
			}
			set
			{
				_Name = value;
			}
		}
		private DateTime _EnqueueTime;
		public DateTime EnqueueTime
		{
			get
			{
				return _EnqueueTime;
			}
			set
			{
				_EnqueueTime = value;
			}
		}
	}
}

#T=configSection GetConfig 通用
namespace Test
{
	using System;
	using System.Configuration;
	using System.Linq;
	using System.Collections.Specialized;
	using System.Collections;
	class Program
	{
		static void Main(string[] args)
		{
			var config = ConfigurationManager.GetSection("AdditionalConfigSectionGroup/Secrets") as NameValueCollection;
			if (config != null)
			{
				Console.WriteLine(config["test1"]);
			}
			Console.ReadLine();
		}
	}
}
/*
<?xml version="1.0"?>
<configuration>
	<configSections>
		<sectionGroup name="AdditionalConfigSectionGroup">
			<!-- <section name="Secrets" type="System.Configuration.DictionarySectionHandler" /> -->
			<section name="Secrets" type="System.Configuration.NameValueSectionHandler" />
		</sectionGroup>
	</configSections>
	<AdditionalConfigSectionGroup>
		<Secrets>
			<add key="test1" value = "king" />
			<add key="test2" value = "jim" />
		</Secrets>
	</AdditionalConfigSectionGroup>
	<startup>
		<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5"/>
	</startup>
</configuration>
*/
#T=configSections getSection
namespace Test
{
	using System;
	using System.Configuration;
	using Microshaoft.Configurations;
	class Class1
	{
		static void Main(string[] args)
		{
			var section = ConfigurationManager.GetSection("SecretsSection") as SecretsSection;
			if (section == null)
			{
				Console.WriteLine("Failed to load SecretsSection.");
			}
			else
			{
				for (int i = 0; i < section.Secrets.Count; i++)
				{
					Console.WriteLine
						(
							"ID={0} secretKey={1}"
							, section.Secrets["Microsoft"].ID
							, section.Secrets[i].SecretKey
						);
				}
			}
			Console.ReadLine();
		}
	}
}
namespace Microshaoft.Configurations
{
	using System;
	using System.Configuration;
	public class SecretsSection : ConfigurationSection
	{
		[ConfigurationProperty("secrets", IsDefaultCollection = false)]
		[
			ConfigurationCollection
				(
					typeof(SecretsConfigurationElementCollection),
					AddItemName = "add",
					ClearItemsName = "clear",
					RemoveItemName = "remove"
				)
		]
		public SecretsConfigurationElementCollection Secrets
		{
			get
			{
				return (SecretsConfigurationElementCollection)base["secrets"];
			}
		}
	}
	public class SecretsConfigurationElementCollection : ConfigurationElementCollection
	{
		public SecretsConfigurationElementCollection()
		{
			var user = (SecretConfigurationElement)CreateNewElement();
			Add(user);
		}
		public override ConfigurationElementCollectionType CollectionType
		{
			get
			{
				return ConfigurationElementCollectionType.AddRemoveClearMap;
			}
		}
		protected override ConfigurationElement CreateNewElement()
		{
			return new SecretConfigurationElement();
		}
		protected override Object GetElementKey(ConfigurationElement element)
		{
			return ((SecretConfigurationElement) element).ID;
		}
		public SecretConfigurationElement this[int index]
		{
			get
			{
				return (SecretConfigurationElement) BaseGet(index);
			}
			set
			{
				if (BaseGet(index) != null)
				{
					BaseRemoveAt(index);
				}
				BaseAdd(index, value);
			}
		}
		new public SecretConfigurationElement this[string Name]
		{
			get
			{
				return (SecretConfigurationElement)BaseGet(Name);
			}
		}
		public int IndexOf(SecretConfigurationElement user)
		{
			return BaseIndexOf(user);
		}
		public void Add(SecretConfigurationElement user)
		{
			BaseAdd(user);
		}
		protected override void BaseAdd(ConfigurationElement element)
		{
			BaseAdd(element, false);
		}
		public void Remove(SecretConfigurationElement user)
		{
			if (BaseIndexOf(user) >= 0)
			{
				BaseRemove(user.ID);
			}
		}
		public void RemoveAt(int index)
		{
			BaseRemoveAt(index);
		}
		public void Remove(string id)
		{
			BaseRemove(id);
		}
		public void Clear()
		{
			BaseClear();
		}
	}
	public class SecretConfigurationElement : ConfigurationElement
	{
		[
			ConfigurationProperty
				(
					"id"
					, IsRequired = true
					, IsKey = true
				)
		]
		public string ID
		{
			get
			{
				return (string)this["id"];
			}
			set
			{
				this["id"] = value;
			}
		}
		[
			ConfigurationProperty
				(
					"secretKey"
					, IsRequired = true
				)
		]
		public string SecretKey
		{
			get
			{
				return (string)this["secretKey"];
			}
			set
			{
				this["secretKey"] = value;
			}
		}
	}
}
/*
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<configSections>
		<section name="SecretsSection" type="Microshaoft.Configurations.SecretsSection, assemblyFileName" />
	</configSections>
	<SecretsSection>
		<secrets>
			<clear />
			<add id="Microsoft"  secretKey="asdsad" />
			<add id="Contoso" secretKey="asdsad" />
		</secrets>
	</SecretsSection>
</configuration>
*/
#T=Configuration.Save 保存配置
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Configuration;
	using System.Reflection;
	//using System.Web.Configuration;
	class Program
	{
		static void Main(string[] args)
		{
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine()))
			{
				Configuration configuration = ConfigurationManager.OpenExeConfiguration
												(
													Assembly.GetExecutingAssembly().Location
												);
				///				configuration = WebConfigurationManager.OpenWebConfiguration
				///												(
				///													HttpContext.Current.Request.ApplicationPath
				///												);
				AppSettingsSection appSettingsSection = (AppSettingsSection)configuration.GetSection("appSettings");
				appSettingsSection.Settings.Add("key1", input);
				appSettingsSection.Settings.Add("key2", input);
				appSettingsSection.Settings["key1"].Value += "\n\r~!@#$%^&*()_+<>?" + input;
				var keys = appSettingsSection.Settings.AllKeys;
				Array.ForEach
						(
							keys
							, (x) =>
								{
									Console.WriteLine(appSettingsSection.Settings[x].Value);
								}
						);
				configuration.Save();
				Array.ForEach
						(
							keys
							, (x) =>
								{
									Console.WriteLine(appSettingsSection.Settings[x].Value);
								}
						);
			}
		}
	}
}

#T=ConnectionPool ADO.NET
namespace Microshaoft
{
	using System;
	using System.Data;
	using System.Data.SqlClient;
	using System.Linq;
	using System.Threading;
	using System.Threading.Tasks;
	class Program
	{
		static void Main()
		{
			var connectionString = @"
									Integrated Security=SSPI;
									Persist Security Info=False;
									Initial Catalog=Test;
									Data Source=localhost\enterprise2012;
									ApplicationIntent=READONLY;
									Max Pool Size=10;
									Min Pool Size=0
									";
			///Enumerable
				///.Range(0, 3000)
					///.AsParallel()
						///.WithDegreeOfParallelism(64)
						Parallel
							.For
								(
									1
									, 3000
									, new ParallelOptions() { MaxDegreeOfParallelism = 30 }
									, (x) =>
									{
										//using
										//(
											SqlConnection connection = new SqlConnection
													(
														connectionString
													);
										//)
										//{
											connection.Open();
											Console.WriteLine("ConnectionID: {0}", x);
											Thread.Sleep(30 * 1000);
											connection.Close();
										//}
									}
								);
			Console.ReadLine();
		}
	}
}

#T=Consistent Hashing ketamahash 一致性哈希
namespace KetamaHash
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using KetamaHash.Utils;
	class Program
	{
		static void Main(string[] args)
		{
			HashAlgorithmTest.Test();
			//HashAlgorithmPercentTest.Test();
		}
	}
}
namespace KetamaHash.Utils
{
	using System;
	using System.Security.Cryptography;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public class HashAlgorithm
	{
		public static long hash(byte[] digest, int nTime)
		{
			long rv = ((long)(digest[3 + nTime * 4] & 0xFF) << 24)
					| ((long)(digest[2 + nTime * 4] & 0xFF) << 16)
					| ((long)(digest[1 + nTime * 4] & 0xFF) << 8)
					| ((long)digest[0 + nTime * 4] & 0xFF);
			return rv & 0xffffffffL; /* Truncate to 32-bits */
		}
		/**
		 * Get the md5 of the given key.
		 */
		public static byte[] computeMd5(string k)
		{
			MD5 md5 = new MD5CryptoServiceProvider();
			byte[] keyBytes = md5.ComputeHash(Encoding.UTF8.GetBytes(k));
			md5.Clear();
			//md5.update(keyBytes);
			//return md5.digest();
			return keyBytes;
		}
	}
}
namespace KetamaHash.Utils
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public class HashAlgorithmPercentTest
	{
		static Random ran = new Random();
		/** key's count */
		private const int EXE_TIMES = 100000;
		private const int NODE_COUNT = 100;
		private const int VIRTUAL_NODE_COUNT = 500;
		static List<String> allKeys = null;
		//static {
		//	allKeys = getAllStrings();
		//}
		public static void Test()
		{
			allKeys = GetAllStrings();
			Dictionary<string, List<string>> mapData = GenerateRecord();
			List<string> allNodes = getNodes(NODE_COUNT);
			Console.WriteLine("Normal case : nodes count : " + allNodes.Count());
			call(allNodes, mapData);
			allNodes = getNodes(NODE_COUNT + 8);
			Console.WriteLine("Added case : nodes count : " + allNodes.Count());
			call(allNodes, mapData);
			allNodes = getNodes(NODE_COUNT - 10);
			Console.WriteLine("Reduced case : nodes count : " + allNodes.Count());
			call(allNodes, mapData);
			int addCount = 0;
			int reduceCount = 0;
			foreach (string key in mapData.Keys)
			{
				List<string> list = mapData[key];
				if (list.Count == 3)
				{
					if (list[0] == list[1])
					{
						addCount++;
					}
					if (list[0] == list[2])
					{
						reduceCount++;
					}
				}
				else
				{
					Console.WriteLine("It's wrong size of list, key is " + key + ", size is " + list.Count);
				}
			}
			Console.WriteLine(addCount + "   ---   " + reduceCount);
			//上面三行分别是正常情况，节点增加，节点删除情况下的节点数目。下面两行表示在节点增加和删除情况下，同一个key分配在相同节点上的比例(命中率)。 
			//多次测试后发现，命中率与结点数目和增减的节点数量有关。同样增删结点数目情况下，结点多时命中率高。同样节点数目，增删结点越少，命中率越高。这些都与实际情况相符。 
			Console.WriteLine("Same percent in added case : " + (float)addCount * 100 / EXE_TIMES + "%");
			Console.WriteLine("Same percent in reduced case : " + (float)reduceCount * 100 / EXE_TIMES + "%");
			Console.ReadLine();
		}
		private static void call(List<string> nodes, Dictionary<string, List<string>> map)
		{
			KetamaNodeLocator locator = new KetamaNodeLocator(nodes, VIRTUAL_NODE_COUNT);
			foreach (string key in map.Keys)
			{
				string node = locator.GetPrimary(key);
				if (node != null)
				{
					List<string> list = map[key];
					list.Add(node);
				}
			}
		}
		private static Dictionary<string, List<string>> GenerateRecord()
		{
			Dictionary<string, List<string>> record = new Dictionary<string, List<string>>(EXE_TIMES);
			foreach (string key in allKeys)
			{
				//List<string> list = record[key];
				//if (list == null)
				//{
					List<string>  list = new List<string>();
					record[key] = list;
				//}
			}
			return record;
		}
		/**
		 * Gets the mock node by the material parameter
		 * 
		 * @param nodeCount 
		 * 		the count of node wanted
		 * @return
		 * 		the node list
		 */
		private static List<string> getNodes(int nodeCount)
		{
			List<string> nodes = new List<string>();
			for (int k = 1; k <= nodeCount; k++)
			{
				string node = "node" + k;
				nodes.Add(node);
			}
			//在应用时，这里会添入memcached server的IP端口地址
			//nodes.Add("10.0.4.114:11211");
			//nodes.Add("10.0.4.114:11212");
			//nodes.Add("10.0.4.114:11213");
			//nodes.Add("10.0.4.114:11214");
			//nodes.Add("10.0.4.114:11215");
			return nodes;
		}
		/**
		 *	All the keys	
		 */
		private static List<String> GetAllStrings()
		{
			List<string> allStrings = new List<string>(EXE_TIMES);
			for (int i = 0; i < EXE_TIMES; i++)
			{
				allStrings.Add(GenerateRandomString(ran.Next(50)));
			}
			return allStrings;
		}
		/**
		 * To generate the random string by the random algorithm
		 * <br>
		 * The char between 32 and 127 is normal char
		 * 
		 * @param length
		 * @return
		 */
		private static String GenerateRandomString(int length)
		{
			StringBuilder sb = new StringBuilder(length);
			for (int i = 0; i < length; i++)
			{
				sb.Append((char)(ran.Next(95) + 32));
			}
			return sb.ToString();
		}
	}
}
namespace KetamaHash.Utils
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public class HashAlgorithmTest
	{
		static Random ran = new Random();
		/** key's count */
		private const int EXE_TIMES = 100000;
		private const int NODE_COUNT = 5;
		private const int VIRTUAL_NODE_COUNT = 160;
		public static void Test()
		{
			HashAlgorithmTest test = new HashAlgorithmTest();
			/** Records the times of locating node*/
			Dictionary<string, int> nodeRecord = new Dictionary<string, int>();
			List<string> allNodes = test.getNodes(NODE_COUNT);
			KetamaNodeLocator locator = new KetamaNodeLocator(allNodes, VIRTUAL_NODE_COUNT);
			List<String> allKeys = test.getAllStrings();
			foreach (string key in allKeys)
			{
				string node = locator.GetPrimary(key);
				if (!nodeRecord.ContainsKey(node))
				{
					nodeRecord[node] = 1;
				}
				else
				{
					nodeRecord[node] = nodeRecord[node] + 1;
				}
			}
			Console.WriteLine("Nodes count : " + NODE_COUNT + ", Keys count : " + EXE_TIMES + ", Normal percent : " + (float)100 / NODE_COUNT + "%");
			Console.WriteLine("-------------------- boundary  ----------------------");
			foreach (string key in nodeRecord.Keys)
			{
				Console.WriteLine("Node name :" + key + " - Times : " + nodeRecord[key] + " - Percent : " + (float)nodeRecord[key] / EXE_TIMES * 100 + "%");
			}
			Console.ReadLine();
		}
		/**
		 * Gets the mock node by the material parameter
		 * 
		 * @param nodeCount 
		 * 		the count of node wanted
		 * @return
		 * 		the node list
		 */
		private List<string> getNodes(int nodeCount)
		{
			List<string> nodes = new List<string>();
			for (int k = 1; k <= nodeCount; k++)
			{
				string node = "node" + k;
				nodes.Add(node);
			}
			//在应用时，这里会添入memcached server的IP端口地址
			//nodes.Add("10.0.4.114:11211");
			//nodes.Add("10.0.4.114:11212");
			//nodes.Add("10.0.4.114:11213");
			//nodes.Add("10.0.4.114:11214");
			//nodes.Add("10.0.4.114:11215");
			return nodes;
		}
		/**
		 *	All the keys	
		 */
		private List<String> getAllStrings()
		{
			List<string> allStrings = new List<string>(EXE_TIMES);
			for (int i = 0; i < EXE_TIMES; i++)
			{
				allStrings.Add(generateRandomString(ran.Next(50)));
			}
			return allStrings;
		}
		/**
		 * To generate the random string by the random algorithm
		 * <br>
		 * The char between 32 and 127 is normal char
		 * 
		 * @param length
		 * @return
		 */
		private String generateRandomString(int length)
		{
			StringBuilder sb = new StringBuilder(length);
			for (int i = 0; i < length; i++)
			{
				sb.Append((char)(ran.Next(95) + 32));
			}
			return sb.ToString();
		}
	}
}
namespace KetamaHash.Utils
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public class KetamaNodeLocator
	{
		private SortedList<long, string> ketamaNodes = new SortedList<long, string>();
		//private HashAlgorithm hashAlg;
		private int numReps = 160;
		public KetamaNodeLocator(List<string> nodes, int nodeCopies)
		{
			ketamaNodes = new SortedList<long, string>();
			numReps = nodeCopies;
			//对所有节点，生成nCopies个虚拟结点
			foreach (string node in nodes)
			{
				//每四个虚拟结点为一组
				for (int i = 0; i < numReps / 4; i++)
				{
					//getKeyForNode方法为这组虚拟结点得到惟一名称 
					byte[] digest = HashAlgorithm.computeMd5(node + i);
					/** Md5是一个16字节长度的数组，将16字节的数组每四个字节一组，分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因*/  
					for (int h = 0; h < 4; h++)
					{
						long m = HashAlgorithm.hash(digest, h);
						ketamaNodes[m] = node;
					}
				}
			}
		}
		public string GetPrimary(string k)
		{
			byte[] digest = HashAlgorithm.computeMd5(k);
			string rv = GetNodeForKey(HashAlgorithm.hash(digest, 0));
			return rv;
		}
		string GetNodeForKey(long hash)
		{
			string rv;
			long key = hash;
			//如果找到这个节点，直接取节点，返回   
			if (!ketamaNodes.ContainsKey(key))
			{
				//得到大于当前key的那个子Map，然后从中取出第一个key，就是大于且离它最近的那个key 说明详见: http://www.javaeye.com/topic/684087
				var tailMap = from coll in ketamaNodes
							  where coll.Key > hash
							  select new { coll.Key };
				if (tailMap == null || tailMap.Count() == 0)
					key = ketamaNodes.FirstOrDefault().Key;
				else
					key = tailMap.FirstOrDefault().Key;
			}
			rv = ketamaNodes[key];
			return rv;
		}
	}
}
//=================================================
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new MainWnd());
		}
	}
}

namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;
	using ConsistentHash;
	public partial class MainWnd : Form
	{
			class Server
			{
					public int ID { get; set; }
					public Server(int _id)
					{
							ID = _id;
					}
					public override int GetHashCode()
					{
							return ("svr_" + ID).GetHashCode();
					}
			}
			public MainWnd()
			{
					InitializeComponent();
			}
			private void btnTest_Click(object sender, EventArgs e)
			{
					List<Server> servers = new List<Server>();
					for (int i = 0; i < 1000; i++)
					{
							servers.Add(new Server(i));
					}
					ConsistentHash<Server> ch = new ConsistentHash<Server>();
					ch.Init(servers);
					int search = 100000;
					DateTime start = DateTime.Now;
					SortedList<int, int> ay1 = new SortedList<int, int>();
					for (int i = 0; i < search; i++)
					{
							int temp = ch.GetNode(i.ToString()).ID;
							ay1[i] = temp;
					}
					TimeSpan ts = DateTime.Now - start;
					MessageBox.Show(search + " each use macro seconds: " + (ts.TotalMilliseconds/search)*1000);
					//ch.Add(new Server(1000));
					ch.Remove(servers[1]);
					SortedList<int, int> ay2 = new SortedList<int, int>();
					for (int i = 0; i < search; i++)
					{
							int temp = ch.GetNode(i.ToString()).ID;
							ay2[i] = temp;
					}
					int diff = 0;
					for (int i = 0; i < search; i++)
					{
							if (ay1[i] != ay2[i])
							{
									diff++;
							}
					}
					MessageBox.Show("diff: " + diff);
			}
	}
}
namespace Test
{
	partial class MainWnd
	{
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		/// <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要
		/// 使用代码编辑器修改此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.btnTest = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// btnTest
			// 
			this.btnTest.Location = new System.Drawing.Point(152, 124);
			this.btnTest.Name = "btnTest";
			this.btnTest.Size = new System.Drawing.Size(75, 23);
			this.btnTest.TabIndex = 0;
			this.btnTest.Text = "Test";
			this.btnTest.UseVisualStyleBackColor = true;
			this.btnTest.Click += new System.EventHandler(this.btnTest_Click);
			// 
			// MainWnd
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(492, 261);
			this.Controls.Add(this.btnTest);
			this.Name = "MainWnd";
			this.Text = "CHashTest";
			this.ResumeLayout(false);
		}
		#endregion
		private System.Windows.Forms.Button btnTest;
	}
}

namespace ConsistentHash
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Runtime.InteropServices;
	using System.Security.Cryptography;
	using System.Text;
		public class MurmurHash2
		{
				public static UInt32 Hash(Byte[] data)
				{
						return Hash(data, 0xc58f1a7b);
				}
				const UInt32 m = 0x5bd1e995;
				const Int32 r = 24;
				[StructLayout(LayoutKind.Explicit)]
				struct BytetoUInt32Converter
				{
						[FieldOffset(0)]
						public Byte[] Bytes;
						[FieldOffset(0)]
						public UInt32[] UInts;
				}
				public static UInt32 Hash(Byte[] data, UInt32 seed)
				{
						Int32 length = data.Length;
						if (length == 0)
								return 0;
						UInt32 h = seed ^ (UInt32)length;
						Int32 currentIndex = 0;
						// array will be length of Bytes but contains Uints
						// therefore the currentIndex will jump with +1 while length will jump with +4
						UInt32[] hackArray = new BytetoUInt32Converter { Bytes = data }.UInts;
						while (length >= 4)
						{
								UInt32 k = hackArray[currentIndex++];
								k *= m;
								k ^= k >> r;
								k *= m;
								h *= m;
								h ^= k;
								length -= 4;
						}
						currentIndex *= 4; // fix the length
						switch (length)
						{
								case 3:
										h ^= (UInt16)(data[currentIndex++] | data[currentIndex++] << 8);
										h ^= (UInt32)data[currentIndex] << 16;
										h *= m;
										break;
								case 2:
										h ^= (UInt16)(data[currentIndex++] | data[currentIndex] << 8);
										h *= m;
										break;
								case 1:
										h ^= data[currentIndex];
										h *= m;
										break;
								default:
										break;
						}
						// Do a few final mixes of the hash to ensure the last few
						// bytes are well-incorporated.
						h ^= h >> 13;
						h *= m;
						h ^= h >> 15;
						return h;
				}
		}
		class ConsistentHash<T>
		{
				SortedDictionary<int, T> circle = new SortedDictionary<int, T>();
				int _replicate = 100;   //default _replicate count
				int[] ayKeys = null;	//cache the ordered keys for better performance
				//it's better you override the GetHashCode() of T.
				//we will use GetHashCode() to identify different node.
				public void Init(IEnumerable<T> nodes)
				{
						Init(nodes, _replicate);
				}
				public void Init(IEnumerable<T> nodes, int replicate)
				{
						_replicate = replicate;
						foreach (T node in nodes)
						{
								this.Add(node, false);
						}
						ayKeys = circle.Keys.ToArray();
				}
				public void Add(T node)
				{
						Add(node, true);
				}
				private void Add(T node, bool updateKeyArray)
				{
						for (int i = 0; i < _replicate; i++)
						{
								int hash = BetterHash(node.GetHashCode().ToString() + i);
								circle[hash] = node;
						}
						if (updateKeyArray)
						{
								ayKeys = circle.Keys.ToArray();
						}
				}
				public void Remove(T node)
				{
						for (int i = 0; i < _replicate; i++)
						{
								int hash = BetterHash(node.GetHashCode().ToString() + i);
								if (!circle.Remove(hash))
								{
										throw new Exception("can not remove a node that not added");
								}
						}
						ayKeys = circle.Keys.ToArray();
				}
				//we keep this function just for performance compare
				private T GetNode_slow(String key)
				{
						int hash = BetterHash(key);
						if (circle.ContainsKey(hash))
						{
								return circle[hash];
						}
						int first = circle.Keys.FirstOrDefault(h => h >= hash);
						if (first == new int())
						{
								first = ayKeys[0];
						}
						T node = circle[first];
						return node;
				}
				//return the index of first item that >= val.
				//if not exist, return 0;
				//ay should be ordered array.
				int First_ge(int[] ay, int val)
				{
						int begin = 0;
						int end = ay.Length - 1;
						if (ay[end] < val || ay[0] > val)
						{
								return 0;
						}
						int mid = begin;
						while (end - begin > 1)
						{
								mid = (end + begin) / 2;
								if (ay[mid] >= val)
								{
										end = mid;
								}
								else
								{
										begin = mid;
								}
						}
						if (ay[begin] > val || ay[end] < val)
						{
								throw new Exception("should not happen");
						}
						return end;
				}
				public T GetNode(String key)
				{
						//return GetNode_slow(key);
						int hash = BetterHash(key);
						int first = First_ge(ayKeys, hash);
						//int diff = circle.Keys[first] - hash;
						return circle[ayKeys[first]];
				}
				//default String.GetHashCode() can't well spread strings like "1", "2", "3"
				public static int BetterHash(String key)
				{
						uint hash = MurmurHash2.Hash(Encoding.ASCII.GetBytes(key));
						return (int)hash;
				}
		}
}

#T=Consistent.Hashing 一致性哈希
namespace Enterprise.Consistent.Hashing.App
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Diagnostics;
	class Program
	{
		static void Main(string[] args)
		{
			OneCircleNodeSpace();
			ThreeDeepNodeSpace();
			Console.ReadLine();
			
		}
		public static void ThreeDeepNodeSpace()
		{
			SpaceMgr mgr = null;
			List<Node> nodeSpace = new List<Node>();
			List<Node> nodes = null;
			List<Node> child = null;
			for (int i = 0; i < 1000; i++)
			{
				nodes = new List<Node>();
				for (int j = 0; j < 3; j++)
				{
					child = new List<Node>();
					for (int k = 0; k < 2; k++)
					{
						child.Add(new Node("D" + k.ToString(), k.ToString()));
					}
					nodes.Add(new Node(i.ToString(), j.ToString(), child, 200));
				}
				nodeSpace.Add(new Node(i.ToString(), i.ToString(), nodes, 200));
			}
			//create the node manager object
			mgr = new SpaceMgr(nodeSpace);
			//Assign value for a key
			mgr.Locate("Author").value = "Debru Aklil";
			//display key
			Console.WriteLine("looking for Author key....");
			//locate a node and get a value for a key
			Console.WriteLine(mgr.Locate("Author").value);
			//number of node key to search
			int search = 100000;
			//Get number of nodes in the node space
			NodeList<Node> sp = mgr.nodespace;
			int count = 1;
			while (sp.nodes.Count >= 1)
			{
				count = count * sp.nodes.Count;
				sp = sp.nodes[0]; ;
			}
			Console.WriteLine("Start Processing " + search + " keys in " + count + " nodes.");
			//Calculate time taken to look n number of keys
			Stopwatch sw = new Stopwatch();
			sw.Start();
			for (int i = 0; i < search; i++)
			{
				mgr.Locate(i.ToString());
			}
			sw.Stop();
			Console.WriteLine(search + " Each node lookup took : " + (sw.Elapsed.TotalMilliseconds / search) * 1000 + " Microseconds.");
		}
		public static void OneCircleNodeSpace()
		{
			SpaceMgr mgr = null;
			List<Node> nodeSpace = new List<Node>();	
			for (int i = 0; i < 1000; i++)		 
				nodeSpace.Add(new Node(i.ToString(), i.ToString()));		  
			//create the node manager object
			mgr = new SpaceMgr(nodeSpace);
			//Assign value for a key
			mgr.Locate("Author").value = "Debru Aklil";
			//display key
			Console.WriteLine("looking for Author key....");
			//locate a node and get a value for a key
			Console.WriteLine(mgr.Locate("Author").value);
			//number of keys to search
			int search = 100000;
			NodeList<Node> sp = mgr.nodespace;
			//Get number of nodes in the node space
			int count = 1;
			while (sp.nodes.Count >= 1)
			{
				count = count * sp.nodes.Count;
				sp = sp.nodes[0]; ;
			}
			Console.WriteLine("Start Processing " + search + " keys in " + nodeSpace.Count + " nodes.");
			//Calculate time taken to look n number of keys
			Stopwatch sw = new Stopwatch();
			sw.Start();
			for (int i = 0; i < search; i++)
			{
				mgr.Locate(i.ToString());
			}
			sw.Stop();
			Console.WriteLine(search + " Each node lookup took : " + (sw.Elapsed.TotalMilliseconds / search) * 1000 + " Microseconds.");
		}
	}
}
namespace Enterprise.Consistent.Hashing
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Security.Cryptography;
	/// <summary>
	/// Implements an FNV hash algorithm.
	/// </summary>
	public static class FNVHash 
	{
		private const uint Prime = 16777619;
		private const uint Offset = 2166136261;		
/// <summary>
/// Compute the hash value for a specified data.
/// </summary>
/// <param name="Data"></param>
/// <returns></returns>
		public static uint Hash(string Data)
		{
			uint hashvalue = Offset;
			byte[] array = ASCIIEncoding.ASCII.GetBytes(Data);
			int end = array.Length;
			for (int i = 0; i < end; i++)
			{
				hashvalue = (hashvalue ^ array[i]) * Prime;
			}
			hashvalue += hashvalue << 13;
			hashvalue ^= hashvalue >> 7;
			hashvalue += hashvalue << 3;
			hashvalue ^= hashvalue >> 17;
			hashvalue += hashvalue << 5;
			return hashvalue;
			
		}
		/// <summary>
		/// Gets the MD5 hash value for the passed in value parameter
		/// </summary>
		/// <param name="value">The string value to hash</param>
		/// <param name="upperCase">Indicates whether or not the return value should be upper case</param>
		/// <returns>The MD5 hash of the value parameter</returns>
		public static uint MD5Hash(string value)
		{
			// Instantiate new MD5 Service Provider to perform the hash
			System.Security.Cryptography.MD5CryptoServiceProvider md5ServiceProdivder = new System.Security.Cryptography.MD5CryptoServiceProvider();
			// Get a byte array representing the value to be hashed and hash it
			byte[] data = System.Text.Encoding.ASCII.GetBytes(value);
			data = md5ServiceProdivder.ComputeHash(data);
			
		  return  BitConverter.ToUInt32(data,0);
		  
		  
		}
	 
	}
}
namespace Enterprise.Consistent.Hashing
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	/// <summary>
	/// A server node in the node space
	/// </summary>
	public  class Node : NodeList<Node>
	{
		public string Address { get; set; }
		public string Port { get; set; }
		public bool IsLive = true;
		public override string ToString()
		{
			return Address +":"+ Port;
		}
		public string value
		{
			get;
			set;
		}
		public Node(string Address, string Port)
		{
			this.Address = Address;
			this.Port = Port;
		}
	 
		public Node(string Address, string Port, bool IsLive)
		{
			this.Address = Address;
			this.Port = Port;
			this.IsLive = IsLive;
		}
		public Node(string Address, string Port, IEnumerable<Node> Nodes, int Replicate)
			: base(Nodes, Replicate)
		{
			this.Address = Address;
			this.Port = Port;
		}
		public uint HashCode()
		{
			return  FNVHash.Hash(this.ToString());
		}
		public Node(IEnumerable<Node> Nodes, int Replicate)
			: base(Nodes, Replicate)
		{
		}
		public Node(IEnumerable<Node> Nodes)
			: base(Nodes)
		{
		}
		internal override void UpdateNode()
		{
			base.UpdateNode();
			 
		}
	}
}
namespace Enterprise.Consistent.Hashing
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	/// <summary>
	/// Create the node list in the circle
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public abstract class NodeList<T>
	{
		internal int _replicate = 100;	//helps to add closure to the nodes in the ring
		internal uint[] Keys = null;	//ordered keys for better performance, contain all hashed node keys
		internal Ring<T> Circle = new Ring<T>();//collection of  nodes in a circle
		internal bool IsInitialized = false;// used to flag node space creation 
		public List<T> nodes = new List<T>();//list of actual nodes before virtually got replicated
		private static object syncLock = new object();
		public NodeList(IEnumerable<T> Nodes, int Replicate)
		{		
			this._replicate = Replicate;
			Initialize(Nodes);
		}		
		public NodeList(IEnumerable<T> Nodes)
		{
			Initialize(Nodes);
		}
		public NodeList()
		{
			this.IsInitialized = false;
		 
		}
		internal  void Add(T node)
		{
			for (int i = 0; i < _replicate; i++)
			{
				uint hash =FNVHash.Hash(node.ToString() + "-"+ i);
				Circle[hash] = node;
			}
			nodes.Add(node);
		}
		internal void Add(T node, bool ready)
		{
			
			for (int i = 0; i < _replicate; i++)
			{
				uint hash = FNVHash.Hash(node.ToString() + "-" + i);				
				Circle[hash] = node;
			}
			if(ready)
				Keys = Circle.Keys.ToArray();
			this.IsInitialized = true;
		}
		internal virtual void UpdateNode()
		{
			Keys = Circle.Keys.ToArray();
		}
		internal void Remove(T node)
		{
			for (int i = 0; i < _replicate; i++)
			{
				uint hash =  FNVHash.Hash(node.ToString() + "-" + i);
				Circle.Remove(hash);
			}
			Keys = Circle.Keys.ToArray();			
		}
		private void Initialize(IEnumerable<T> Nodes)
		{
			if (this.IsInitialized)
				throw new InvalidOperationException("Instance is already initialized.");
			lock (syncLock)
			{
				if (this.IsInitialized)
					throw new InvalidOperationException("Instance is already initialized.");
				T[] nds = Nodes.ToArray();
				for (int k = 0; k < nds.Length; k++)
				{
					for (int i = 0; i < _replicate; i++)
					{
						uint hash = FNVHash.Hash(nds[k].ToString() + i);
						Circle[hash] = nds[k];
					}
				}
				Keys = Circle.Keys.ToArray();
				this.IsInitialized = true;
				nodes.AddRange(Nodes);
			}
		}
	}
}
namespace Enterprise.Consistent.Hashing
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	/// <summary>
	/// This is a consistent hash node locator.
	/// </summary>
	public static class NodeLocator
	{
		///// <summary>
		///// Locates a node in a node space, faster than b
		///// </summary>
		//  /// <param name="space">A node space contains all active nodes</param>
		//  /// <param name="Key">Un hashed string key to locate a node in a space</param>
		//  /// <returns> <see cref="T:Node" /></returns>
		// public static Node Locate(Space space, string Key)
		// {
		//	 uint[] keys = space.Keys;
		//	 if (!space.IsInitialized)
		//		 throw new InvalidOperationException("You must initialize the space first");
		//	 if (Key == null)
		//		 throw new ArgumentNullException("key");
		//	 if (keys.Length == 0)
		//		 return null;
		//	 uint hashKey = FNVHash.Hash(Key);
		//	 int start = 0;
		//	 int index = keys.Length - 1;
		//	 if (keys[index] < hashKey || keys[0] > hashKey)
		//	 {
		//		 index = 0;
		//	 }
		//	 else
		//	 {
		//		 int mid = start;
		//		 while (index - start > 1)
		//		 {
		//			 mid = (index + start) / 2;
		//			 if (keys[mid] >= hashKey)
		//				 index = mid;
		//			 else
		//				 start = mid;
		//		 }
				
		//	 }
		//	 return space.Circle[keys[index]];
		// }
		/// <summary>
		/// Locates a node in a node space, faster than b
		/// </summary>
		/// <param name="space">A node space contains all active nodes</param>
		/// <param name="Key">Un hashed string key to locate a node in a space</param>
		/// <returns> <see cref="T:Node" /></returns>
		public static Node Locate(NodeList<Node> space, string Key)
		{
			uint[] keys = null;
			int index = 0;
			uint hashKey = FNVHash.Hash(Key);
			int mid = 0;
			int start = 0;
			while (space.nodes.Count >= 1)
			{
				keys = space.Keys;
				if (!space.IsInitialized)
					throw new InvalidOperationException("You must initialize the node space first");
				if (Key == null)
					throw new ArgumentNullException("key");
				if (keys.Length == 0)
					return null;			
				start = 0;
				index = keys.Length - 1;
				if (keys[index] < hashKey || keys[0] > hashKey)
				{
					index = 0;
				}
				else
				{
					mid = start;
					while (index - start > 1)
					{
						mid = (index + start) / 2;
						if (keys[mid] >= hashKey)
							index = mid;
						else
							start = mid;
					}
				}
				space = space.Circle[keys[index]];
			}
			return (Node)space;
		}
		
		/// <summary>
		/// Using bitwise complement operation to find the hash key index in the keys, it is slower than the bove method
		/// </summary>
		/// <param name="space">A node space contains all active nodes</param>
		/// <param name="Key">Un hashed string key to locate a node in a space</param>
		/// <returns> <see cref="T:Node" /></returns>
		public static Node SLocate(Node space, string Key)
		{
			uint[] keys = space.Keys;
			if (!space.IsInitialized)
				throw new InvalidOperationException("You must initialize the space first");
			if (Key == null)
				throw new ArgumentNullException("key");
			if (keys.Length == 0)
				return null;
			uint hashKey = FNVHash.Hash(Key);
			
			int index = Array.BinarySearch<uint>(keys, hashKey);			
			if (index < 0)
			{				
				index = ~index;
				if (index == 0)
				{					
					index = keys.Length - 1;				}
				else if (index >= keys.Length)
				{					
					index = 0;
				}
			}			
			return space.Circle[keys[index]];
		}
	}
}
namespace Enterprise.Consistent.Hashing
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public class Ring<T> : SortedDictionary<uint, T>
	{
	}
}
namespace Enterprise.Consistent.Hashing
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public class Space: NodeList<Node>
	{
		internal Space(IEnumerable<Node> Nodes, int Replicate)
			: base(Nodes, Replicate)
		{
		}
		internal Space(IEnumerable<Node> Nodes)
			: base(Nodes)
		{
		}
		internal override void UpdateNode()
		{
			base.UpdateNode();
			 
		}
	}
}
namespace Enterprise.Consistent.Hashing
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	/// <summary>
	/// Manager class to interface with the hashing and node locator class.
	/// </summary>
   public class SpaceMgr
	{
		public  Node nodespace = null;
		public  Node Locate(string Key)
		{
			return NodeLocator.Locate(nodespace, Key);
		}
		/// <summary>
		/// Initialize the space with a collection of nodes.
		/// </summary>
		/// <param name="Nodes"> Collection of nodes</param>
		/// <param name="Replicate"> number to replicate node</param>
		public SpaceMgr(IEnumerable<Node> Nodes, int Replicate)
		{
			nodespace = new Node(Nodes, Replicate);
			
		}
		/// <summary>
		/// Initialize the space with a collection of nodes.
		/// </summary>
		/// <param name="Nodes"> Collection of nodes</param>
		public SpaceMgr(IEnumerable<Node> Nodes)
		{
			nodespace = new Node(Nodes);
		}
		/// <summary>
		/// Add a node in the node space
		/// </summary>
		/// <param name="node">a node to be added in the space.</param>
		public  void Add(Node node)
		{
			nodespace.Add(node);
		}
		/// <summary>
		/// Add a node in the node space and activate it immediately.
		/// </summary>
		/// <param name="node">a node to be added in the space.</param>
		/// <param name="ready">boolen value to activate a node in the space </param>
		public void Add(Node node, bool ready)
		{
			nodespace.Add(node,ready);
		}
		/// <summary>
		/// Update all the nodes in the ring, you call this usually after adding a node and when it is ready to participate in the space.
		/// </summary>
		public void UpdateNode()
		{
			nodespace.UpdateNode();
		}
		/// <summary>
		/// Remove node from the space
		/// </summary>
		/// <param name="node">Node to be removed</param>
		public void Remove(Node node)
		{
			nodespace.Remove(node);
		}
		
	}
}

#T=Console Alloc/Attach/Free
namespace ConsoleApplication
{
	using System;
	using Microshaoft.Win32;
	using System.Windows.Forms;
	using System.Threading;
	using System.Diagnostics;

		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			string run = "winexe";
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					run = "console";
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					//Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
				}
				Console.Title = "Console"; //不能以服务运行
				Console.WriteLine("Console");
				//service.OnStart(null);
				//Console.ReadLine();
				//return;
			}
			DateTime begin = DateTime.Now;
			for (int i = 0; i < 10 * 10 * 10000 ; i++)
			{
				//Thread.Sleep(1000);
				Console.WriteLine(i);
				
			}
			
			//ServiceBase.Run(service);
			if (!needFreeConsole)
			{
				needFreeConsole = true;
				//int pid = Process.GetCurrentProcess().Id;
				NativeMethods.AllocConsole();
			}
			Console.WriteLine("target: {0}", run);
			Console.WriteLine("{0} - {1}", begin, DateTime.Now);
			
			
			if (needFreeConsole)
			{
				//Console.ReadLine();
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
			//Application.Run();
		}
	}

}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AttachConsole(int dwProcessId);

		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}

#T=Console Color
namespace Microshaoft
{
	using System;

	class Sample 
	{
		public static void Main() 
		{
		String nl = Environment.NewLine;
		String[] colorNames = ConsoleColor.GetNames(typeof(ConsoleColor));

	// ---------------------------------------------------------------------------------------
		Console.WriteLine("{0}All the foreground colors on a constant black background.", nl);
		Console.WriteLine("  (Black on black is not readable.){0}", nl);

		for (int x = 0; x < colorNames.Length; x++)
		{
		Console.Write("{0,2}: ", x);
		Console.BackgroundColor = ConsoleColor.Black;
		Console.ForegroundColor = (ConsoleColor)Enum.Parse(typeof(ConsoleColor), colorNames[x]);
		Console.Write("This is foreground color {0}.", colorNames[x]);
		Console.ResetColor();
		Console.WriteLine();
		}
	// ---------------------------------------------------------------------------------------
		Console.WriteLine("{0}A constant white foreground on all the background colors.", nl);
		Console.WriteLine("  (White on white is not readable.){0}", nl);

		for (int x = 0; x < colorNames.Length; x++)
		{
		Console.Write("{0,2}: ", x);
		Console.ForegroundColor = ConsoleColor.White;
		Console.BackgroundColor = (ConsoleColor)Enum.Parse(typeof(ConsoleColor), colorNames[x]);
		Console.Write("This is background color {0}.", colorNames[x]);
		Console.ResetColor();
		Console.WriteLine();
		}
	// ---------------------------------------------------------------------------------------
		}
	}
}
/*
This example produces the following results:

All the foreground colors on a constant black background.
  (Black on black is not readable.)

 0: This is foreground color Black.
 1: This is foreground color DarkBlue.
 2: This is foreground color DarkGreen.
 3: This is foreground color DarkCyan.
 4: This is foreground color DarkRed.
 5: This is foreground color DarkMagenta.
 6: This is foreground color DarkYellow.
 7: This is foreground color Gray.
 8: This is foreground color DarkGray.
 9: This is foreground color Blue.
10: This is foreground color Green.
11: This is foreground color Cyan.
12: This is foreground color Red.
13: This is foreground color Magenta.
14: This is foreground color Yellow.
15: This is foreground color White.

A constant white foreground on all the background colors.
  (White on white is not readable.)

 0: This is background color Black.
 1: This is background color DarkBlue.
 2: This is background color DarkGreen.
 3: This is background color DarkCyan.
 4: This is background color DarkRed.
 5: This is background color DarkMagenta.
 6: This is background color DarkYellow.
 7: This is background color Gray.
 8: This is background color DarkGray.
 9: This is background color Blue.
10: This is background color Green.
11: This is background color Cyan.
12: This is background color Red.
13: This is background color Magenta.
14: This is background color Yellow.
15: This is background color White.
*/

#T=Console Spiner
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			ConsoleSpiner spin = new ConsoleSpiner();
			Console.Write("Working....");
			while (true) 
			{
				spin.Turn();
			}
		}

	}

}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public class ConsoleSpiner
	{
		int counter;
		public ConsoleSpiner()
		{
			counter = 0;
		}
		public void Turn()
		{
			Thread.Sleep(500);
			counter++;
			switch (counter % 4)
			{
				case 0: Console.Write("/"); break;
				case 1: Console.Write("-"); break;
				case 2: Console.Write("\\"); break;
				case 3: Console.Write("-"); break;
			}
			Console.SetCursorPosition(Console.CursorLeft - 1, Console.CursorTop);
		}
	}
}

#T=Console Tray
/*
 * 控制台禁用关闭按钮并最小化到系统托盘演示
 * 
 * 通过ConsoleWin32类来进行控制
 * 添加引用 System.Runtime.InteropServices; 和 System.Threading; 用于禁用关闭按钮
 * 添加引用 System.Drawing; 和 System.Windows.Forms; 用于系统托盘
 * 
 */



namespace Tray_beta_1
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Runtime.InteropServices;
	using System.Threading;
	using System.Drawing;
	using System.Windows.Forms;
	class Program
	{
		static bool _IsExit = false;

		static void Main(string[] args)
		{
			Console.Title = "TestConsoleLikeWin32";
			ConsoleWin32Helper.ShowNotifyIcon();
			ConsoleWin32Helper.DisableCloseButton(Console.Title);

			Thread threadMonitorInput = new Thread(new ThreadStart(MonitorInput));
			threadMonitorInput.Start();

			while (true)
			{
				Application.DoEvents();
				if (_IsExit)
				{
					break;
				}
			}
		}

		static void MonitorInput()
		{
			while (true)
			{
				string input = Console.ReadLine();
				if (input == "exit")
				{
					_IsExit = true;
					Thread.CurrentThread.Abort();
				}
			}
		}
	}

	class ConsoleWin32Helper
	{
		static ConsoleWin32Helper()
		{
			//_NotifyIcon.Icon = new Icon();
			_NotifyIcon.Visible = false;
			_NotifyIcon.Text = "tray";

			ContextMenu menu = new ContextMenu();
			MenuItem item = new MenuItem();
			item.Text = "右键菜单，还没有添加事件";
			item.Index = 0;

			menu.MenuItems.Add(item);
			_NotifyIcon.ContextMenu = menu;

			_NotifyIcon.MouseDoubleClick += new MouseEventHandler(_NotifyIcon_MouseDoubleClick);

		}

		static void _NotifyIcon_MouseDoubleClick(object sender, MouseEventArgs e)
		{
			Console.WriteLine("托盘被双击.");
		}

		#region 禁用关闭按钮
		[DllImport("User32.dll", EntryPoint = "FindWindow")]
		static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

		[DllImport("user32.dll", EntryPoint = "GetSystemMenu")]
		static extern IntPtr GetSystemMenu(IntPtr hWnd, IntPtr bRevert);

		[DllImport("user32.dll", EntryPoint = "RemoveMenu")]
		static extern IntPtr RemoveMenu(IntPtr hMenu, uint uPosition, uint uFlags);

		/// <summary>
		/// 禁用关闭按钮
		/// </summary>
		/// <param name="consoleName">控制台名字</param>
		public static void DisableCloseButton(string title)
		{
			//线程睡眠，确保closebtn中能够正常FindWindow，否则有时会Find失败。。
			Thread.Sleep(100);

			IntPtr windowHandle = FindWindow(null, title);
			IntPtr closeMenu = GetSystemMenu(windowHandle, IntPtr.Zero);
			uint SC_CLOSE = 0xF060;
			RemoveMenu(closeMenu, SC_CLOSE, 0x0);
		}
		public static bool IsExistsConsole(string title)
		{
			IntPtr windowHandle = FindWindow(null, title);
			if (windowHandle.Equals(IntPtr.Zero)) return false;

			return true;
		}
		#endregion

		#region 托盘图标
		static NotifyIcon _NotifyIcon = new NotifyIcon();
		public static void ShowNotifyIcon()
		{
			_NotifyIcon.Visible = true;
			_NotifyIcon.ShowBalloonTip(3000, "", "我是托盘图标，用右键点击我试试，还可以双击看看。", ToolTipIcon.None);
		}
		public static void HideNotifyIcon()
		{
			_NotifyIcon.Visible = false;
		}

		#endregion
	}
}
#T=Console Util C# 3.0
namespace ConsoleTest
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	class Program
	{
		static Boolean EXIT = false;
		static void Main(string[] args)
		{
			String id = ConsoleUtil.Readline("请输入帐号:","帐号不能为空.");
			String pwd = ConsoleUtil.ReadPassword("请输入密码:","密码不能为空.");
			Console.WriteLine("欢迎你，"+ id + "!");
			CmdDispatcher cd = CreateDispatcher();
			while (true)
			{
				Console.Write(cd.Prefix);
				String input = cd.ReadlineWithIntelliSence();
				cd.Handle(input);
				if (EXIT) return;
			}
		}

		static CmdDispatcher CreateDispatcher()
		{
			CmdDispatcher cd = new CmdDispatcher();
			cd.AddCmdFunc("help", "无参数", "查询帮助.",
				() => { cd.PrintHelp(); });
			cd.AddCmdFunc("help", "cmd", "查询指定指令的帮助.",
				(cmd) => { cd.PrintHelp(cmd); });
			cd.AddCmdFunc("exit","无参数","退出程序.",
				() => { EXIT = true; });
			cd.AddCmdFunc("cmd1", "无参数", "指令cmd1.",
				() => { Console.WriteLine(String.Format("Invoke cmd1.")); });
			cd.AddCmdFunc("cmd1", "arg0", "指令cmd1.",
				(arg0) => { Console.WriteLine(String.Format("Invoke cmd1({0}).", arg0)); });
			cd.AddCmdFunc("cmd2", "arg0 arg1", "指令cmd1.",
				(arg0, arg1) => { Console.WriteLine(String.Format("Invoke cmd1({0},{1}).", arg0, arg1)); });
			cd.AddCmdFunc("cmd3",
				(arg0, arg1, arg2) => { Console.WriteLine(String.Format("Invoke cmd1({0},{1},{2}).", arg0, arg1, arg2)); });
			return cd;
		}
	}
}
namespace ConsoleTest
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public delegate void Func0();
	public delegate void Func1(String s1);
	public delegate void Func2(String s1, String s2);
	public delegate void Func3(String s1, String s2, String s3);
	public delegate void Func4(String s1, String s2, String s3, String s4);

	public class CmdDispatcher
	{
		protected class CmdFunc<TFunc>
		{
			public TFunc Func { get; set; }
			public String ArgsString { get; set; }
			public String Introduce { get; set; }
			public CmdFunc(TFunc func, String argsString, String introduce)
			{
				Func = func; ArgsString = argsString; Introduce = introduce;
			}
			public CmdFunc(TFunc func)
				: this(func, String.Empty, String.Empty)
			{ }
		}

		protected class CmdHistory
		{
			public Int32 MaxCount { get; set; }
			public LinkedList<String> History { get; set; }
			public Int32 Count { get { return History.Count; } }
			public void Add(String cmd)
			{
				if (Count > MaxCount) History.RemoveLast();
				History.AddAfter(EmptyFirst, cmd);
				Now = History.First;
			}
			public LinkedListNode<String> Now { get; set; }
			protected LinkedListNode<String> EmptyFirst { get; set; }
			protected LinkedListNode<String> EmptyLast { get; set; }
			public CmdHistory()
			{
				History = new LinkedList<string>();
				History.AddFirst(String.Empty);
				History.AddFirst(String.Empty);
				EmptyFirst = History.First;
				EmptyLast = History.Last;
				MaxCount = 100;
			}

			public LinkedListNode<String> Previous
			{
				get
				{
					if (Now != null)
					{
						if (Now.Next != History.Last)
						{
							Now = Now.Next;
						}
					}
					return Now;
				}
			}

			public LinkedListNode<String> Next
			{
				get
				{
					if (Now != null)
					{
						if (Now.Previous != History.First)
						{
							Now = Now.Previous;
						}
					}
					return Now;
				}
			}
		}

		public readonly static char[] SPLIT_CHARS = { ' ', '\t' };

		private IDictionary<String, CmdFunc<Func0>> Func0Dic = new Dictionary<String, CmdFunc<Func0>>();
		private IDictionary<String, CmdFunc<Func1>> Func1Dic = new Dictionary<String, CmdFunc<Func1>>();
		private IDictionary<String, CmdFunc<Func2>> Func2Dic = new Dictionary<String, CmdFunc<Func2>>();
		private IDictionary<String, CmdFunc<Func3>> Func3Dic = new Dictionary<String, CmdFunc<Func3>>();
		private IDictionary<String, CmdFunc<Func4>> Func4Dic = new Dictionary<String, CmdFunc<Func4>>();
		private CmdHistory InnerCmdHistory { get; set; }
		private HashSet<String> CmdSet = new HashSet<String>();

		public Func0 DefaultFunc { get; set; }

		public String Prefix { get; set; }

		public CmdDispatcher()
		{
			DefaultFunc = delegate() { Console.WriteLine("解析错误."); };
			Prefix = ">>";
			InnerCmdHistory = new CmdHistory();
		}

		public void AddCmdFunc(String cmd, Func0 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func0Dic); }
		public void AddCmdFunc(String cmd, Func1 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func1Dic); }
		public void AddCmdFunc(String cmd, Func2 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func2Dic); }
		public void AddCmdFunc(String cmd, Func3 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func3Dic); }
		public void AddCmdFunc(String cmd, Func4 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func4Dic); }
		public void AddCmdFunc(String cmd, String argsString, String introduce, Func0 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func0Dic, argsString, introduce); }
		public void AddCmdFunc(String cmd, String argsString, String introduce, Func1 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func1Dic, argsString, introduce); }
		public void AddCmdFunc(String cmd, String argsString, String introduce, Func2 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func2Dic, argsString, introduce); }
		public void AddCmdFunc(String cmd, String argsString, String introduce, Func3 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func3Dic, argsString, introduce); }
		public void AddCmdFunc(String cmd, String argsString, String introduce, Func4 func)
		{ AddCmdFuncIntoFuncDic(cmd, func, Func4Dic, argsString, introduce); }

		/// <summary>
		/// 处理指令。
		/// CmdDispatcher 自动在指令库中寻找匹配能处理相同参数的cmd指令委托，执行该委托。
		/// 如果找不到合适的指令委托，则执行默认的指令委托 DefaultFunc 。
		/// </summary>
		/// <param name="cmd">指令名称</param>
		/// <param name="args">参数列表</param>
		public void Dispatch(String cmd, params String[] args)
		{
			if (args == null || args.Length == 0)
			{
				if (Func0Dic.ContainsKey(cmd)) Func0Dic[cmd].Func();
				else DefaultFunc();
			}
			else if (args.Length == 1)
			{
				if (Func1Dic.ContainsKey(cmd)) Func1Dic[cmd].Func(args[0]);
				else DefaultFunc();
			}
			else if (args.Length == 2)
			{
				if (Func2Dic.ContainsKey(cmd)) Func2Dic[cmd].Func(args[0], args[1]);
				else DefaultFunc();
			}
			else if (args.Length == 3)
			{
				if (Func3Dic.ContainsKey(cmd)) Func3Dic[cmd].Func(args[0], args[1], args[2]);
				else DefaultFunc();
			}
			else if (args.Length == 4)
			{
				if (Func4Dic.ContainsKey(cmd)) Func4Dic[cmd].Func(args[0], args[1], args[2], args[3]);
				else DefaultFunc();
			}
			else throw new ArgumentException("参数过多.");
		}

		/// <summary>
		/// 处理指令。指令格式为：
		///	 cmd arg0 arg1 arg2
		/// CmdDispatcher 自动在指令库中寻找匹配能处理相同参数的cmd指令委托，执行该委托。
		/// 如果找不到合适的指令委托，则执行默认的指令委托 DefaultFunc 。
		/// </summary>
		/// <param name="input">输入的指令。</param>
		public void Handle(String input)
		{
			InnerCmdHistory.Add(input);
			String[] words = input.Split(SPLIT_CHARS, StringSplitOptions.RemoveEmptyEntries);
			if (words == null || words.Length == 0) throw new ArgumentException("参数解析错误.");

			if (words.Length == 0) this.Dispatch(words[0]);
			else
			{
				String cmd = words[0];
				String[] args = new String[words.Length - 1];
				for (int i = 0; i < words.Length - 1; i++)
				{
					args[i] = words[i + 1];
				}
				this.Dispatch(cmd, args);
			}
		}

		/// <summary>
		/// 带有指令自动补全功能的命令行读取工具。输入 tab 键激活补全功能。只能补全添加到本 CmdDispatcher 中的指令。
		/// </summary>
		/// <returns>指令字符串</returns>
		public String ReadlineWithIntelliSence()
		{
			String text = "";
			ConsoleKeyInfo info = Console.ReadKey(true);
			while (info.Key != ConsoleKey.Enter)
			{
				if (info.Key == ConsoleKey.UpArrow)
				{
					LinkedListNode<String> now = InnerCmdHistory.Previous;
					
					if (now != null)
					{
						Backspace(text.Length);
						text = now.Value.ToString();
						Console.Write(now.Value.ToString());
					}
				}
				else if (info.Key == ConsoleKey.DownArrow)
				{
					LinkedListNode<String> now = InnerCmdHistory.Next;
					if (now != null)
					{
						Backspace(text.Length);
						text = now.Value.ToString();
						Console.Write(now.Value.ToString());
					}
				}
				else if (info.Key == ConsoleKey.Tab)
				{
					String prefix = text.TrimStart();
					if (!String.IsNullOrEmpty(prefix))
					{
						IList<String> matchers = this.FindCmdsStartsWith(prefix);
						if (matchers.Count == 0) Console.Beep();
						if (matchers.Count == 1)
						{
							Console.Write(matchers[0].Substring(text.Length));
							text = matchers[0];
						}
						else
						{
							Console.WriteLine();
							foreach (String matcher in matchers)
							{
								Console.Write(matcher);
								Console.Write("\t");
							}
							Console.WriteLine();
							Console.Write(Prefix + text);
						}
					}
				}
				else if (info.Key == ConsoleKey.Backspace)
				{
					if (text != "")
					{
						text = text.Substring(0, text.Length - 1);
						Backspace(1);
					}
				}
				else
				{
					if (info.KeyChar != '\0')
					{
						text += info.KeyChar;
						Console.Write(info.KeyChar);
					}
				}

				info = Console.ReadKey(true);
			}

			Console.WriteLine();

			return text;
		}

		public void PrintHelp()
		{
			foreach (String cmd in this.CmdSet)
			{
				PrintCmdHelp(cmd);
			}
		}

		public void PrintHelp(String cmd)
		{
			if (!this.CmdSet.Contains(cmd)) Console.WriteLine("指令{0}不存在.", cmd);
			else PrintCmdHelp(cmd);
		}

		protected void PrintCmdHelp(String cmd)
		{
			PrintCmdHelpInFuncDic<Func0>(cmd, Func0Dic);
			PrintCmdHelpInFuncDic<Func1>(cmd, Func1Dic);
			PrintCmdHelpInFuncDic<Func2>(cmd, Func2Dic);
			PrintCmdHelpInFuncDic<Func3>(cmd, Func3Dic);
			PrintCmdHelpInFuncDic<Func4>(cmd, Func4Dic);
		}

		protected void PrintCmdHelpInFuncDic<TFunc>(String cmd, IDictionary<String, CmdFunc<TFunc>> funcDic)
		{
			if (funcDic.ContainsKey(cmd))
			{
				CmdFunc<TFunc> cf = funcDic[cmd];
				Console.Write(cmd + "\t");
				if (String.IsNullOrEmpty(cf.ArgsString))
				{
					Console.Write("无参数");
				}
				else
				{
					Console.Write(cf.ArgsString);
				}
				Console.WriteLine();
				if (!String.IsNullOrEmpty(cf.Introduce))
				{
					Console.WriteLine(String.Format("\t{0}", cf.Introduce));
				}
				Console.WriteLine();
			}
		}

		protected void AddCmdFuncIntoFuncDic<TFunc>
			(String cmd, TFunc func, IDictionary<String, CmdFunc<TFunc>> funcDic)
		{
			this.AddCmdFuncIntoFuncDic<TFunc>(cmd, func, funcDic, String.Empty, String.Empty);
		}

		protected void AddCmdFuncIntoFuncDic<TFunc>
			(String cmd, TFunc func, IDictionary<String, CmdFunc<TFunc>> funcDic, String argsString, String introduce)
		{
			try
			{
				funcDic.Add(cmd, new CmdFunc<TFunc>(func, argsString, introduce));
				if (!this.CmdSet.Contains(cmd))
				{ this.CmdSet.Add(cmd); }
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
			}
		}

		protected IList<String> FindCmdsStartsWith(String prefix)
		{
			IList<String> matchList = new List<String>();
			foreach (String s in this.CmdSet)
			{
				if (s.StartsWith(prefix)) matchList.Add(s);
			}
			return matchList;
		}

		protected void Backspace(Int32 count)
		{
			for (int i = 0; i < count; i++)
			{
				Console.Write("\b \b");
			}
		}
	}
}
namespace ConsoleTest
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public class ConsoleUtil
	{
		public static String Readline(String msg, String errMsgOnNull)
		{
			String text;
			while (true)
			{
				Console.Write(msg);
				text = Console.ReadLine().Trim();
				if (String.IsNullOrEmpty(text))
				{
					Console.WriteLine(errMsgOnNull);
				}
				else break;
			}
			return text;
		}

		public static String ReadPassword(String msg, String errMsgOnNull)
		{
			String password;
			while (true)
			{
				Console.Write(msg);
				password = "";
				ConsoleKeyInfo info = Console.ReadKey(true);
				while (info.Key != ConsoleKey.Enter)
				{
					if (info.Key != ConsoleKey.Backspace)
					{
						if (info.KeyChar != '\0')
						{
							password += info.KeyChar;
							Console.Write("*");
						}
					}
					else if (info.Key == ConsoleKey.Backspace)
					{
						if (password != "")
						{
							password = password.Substring(0, password.Length - 1);
							Console.Write(info.KeyChar);
							Console.Write(" ");
							Console.Write(info.KeyChar);
						}
					}
					info = Console.ReadKey(true);
				}
				if (String.IsNullOrEmpty(password))
				{
					Console.WriteLine(errMsgOnNull);
				}
				else
				{
					Console.WriteLine();
					break;
				}
			}
			return password;
		}
	}
}

#T=Console WaitForEnd
/*
给枯燥的 .Net 命令行控制台程序来点儿心跳(关于退格[\b]的使用)
雕虫小技 见笑
Java 同理
*/

public class Class1
{
	public static bool b;
	static void Main(string[] args)
	{
		System.Console.WriteLine("测试1: 直接等待 n = 199 次循环");
		Wait(199);

		System.Console.WriteLine("\n\n测试2: 等待结束条件: b == true");
		// 主程序 开始
		b = false;
		new System.Threading.Thread(new System.Threading.ThreadStart(DoWait)).Start(); //监视线程: 显示滚动计数器
		//以下是耗时的主程序
		System.Threading.Thread.Sleep(5 * 1000); //主程序耗时 5 秒
		b = true; //主程序 结束
		System.Console.WriteLine("\n主程序耗时 5 秒\n");

	}
	

	private static void Wait(int Count)
	{
		System.Console.Write("\n在进行第    ");
		string bs = ""; //用于记录上次的位数
		for (int i = 0; i < Count + 1; i++)
		{
			System.Threading.Thread.Sleep(10); // 10/1000 second
			System.Console.Write(bs + "\b\b\b" + i + " 次," + System.DateTime.Now);
			bs = new string('\b',Digits(i) + 19 + 1); //19 为日期时间字符串长度, 1 是 ","
		}
	}

	private static void DoWait()
	{
		Wait(ref b); //由委托调用的真正函数
	}

	private static void Wait(ref bool Flag) //Flag 可在其他线程改
	{
		System.Console.Write("\n在进行第    ");
		int i = 0;
		string bs = "";
		while (!Flag)
		{
			//System.Threading.Thread.Sleep(1000); // 1 second
			System.Console.Write(bs + "\b\b\b" + i + " 次," + System.DateTime.Now);
			bs = new string('\b',Digits(i) + 19 + 1); //19 为日期时间字符串长度, 1 是 ","
			i ++;
		}
	}

	static int Digits(int n) //数字所占位数
	{
		n = System.Math.Abs(n) ;
		n = n/10;
		int i = 1;
		while (n > 0)
		{
			n = n / 10;
			i++;
		}
		return i;
	}
}

#T=Console.ReadLine input
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine()))
			{
				
			}
#T=ConsoleProgressBar
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	class Program
	{
		static void Main(string[] args)
		{
			bool isBreak = false;
			ConsoleColor colorBack = Console.BackgroundColor;
			ConsoleColor colorFore = Console.ForegroundColor;
			//第一行信息
			Console.WriteLine("*********** running ******");
			//第二行绘制进度条背景
			Console.BackgroundColor = ConsoleColor.DarkCyan;
			for (int i = 0; ++i <= 25; )
			{
				Console.Write(" ");
			}
			Console.WriteLine(" ");
			Console.BackgroundColor = colorBack;
			//第三行输出进度
			Console.WriteLine("0%");
			//第四行输出提示,按下回车可以取消当前进度
			Console.WriteLine("<Press Enter To Break.>");
			//-----------------------上面绘制了一个完整的工作区域,下面开始工作
			//开始控制进度条和进度变化 
			for (int i = 0; ++i <= 100; )
			{
				//先检查是否有按键请求,如果有,判断是否为回车键,如果是则退出循环 
				if
					(
						Console.KeyAvailable
						&& Console.ReadKey(true).Key == ConsoleKey.Enter
					)
				{
					isBreak = true;
					break;
				}
				//绘制进度条进度
				Console.BackgroundColor = ConsoleColor.Yellow;//设置进度条颜色
				Console.SetCursorPosition(i / 4, 1);
				//设置光标位置,参数为第几列和第几行
				Console.Write(" ");//移动进度条
				Console.BackgroundColor = colorBack;//恢复输出颜色
				//更新进度百分比,原理同上.
				Console.ForegroundColor = ConsoleColor.Green;
				Console.SetCursorPosition(0, 2);
				Console.Write("{0}%", i);
				Console.ForegroundColor = colorFore;
				//模拟实际工作中的延迟,否则进度太快
				System.Threading.Thread.Sleep(100);
			}
			//工作完成,根据实际情况输出信息,而且清楚提示退出的信息
			Console.SetCursorPosition(0, 3);
			Console.Write(isBreak ? "break!!!" : "finished.");
			Console.WriteLine(" ");
			//等待退出
			Console.ReadKey(true);
		}
	}
}
//=============================================================================================================
 namespace Test
{
	using System;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			Random r = new Random();
			while (true)
			{
				ConsoleProgressBar bar = new ConsoleProgressBar("测试ConsoleApplication ProgressBar");
				int c = r.Next(534);
				for (int i = 1; i <= c; i++)
				{
					bar.Update(i, c, string.Format("完成进度：{0}/{1}", i, c));
					System.Threading.Thread.Sleep(10);
				}
				// 等待退出 
				Console.ReadKey(true);
			}	
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Text;
	using System.Linq;
	using System.Runtime.InteropServices;
	public class ConsoleProgressBar
	{
		int left = 0;
		int backgroundLength = 50;
		#region [ window api ]
		ConsoleColor colorBack = Console.BackgroundColor;
		ConsoleColor colorFore = Console.ForegroundColor;
		private const int STD_OUTPUT_HANDLE = -11;
		private int mHConsoleHandle;
		COORD barCoord;
		[StructLayout(LayoutKind.Sequential)]
		public struct COORD
		{
			public short X;
			public short Y;
			public COORD(short x, short y)
			{
				X = x;
				Y = y;
			}
		}
		[StructLayout(LayoutKind.Sequential)]
		struct SMALL_RECT
		{
			public short Left;
			public short Top;
			public short Right;
			public short Bottom;
		}
		[StructLayout(LayoutKind.Sequential)]
		struct CONSOLE_SCREEN_BUFFER_INFO
		{
			public COORD dwSize;
			public COORD dwCursorPosition;
			public int wAttributes;
			public SMALL_RECT srWindow;
			public COORD dwMaximumWindowSize;
		}
		[DllImport("kernel32.dll", EntryPoint = "GetStdHandle", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
		private static extern int GetStdHandle(int nStdHandle);
		[DllImport("kernel32.dll", EntryPoint = "GetConsoleScreenBufferInfo", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
		private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput, out CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
		[DllImport("kernel32.dll", EntryPoint = "SetConsoleCursorPosition", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
		private static extern int SetConsoleCursorPosition(int hConsoleOutput, COORD dwCursorPosition);
		public void SetCursorPos(short x, short y)
		{
			SetConsoleCursorPosition(mHConsoleHandle, new COORD(x, y));
		}
		public COORD GetCursorPos()
		{
			CONSOLE_SCREEN_BUFFER_INFO res;
			GetConsoleScreenBufferInfo(mHConsoleHandle, out res);
			return res.dwCursorPosition;
		}
		#endregion
		public ConsoleProgressBar(string title, int left = 10)
		{
			Console.WriteLine();
			//获取当前窗体句柄
			mHConsoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
			//获取当前窗体偏移量
			barCoord = this.GetCursorPos();
			this.left = left;
			//获取字符长度
			int len = GetStringLength(title);
			//设置标题的相对居中位置
			Console.SetCursorPosition(left + (backgroundLength / 2 - len), barCoord.Y);
			Console.Write(title);
			//写入进度条背景
			Console.BackgroundColor = ConsoleColor.DarkCyan;
			Console.SetCursorPosition(left, barCoord.Y + 1);
			for (int i = 0; ++i <= backgroundLength; )
				Console.Write(" ");
			Console.WriteLine();
			Console.BackgroundColor = colorBack;
		}
		/// <summary>
		/// 更新进度条
		/// </summary>
		/// <param name="current">当前进度</param>
		/// <param name="total">总进度</param>
		/// <param name="message">说明文字</param>
		public void Update(int current, int total, string message)
		{
			//计算百分比
			int i = (int)Math.Ceiling(current / (double)total * 100);
			Console.BackgroundColor = ConsoleColor.Yellow;
			Console.SetCursorPosition(left, barCoord.Y + 1);
			//写入进度条
			StringBuilder bar = new StringBuilder();
			//当前百分比*进度条总长度=要输出的进度最小单位数量
			int count = (int)Math.Ceiling((double)i / 100 * backgroundLength);
			for (int n = 0; n < count; n++) bar.Append(" ");
			Console.Write(bar);
			//设置和写入百分比
			Console.BackgroundColor = colorBack;
			Console.ForegroundColor = ConsoleColor.Green;
			Console.SetCursorPosition(left + backgroundLength, barCoord.Y + 1);
			Console.Write(" {0}% ", i);
			Console.ForegroundColor = colorFore;
			//获取字符长度
			int len = GetStringLength(message);
			//获取相对居中的message偏移量
			Console.SetCursorPosition(left + (backgroundLength / 2 - len), barCoord.Y + 2);
			Console.Write(message);
			//进度完成另起新行作为输出
			if (i >= 100) Console.WriteLine();
		}
		/// <summary>
		/// 获取字符长度
		/// </summary>
		/// <remarks>中文和全角占长度1，英文和半角字符2个字母占长度1</remarks>
		/// <param name="message"></param>
		/// <returns></returns>
		private int GetStringLength(string message)
		{
			int len = Encoding.ASCII.GetBytes(message).Count(b => b == 63);
			return (message.Length - len) / 2 + len;
		}
	}
}

#T=ConsoleReadMaskLine
namespace Microshaoft
{
	using System;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Enter password:");
			string password = ConsoleReadMaskLine('*',true);
			Console.WriteLine("\n" + password + "]");
			password = ConsoleReadMaskLine('%',false);
			Console.WriteLine("\n" + password + "]");
		}

		public static string ConsoleReadMaskLine
			(
				char PasswordChar
				, bool WithMask
			)
		{
			string password = "";
			ConsoleKey ck;
			string s = @"~!@#$%&*()_+`1234567890-="; //可输入字符
			s += @"QWERTYUIOP{}|qwertyuiop[]\";
			s += "ASDFGHJKL:\"asdfghjkl;'";
			s += "ZXCVBNM<>?zxcvbnm,./ ";

			do
			{
				ConsoleKeyInfo cki = Console.ReadKey(true);
				char c = cki.KeyChar;
				ck = cki.Key;
				int p = Console.CursorLeft;
				if (ck == ConsoleKey.Backspace)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p - 1);
					}
					string right = password.Substring(p);
					password  = left + right;
					Console.Write(c);

					string output = right;
					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}

					output += "\0";
					Console.Write(output);
					if (p > 0)
					{
						p --;
					}
				}
				else if (ck == ConsoleKey.Delete)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p);
					}
					string right = "";
					if (p < password.Length)
					{
						right = password.Substring(p + 1);
					}
					password = left + right;
					//Console.Write(right + " ");

					string output = right;

					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}
					output += "\0";

					Console.Write(output);
				}
				else
				{
					if (s.IndexOf(c) >= 0)
					{
						string left = password.Substring(0, p);
						string right = password.Substring(p);
						password = left + c + right;

						string output = c + right;

						if (WithMask)
						{
							output = GetPasswordChars(c + right, PasswordChar);
						}
						Console.Write(output);

						p ++;
					}
					else
					{
						switch (ck)
						{
							case ConsoleKey.LeftArrow :
								if (p > 0)
								{
									p --;
								}
								break;
							case ConsoleKey.RightArrow :
								if (p < password.Length)
								{
									p ++;
								}
								break;
							case ConsoleKey.Home :
								p = 0;
								break;
							case ConsoleKey.End :
								p = password.Length;
								break;
							default :
								Console.Beep();
								break;
						}
					}
				}
				Console.CursorLeft = p;
			} while (ck != ConsoleKey.Enter);
			return password;
		}
		private static string GetPasswordChars(string s, char c)
		{
			string passwordChars = "";
			for (int i = 0; i < s.Length; i++)
			{
				passwordChars += c;
			}
			return passwordChars;
		}
	}
}
#T=ConsoleWin32NativeMethodsHelper
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			ConsoleWin32NativeMethordsHelper.EchoInput = false;
			string s = Console.ReadLine();
			ConsoleWin32NativeMethordsHelper.EchoInput = true;
			Console.WriteLine(s);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	/*
		Copyright ?2002, The KPD-Team
		All rights reserved.
		http://www.mentalis.org/

		Redistribution and use in source and binary forms, with or without
		modification, are permitted provided that the following conditions
		are met:

		- Redistributions of source code must retain the above copyright
			 notice, this list of conditions and the following disclaimer. 

		- Neither the name of the KPD-Team, nor the names of its contributors
			 may be used to endorse or promote products derived from this
			 software without specific prior written permission. 

		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
		FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
		THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
		INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
		(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
		SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
		HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
		STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
		ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
		OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	using System;
	using System.Text;
	using System.Runtime.InteropServices;
	/// <summary>
	/// The CONSOLE_CURSOR_INFO structure contains information about the console cursor.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	internal struct CONSOLE_CURSOR_INFO {
		/// <summary>Specifies a number between 1 and 100, indicating the percentage of the character cell that is filled by the cursor. The cursor appearance varies, ranging from completely filling the cell to showing up as a horizontal line at the bottom of the cell.</summary>
		public int dwSize;
		/// <summary>Specifies the visibility of the cursor. If the cursor is visible, this member is TRUE (nonzero).</summary>
		public int bVisible;
	}
	/// <summary>
	/// The COORD structure defines the coordinates of a character cell in a console screen buffer. The origin of the coordinate system (0,0) is at the top, left cell of the buffer.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	internal struct COORD {
		/// <summary>Horizontal or column value.</summary>
		public short x;
		/// <summary>Vertical or row value.</summary>
		public short y;
	}
	/// <summary>
	/// The SMALL_RECT structure defines the coordinates of the upper left and lower right corners of a rectangle.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	internal struct SMALL_RECT {
		/// <summary>Specifies the x-coordinate of the upper left corner of the rectangle.</summary>
		public short Left;
		/// <summary>Specifies the y-coordinate of the upper left corner of the rectangle.</summary>
		public short Top;
		/// <summary>Specifies the x-coordinate of the lower right corner of the rectangle.</summary>
		public short Right;
		/// <summary>Specifies the y-coordinate of the lower right corner of the rectangle.</summary>
		public short Bottom;
	}
	/// <summary>
	/// The CONSOLE_SCREEN_BUFFER_INFO structure contains information about a console screen buffer.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	internal struct CONSOLE_SCREEN_BUFFER_INFO {
		/// <summary>Specifies the size, in character columns and rows, of the screen buffer.</summary>
		public COORD dwSize;
		/// <summary>Specifies the column and row coordinates of the cursor in the screen buffer.</summary>
		public COORD dwCursorPosition;
		/// <summary>Specifies the foreground (text) and background color attributes to be used for characters that are written to a screen buffer by the WriteFile and WriteConsole functions, or echoed to a screen buffer by the ReadFile and ReadConsole functions. The attribute values are some combination of the following values: FOREGROUND_BLUE, FOREGROUND_GREEN, FOREGROUND_RED, FOREGROUND_INTENSITY, BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED, and BACKGROUND_INTENSITY.</summary>
		public short wAttributes;
		/// <summary>Specifies a SMALL_RECT structure that contains the screen buffer coordinates of the upper-left and lower-right corners of the display window.</summary>
		public SMALL_RECT srWindow;
		/// <summary>Specifies the maximum size of the console window, given the current screen buffer size and font and the screen size.</summary>
		public COORD dwMaximumWindowSize;
	}
	/// <summary>Enumerates all available colors for the forecolor or the backcolor of the console.</summary>
	public enum ConsoleColor : int {
		/// <summary>Black</summary>
		Black = 0,
		/// <summary>Red</summary>
		Red = 1,
		/// <summary>Light red</summary>
		LightRed = 2,
		/// <summary>Green</summary>
		Green = 3,
		/// <summary>Light green</summary>
		LightGreen = 4,
		/// <summary>Blue</summary>
		Blue = 5,
		/// <summary>Light blue</summary>
		LightBlue = 6,
		/// <summary>Gold</summary>
		Gold = 7,
		/// <summary>Yellow</summary>
		Yellow = 8,
		/// <summary>Cyan</summary>
		Cyan = 9,
		/// <summary>Light cyan</summary>
		LightCyan = 10,
		/// <summary>Purple</summary>
		Purple = 11,
		/// <summary>Light purple</summary>
		LightPurple = 12,
		/// <summary>Gray</summary>
		Gray = 13,
		/// <summary>White</summary>
		White = 14
	}
	/// <summary>The ConsoleAttributes class can change several attributes of your console window.</summary>
	/// <example>
	/// The following example wil change the forecolor of te console, disable 'EchoInput', ask for a string and show that string.
	///	<code>
	///	ConsoleAttributes.ForeColor = ConsoleColor.White;
	/// Console.Write("Please enter your password: ");
	/// ConsoleAttributes.EchoInput = false;
	/// string ThePass = Console.ReadLine();
	/// ConsoleAttributes.EchoInput = true;
	/// ConsoleAttributes.ForeColor = ConsoleColor.Gray;
	/// Console.WriteLine("");
	/// Console.WriteLine("The password you entered was: " + ThePass);
	/// Console.WriteLine("Press enter to exit...");
	/// Console.Read();
	/// </code>
	/// </example>
	public static class ConsoleWin32NativeMethordsHelper {
		
		
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
		
		/// <summary>
		/// Lists all the possible background color values.
		/// </summary>
		private static int [] BacgroundColors = {0x0, 0x40, 0x80 | 0x40, 0x20, 0x80 | 0x20, 0x10, 0x80 | 0x10, 0x40 | 0x20, 0x80 | 0x40 | 0x20, 0x20 | 0x10, 0x80 | 0x20 | 0x10, 0x40 | 0x10, 0x80 | 0x40 | 0x10, 0x40 | 0x20 | 0x10, 0x80 | 0x40 | 0x20 | 0x10};
		/// <summary>
		/// Lists all the possible foreground color values.
		/// </summary>
		private static int [] ForegroundColors = {0x0, 0x4, 0x8 | 0x4, 0x2, 0x8 | 0x2, 0x1, 0x8 | 0x1, 0x4 | 0x2, 0x8 | 0x4 | 0x2, 0x2 | 0x1, 0x8 | 0x2 | 0x1, 0x4 | 0x1, 0x8 | 0x4 | 0x1, 0x4 | 0x2 | 0x1, 0x8 | 0x4 | 0x2 | 0x1};
		/// <summary>
		/// The SetConsoleTextAttribute function sets the foreground (text) and background color attributes of characters written to the screen buffer by the WriteFile or WriteConsole function, or echoed by the ReadFile or ReadConsole function. This function affects only text written after the function call.
		/// </summary>
		/// <param name="hConsoleOutput">Handle to a console screen buffer. The handle must have GENERIC_READ access.</param>
		/// <param name="wAttributes">Specifies the foreground and background color attributes. Any combination of the following values can be specified: FOREGROUND_BLUE, FOREGROUND_GREEN, FOREGROUND_RED, FOREGROUND_INTENSITY, BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED, and BACKGROUND_INTENSITY.</param>
		/// <returns>If the function succeeds, the return value is nonzero.<br></br><br>If the function fails, the return value is zero. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="SetConsoleTextAttribute", CharSet=CharSet.Ansi)]
		internal static extern int SetConsoleTextAttribute (int hConsoleOutput, int wAttributes);
		/// <summary>
		/// The GetStdHandle function returns a handle for the standard input, standard output, or standard error device.
		/// </summary>
		/// <param name="nStdHandle">Specifies the device for which to return the handle. This parameter can have one of the following values:
		/// <list type="bullet"> 
		///		<listheader>
		///			<value>Value</value>
		///			<meaning>Meaning</meaning>
		///		</listheader>
		///		<item>
		///			<value>STD_INPUT_HANDLE</value>
		///			<meaning>Standard input handle.</meaning>
		///		</item>
		///		<item>
		///			<value>STD_OUTPUT_HANDLE</value>
		///			<meaning>Standard output handle.</meaning>
		///		</item>
		///		<item>
		///			<value>STD_ERROR_HANDLE</value>
		///			<meaning>Standard error handle.</meaning>
		///		</item>
		/// </list>
		/// </param>
		/// <returns>If the function succeeds, the return value is a handle to the specified device.<br></br><br>If the function fails, the return value is the INVALID_HANDLE_VALUE flag. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="GetStdHandle")]
		internal static extern int GetStdHandle (int nStdHandle);
		/// <summary>
		/// The SetConsoleCursorInfo function sets the size and visibility of the cursor for the specified console screen buffer.
		/// </summary>
		/// <param name="hConsoleOutput">Handle to a console screen buffer. The handle must have GENERIC_WRITE access.</param>
		/// <param name="lpConsoleCursorInfo">Pointer to a CONSOLE_CURSOR_INFO structure containing the new specifications for the screen buffer's cursor.</param>
		/// <returns>If the function succeeds, the return value is nonzero.<br></br><br>If the function fails, the return value is zero. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="SetConsoleCursorInfo")]
		internal static extern int SetConsoleCursorInfo (int hConsoleOutput, ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);
		/// <summary>
		/// The GetConsoleMode function reports the current input mode of a console's input buffer or the current output mode of a console screen buffer.
		/// </summary>
		/// <param name="hConsoleHandle">Handle to a console input buffer or a screen buffer. The handle must have GENERIC_READ access.</param>
		/// <param name="lpConsoleCursorInfo">
		/// Pointer to a 32-bit variable that indicates the current mode of the specified buffer.<br>If the hConsoleHandle parameter is an input handle, the mode can be a combination of the following values. When a console is created, all input modes except ENABLE_WINDOW_INPUT are enabled by default.</br>
		/// <list type="bullet">
		/// 	<listheader>
		/// 		<value>Value</value>
		/// 		<meaning>Meaning</meaning>
		/// 	</listheader>
		/// 	<item>
		/// 		<value>ENABLE_LINE_INPUT</value>
		/// 		<meaning>The ReadFile or ReadConsole function returns only when a carriage return character is read. If this mode is disabled, the functions return when one or more characters are available.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_ECHO_INPUT</value>
		/// 		<meaning>Characters read by the ReadFile or ReadConsole function are written to the active screen buffer as they are read. This mode can be used only if the ENABLE_LINE_INPUT mode is also enabled.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_PROCESSED_INPUT</value>
		/// 		<meaning>ctrl+c is processed by the system and is not placed in the input buffer. If the input buffer is being read by ReadFile or ReadConsole, other control keys are processed by the system and are not returned in the ReadFile or ReadConsole buffer. If the ENABLE_LINE_INPUT mode is also enabled, backspace, carriage return, and linefeed characters are handled by the system.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_WINDOW_INPUT</value>
		/// 		<meaning>User interactions that change the size of the console screen buffer are reported in the console's input buffer. Information about these events can be read from the input buffer by applications using the ReadConsoleInput function, but not by those using ReadFile or ReadConsole.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_MOUSE_INPUT</value>
		/// 		<meaning>If the mouse pointer is within the borders of the console window and the window has the keyboard focus, mouse events generated by mouse movement and button presses are placed in the input buffer. These events are discarded by ReadFile or ReadConsole, even when this mode is enabled.</meaning>
		/// 	</item>
		/// </list>
		/// If the hConsoleHandle parameter is a screen buffer handle, the mode can be a combination of the following values. When a screen buffer is created, both output modes are enabled by default.
		/// <list type="bullet">
		/// 	<listheader>
		/// 		<value>Value</value>
		/// 		<meaning>Meaning</meaning>
		/// 	</listheader>
		/// 	<item>
		/// 		<value>ENABLE_PROCESSED_OUTPUT</value>
		/// 		<meaning>Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are parsed for ASCII control sequences, and the correct action is performed. Backspace, tab, bell, carriage return, and linefeed characters are processed.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_WRAP_AT_EOL_OUTPUT</value>
		/// 		<meaning>When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row. This causes the rows displayed in the console window to scroll up automatically when the cursor advances beyond the last row in the window. It also causes the contents of the screen buffer to scroll up (discarding the top row of the screen buffer) when the cursor advances beyond the last row in the screen buffer. If this mode is disabled, the last character in the row is overwritten with any subsequent characters.</meaning>
		/// 	</item>
		/// </list>
		/// </param>
		/// <returns>If the function succeeds, the return value is nonzero.<br></br><br>If the function fails, the return value is zero. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="GetConsoleMode")]
		internal static extern int GetConsoleMode (int hConsoleHandle, ref int lpConsoleCursorInfo);
		/// <summary>
		/// The SetConsoleMode function sets the input mode of a console's input buffer or the output mode of a console screen buffer.
		/// </summary>
		/// <param name="hConsoleHandle">Handle to a console input buffer or a screen buffer. The handle must have GENERIC_WRITE access.</param>
		/// <param name="lpConsoleCursorInfo">
		/// Pointer to a 32-bit variable that indicates the current mode of the specified buffer.<br>If the hConsoleHandle parameter is an input handle, the mode can be a combination of the following values. When a console is created, all input modes except ENABLE_WINDOW_INPUT are enabled by default.</br>
		/// <list type="bullet">
		/// 	<listheader>
		/// 		<value>Value</value>
		/// 		<meaning>Meaning</meaning>
		/// 	</listheader>
		/// 	<item>
		/// 		<value>ENABLE_LINE_INPUT</value>
		/// 		<meaning>The ReadFile or ReadConsole function returns only when a carriage return character is read. If this mode is disabled, the functions return when one or more characters are available.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_ECHO_INPUT</value>
		/// 		<meaning>Characters read by the ReadFile or ReadConsole function are written to the active screen buffer as they are read. This mode can be used only if the ENABLE_LINE_INPUT mode is also enabled.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_PROCESSED_INPUT</value>
		/// 		<meaning>ctrl+c is processed by the system and is not placed in the input buffer. If the input buffer is being read by ReadFile or ReadConsole, other control keys are processed by the system and are not returned in the ReadFile or ReadConsole buffer. If the ENABLE_LINE_INPUT mode is also enabled, backspace, carriage return, and linefeed characters are handled by the system.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_WINDOW_INPUT</value>
		/// 		<meaning>User interactions that change the size of the console screen buffer are reported in the console's input buffer. Information about these events can be read from the input buffer by applications using the ReadConsoleInput function, but not by those using ReadFile or ReadConsole.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_MOUSE_INPUT</value>
		/// 		<meaning>If the mouse pointer is within the borders of the console window and the window has the keyboard focus, mouse events generated by mouse movement and button presses are placed in the input buffer. These events are discarded by ReadFile or ReadConsole, even when this mode is enabled.</meaning>
		/// 	</item>
		/// </list>
		/// If the hConsoleHandle parameter is a screen buffer handle, the mode can be a combination of the following values. When a screen buffer is created, both output modes are enabled by default.
		/// <list type="bullet">
		/// 	<listheader>
		/// 		<value>Value</value>
		/// 		<meaning>Meaning</meaning>
		/// 	</listheader>
		/// 	<item>
		/// 		<value>ENABLE_PROCESSED_OUTPUT</value>
		/// 		<meaning>Characters written by the WriteFile or WriteConsole function or echoed by the ReadFile or ReadConsole function are parsed for ASCII control sequences, and the correct action is performed. Backspace, tab, bell, carriage return, and linefeed characters are processed.</meaning>
		/// 	</item>
		/// 	<item>
		/// 		<value>ENABLE_WRAP_AT_EOL_OUTPUT</value>
		/// 		<meaning>When writing with WriteFile or WriteConsole or echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next row when it reaches the end of the current row. This causes the rows displayed in the console window to scroll up automatically when the cursor advances beyond the last row in the window. It also causes the contents of the screen buffer to scroll up (discarding the top row of the screen buffer) when the cursor advances beyond the last row in the screen buffer. If this mode is disabled, the last character in the row is overwritten with any subsequent characters.</meaning>
		/// 	</item>
		/// </list>
		/// </param>
		/// <returns>If the function succeeds, the return value is nonzero.<br></br><br>If the function fails, the return value is zero. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="SetConsoleMode")]
		internal static extern int SetConsoleMode (int hConsoleHandle, int lpConsoleCursorInfo);
		/// <summary>
		/// The SetConsoleTitle function sets the title bar string for the current console window.
		/// </summary>
		/// <param name="lpConsoleTitle">Pointer to a null-terminated string that contains the string to appear in the title bar of the console window.</param>
		/// <returns>If the function succeeds, the return value is nonzero.<br></br><br>If the function fails, the return value is zero. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="SetConsoleTitleA", CharSet=CharSet.Ansi)]
		internal static extern int SetConsoleTitle (string lpConsoleTitle);
		/// <summary>
		/// The GetConsoleTitle function retrieves the title bar string for the current console window.
		/// </summary>
		/// <param name="lpConsoleTitle">Pointer to a buffer that receives a null-terminated string containing the text that appears in the title bar of the console window.</param>
		/// <param name="nSize">Specifies the size, in characters, of the buffer pointed to by the lpConsoleTitle parameter.</param>
		/// <returns>If the function succeeds, the return value is the length, in characters, of the string copied to the buffer.<br></br><br>If the function fails, the return value is zero. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="GetConsoleTitleA", CharSet=CharSet.Ansi)]
		internal static extern int GetConsoleTitle (StringBuilder lpConsoleTitle, int nSize);
		/// <summary>
		/// The GetConsoleScreenBufferInfo function retrieves information about the specified console screen buffer.
		/// </summary>
		/// <param name="hConsoleOutput">Handle to a console screen buffer. The handle must have GENERIC_READ access.</param>
		/// <param name="lpConsoleScreenBufferInfo">Pointer to a CONSOLE_SCREEN_BUFFER_INFO structure in which the screen buffer information is returned.</param>
		/// <returns>If the function succeeds, the return value is nonzero.<br></br><br>If the function fails, the return value is zero. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="GetConsoleScreenBufferInfo")]
		internal static extern int GetConsoleScreenBufferInfo (int hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
		/// <summary>
		/// The SetConsoleCursorPosition function sets the cursor position in the specified console screen buffer.
		/// </summary>
		/// <param name="hConsoleOutput">Handle to a console screen buffer. The handle must have GENERIC_WRITE access.</param>
		/// <param name="dwCursorPosition">Specifies a COORD structure containing the new cursor position. The coordinates are the column and row of a screen buffer character cell. The coordinates must be within the boundaries of the screen buffer.</param>
		/// <returns>If the function succeeds, the return value is nonzero.<br></br><br>If the function fails, the return value is zero. To get extended error information, call GetLastError.</br></returns>
		[DllImport("KERNEL32.DLL", EntryPoint="SetConsoleCursorPosition")]
		internal static extern int SetConsoleCursorPosition (int hConsoleOutput, ref COORD dwCursorPosition);
		/// <summary>Gets or sets the color of the console font.</summary>
		/// <value>A value of the ConsoleColor enum that specifies the color of the console font.</value>
		public static ConsoleColor ForeColor {
			get {
				return m_ForeColor;
			}
			set {
				m_ForeColor = value;
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), ForegroundColors[(int)value] | BacgroundColors[(int)BackColor]);
			}
		}
		/// <summary>Gets or sets the color of the console background.</summary>
		/// <value>A value of the ConsoleColor enum that specifies the color of the console background.</value>
		public static ConsoleColor BackColor {
			get {
				return m_BackColor;
			}
			set {
				m_BackColor = value;
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), ForegroundColors[(int)ForeColor] | BacgroundColors[(int)value]);
			}
		}
		/// <summary>Gets or sets whether the cursor is visible or not.</summary>
		/// <value>A boolean value that specifies the visibility of the cursor.</value>
		public static bool CursorVisible {
			get {
				return m_CursorVisible;
			}
			set {
				m_CursorVisible = value;
				ChangeCursor();
			}
		}
		/// <summary>Gets or sets whether the cursor is in overwrite-mode or not.</summary>
		/// <value>A boolean value that specifies the mode of the cursor.</value>
		/// <remarks>In overwrite mode, the cursor size will be 50% of the character space instead of 25% in normal mode</remarks>
		public static bool OvrMode {
			get {
				return m_OvrMode;
			}
			set {
				m_OvrMode = value;
				ChangeCursor();
			}
		}
		/// <summary>Applies the current cursor settings.</summary>
		/// <remarks>This method applies changes in the CursorVisible and OvrMode properties.</remarks>
		private static void ChangeCursor() {
			CONSOLE_CURSOR_INFO CCI;
			CCI.bVisible = System.Convert.ToInt32(CursorVisible);
			CCI.dwSize = (int)(OvrMode ? 50 : 25);
			SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref CCI);
		}
		/// <summary>Gets or sets whether the console must echo the input or not.</summary>
		/// <value>A boolean value that specifies the console must echo the input or not.</value>
		/// <remarks>EchoInput is often turned off when the program asks the user to type in a password.</remarks>
		public static bool EchoInput {
			get {
				return m_EchoInput;
			}
			set {
				m_EchoInput = value;
				int Ret = 0;
				GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), ref Ret);
				if (EchoInput)
					Ret = Ret | ENABLE_ECHO_INPUT;
				else
					Ret = Ret & ~ENABLE_ECHO_INPUT;
				SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), Ret);
			}
		}
		/// <summary>Gets or sets the caption of the console.</summary>
		/// <value>A String that specifies the caption of the console.</value>
		public static string Caption {
			get {
				StringBuilder sb = new StringBuilder(256);
				GetConsoleTitle(sb, 256);
				return sb.ToString();
			}
			set {
				SetConsoleTitle(value);
			}
		}
		/// <summary>Gets or sets the current cursos position on the x axis in the console.</summary>
		/// <value>A short that specifies the current cursos position on the x axis in the console.</value>
		public static short CursorX {
			get {
				CONSOLE_SCREEN_BUFFER_INFO SBI = new CONSOLE_SCREEN_BUFFER_INFO();
				GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref SBI);
				return SBI.dwCursorPosition.x;
			}
			set {
				MoveCursor(value, CursorY);
			}
		}
		/// <summary>Gets or sets the current cursos position on the y axis in the console.</summary>
		/// <value>A short value that specifies the current cursos position on the y axis in the console.</value>
		public static short CursorY {
			get {
				CONSOLE_SCREEN_BUFFER_INFO SBI = new CONSOLE_SCREEN_BUFFER_INFO();
				GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref SBI);
				return SBI.dwCursorPosition.y;
			}
			set {
				MoveCursor(CursorX, value);
			}
		}
		/// <summary>Moves the cursor to the specified location.</summary>
		/// <param name="x">Specifies the x value of the new location.</param>
		/// <param name="y">Specifies the y value of the new location.</param>
		public static void MoveCursor(short x, short y) {
			COORD Crd;
			Crd.x = x;
			Crd.y = y;
			SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), ref Crd);
		}
		/// <summary>Gets the width (in characters) of the console window.</summary>
		/// <value>An integer that holds the width of the console window in characters.</value>
		public static int WindowWidth {
			get {
				CONSOLE_SCREEN_BUFFER_INFO SBI = new CONSOLE_SCREEN_BUFFER_INFO();
				GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref SBI);
				return SBI.srWindow.Right - SBI.srWindow.Left + 1;
			}
		}
		/// <summary>Gets the height (in characters) of the console window.</summary>
		/// <value>An integer that holds the height of the console window in characters.</value>
		public static int WindowHeight {
			get {
				CONSOLE_SCREEN_BUFFER_INFO SBI = new CONSOLE_SCREEN_BUFFER_INFO();
				GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref SBI);
				return SBI.srWindow.Bottom - SBI.srWindow.Top + 1;
			}
		}
		// Private constants
		/// <summary>Standard output handle.</summary>
		private static int STD_OUTPUT_HANDLE = -11;
		/// <summary>Standard input handle.</summary>
		private static int STD_INPUT_HANDLE = -10;
		/// <summary>Characters read by the ReadFile or ReadConsole function are written to the active screen buffer as they are read. This mode can be used only if the ENABLE_LINE_INPUT mode is also enabled.</summary>
		private static int ENABLE_ECHO_INPUT = 0x4;
		//Private variables
		/// <summary>Holds the forecolor of the console window.</summary>
		private static ConsoleColor m_ForeColor = ConsoleColor.Gray;
		/// <summary>Holds the backcolor of the console window.</summary>
		private static ConsoleColor m_BackColor = ConsoleColor.Black;
		/// <summary>Holds the value of the CursorVisible property.</summary>
		private static bool m_CursorVisible = true;
		/// <summary>Holds the value of the OvrMode property.</summary>
		private static bool m_OvrMode = false;
		/// <summary>Holds the value of the EchoInput property.</summary>
		private static bool m_EchoInput = true;
	}
}
#T=Cookie add
<%@ Page language="c#" AutoEventWireup="true"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" >
<HTML>
	<HEAD>
		<title>Check F5 refresh submit post back repeatly</title>
		<meta name="generator" content="editplus" />
		<meta name="author" content="" />
		<meta name="keywords" content="" />
		<meta name="description" content="" />
	<script language="C#" runat="server">
	protected void Page_Load(object sender, EventArgs ea) 
	{
		string s = Request.QueryString["a"];
		//this.label1.Text = timeStamp;
		HttpCookie cookie = new HttpCookie("testcookie", s);
		cookie.Domain = "service.im.vnet.cn";
		Response.Cookies.Add(cookie);

	}
	</script>
	</HEAD>
	<body>
	</body>
</HTML>
#T=CryptographyHelper New
/*
makecert.exe -n "CN=Microshaoft X509 Test - A" -sky exchange -pe -sv a.pvk a.cer
pvk2pfx.exe -pvk a.pvk -spc a.cer -pfx a.pfx -f -po 123
makecert.exe -n "CN=Microshaoft X509 Test - B" -sky exchange -pe -sv b.pvk b.cer
pvk2pfx.exe -pvk b.pvk -spc b.cer -pfx b.pfx -f -po abc
*/
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using System.Threading;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;
	using Microshaoft;
	class Class1
	{
		static void Main()
		{
			//=======================================
			UTF8Encoding e = new UTF8Encoding();
			string s;
			byte[] data = e.GetBytes
								(
@"测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com
测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com");
			byte[] encryptedData;
			// Hybird
			Console.WriteLine("Hybird(X509+3DES):=====================");
			X509Certificate2 cerA = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\a.cer");
			X509Certificate2 pfxA = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\a.pfx", "123");
			X509Certificate2 cerB = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\b.cer");
			Secret secret = CryptographyHelper.HybridEncrypt
													(
														pfxA
														, cerA
														, cerB
														, HashSignatureMode.SHA1
														, false
														, data
													);
			X509Certificate2 pfxB = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\b.pfx", "abc");
			data = CryptographyHelper.HybridDecrypt(pfxB, secret);
			s = e.GetString(data);
			Console.WriteLine("Hybird decrypted plain text:");
			Console.WriteLine(s);
			//100 字节以内
			s = "测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com测试";
			data = e.GetBytes(s);
			// X509
			Console.WriteLine("\nX509 加解密 只能处理100字节以内的加解密:=====================");
			X509Certificate2[] certs = X509CertificateHelper.LoadCertificatesFromStore
																		(
																			StoreName.My
																			, StoreLocation.CurrentUser
																			, "Microshaoft X509 Test"
																			, X509FindType.FindBySubjectName
																		);
			X509Certificate2 cert = null;
			if (certs != null)
			{
				foreach (X509Certificate2 c in certs)
				{
					Console.WriteLine(c.Subject);
					cert = c;
				}
			}
			X509Certificate2 cer = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\a.cer");
			X509Certificate2 pfx = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\a.pfx", "123");
			encryptedData = CryptographyHelper.X509CertificateEncrypt(cer, data, false);
			encryptedData = CryptographyHelper.X509CertificateDecrypt(pfx, encryptedData, false);
			s = e.GetString(encryptedData);
			Console.WriteLine("X509 decrypted plain text: {0}", s);
			//RSA
			Console.WriteLine("\nRSA 加解密 只能处理100字节以内的加解密:=====================");
			// RSA 非证书 只能处理100字节以内的加解密
			s = "测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com测试";
			data = e.GetBytes(s);
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			string privateKey = x.ToXmlString(true);
			Console.WriteLine("RSA Private Key: {0}", privateKey);
			string publicKey = x.ToXmlString(false);
			Console.WriteLine("RSA Public Key: {0}", publicKey);
			//公钥加密
			encryptedData = CryptographyHelper.RSAEncrypt(publicKey, data, false);
			//私钥解密
			data = CryptographyHelper.RSADecrypt(privateKey, encryptedData, false);
			Console.WriteLine("RSA Decrypted plaintext: {0}", e.GetString(data));
			//私钥签名
			byte[] signature = CryptographyHelper.RSASignSHA1(privateKey, data);
			//公钥验签
			Console.WriteLine(CryptographyHelper.RSAVerifySHA1(publicKey, data, signature));
			//TripleDES
			Console.WriteLine("\nTripleDES:===============");
			string key = "000111222333444555666777888999aaabbbcccdddeeefff";//48
			key = "0123456789abcdef01111111111111111111111111111110";
			string iv = "0123456789abcdef";//16
			iv = "0000000000000000";
			data = e.GetBytes("测试@microshaoft.com");
			SymmetricAlgorithm symmetricAlgorithm = new TripleDESCryptoServiceProvider();
			symmetricAlgorithm.Key = CryptographyHelper.HexStringToBytesArray(key);
			symmetricAlgorithm.IV = CryptographyHelper.HexStringToBytesArray(iv);
			data = CryptographyHelper.SymmetricAlgorithmEncrypt
											(
												symmetricAlgorithm
												, data 
											);
			//"测试@microshaoft.com"
			//3des: "A668632B4AA1EB8C1B25F7E66128846D28CEB416AC7B7B21"
			//篡改: "B668632B4AA1EB8C1B25F7E66128846D28CEB416AC7B7B21"
			data = CryptographyHelper.SymmetricAlgorithmDecrypt
											(
												symmetricAlgorithm, 
												data
											);
			Console.WriteLine("3DES Decrypted plaintext: {0}", e.GetString(data));
			Console.WriteLine("X509 并发测试");
			Console.ReadLine();
			encryptorPrivateKeyPfxProvider = encryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			encryptorPublicKeyCerProvider = encryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			decryptorPublicKeyCerProvider = decryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			decryptorPrivateKeyPfxProvider = decryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			for (int i = 0; i < 1000; i++)
			{
				ThreadStart ts = new ThreadStart(Run);
				Thread t = new Thread(ts);
				t.Name = _ThreadID.ToString();
				_ThreadID++;
				t.Start();
				//Run();
			}
			Console.WriteLine(Environment.Version.ToString());
		}
		private static volatile int _ThreadID = 0;
		private static object _syncLockObject = new object();
		private static X509Certificate2 encryptorPrivateKeyPfx = new X509Certificate2(@"a.pfx", "123");
		private static X509Certificate2 encryptorPublicKeyCer = new X509Certificate2(@"a.cer");
		private static X509Certificate2 decryptorPublicKeyCer = new X509Certificate2(@"b.cer");
		private static X509Certificate2 decryptorPrivateKeyPfx = new X509Certificate2(@"b.pfx", "abc");
		private static RSACryptoServiceProvider encryptorPrivateKeyPfxProvider = null;
		private static RSACryptoServiceProvider encryptorPublicKeyCerProvider = null;
		private static RSACryptoServiceProvider decryptorPublicKeyCerProvider = null;
		private static RSACryptoServiceProvider decryptorPrivateKeyPfxProvider = null;
		static void Run()
		{
			///			X509Certificate2 cerA = null;// = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\a.cer");
			///			X509Certificate2 pfxA = null;// = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\a.pfx", "123");
			///			X509Certificate2 cerB = null;// = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\b.cer");
			///			X509Certificate2 pfxB = null;// = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\b.pfx", "abc");
			//lock (_syncLockObject)
			{
				try
				{
					//Thread.Sleep(50);
					///						cerA = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\a.cer");
					///						pfxA = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\a.pfx", "123");
					///						cerB = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\b.cer");
					///						pfxB = new X509Certificate2(@"C:\Users\xiyueyu\Desktop\b.pfx", "abc");
					UTF8Encoding e = new UTF8Encoding();
					string s;
					byte[] data = e.GetBytes
										(
@"并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com");
					//byte[] encryptedData;
					// Hybird
					//Console.WriteLine("Hybird(X509+3DES):=====================");
					Secret secret = CryptographyHelper.HybridEncrypt
														(
															encryptorPrivateKeyPfxProvider
															, encryptorPublicKeyCer
															, decryptorPublicKeyCerProvider
															, HashSignatureMode.SHA1
															, false
															, data
														);
					data = CryptographyHelper.HybridDecrypt
												(
													decryptorPrivateKeyPfxProvider
													, encryptorPublicKeyCerProvider
													, secret
												);
					s = e.GetString(data);
					Console.WriteLine("Hybird decrypted plain text: {0}", Thread.CurrentThread.Name);
					Console.WriteLine(s);
				}
				catch (Exception e)
				{
					//	Thread.Sleep(1200);
					Console.WriteLine("exception sleep: {0}", e.ToString());
					Console.WriteLine("exception sleep: {0}", Thread.CurrentThread.Name);
					//	Run();
				}
				finally
				{
					///					cerA.Reset();
					///					pfxA.Reset();
					///					cerB.Reset();
					///					cerB.Reset();
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;
	public static class X509CertificateHelper
	{
		public static X509Certificate2[] LoadCertificatesFromStore
											(
												StoreName storeName
												, StoreLocation storeLocation
												, string findValue
												, X509FindType findType
											)
		{
			X509Certificate2[] certs = null;
			X509Store store = new X509Store(storeName, storeLocation);
			store.Open(OpenFlags.ReadOnly);
			try
			{
				X509Certificate2Collection matches = store.Certificates.Find(findType, findValue, false);
				certs = new X509Certificate2[matches.Count];
				matches.CopyTo(certs, 0);
			}
			finally
			{
				store.Close();
			}
			return certs;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;
	public class Secret
	{
		public byte[] EncryptorSharedEncryptedOnceKey;
		public byte[] EncryptorSharedEncryptedOnceIV;
		public byte[] EncryptorHashSignature;
		public byte[] EncryptorPublicKeyCerRawData;
		public byte[] EncryptedData;
		public HashSignatureMode SignHashMode;
		public bool DoOAEPadding;
	}
	public enum HashSignatureMode
	{
		MD5
		, SHA1
	}
	public static class CryptographyHelper
	{
		public static byte[] HybridDecrypt
									(
										X509Certificate2 decryptorPrivateKeyPfx
										, Secret data
									)
		{
			X509Certificate2 encryptorPublicKeyCer = null;
			try
			{
				RSACryptoServiceProvider decryptorPrivateKeyPfxProvider = decryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
				encryptorPublicKeyCer = new X509Certificate2(data.EncryptorPublicKeyCerRawData);
				RSACryptoServiceProvider encryptorPublicKeyCerProvider = encryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
				return HybridDecrypt
									(
										decryptorPrivateKeyPfxProvider
										, encryptorPublicKeyCerProvider
										, data
									);
			}
			catch
			{
				return null;
			}
			finally
			{
				if (encryptorPublicKeyCer != null)
				{
					encryptorPublicKeyCer.Reset();
				}
			}
		}
		public static byte[] HybridDecrypt
									(
										RSACryptoServiceProvider decryptorPrivateKeyPfxProvider
										, RSACryptoServiceProvider encryptorPublicKeyCerProvider
										, Secret data
									)
		{
			byte[] buffer = null;
			HashAlgorithm hashAlgorithm;
			if (data.SignHashMode == HashSignatureMode.SHA1)
			{
				hashAlgorithm = new SHA1CryptoServiceProvider();
			}
			else //(hashSignatureMode == HashSignatureMode.MD5)
			{
				hashAlgorithm = new MD5CryptoServiceProvider();
			}
			using (MemoryStream stream = new MemoryStream())
			{
				buffer = data.EncryptorSharedEncryptedOnceIV;
				stream.Write(buffer, 0, buffer.Length);
				buffer = data.EncryptorSharedEncryptedOnceKey;
				stream.Write(buffer, 0, buffer.Length);
				buffer = data.EncryptedData;
				stream.Position = 0;
				buffer = hashAlgorithm.ComputeHash(stream);
				stream.Close();
			}
			//X509Certificate2 encryptorPublicKeyCer = new X509Certificate2(data.EncryptorPublicKeyCerRawData);
			//RSACryptoServiceProvider encryptorPublicKeyCerProvider = encryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			if (encryptorPublicKeyCerProvider.VerifyHash
												(
													buffer
													, Enum.GetName
																(
																	data.SignHashMode.GetType()
																	, data.SignHashMode
																)
													, data.EncryptorHashSignature
												)
				)
			{
				//decryptorPrivateKeyPfxProvider = decryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
				using (TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider())
				{
					buffer = data.EncryptorSharedEncryptedOnceIV;
					buffer = decryptorPrivateKeyPfxProvider.Decrypt(buffer, data.DoOAEPadding);
					des.IV = buffer;
					buffer = data.EncryptorSharedEncryptedOnceKey;
					buffer = decryptorPrivateKeyPfxProvider.Decrypt(buffer, data.DoOAEPadding);
					des.Key = buffer;
					buffer = data.EncryptedData;
					buffer = des.CreateDecryptor().TransformFinalBlock(buffer, 0, buffer.Length);
				}
			}
			else
			{
				buffer = null;
			}
			return buffer;
		}
		public static Secret HybridEncrypt
									(
										byte[] encryptorPrivateKeyPfxRawData
										, byte[] encryptorPublicKeyCerRawData
										, byte[] decryptorPublicKeyCerRawData
										, HashSignatureMode hashSignatureMode
										, bool DoOAEPadding
										, byte[] data
									)
		{
			X509Certificate2 encryptorPrivateKeyPfx = null;
			X509Certificate2 encryptorPublicKeyCer = null;
			X509Certificate2 decryptorPublicKeyCer = null;
			try
			{
				encryptorPrivateKeyPfx = null;
				encryptorPublicKeyCer = null;
				decryptorPublicKeyCer = null;
				return HybridEncrypt
						(
							encryptorPrivateKeyPfx
							, encryptorPublicKeyCer
							, decryptorPublicKeyCer
							, hashSignatureMode
							, DoOAEPadding
							, data
						);
			}
			catch
			{
				return null;
			}
			finally
			{
				if (encryptorPrivateKeyPfx != null)
				{
					encryptorPrivateKeyPfx.Reset();
				}
				if (encryptorPublicKeyCer != null)
				{
					encryptorPublicKeyCer.Reset();
				}
				if (decryptorPublicKeyCer != null)
				{
					decryptorPublicKeyCer.Reset();
				}
			}
		}
		public static Secret HybridEncrypt
									(
										string encryptorPrivateKeyPfxFileName
										, string encryptorPublicKeyCerFileName
										, string decryptorPublicKeyCerFileName
										, HashSignatureMode hashSignatureMode
										, bool DoOAEPadding
										, byte[] data
									)
		{
			X509Certificate2 encryptorPrivateKeyPfx = null;
			X509Certificate2 encryptorPublicKeyCer = null;
			X509Certificate2 decryptorPublicKeyCer = null;
			try
			{
				encryptorPrivateKeyPfx = new X509Certificate2(encryptorPrivateKeyPfxFileName);
				encryptorPublicKeyCer = new X509Certificate2(encryptorPublicKeyCerFileName);
				decryptorPublicKeyCer = new X509Certificate2(decryptorPublicKeyCerFileName);
				return HybridEncrypt
						(
							encryptorPrivateKeyPfx
							, encryptorPublicKeyCer
							, decryptorPublicKeyCer
							, hashSignatureMode
							, DoOAEPadding
							, data
						);
			}
			catch
			{
				return null;
			}
			finally
			{
				if (encryptorPrivateKeyPfx != null)
				{
					encryptorPrivateKeyPfx.Reset();
				}
				if (encryptorPublicKeyCer != null)
				{
					encryptorPublicKeyCer.Reset();
				}
				if (decryptorPublicKeyCer != null)
				{
					decryptorPublicKeyCer.Reset();
				}
			}
		}
		public static Secret HybridEncrypt
									(
										X509Certificate2 encryptorPrivateKeyPfx
										, X509Certificate2 encryptorPublicKeyCer
										, X509Certificate2 decryptorPublicKeyCer
										, HashSignatureMode signHashMode
										, bool DoOAEPadding
										, byte[] data
									)
		{
			RSACryptoServiceProvider encryptorPrivateKeyPfxProvider = encryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			RSACryptoServiceProvider decryptorPublicKeyCerProvider = decryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			return HybridEncrypt
						(
							encryptorPrivateKeyPfxProvider
							, encryptorPublicKeyCer
							, decryptorPublicKeyCerProvider
							, signHashMode
							, DoOAEPadding
							, data
						);
		}
		public static Secret HybridEncrypt
									(
										RSACryptoServiceProvider encryptorPrivateKeyPfxProvider
										, X509Certificate2 encryptorPublicKeyCer
										, RSACryptoServiceProvider decryptorPublicKeyCerProvider
										, HashSignatureMode signHashMode
										, bool DoOAEPadding
										, byte[] data
									)
		{
			Secret secret = new Secret();
			using (TripleDESCryptoServiceProvider provider = new TripleDESCryptoServiceProvider())
			{
				provider.GenerateIV();
				secret.EncryptorSharedEncryptedOnceIV = provider.IV;
				provider.GenerateKey();
				secret.EncryptorSharedEncryptedOnceKey = provider.Key;
				secret.EncryptedData = provider.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
			}
			secret.EncryptorSharedEncryptedOnceIV = decryptorPublicKeyCerProvider.Encrypt(secret.EncryptorSharedEncryptedOnceIV, DoOAEPadding);
			secret.EncryptorSharedEncryptedOnceKey = decryptorPublicKeyCerProvider.Encrypt(secret.EncryptorSharedEncryptedOnceKey, DoOAEPadding);
			HashAlgorithm hashAlgorithm;
			if (signHashMode == HashSignatureMode.SHA1)
			{
				hashAlgorithm = new SHA1CryptoServiceProvider();
			}
			else //(hashSignatureMode == HashSignatureMode.MD5)
			{
				hashAlgorithm = new MD5CryptoServiceProvider();
			}
			MemoryStream stream = new MemoryStream();
			byte[] buffer = secret.EncryptorSharedEncryptedOnceIV;
			stream.Write(buffer, 0, buffer.Length);
			buffer = secret.EncryptorSharedEncryptedOnceKey;
			stream.Write(buffer, 0, buffer.Length);
			buffer = secret.EncryptedData;
			stream.Position = 0;
			buffer = hashAlgorithm.ComputeHash(stream);
			stream.Close();
			stream.Dispose();
			secret.EncryptorHashSignature = encryptorPrivateKeyPfxProvider.SignHash
																				(
																					buffer
																					, Enum.GetName
																								(
																									signHashMode.GetType()
																									, signHashMode
																								)
																				);
			secret.EncryptorPublicKeyCerRawData = encryptorPublicKeyCer.RawData;
			secret.SignHashMode = signHashMode;
			secret.DoOAEPadding = DoOAEPadding;
			return secret;
		}
	   
		
		public static string GenerateTripleDESHexStringKey()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateKey();
			return BytesArrayToHexString(des.Key);
		}
		public static string GenerateTripleDESHexStringIV()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateIV();
			return BytesArrayToHexString(des.IV);
		}
	   public static byte[] SymmetricAlgorithmEncrypt
							   (
									SymmetricAlgorithm algorithm
									, byte[] data
								)
		{
			return algorithm.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
		}
		public static byte[] SymmetricAlgorithmEncrypt
									   (
											SymmetricAlgorithm algorithm
											, string text
											, Encoding e
										)
		{
			return SymmetricAlgorithmEncrypt
							(
								algorithm
								, e.GetBytes(text)
							);
		}
		public static byte[] SymmetricAlgorithmDecrypt
										(
											SymmetricAlgorithm algorithm
											, byte[] data
										 )
		{
			return algorithm.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
		}
		public static string SymmetricAlgorithmDecrypt
										(
											SymmetricAlgorithm algorithm
											, byte[] data
											, Encoding e //原文的encoding
										)
		{
			return e.GetString
						(
							SymmetricAlgorithmDecrypt
												(
													algorithm
													, data
												)
						);
		}
		public static byte[] ComputeHash
									(
										HashAlgorithm algorithm
										, byte[] data
									)
		{
			return algorithm.ComputeHash(data);
		}
		public static byte[] ComputeHash
									(
										HashAlgorithm algorithm
										, string text
										, Encoding e
									)
		{
			return ComputeHash(algorithm, e.GetBytes(text));
		}
		public static byte[] ComputeKeyedHash
									(
										KeyedHashAlgorithm algorithm
										, byte[] data
									)
		{
			return ComputeHash(algorithm, data);
		}
		public static byte[] ComputeKeyedHash
									(
										KeyedHashAlgorithm algorithm
										, string text
										, Encoding e
									)
		{
			return ComputeHash(algorithm, text, e);
		}
				public static byte[] RSASignSHA1
								(
									string privateKeyXml
									, byte[] data
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKeyXml);
			return RSASignSHA1
						(
							provider
							, data
						);
		}
		public static byte[] RSASignSHA1
								(
									RSACryptoServiceProvider provider
									, byte[] data
								)
		{
			HashAlgorithm hashAlgorithm = new SHA1CryptoServiceProvider();
			return provider.SignHash
								(
									ComputeHash(hashAlgorithm, data)
									, "SHA1"
								);
		}
		public static bool RSAVerifySHA1
								(
									string publicKeyXml
									, byte[] data
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKeyXml);
			return RSAVerifySHA1
							(
								provider
								, data
								, signature
							);
		}
		public static bool RSAVerifySHA1
								(
									RSACryptoServiceProvider provider
									, byte[] data
									, byte[] signature
								)
		{
			HashAlgorithm hashAlgorithm = new SHA1CryptoServiceProvider();
			return provider.VerifyHash
								(
									ComputeHash(hashAlgorithm, data)
									, "SHA1"
									, signature
								);
		}
		public static byte[] RSASignMD5
								(
									string privateKeyXml
									, byte[] data
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKeyXml);
			return RSASignMD5
						(
							provider
							, data
						);
		}
		public static byte[] RSASignMD5
								(
									RSACryptoServiceProvider provider
									, byte[] data
								)
		{
			HashAlgorithm hashAlgorithm = new MD5CryptoServiceProvider();
			return provider.SignHash
						(
							ComputeHash(hashAlgorithm, data)
							, "MD5"
						);
		}
		public static bool RSAVerifyMD5
								(
									string publicKeyXml
									, byte[] data
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKeyXml);
			return RSAVerifyMD5
							(
								provider
								, data
								, signature
							);
		}
		public static bool RSAVerifyMD5
								(
									RSACryptoServiceProvider provider
									, byte[] data
									, byte[] signature
								)
		{
			HashAlgorithm hashAlgorithm = new MD5CryptoServiceProvider();
			return provider.VerifyHash
								(
									ComputeHash(hashAlgorithm, data)
									, "MD5"
									, signature
								);
		}
		public static byte[] RSAEncrypt
								(
									string publicKeyXml
									, byte[] data
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKeyXml);
			return RSAEncrypt
						(
							provider
							, data
							, DoOAEPPadding
						);
		}
		public static byte[] RSAEncrypt
						(
							RSACryptoServiceProvider provider
							, byte[] data
							, bool DoOAEPPadding
						)
		{
			return provider.Encrypt(data, DoOAEPPadding);
		}
		public static byte[] RSADecrypt
								(
									string privateKeyXml
									, byte[] data
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKeyXml);
			return RSADecrypt
						(
							provider
							, data
							, DoOAEPPadding
						);
		}
		public static byte[] RSADecrypt
								(
									RSACryptoServiceProvider provider
									, byte[] data
									, bool DoOAEPPadding
								)
		{
			return provider.Decrypt(data, DoOAEPPadding);
		}
		public static byte[] X509CertificateEncrypt
									(
										X509Certificate2 publicKeyCer
										, byte[] data
										, bool DoOAEPadding
									)
		{
			RSACryptoServiceProvider provider = publicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			return RSAEncrypt
						(
							provider
							, data
							, DoOAEPadding
						);
		}
		public static byte[] X509CertificateDecrypt
									(
										X509Certificate2 privateKeyPfx
										, byte[] data
										, bool DoOAEPadding
									)
		{
			RSACryptoServiceProvider provider = privateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			return RSADecrypt
						(
							provider
							, data
							, DoOAEPadding
						);
		}
		public static byte[] X509CertificateSignSHA1
									(
										X509Certificate2 privateKeyPfx
										, byte[] data
									)
		{
			RSACryptoServiceProvider provider = privateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			return RSASignSHA1
						(
							provider
							, data
						);
		}
		public static byte[] X509CertificateSignMD5
									(
										X509Certificate2 privateKeyPfx
										, byte[] data
									)
		{
			RSACryptoServiceProvider provider = privateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			return RSASignMD5(provider, data);
		}
		public static bool X509CertificateVerifySHA1
									(
										X509Certificate2 publicKeyCer
										, byte[] data
										, byte[] signature
									)
		{
			RSACryptoServiceProvider provider = publicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			return RSAVerifySHA1
						(
							provider
							, data
							, signature
						);
		}
		public static bool X509CertificateVerifyMD5
									(
										X509Certificate2 publicKeyCer
										, byte[] data
										, byte[] signature
									)
		{
			RSACryptoServiceProvider provider = publicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			return RSAVerifyMD5
						(
							provider
							, data
							, signature
						);
		}
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}

#T=CryptoHelper X509/RSA/3DES/Hash/HMAC
/*
makecert.exe -n "CN=Microshaoft X509 Test - A" -sky exchange -pe -sv a.pvk a.cer
pvk2pfx.exe -pvk a.pvk -spc a.cer -pfx a.pfx -f -po 123
makecert.exe -n "CN=Microshaoft X509 Test - B" -sky exchange -pe -sv b.pvk b.cer
pvk2pfx.exe -pvk b.pvk -spc b.cer -pfx b.pfx -f -po abc
*/
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using System.Threading;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;
	using Microshaoft;
	class Class1
	{
		
		static void Main()
		{
			//=======================================
			UTF8Encoding e = new UTF8Encoding();
			string s;
			byte[] data = e.GetBytes
								(
@"测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com
测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com");
			byte[] encryptedData;
			// Hybird
			Console.WriteLine("Hybird(X509+3DES):=====================");
			X509Certificate2 cerA = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\a.cer");
			X509Certificate2 pfxA = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\a.pfx", "123");
			X509Certificate2 cerB = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\b.cer");
			Secret secret = CryptoHelper.HybridEncrypt
													(
														pfxA
														, cerA
														, cerB
														, HashSignatureMode.SHA1
														, false
														, data
													);
			X509Certificate2 pfxB = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\b.pfx", "abc");
			data = CryptoHelper.HybridDecrypt(pfxB, secret);
			s = e.GetString(data);
			Console.WriteLine("Hybird decrypted plain text:");
			Console.WriteLine(s);
			//100 字节以内
			s = "测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com测试";
			data = e.GetBytes(s);
			// X509
			Console.WriteLine("\nX509 加解密 只能处理100字节以内的加解密:=====================");
			X509Certificate2[] certs = X509CertificateHelper.LoadCertificatesFromStore
																		(
																			StoreName.My
																			, StoreLocation.CurrentUser
																			, "Microshaoft X509 Test"
																			, X509FindType.FindBySubjectName
																		);
			X509Certificate2 cert = null;
			if (certs != null)
			{
				foreach (X509Certificate2 c in certs)
				{
					Console.WriteLine(c.Subject);
					cert = c;
				}
			}
			X509Certificate2 cer = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\a.cer");
			X509Certificate2 pfx = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\a.pfx", "123");
			encryptedData = CryptoHelper.X509CertificateEncrypt(cer, data, false);
			encryptedData = CryptoHelper.X509CertificateDecrypt(pfx, encryptedData, false);
			s = e.GetString(encryptedData);
			Console.WriteLine("X509 decrypted plain text: {0}", s);
			//RSA
			Console.WriteLine("\nRSA 加解密 只能处理100字节以内的加解密:=====================");
			// RSA 非证书 只能处理100字节以内的加解密
			s = "测试@microshaoft.com测试@microshaoft.com测试@microshaoft.com测试";
			data = e.GetBytes(s);
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			string privateKey = x.ToXmlString(true);
			Console.WriteLine("RSA Private Key: {0}", privateKey);
			string publicKey = x.ToXmlString(false);
			Console.WriteLine("RSA Public Key: {0}", publicKey);
			//公钥加密
			encryptedData = CryptoHelper.RSAEncrypt(publicKey, data, false);
			//私钥解密
			data = CryptoHelper.RSADecrypt(privateKey, encryptedData, false);
			Console.WriteLine("RSA Decrypted plaintext: {0}", e.GetString(data));
			//私钥签名
			byte[] signature = CryptoHelper.RSASignSHA1(privateKey, data);
			//公钥验签
			Console.WriteLine(CryptoHelper.RSAVerifySHA1(publicKey, data, signature));
			//TripleDES
			Console.WriteLine("\nTripleDES:===============");
			string key = "000111222333444555666777888999aaabbbcccdddeeefff";//48
			key = "0123456789abcdef01111111111111111111111111111110";
			string iv = "0123456789abcdef";//16
			iv = "0000000000000000";
			data = e.GetBytes("测试@microshaoft.com");
			data = CryptoHelper.TripleDESEncrypt
											(
												data,
												CryptoHelper.HexStringToBytesArray(key),
												CryptoHelper.HexStringToBytesArray(iv)
											);
			//"测试@microshaoft.com"
			//3des: "A668632B4AA1EB8C1B25F7E66128846D28CEB416AC7B7B21"
			//篡改: "B668632B4AA1EB8C1B25F7E66128846D28CEB416AC7B7B21"
			data = CryptoHelper.TripleDESDecrypt
											(
												data,
												CryptoHelper.HexStringToBytesArray(key),
												CryptoHelper.HexStringToBytesArray(iv)
											);
			Console.WriteLine("3DES Decrypted plaintext: {0}", e.GetString(data));
			Console.WriteLine("X509 并发测试");
			encryptorPrivateKeyPfxProvider = encryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			encryptorPublicKeyCerProvider = encryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			decryptorPublicKeyCerProvider = decryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			decryptorPrivateKeyPfxProvider = decryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			for (int i = 0 ; i < 1000 ; i++)
			{
				ThreadStart ts = new ThreadStart(Run);
				Thread t = new Thread(ts);
				t.Name = _ThreadID.ToString();
				_ThreadID ++;
				t.Start();
				//Run();
			}
			Console.WriteLine(Environment.Version.ToString());
		}
		private static volatile int _ThreadID = 0;
		private static object _syncLockObject = new object();
		private static X509Certificate2 encryptorPrivateKeyPfx = new X509Certificate2(@"a.pfx", "123");
		private static X509Certificate2 encryptorPublicKeyCer = new X509Certificate2(@"a.cer");
		private static X509Certificate2 decryptorPublicKeyCer = new X509Certificate2(@"b.cer");
		private static X509Certificate2 decryptorPrivateKeyPfx = new X509Certificate2(@"b.pfx", "abc");
		private static RSACryptoServiceProvider encryptorPrivateKeyPfxProvider = null;
		private static RSACryptoServiceProvider encryptorPublicKeyCerProvider = null;
		private static RSACryptoServiceProvider decryptorPublicKeyCerProvider = null;
		private static RSACryptoServiceProvider decryptorPrivateKeyPfxProvider = null;
		static void Run()
		{
///			X509Certificate2 cerA = null;// = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\a.cer");
///			X509Certificate2 pfxA = null;// = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\a.pfx", "123");
///			X509Certificate2 cerB = null;// = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\b.cer");
///			X509Certificate2 pfxB = null;// = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\b.pfx", "abc");
			//lock (_syncLockObject)
			{
				try
				{
						//Thread.Sleep(50);
///						cerA = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\a.cer");
///						pfxA = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\a.pfx", "123");
///						cerB = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\b.cer");
///						pfxB = new X509Certificate2(@"C:\Documents and Settings\xiyueyu\桌面\b.pfx", "abc");
						UTF8Encoding e = new UTF8Encoding();
						string s;
						byte[] data = e.GetBytes
											(
@"并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com
并发测试@microshaoft.com并发测试@microshaoft.com并发测试@microshaoft.com");
						//byte[] encryptedData;
						// Hybird
						//Console.WriteLine("Hybird(X509+3DES):=====================");
						Secret secret = CryptoHelper.HybridEncrypt
															(
																encryptorPrivateKeyPfxProvider
																, encryptorPublicKeyCer
																, decryptorPublicKeyCerProvider
																, HashSignatureMode.SHA1
																, false
																, data
															);
						data = CryptoHelper.HybridDecrypt
													(
														decryptorPrivateKeyPfxProvider
														, encryptorPublicKeyCerProvider
														, secret
													);
						s = e.GetString(data);
						Console.WriteLine("Hybird decrypted plain text: {0}", Thread.CurrentThread.Name);
						Console.WriteLine(s);
				
				
				}
				catch (Exception e)
				{
				//	Thread.Sleep(1200);
				Console.WriteLine("exception sleep: {0}", e.ToString());
					Console.WriteLine("exception sleep: {0}", Thread.CurrentThread.Name);
				//	Run();
				}
				finally
				{
///					cerA.Reset();
///					pfxA.Reset();
///					cerB.Reset();
///					cerB.Reset();
				}
			}
			
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;
	public static class X509CertificateHelper
	{
		public static X509Certificate2[] LoadCertificatesFromStore
											(
												StoreName storeName
												, StoreLocation storeLocation
												, string findValue
												, X509FindType findType
											)
		{
			X509Certificate2[] certs = null;
			X509Store store = new X509Store(storeName, storeLocation);
			store.Open(OpenFlags.ReadOnly);
			try
			{
				X509Certificate2Collection matches = store.Certificates.Find(findType, findValue, false);
				certs = new X509Certificate2[matches.Count];
				matches.CopyTo(certs, 0);
			}
			finally
			{
				store.Close();
			}
			return certs;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;
	public class Secret
	{
		public byte[] EncryptorSharedEncryptedOnceKey;
		public byte[] EncryptorSharedEncryptedOnceIV;
		public byte[] EncryptorHashSignature;
		public byte[] EncryptorPublicKeyCerRawData;
		public byte[] EncryptedData;
		public HashSignatureMode SignHashMode;
		public bool DoOAEPadding;
	}
	public enum HashSignatureMode
	{
		MD5
		, SHA1
	}
	public static class CryptoHelper
	{
		public static byte[] HybridDecrypt
									(
										X509Certificate2 decryptorPrivateKeyPfx
										, Secret data
									)
		{
			X509Certificate2 encryptorPublicKeyCer = null;
			try
			{
				RSACryptoServiceProvider decryptorPrivateKeyPfxProvider = decryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
				encryptorPublicKeyCer = new X509Certificate2(data.EncryptorPublicKeyCerRawData);
				RSACryptoServiceProvider encryptorPublicKeyCerProvider = encryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
				return HybridDecrypt
									(
										decryptorPrivateKeyPfxProvider
										, encryptorPublicKeyCerProvider
										, data
									);
			}
			catch
			{
				return null;
			}
			finally
			{
				if (encryptorPublicKeyCer != null)
				{
					encryptorPublicKeyCer.Reset();
				}
			}
		}
		
		public static byte[] HybridDecrypt
									(
										RSACryptoServiceProvider decryptorPrivateKeyPfxProvider
										, RSACryptoServiceProvider encryptorPublicKeyCerProvider
										, Secret data
									)
		{
			byte[] buffer = null;
			HashAlgorithm hashAlgorithm;
			if (data.SignHashMode == HashSignatureMode.SHA1)
			{
				hashAlgorithm = new SHA1CryptoServiceProvider();
			}
			else //(hashSignatureMode == HashSignatureMode.MD5)
			{
				hashAlgorithm = new MD5CryptoServiceProvider();
			}
			using (MemoryStream stream = new MemoryStream())
			{
				buffer = data.EncryptorSharedEncryptedOnceIV;
				stream.Write(buffer, 0, buffer.Length);
				buffer = data.EncryptorSharedEncryptedOnceKey;
				stream.Write(buffer, 0, buffer.Length);
				buffer = data.EncryptedData;
				stream.Position = 0;
				buffer = hashAlgorithm.ComputeHash(stream);
				stream.Close();
			}
			//X509Certificate2 encryptorPublicKeyCer = new X509Certificate2(data.EncryptorPublicKeyCerRawData);
			//RSACryptoServiceProvider encryptorPublicKeyCerProvider = encryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			if (encryptorPublicKeyCerProvider.VerifyHash
												(
													buffer
													, Enum.GetName
																(
																	data.SignHashMode.GetType()
																	, data.SignHashMode
																)
													, data.EncryptorHashSignature
												)
				)
			{
				//decryptorPrivateKeyPfxProvider = decryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
				using (TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider())
				{
					buffer = data.EncryptorSharedEncryptedOnceIV;
					buffer = decryptorPrivateKeyPfxProvider.Decrypt(buffer, data.DoOAEPadding);
					des.IV = buffer;
					buffer = data.EncryptorSharedEncryptedOnceKey;
					buffer = decryptorPrivateKeyPfxProvider.Decrypt(buffer, data.DoOAEPadding);
					des.Key = buffer;
					buffer = data.EncryptedData;
					buffer = des.CreateDecryptor().TransformFinalBlock(buffer, 0, buffer.Length);
				}
			}
			else
			{
				buffer = null;
			}
			return buffer;
		}
		public static Secret HybridEncrypt
									(
										byte[] encryptorPrivateKeyPfxRawData
										, byte[] encryptorPublicKeyCerRawData
										, byte[] decryptorPublicKeyCerRawData
										, HashSignatureMode hashSignatureMode
										, bool DoOAEPadding
										, byte[] data
									)
		{
			X509Certificate2 encryptorPrivateKeyPfx = null;
			X509Certificate2 encryptorPublicKeyCer = null;
			X509Certificate2 decryptorPublicKeyCer = null;
			try
			{
				encryptorPrivateKeyPfx = null;
				encryptorPublicKeyCer = null;
				decryptorPublicKeyCer = null;
				return HybridEncrypt
						(
							encryptorPrivateKeyPfx
							, encryptorPublicKeyCer
							, decryptorPublicKeyCer
							, hashSignatureMode
							, DoOAEPadding
							, data
						);
			}
			catch
			{
				return null;
			}
			finally
			{
				if (encryptorPrivateKeyPfx != null)
				{
					encryptorPrivateKeyPfx.Reset();
				}
				if (encryptorPublicKeyCer != null)
				{
					encryptorPublicKeyCer.Reset();
				}
				if (decryptorPublicKeyCer != null)
				{
					decryptorPublicKeyCer.Reset();
				}
			}
		}
		public static Secret HybridEncrypt
									(
										string encryptorPrivateKeyPfxFileName
										, string encryptorPublicKeyCerFileName
										, string decryptorPublicKeyCerFileName
										, HashSignatureMode hashSignatureMode
										, bool DoOAEPadding
										, byte[] data
									)
		{
			X509Certificate2 encryptorPrivateKeyPfx = null;
			X509Certificate2 encryptorPublicKeyCer = null;
			X509Certificate2 decryptorPublicKeyCer = null;
			try
			{
				encryptorPrivateKeyPfx = new X509Certificate2(encryptorPrivateKeyPfxFileName);
				encryptorPublicKeyCer = new X509Certificate2(encryptorPublicKeyCerFileName);
				decryptorPublicKeyCer = new X509Certificate2(decryptorPublicKeyCerFileName);
				return HybridEncrypt
						(
							encryptorPrivateKeyPfx
							, encryptorPublicKeyCer
							, decryptorPublicKeyCer
							, hashSignatureMode
							, DoOAEPadding
							, data
						);
			}
			catch
			{
				return null;
			}
			finally
			{
				if (encryptorPrivateKeyPfx != null)
				{
					encryptorPrivateKeyPfx.Reset();
				}
				if (encryptorPublicKeyCer != null)
				{
					encryptorPublicKeyCer.Reset();
				}
				if (decryptorPublicKeyCer != null)
				{
					decryptorPublicKeyCer.Reset();
				}
			}
			
		}
		public static Secret HybridEncrypt
									(
										X509Certificate2 encryptorPrivateKeyPfx
										, X509Certificate2 encryptorPublicKeyCer
										, X509Certificate2 decryptorPublicKeyCer
										, HashSignatureMode signHashMode
										, bool DoOAEPadding
										, byte[] data
									)
		{
			RSACryptoServiceProvider encryptorPrivateKeyPfxProvider = encryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			RSACryptoServiceProvider decryptorPublicKeyCerProvider = decryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			return HybridEncrypt
						(
							encryptorPrivateKeyPfxProvider
							, encryptorPublicKeyCer
							, decryptorPublicKeyCerProvider
							, signHashMode
							, DoOAEPadding
							, data
						);
		}
		public static Secret HybridEncrypt
									(
										RSACryptoServiceProvider encryptorPrivateKeyPfxProvider
										, X509Certificate2 encryptorPublicKeyCer
										, RSACryptoServiceProvider decryptorPublicKeyCerProvider
										, HashSignatureMode signHashMode
										, bool DoOAEPadding
										, byte[] data
									)
		{
			Secret secret = new Secret();
			using (TripleDESCryptoServiceProvider provider = new TripleDESCryptoServiceProvider())
			{
				provider.GenerateIV();
				secret.EncryptorSharedEncryptedOnceIV = provider.IV;
				provider.GenerateKey();
				secret.EncryptorSharedEncryptedOnceKey = provider.Key;
				secret.EncryptedData = provider.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
			}
			secret.EncryptorSharedEncryptedOnceIV = decryptorPublicKeyCerProvider.Encrypt(secret.EncryptorSharedEncryptedOnceIV, DoOAEPadding);
			secret.EncryptorSharedEncryptedOnceKey = decryptorPublicKeyCerProvider.Encrypt(secret.EncryptorSharedEncryptedOnceKey, DoOAEPadding);
			HashAlgorithm hashAlgorithm;
			if (signHashMode == HashSignatureMode.SHA1)
			{
				hashAlgorithm = new SHA1CryptoServiceProvider();
			}
			else //(hashSignatureMode == HashSignatureMode.MD5)
			{
				hashAlgorithm = new MD5CryptoServiceProvider();
			}
			MemoryStream stream = new MemoryStream();
			byte[] buffer = secret.EncryptorSharedEncryptedOnceIV;
			stream.Write(buffer, 0, buffer.Length);
			buffer = secret.EncryptorSharedEncryptedOnceKey;
			stream.Write(buffer, 0, buffer.Length);
			buffer = secret.EncryptedData;
			stream.Position = 0;
			buffer = hashAlgorithm.ComputeHash(stream);
			stream.Close();
			stream.Dispose();
			secret.EncryptorHashSignature = encryptorPrivateKeyPfxProvider.SignHash
																				(
																					buffer
																					, Enum.GetName
																								(
																									signHashMode.GetType()
																									, signHashMode
																								)
																				);
			secret.EncryptorPublicKeyCerRawData = encryptorPublicKeyCer.RawData;
			secret.SignHashMode = signHashMode;
			secret.DoOAEPadding = DoOAEPadding;
			return secret;
		}
		public static byte[] X509CertificateEncrypt
								(
									X509Certificate2 publicKeyCer
									, byte[] data
									, bool DoOAEPadding
								)
		{
			RSACryptoServiceProvider provider = publicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			return RSAEncrypt
						(
							provider
							, data
							, DoOAEPadding
						);
		}
		public static byte[] X509CertificateDecrypt
								(
									X509Certificate2 privateKeyPfx
									, byte[] data
									, bool DoOAEPadding
								)
		{
			RSACryptoServiceProvider provider = privateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			return RSADecrypt
						(
							provider
							, data
							, DoOAEPadding
						);
		}
		public static byte[] X509CertificateSignSHA1
								(
									X509Certificate2 privateKeyPfx
									, byte[] data
								)
		{
			RSACryptoServiceProvider provider = privateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			return RSASignSHA1
						(
							provider
							, data
						);
		}
		public static byte[] X509CertificateSignMD5
								(
									X509Certificate2 privateKeyPfx
									, byte[] data
								)
		{
			RSACryptoServiceProvider provider = privateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			return RSASignMD5(provider, data);
		}
		public static bool X509CertificateVerifySHA1
								(
									X509Certificate2 publicKeyCer
									, byte[] data
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = publicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			return RSAVerifySHA1
						(
							provider
							, data
							, signature
						);
		}
		public static bool X509CertificateVerifyMD5
								(
									X509Certificate2 publicKeyCer
									, byte[] data
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = publicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			return RSAVerifyMD5
						(
							provider
							, data
							, signature
						);
		}
		public static byte[] RSASignSHA1
								(
									string privateKeyXml
									, byte[] data
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKeyXml);
			return RSASignSHA1
						(
							provider
							, data
						);
		}
		public static byte[] RSASignSHA1
								(
									RSACryptoServiceProvider provider
									, byte[] data
								)
		{
			return provider.SignHash
								(
									ComputeSHA1(data)
									, "SHA1"
								);
		}
		public static bool RSAVerifySHA1
								(
									string publicKeyXml
									, byte[] data
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKeyXml);
			return RSAVerifySHA1
							(
								provider
								, data
								, signature
							);
		}
		public static bool RSAVerifySHA1
								(
									RSACryptoServiceProvider provider
									, byte[] data
									, byte[] signature
								)
		{
			return provider.VerifyHash
								(
									ComputeSHA1(data)
									, "SHA1"
									, signature
								);
		}
		public static byte[] RSASignMD5
								(
									string privateKeyXml
									, byte[] data
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKeyXml);
			return RSASignMD5
						(
							provider
							, data
						);
		}
		public static byte[] RSASignMD5
								(
									RSACryptoServiceProvider provider
									, byte[] data
								)
		{
			return provider.SignHash
						(
							ComputeMD5(data)
							, "MD5"
						);
		}
		public static bool RSAVerifyMD5
								(
									string publicKeyXml
									, byte[] data
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKeyXml);
			return RSAVerifyMD5
							(
								provider
								, data
								, signature
							);
		}
		public static bool RSAVerifyMD5
								(
									RSACryptoServiceProvider provider
									, byte[] data
									, byte[] signature
								)
		{
			return provider.VerifyHash
								(
									ComputeMD5(data)
									, "MD5"
									, signature
								);
		}
		public static byte[] RSAEncrypt
								(
									string publicKeyXml
									, byte[] data
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKeyXml);
			return RSAEncrypt
						(
							provider
							, data
							, DoOAEPPadding
						);
		}
		public static byte[] RSAEncrypt
						(
							RSACryptoServiceProvider provider
							, byte[] data
							, bool DoOAEPPadding
						)
		{
			return provider.Encrypt(data, DoOAEPPadding);
		}
		public static byte[] RSADecrypt
								(
									string privateKeyXml
									, byte[] data
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKeyXml);
			return RSADecrypt
						(
							provider
							, data
							, DoOAEPPadding
						);
		}
		public static byte[] RSADecrypt
						(
							RSACryptoServiceProvider provider
							, byte[] data
							, bool DoOAEPPadding
						)
		{
			return provider.Decrypt(data, DoOAEPPadding);
		}
		public static byte[] TripleDESDecrypt
										(
											byte[] data
											, byte[] Key
											, byte[] IV
										)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
		}
		public static byte[] TripleDESDecrypt
										(
											string text
											, string HexStringKey
											, string HexStringIV
										)
		{
			return TripleDESDecrypt
							(
								HexStringToBytesArray(text)
								, HexStringToBytesArray(HexStringKey)
								, HexStringToBytesArray(HexStringIV)
							);
		}
		public static byte[] TripleDESDecrypt
									(
										string text
										, byte[] Key
										, byte[] IV
									)
		{
			return TripleDESDecrypt
							(
								HexStringToBytesArray(text)
								, Key
								, IV
							);
		}
		public static string TripleDESDecrypt
									(
										string text
										, string HexStringKey
										, string HexStringIV
										, Encoding e //原文的encoding
									)
		{
			return e.GetString
				(
					TripleDESDecrypt
						(
							text
							, HexStringKey
							, HexStringIV
						)
				);
		}
		public static string TripleDESDecrypt
									(
										string text
										, byte[] Key
										, byte[] IV
										, Encoding e //原文的encoding
									)
		{
			return e.GetString
						(
							TripleDESDecrypt
								(
									text
									, Key
									, IV
								)
						);
		}
		public static string GenerateTripleDESHexStringKey()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateKey();
			return BytesArrayToHexString(des.Key);
		}
		public static string GenerateTripleDESHexStringIV()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateIV();
			return BytesArrayToHexString(des.IV);
		}
		public static byte[] TripleDESEncrypt
										(
											byte[] data
											, byte[] Key
											, byte[] IV
										)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
		}
		public static byte[] TripleDESEncrypt
										(
											string text
											, Encoding e
											, byte[] Key
											, byte[] IV
										)
		{
			return TripleDESEncrypt
							(
								e.GetBytes(text)
								, Key
								, IV
							);
		}
		public static byte[] TripleDESEncrypt
										(
											string text
											, Encoding e
											, string HexStringKey
											, string HexStringIV
										)
		{
			return TripleDESEncrypt
							(
								text
								, e
								, HexStringToBytesArray(HexStringKey)
								, HexStringToBytesArray(HexStringIV)
							);
		}
		public static byte[] ComputeHMACMD5(byte[] key, Stream stream)
		{
			HMACMD5 hmac = new HMACMD5(key);
			return hmac.ComputeHash(stream);
		}
		public static byte[] ComputeHMACMD5(byte[] key, byte[] data)
		{
			HMACMD5 hmac = new HMACMD5(key);
			return hmac.ComputeHash(data);
		}
		public static byte[] ComputeHMACMD5(string HexStringKey, byte[] data)
		{
			byte[] key = HexStringToBytesArray(HexStringKey);
			return ComputeHMACMD5(key, data);
		}
		public static byte[] ComputeHMACMD5(string HexStringKey, Stream stream)
		{
			byte[] key = HexStringToBytesArray(HexStringKey);
			return ComputeHMACMD5(key, stream);
		}
		public static byte[] ComputeHMACSHA1(byte[] key, Stream stream)
		{
			HMACSHA1 hmac = new HMACSHA1(key);
			return hmac.ComputeHash(stream);
		}
		public static byte[] ComputeHMACSHA1(byte[] key, byte[] data)
		{
			HMACSHA1 hmac = new HMACSHA1(key);
			return hmac.ComputeHash(data);
		}
		public static byte[] ComputeHMACSHA1(string HexStringKey, byte[] data)
		{
			byte[] key = HexStringToBytesArray(HexStringKey);
			return ComputeHMACSHA1(key, data);
		}
		public static byte[] ComputeHMACSHA1(string HexStringKey, Stream stream)
		{
			byte[] key = HexStringToBytesArray(HexStringKey);
			return ComputeHMACSHA1(key, stream);
		}
		public static byte[] ComputeSHA1(byte[] data)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(data);
		}
		public static byte[] ComputeSHA1(string text, Encoding e)
		{
			return ComputeSHA1(e.GetBytes(text));
		}
		public static byte[] ComputeSHA1(string text)
		{
			return ComputeSHA1(text, Encoding.UTF8);
		}
		public static byte[] ComputeSHA1(Stream stream)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(stream);
		}
		public static byte[] ComputeMD5(byte[] data)
		{
			return new MD5CryptoServiceProvider().ComputeHash(data, 0, data.Length);
		}
		public static byte[] ComputeMD5(string text, Encoding e)
		{
			return ComputeMD5(e.GetBytes(text));
		}
		public static byte[] ComputeMD5(string text)
		{
			return ComputeMD5(text, Encoding.UTF8);
		}
		public static byte[] ComputeMD5(Stream stream)
		{
			return new MD5CryptoServiceProvider().ComputeHash(stream);
		}
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}

#T=csc.rsp
^# This file contains command-line options that the C#
^# command line compiler (CSC) will process as part
^# of every compilation, unless the "/noconfig" option
^# is specified.

^# Reference the common Framework libraries
/r:Accessibility.dll
/r:Microsoft.CSharp.dll
/r:System.Configuration.dll
/r:System.Configuration.Install.dll
/r:System.Core.dll
/r:System.Data.dll
/r:System.Data.DataSetExtensions.dll
/r:System.Data.Linq.dll
/r:System.Data.OracleClient.dll
/r:System.Deployment.dll
/r:System.Design.dll
/r:System.DirectoryServices.dll
/r:System.dll
/r:System.Drawing.Design.dll
/r:System.Drawing.dll
/r:System.EnterpriseServices.dll
/r:System.Management.dll
/r:System.Messaging.dll
/r:System.Runtime.Remoting.dll
/r:System.Runtime.Serialization.dll
/r:System.Runtime.Serialization.Formatters.Soap.dll
/r:System.Security.dll
/r:System.ServiceModel.dll
/r:System.ServiceModel.Web.dll
/r:System.ServiceProcess.dll
/r:System.Transactions.dll
/r:System.Web.dll
/r:System.Web.Extensions.Design.dll
/r:System.Web.Extensions.dll
/r:System.Web.Mobile.dll
/r:System.Web.RegularExpressions.dll
/r:System.Web.Services.dll
/r:System.Windows.Forms.Dll
/r:System.Workflow.Activities.dll
/r:System.Workflow.ComponentModel.dll
/r:System.Workflow.Runtime.dll
/r:System.Xml.dll
/r:System.Xml.Linq.dll
/r:System.Net.Http.dll

^# MEF add by Microshaoft
/r:System.ComponentModel.Composition.dll

^# VB add by Microshaoft
/r:Microsoft.VisualBasic.dll

^# wcf add by Microshaoft
/r:System.ServiceModel.Activation.dll

^# WPF add by Microshaoft
/r:"WPF\PresentationCore.dll"
/r:"WPF\PresentationFramework.dll"
/r:"WPF\WindowsBase.dll"
/r:"System.Xaml.dll"
/r:"C:\Program Files (x86)\Microsoft SDKs\Expression\Blend\.NETFramework\v4.5\Libraries\System.Windows.Interactivity.dll"

^# WWF add by Microshaoft
/r:System.Activities.dll
/r:System.ServiceModel.Activities.dll

^# 以下为常用的第三方库引用,注意引用正确路径!
^# mshtml add by Microshaoft
/r:"C:\Program Files (x86)\Microsoft.NET\Primary Interop Assemblies\Microsoft.mshtml.dll"

^# WEB MVC API add by Microshaoft
^#/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Assemblies\System.Net.Http.dll"
/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Assemblies\System.Net.Http.Formatting.dll"
/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Assemblies\System.Net.Http.WebRequest.dll"
/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Assemblies\System.Web.Http.dll"
/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Assemblies\System.Web.Http.SelfHost.dll"
/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Assemblies\System.Web.Http.WebHost.dll"
/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Assemblies\System.Web.Mvc.dll"
/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Packages\Microsoft.AspNet.Web.Optimization.1.0.0\lib\net40\System.Web.Optimization.dll"
/r:"C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET MVC 4\Packages\Microsoft.AspNet.WebApi.Tracing.4.0.0\lib\net40\System.Web.Http.Tracing.dll"

^# Reactive Extensions - Core Library add by Microshaoft
/r:System.Runtime.dll
/r:"D:\Rx\Rx-Core.2.1.30214.0\lib\Net45\System.Reactive.Core.dll"
/r:"D:\Rx\Rx-Interfaces.2.1.30214.0\lib\Net45\System.Reactive.Interfaces.dll"
/r:"D:\Rx\Rx-Linq.2.1.30214.0\lib\Net45\System.Reactive.Linq.dll"
/r:"D:\Rx\Rx-PlatformServices.2.1.30214.0\lib\Net45\System.Reactive.PlatformServices.dll"

^# SignalR add by Microshaoft
/r:D:\SignalR\bin\Microsoft.AspNet.SignalR.Core.dll
/r:D:\SignalR\bin\Microsoft.AspNet.SignalR.Owin.dll
/r:D:\SignalR\bin\Microsoft.AspNet.SignalR.SystemWeb.dll
/r:D:\SignalR\bin\Microsoft.Owin.Host.SystemWeb.dll
/r:D:\SignalR\bin\Microsoft.Web.Infrastructure.dll
/r:D:\SignalR\bin\Owin.dll

^# Json.NET add by Microshaoft
/r:"D:\Json\bin\Newtonsoft.Json.dll"

^# Redis add by Microshaoft
/r:D:\Redis\dotNET\ServiceStack.Common.dll
/r:D:\Redis\dotNET\ServiceStack.dll
/r:D:\Redis\dotNET\ServiceStack.Interfaces.dll
/r:D:\Redis\dotNET\ServiceStack.OrmLite.dll
/r:D:\Redis\dotNET\ServiceStack.OrmLite.SqlServer.dll
/r:D:\Redis\dotNET\ServiceStack.Redis.dll

^# Microsoft.Composition/MEF2 add by Microshaoft
/r:"D:\Microsoft.Composition\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.AttributedModel.dll"
/r:"D:\Microsoft.Composition\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.Convention.dll"
/r:"D:\Microsoft.Composition\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.Hosting.dll"
/r:"D:\Microsoft.Composition\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.Runtime.dll"
/r:"D:\Microsoft.Composition\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.TypedParts.dll"
#T=csc.rsp 2013-10-19 (1)
^# This file contains command-line options that the C#
^# command line compiler (CSC) will process as part
^# of every compilation, unless the "/noconfig" option
^# is specified.

^# Reference the common Framework libraries
/r:Accessibility.dll
/r:Microsoft.CSharp.dll
/r:System.Configuration.dll
/r:System.Configuration.Install.dll
/r:System.Core.dll
/r:System.Data.dll
/r:System.Data.DataSetExtensions.dll
/r:System.Data.Linq.dll
/r:System.Data.OracleClient.dll
/r:System.Deployment.dll
/r:System.Design.dll
/r:System.DirectoryServices.dll
/r:System.dll
/r:System.Drawing.Design.dll
/r:System.Drawing.dll
/r:System.EnterpriseServices.dll
/r:System.Management.dll
/r:System.Messaging.dll
/r:System.Runtime.Remoting.dll
/r:System.Runtime.Serialization.dll
/r:System.Runtime.Serialization.Formatters.Soap.dll
/r:System.Security.dll
/r:System.ServiceModel.dll
/r:System.ServiceModel.Web.dll
/r:System.ServiceProcess.dll
/r:System.Transactions.dll
/r:System.Web.dll
/r:System.Web.Extensions.Design.dll
/r:System.Web.Extensions.dll
/r:System.Web.Mobile.dll
/r:System.Web.RegularExpressions.dll
/r:System.Web.Services.dll
/r:System.Windows.Forms.Dll
/r:System.Workflow.Activities.dll
/r:System.Workflow.ComponentModel.dll
/r:System.Workflow.Runtime.dll
/r:System.Xml.dll
/r:System.Xml.Linq.dll
/r:System.Net.Http.dll

^# MEF add by Microshaoft
/r:System.ComponentModel.Composition.dll

^# VB add by Microshaoft
/r:Microsoft.VisualBasic.dll

^# wcf add by Microshaoft
/r:System.ServiceModel.Activation.dll

^# WPF add by Microshaoft
/r:"WPF\PresentationCore.dll"
/r:"WPF\PresentationFramework.dll"
/r:"WPF\WindowsBase.dll"
/r:"System.Xaml.dll"
/r:"C:\Program Files (x86)\Microsoft SDKs\Expression\Blend\.NETFramework\v4.5\Libraries\System.Windows.Interactivity.dll"

^# WWF add by Microshaoft
/r:System.Activities.dll
/r:System.ServiceModel.Activities.dll

^# 以下为常用的第三方库引用,注意引用正确路径!
^# mshtml add by Microshaoft
/r:"C:\Program Files (x86)\Microsoft.NET\Primary Interop Assemblies\Microsoft.mshtml.dll"

^# WEB MVC API 5.0 SignalR 2.0 add by Microshaoft
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Antlr.3.4.1.9004\lib\Antlr3.Runtime.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.Mvc.5.0.0\lib\net45\System.Web.Mvc.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.Razor.3.0.0\lib\net45\System.Web.Razor.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.SignalR.Core.2.0.0\lib\net45\Microsoft.AspNet.SignalR.Core.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.SignalR.SystemWeb.2.0.0\lib\net45\Microsoft.AspNet.SignalR.SystemWeb.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.Web.Optimization.1.1.1\lib\net40\System.Web.Optimization.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebApi.Client.5.0.0\lib\net45\System.Net.Http.Formatting.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebApi.Client.5.0.0\lib\portable-wp8+netcore45+net45\System.Net.Http.Formatting.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebApi.Core.5.0.0\lib\net45\System.Web.Http.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebApi.SelfHost.5.0.0\lib\net45\System.Web.Http.SelfHost.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebApi.Tracing.5.0.0\lib\net45\System.Web.Http.Tracing.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebApi.WebHost.5.0.0\lib\net45\System.Web.Http.WebHost.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebPages.3.0.0\lib\net45\System.Web.Helpers.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebPages.3.0.0\lib\net45\System.Web.WebPages.Deployment.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebPages.3.0.0\lib\net45\System.Web.WebPages.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.AspNet.WebPages.3.0.0\lib\net45\System.Web.WebPages.Razor.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.Owin.2.0.0\lib\net40\Microsoft.Owin.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.Owin.2.0.0\lib\net45\Microsoft.Owin.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.Owin.Host.SystemWeb.2.0.0\lib\net40\Microsoft.Owin.Host.SystemWeb.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.Owin.Host.SystemWeb.2.0.0\lib\net45\Microsoft.Owin.Host.SystemWeb.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.Owin.Security.2.0.0\lib\net45\Microsoft.Owin.Security.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Microsoft.Web.Infrastructure.1.0.0.0\lib\net40\Microsoft.Web.Infrastructure.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Newtonsoft.Json.5.0.8\lib\net20\Newtonsoft.Json.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Newtonsoft.Json.5.0.8\lib\net35\Newtonsoft.Json.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Newtonsoft.Json.5.0.8\lib\net40\Newtonsoft.Json.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Newtonsoft.Json.5.0.8\lib\net45\Newtonsoft.Json.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Newtonsoft.Json.5.0.8\lib\netcore45\Newtonsoft.Json.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Newtonsoft.Json.5.0.8\lib\portable-net40+sl4+wp7+win8\Newtonsoft.Json.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Newtonsoft.Json.5.0.8\lib\portable-net45+wp80+win8\Newtonsoft.Json.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\Owin.1.0\lib\net40\Owin.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Asp.NET\WebGrease.1.5.2\lib\WebGrease.dll

^# Reactive Extensions add by Microshaoft
/r:System.Runtime.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Core.2.1.30214.0\lib\Net40\System.Reactive.Core.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Core.2.1.30214.0\lib\Net45\System.Reactive.Core.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Core.2.1.30214.0\lib\NetCore45\System.Reactive.Core.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Core.2.1.30214.0\lib\Portable-Net45+WinRT45+WP8\System.Reactive.Core.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Core.2.1.30214.0\lib\SL4-WindowsPhone71\System.Reactive.Core.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Core.2.1.30214.0\lib\SL5\System.Reactive.Core.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Interfaces.2.1.30214.0\lib\Net40\System.Reactive.Interfaces.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Interfaces.2.1.30214.0\lib\Net45\System.Reactive.Interfaces.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Interfaces.2.1.30214.0\lib\NetCore45\System.Reactive.Interfaces.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Interfaces.2.1.30214.0\lib\Portable-Net45+WinRT45+WP8\System.Reactive.Interfaces.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Interfaces.2.1.30214.0\lib\SL4-WindowsPhone71\System.Reactive.Interfaces.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Interfaces.2.1.30214.0\lib\SL5\System.Reactive.Interfaces.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Interfaces.2.1.30214.0\lib\WP8\System.Reactive.Interfaces.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Linq.2.1.30214.0\lib\Net40\System.Reactive.Linq.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Linq.2.1.30214.0\lib\Net45\System.Reactive.Linq.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Linq.2.1.30214.0\lib\NetCore45\System.Reactive.Linq.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Linq.2.1.30214.0\lib\Portable-Net45+WinRT45+WP8\System.Reactive.Linq.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Linq.2.1.30214.0\lib\SL4-WindowsPhone71\System.Reactive.Linq.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Linq.2.1.30214.0\lib\SL5\System.Reactive.Linq.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Linq.2.1.30214.0\lib\WP8\System.Reactive.Linq.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-PlatformServices.2.1.30214.0\lib\Net40\System.Reactive.PlatformServices.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-PlatformServices.2.1.30214.0\lib\Net45\System.Reactive.PlatformServices.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-PlatformServices.2.1.30214.0\lib\NetCore45\System.Reactive.PlatformServices.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-PlatformServices.2.1.30214.0\lib\SL4-WindowsPhone71\System.Reactive.PlatformServices.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-PlatformServices.2.1.30214.0\lib\SL5\System.Reactive.PlatformServices.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-PlatformServices.2.1.30214.0\lib\WP8\System.Reactive.PlatformServices.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Providers.2.1.30214.0\lib\Net40\System.Reactive.Providers.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Providers.2.1.30214.0\lib\Net45\System.Reactive.Providers.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Providers.2.1.30214.0\lib\NetCore45\System.Reactive.Providers.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Providers.2.1.30214.0\lib\Portable-Net45+WinRT45+WP8\System.Reactive.Providers.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Providers.2.1.30214.0\lib\SL4-WindowsPhone71\System.Reactive.Providers.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Providers.2.1.30214.0\lib\SL5\System.Reactive.Providers.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Providers.2.1.30214.0\lib\WP8\System.Reactive.Providers.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Remoting.2.1.30214.0\lib\Net40\System.Reactive.Runtime.Remoting.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Remoting.2.1.30214.0\lib\Net45\System.Reactive.Runtime.Remoting.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Testing.2.1.30214.0\lib\Net40-Full\Microsoft.Reactive.Testing.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Testing.2.1.30214.0\lib\Net45-Full\Microsoft.Reactive.Testing.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Testing.2.1.30214.0\lib\NetCore45\Microsoft.Reactive.Testing.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Testing.2.1.30214.0\lib\SL4-WindowsPhone71\Microsoft.Reactive.Testing.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Testing.2.1.30214.0\lib\SL5\Microsoft.Reactive.Testing.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Testing.2.1.30214.0\lib\WP8\Microsoft.Reactive.Testing.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-WinForms.2.1.30214.0\lib\Net40\System.Reactive.Windows.Forms.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-WinForms.2.1.30214.0\lib\Net45\System.Reactive.Windows.Forms.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Xaml.2.1.30214.0\lib\Net40\System.Reactive.Windows.Threading.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Xaml.2.1.30214.0\lib\Net45\System.Reactive.Windows.Threading.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Xaml.2.1.30214.0\lib\NetCore45\System.Reactive.Windows.Threading.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Xaml.2.1.30214.0\lib\SL4-WindowsPhone71\System.Reactive.Windows.Threading.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Xaml.2.1.30214.0\lib\SL5\System.Reactive.Windows.Threading.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.Reactive.Extensions\Rx-Xaml.2.1.30214.0\lib\WP8\System.Reactive.Windows.Threading.dll

^# Microsoft.Composition/MEF2 add by Microshaoft
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Composition.MEF2\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.AttributedModel.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Composition.MEF2\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.Convention.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Composition.MEF2\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.Hosting.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Composition.MEF2\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.Runtime.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.Composition.MEF2\Microsoft.Composition.1.0.17\lib\portable-net45+win8\System.Composition.TypedParts.dll

^# Azure add by Microshaoft
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Bcl.Async.1.0.16\lib\net40\Microsoft.Threading.Tasks.Extensions.Desktop.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Bcl.Async.1.0.16\lib\net40\Microsoft.Threading.Tasks.Extensions.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Bcl.Async.1.0.16\lib\net45\Microsoft.Threading.Tasks.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Bcl.Async.1.0.16\lib\net45\Microsoft.Threading.Tasks.Extensions.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Bcl.Build.1.0.10\tools\Microsoft.Bcl.Build.Tasks.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\Microsoft.Data.Edm.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\de\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\es\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\fr\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\it\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\ja\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\ko\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\ru\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\zh-Hans\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\net40\zh-Hant\Microsoft.Data.Edm.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\Microsoft.Data.Edm.SL.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\de\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\es\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\fr\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\it\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\ja\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\ko\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\ru\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\zh-Hans\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.Edm.5.2.0\lib\sl4\zh-Hant\Microsoft.Data.Edm.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\Microsoft.Data.OData.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\de\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\es\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\fr\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\it\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\ja\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\ko\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\ru\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\zh-Hans\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\net40\zh-Hant\Microsoft.Data.OData.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\Microsoft.Data.OData.SL.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\de\Microsoft.Data.OData.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\es\Microsoft.Data.OData.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\fr\Microsoft.Data.OData.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\it\Microsoft.Data.OData.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\ja\Microsoft.Data.OData.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\ko\Microsoft.Data.OData.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\ru\Microsoft.Data.OData.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\zh-Hans\Microsoft.Data.OData.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Data.OData.5.2.0\lib\sl4\zh-Hant\Microsoft.Data.OData.SL.resources.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\net40\System.Net.Http.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\net40\System.Net.Http.Extensions.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\net40\System.Net.Http.Primitives.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\net40\System.Net.Http.WebRequest.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\net45\System.Net.Http.Extensions.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\net45\System.Net.Http.Primitives.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\portable-net40+sl4+win8+wp71\System.Net.Http.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\portable-net40+sl4+win8+wp71\System.Net.Http.Extensions.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\portable-net40+sl4+win8+wp71\System.Net.Http.Primitives.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\portable-net45+win8\System.Net.Http.Extensions.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\portable-net45+win8\System.Net.Http.Primitives.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\sl4-windowsphone71\System.Net.Http.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\sl4-windowsphone71\System.Net.Http.Extensions.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\sl4-windowsphone71\System.Net.Http.Primitives.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\win8\System.Net.Http.Extensions.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.Net.Http.2.2.15\lib\win8\System.Net.Http.Primitives.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.2.1.0.0\lib\net40-full\Microsoft.ApplicationServer.Caching.AzureClientHelper.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.2.1.0.0\lib\net40-full\Microsoft.ApplicationServer.Caching.AzureCommon.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.2.1.0.0\lib\net40-full\Microsoft.ApplicationServer.Caching.Client.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.2.1.0.0\lib\net40-full\Microsoft.ApplicationServer.Caching.Core.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.2.1.0.0\lib\net40-full\Microsoft.Web.DistributedCache.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.2.1.0.0\lib\net40-full\Microsoft.WindowsFabric.Common.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.2.1.0.0\lib\net40-full\Microsoft.WindowsFabric.Data.Common.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.ApplicationServer.Caching.AzureClientHelper.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.ApplicationServer.Caching.AzureCommon.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.ApplicationServer.Caching.AzureServerCommon.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.ApplicationServer.Caching.Client.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.ApplicationServer.Caching.Core.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.ApplicationServer.Caching.MemcacheShim.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.Web.DistributedCache.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.WindowsAzure.Diagnostics.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.WindowsAzure.Diagnostics.StorageUtility.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.WindowsFabric.Common.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.Caching.MemcacheShim.2.1.0.0\content\WindowsAzure.Caching.MemcacheShim\Microsoft.WindowsFabric.Data.Common.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\Microsoft.WindowsAzure.ConfigurationManager.2.0.1.0\lib\net40\Microsoft.WindowsAzure.Configuration.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\System.Spatial.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\de\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\es\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\fr\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\it\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\ja\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\ko\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\ru\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\zh-Hans\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\net40\zh-Hant\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\System.Spatial.SL.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\de\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\es\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\fr\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\it\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\ja\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\ko\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\ru\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\zh-Hans\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\System.Spatial.5.2.0\lib\sl4\zh-Hant\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\net45\Microsoft.WindowsAzure.Mobile.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\net45\Microsoft.WindowsAzure.Mobile.Ext.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\netcore45\Microsoft.WindowsAzure.Mobile.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\netcore45\Microsoft.WindowsAzure.Mobile.Ext.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\portable-win+net45+sl40+wp71\Microsoft.WindowsAzure.Mobile.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\sl4-windowsphone71\Microsoft.WindowsAzure.Mobile.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\sl4-windowsphone71\Microsoft.WindowsAzure.Mobile.Ext.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\sl4-windowsphone71\Microsoft.WindowsAzure.Mobile.UI.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\wp8\Microsoft.WindowsAzure.Mobile.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\wp8\Microsoft.WindowsAzure.Mobile.Ext.dll
^#/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.MobileServices.1.0.2\lib\wp8\Microsoft.WindowsAzure.Mobile.UI.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.ServiceBus.2.1.3.0\lib\net40-full\Microsoft.ServiceBus.dll
/r:D:\Microshaoft.Nuget.Packages\Azure\WindowsAzure.Storage.2.1.0.3\lib\net40\Microsoft.WindowsAzure.Storage.dll

^#=========================================
#T=csc.rsp 2013-10-19 (2)
^#=========================================
^# Spatial add by Microshaoft
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\System.Spatial.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\de\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\es\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\fr\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\it\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\ja\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\ko\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\ru\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\zh-Hans\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\net40\zh-Hant\System.Spatial.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\System.Spatial.Portable.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\de\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\es\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\fr\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\it\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\ja\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\ko\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\ru\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\zh-Hans\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\portable-net40+sl5+wp8+win8\zh-Hant\System.Spatial.Portable.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\System.Spatial.SL.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\de\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\es\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\fr\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\it\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\ja\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\ko\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\ru\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\zh-Hans\System.Spatial.SL.resources.dll
/r:D:\Microshaoft.Nuget.Packages\System.Spatial\System.Spatial.5.6.0\lib\sl4\zh-Hant\System.Spatial.SL.resources.dll

^# OAuth add by Microshaoft
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\CodeContracts.Unofficial.1.0.0.2\lib\net35-client\Microsoft.Contracts.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\CodeContracts.Unofficial.1.0.0.2\lib\net40-client\DELETE_ME.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\CodeContracts.Unofficial.1.0.0.2\lib\sl3-wp\Microsoft.Contracts.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\CodeContracts.Unofficial.1.0.0.2\lib\sl4\Microsoft.Contracts.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.AspNet.4.1.4.12333\lib\net40-full\DotNetOpenAuth.AspNet.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.AspNet.4.1.4.12333\lib\net45-full\DotNetOpenAuth.AspNet.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.Core.4.1.4.12333\lib\net40-full\DotNetOpenAuth.Core.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.Core.4.1.4.12333\lib\net45-full\DotNetOpenAuth.Core.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OAuth.Consumer.4.1.4.12333\lib\net40-full\DotNetOpenAuth.OAuth.Consumer.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OAuth.Consumer.4.1.4.12333\lib\net45-full\DotNetOpenAuth.OAuth.Consumer.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OAuth.Core.4.1.4.12333\lib\net40-full\DotNetOpenAuth.OAuth.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OAuth.Core.4.1.4.12333\lib\net45-full\DotNetOpenAuth.OAuth.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OpenId.Core.4.1.4.12333\lib\net40-full\DotNetOpenAuth.OpenId.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OpenId.Core.4.1.4.12333\lib\net40-full\Mono.Math.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OpenId.Core.4.1.4.12333\lib\net40-full\Org.Mentalis.Security.Cryptography.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OpenId.Core.4.1.4.12333\lib\net45-full\DotNetOpenAuth.OpenId.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OpenId.Core.4.1.4.12333\lib\net45-full\Mono.Math.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OpenId.Core.4.1.4.12333\lib\net45-full\Org.Mentalis.Security.Cryptography.dll
^#/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OpenId.RelyingParty.4.1.4.12333\lib\net40-full\DotNetOpenAuth.OpenId.RelyingParty.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\DotNetOpenAuth.OpenId.RelyingParty.4.1.4.12333\lib\net45-full\DotNetOpenAuth.OpenId.RelyingParty.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\Microsoft.AspNet.WebPages.Data.3.0.0\lib\net45\WebMatrix.Data.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\Microsoft.AspNet.WebPages.OAuth.3.0.0\lib\net45\Microsoft.Web.WebPages.OAuth.dll
/r:d:\Microshaoft.Nuget.Packages\Microsoft.AspNet.WebPages.OAuth\Microsoft.AspNet.WebPages.WebData.3.0.0\lib\net45\WebMatrix.WebData.dll

^# Entity Framework add by Microshaoft
^#/r:D:\Microshaoft.Nuget.Packages\EntityFramework\EntityFramework.6.0.1\lib\net40\EntityFramework.dll
^#/r:D:\Microshaoft.Nuget.Packages\EntityFramework\EntityFramework.6.0.1\lib\net40\EntityFramework.SqlServer.dll
/r:D:\Microshaoft.Nuget.Packages\EntityFramework\EntityFramework.6.0.1\lib\net45\EntityFramework.dll
/r:D:\Microshaoft.Nuget.Packages\EntityFramework\EntityFramework.6.0.1\lib\net45\EntityFramework.SqlServer.dll
/r:D:\Microshaoft.Nuget.Packages\EntityFramework\EntityFramework.6.0.1\tools\EntityFramework.PowerShell.dll
/r:D:\Microshaoft.Nuget.Packages\EntityFramework\EntityFramework.6.0.1\tools\EntityFramework.PowerShell.Utility.dll

^# OpenXML add by Microshaoft
^#/r:"D:\Microshaoft.Nuget.Packages\OpenXML\OpenXMLSDKV25\Global Assembly Cache Folder\DocumentFormat.OpenXml\2.0.3302.0_31BF3856AD364E35\DocumentFormat.OpenXml.dll"
/r:D:\Microshaoft.Nuget.Packages\OpenXML\OpenXMLSDKV25\lib\DocumentFormat.OpenXml.dll

^# Redis add by Microshaoft
^#/r:D:\Redis\dotNET\ServiceStack.Common.dll
^#/r:D:\Redis\dotNET\ServiceStack.dll
^#/r:D:\Redis\dotNET\ServiceStack.Interfaces.dll
^#/r:D:\Redis\dotNET\ServiceStack.OrmLite.dll
^#/r:D:\Redis\dotNET\ServiceStack.OrmLite.SqlServer.dll
^#/r:D:\Redis\dotNET\ServiceStack.Redis.dll

^#=================================================
#T=csc.rsp 2013-11-10 (1)
csc.rsp 2013-11-10 (1)
#T=csc.rsp 2013-11-10 (2)
csc.rsp 2013-11-10 (2)
#T=CSharpCodeProvider WebReference
namespace Microsoft.Samples
{
	#region Using directives

	using System;
	using System.Collections;
	using System.IO;
	using System.Collections.Generic;
	using System.Text;
	using System.Xml.Serialization;
	using System.Xml;
	using System.Xml.Schema;
	using System.Web.Services.Description;
	using System.Web.Services.Discovery;
	using System.CodeDom;
	using System.CodeDom.Compiler;
	using System.Diagnostics;

	using Microsoft.CSharp;

	#endregion
	class Program
	{
		static void Main(string[] args)
		{

			Uri wsdlLocation = new Uri(Directory.GetCurrentDirectory() + "\\..\\..\\..\\OrderService.wsdl");

			Console.WriteLine("Beginning schema import.");
			Console.WriteLine();

			DiscoveryClientProtocol client = new DiscoveryClientProtocol();
			client.AllowAutoRedirect = true;
			DiscoveryDocument doc = client.DiscoverAny(wsdlLocation.ToString());
			client.ResolveAll();
			
			WebReferenceCollection references=new WebReferenceCollection();
			
			//add 1st web reference document
			WebReference wr = new WebReference(client.Documents, new CodeNamespace("Microsoft.Samples"));
			references.Add(wr);
			
			//add other web reference documents if needed
			
			CodeDomProvider codeProvider = new CSharpCodeProvider ();
			CodeCompileUnit ccu = new CodeCompileUnit();
			ccu.Namespaces.Add(wr.ProxyCode);
			try
			{
				//This is the new API call
				ServiceDescriptionImporter.GenerateWebReferences
												(
													references,
													codeProvider,
													ccu,
													new WebReferenceOptions()
												);
			}
			catch(Exception ex)
			{
				//do exception handling
				Console.WriteLine("An exception occured during importation:\n {0}", ex.ToString());
			}
			
			StreamWriter writer = new StreamWriter
											(
												"OrderProxy.cs",
												false,
												new UTF8Encoding(true)
											);

			codeProvider.GenerateCodeFromCompileUnit(ccu, writer, new CodeGeneratorOptions());
			writer.Close ();


//			importer.Import(new CodeNamespace("Microsoft.Samples"), compileUnit);
			Console.WriteLine();
			Console.WriteLine("Schema import completed.");

			//reader.Close();

			Console.WriteLine("Finished. Press any key to continue...");
			Console.ReadLine();

			Process.Start("notepad", "OrderProxy.cs");

		}
	}
}

#T=DataSet GZip/Deflate Serializer
namespace Test
{
	using System.Diagnostics;
	using System.Web;
	using System.Web.Services;
	using System.Data;
	using System;

	using Microshaoft;
	[WebService(Namespace="http://www.microshaoft.com/")]
	public class Service1Class : WebService
	{
		[WebMethod]
		public string HelloWorld()
		{
			return "Hello World";
		}
		[WebMethod]
		public byte[] GetData()
		{
			DataSet ds = new DataSet();
			//populate dataset to do
			return DataSetSerializer.DataSetToGZipBytes(ds);
		}
		static void Main()
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			byte[] data = DataSetSerializer.DataSetToGZipBytes(new DataSet());
			Console.WriteLine(data.Length);
			DataSet ds = DataSetSerializer.GZipBytesToDataSet(data);

			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}



namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Data;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Formatters.Binary;
	public class DataSetSerializer
	{
		//Server
		static public byte[] DataSetToGZipBytes(DataSet dataSet)
		{
			MemoryStream ms= new MemoryStream();
			IFormatter f = new BinaryFormatter();
			dataSet.RemotingFormat = SerializationFormat.Binary;

			f.Serialize(ms, dataSet);
			byte[] data = ms.ToArray();
			ms.Close();
			ms.Dispose();
			ms = null;
			return CompressHelper.GZipCompress(data);
		}

		//Client
		static public DataSet GZipBytesToDataSet(byte[] data)
		{

			data = CompressHelper.GZipDecompress(data);
			MemoryStream ms = new MemoryStream(data);
			IFormatter f = new BinaryFormatter();
			DataSet dataSet = f.Deserialize(ms) as DataSet;
			ms.Close();
			ms.Dispose();
			ms = null;
			return dataSet;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Text;
	using System.IO;
	using System.IO.Compression;
	/// <summary>
	/// Crypto 的摘要说明。
	/// </summary>
	public class CompressHelper
	{

		private static byte[] ReadStreamToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;

			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}

			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;

		}

		public static byte[] GZipCompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream();
			GZipStream stream = new GZipStream(ms, CompressionMode.Compress, true);
			stream.Write(data, 0, data.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			byte[] buffer = ReadStreamToBytes(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return buffer;
		}
		public static byte[] GZipDecompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream(data);
			GZipStream stream = new GZipStream(ms, CompressionMode.Decompress);
			byte[] buffer = ReadStreamToBytes(stream);
			ms.Close();
			ms.Dispose();
			ms = null;
			stream.Close();
			stream.Dispose();
			stream = null;
			return buffer;
		}

		public static byte[] DeflateCompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream();
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true);
			stream.Write(data, 0, data.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			byte[] buffer = ReadStreamToBytes(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return buffer;
		}
		public static byte[] DeflateDecompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream(data);
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Decompress);
			byte[] buffer = ReadStreamToBytes(stream);
			ms.Close();
			ms.Dispose();
			ms = null;
			stream.Close();
			stream.Dispose();
			stream = null;
			return buffer;
		}
	}
}
#T=DataSet SQL
using System;
using System.Data;
using System.Data.SqlClient;

public class gettingdata
{
	public static void Main()
	{
		gettingdata mygettingdata = new gettingdata();
		mygettingdata.Run();
	}

	public void Run()
	{

		SqlConnection myConnection = new SqlConnection("server=(local)\\NetSDK;Integrated Security=SSPI;database=northwind");
		SqlDataAdapter mySqlDataAdapter = new SqlDataAdapter("select * from customers", myConnection);

		try
		{
			DataSet myDataSet = new DataSet();

			mySqlDataAdapter.Fill(myDataSet,"Customers");

			foreach (DataRow myDataRow in myDataSet.Tables["Customers"].Rows)
			{
				Console.WriteLine(myDataRow["CustomerId"].ToString());
			}
		}
		catch(Exception e)
		{
			Console.WriteLine(e.ToString());
		}
		finally
		{
			myConnection.Close();
		}
	}
}
#T=DataSet Test
		private static DataSet CreateDataSet()
		{
			DataSet dataSet = new DataSet();
			// Create two DataTable objects using a function.
			DataTable table1 = MakeTable("idTable1", "thing1");
			DataTable table2 = MakeTable("idTable2", "thing2");
			dataSet.Tables.Add(table1);
			dataSet.Tables.Add(table2);
			return dataSet;
			//Console.WriteLine(dataSet.Tables.Count)
		}
		private static DataTable MakeTable
							(
								string c1Name
								, string c2Name
							)
		{
			DataTable table= new DataTable();
			//' Add two DataColumns
			DataColumn column = new DataColumn(c1Name, typeof(int));
			table.Columns.Add(column);
			column = new DataColumn(c2Name, typeof(string));
			table.Columns.Add(column);
			table.Rows.Add(1,"aa");
			table.Rows.Add(2, "bb");
			return table;
		}
#T=DataTable <=> List Linq FullTextSearch
namespace ConsoleApplication
{
	using System;
	using System.Collections.Generic;
	using System.Data;
	using System.Linq;
	using System.Text;
	using System.Xml.Serialization;
	using Microshaoft;
	public class Class1
	{
		//[STAThread]
		[Serializable]
		public class Entry
		{
			[XmlElement("F1")]
			public string F1 { get; set; }
			[XmlElement("F2")]
			public int F2 { get; set; }
			[XmlAttribute("F3")]
			public DateTime F3 { get; set; }
			public DateTime? FF3 { get; set; }
			[XmlArrayItem("Entry2", typeof(Entry2))]
			[XmlArray("Entry2S")]
			public Entry2[] Entry2S { get; set; }
		};
		public class Entry2
		{
			[XmlElement("F1")]
			public string F1 { get; set; }
			[XmlElement("F2")]
			public int F2 { get; set; }
			[XmlAttribute("F3")]
			public DateTime F3 { get; set; }
			public DateTime? FF3 { get; set; }
		};
		static void Main(string[] args)
		{
			var list = new List<Entry>()
							{
								new Entry() 
									{
										F1 = "a"
										, F2= 1
										, F3 = DateTime.Now
										, FF3 = null
										, Entry2S = new []
														{
															new Entry2 ()
															{
																F1 = "sadasd"
																, F2 = 10
																, F3 = DateTime.Now
																, FF3 = null
															}
															, new Entry2 ()
															{
																F1 = "sadasd"
																, F2 = 10
																, F3 = DateTime.Now
																, FF3 = DateTime.Now
															}
															, new Entry2 ()
															{
																F1 = "sadasd"
																, F2 = 10
																, F3 = DateTime.Now
															}
														}
									}
								,new Entry() 
									{
										F1= "b"
										, F2= 2
										, F3 = DateTime.Now
										, FF3 = null
										, Entry2S = new []
													{
														new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
														, new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
														, new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
													}
									}
								,new Entry() 
									{
										F1= "c"
										, F2= 3
										, F3 = DateTime.Now
										, FF3 = DateTime.Now
										, Entry2S = new []
													{
														new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
														, new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
														, new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
													}
									}
							};
			var dataTable = list.ToDataTable<Entry>();
			var keyWords = new[] { "", "" };
			dataTable = list.AsEnumerable().ToDataTable();
			var l = dataTable.ToList<Entry>();
			l.ForEach
				(
					(x) =>
					{
						x.Entry2S = new[]
										{
											new Entry2 ()
											{
												F1 = "sadasd"
												, F2 = 10
												, F3 = DateTime.Now
											}
											, new Entry2 ()
											{
												F1 = "sadasd"
												, F2 = 10
												, F3 = DateTime.Now
											}
											, new Entry2 ()
											{
												F1 = "sadasd"
												, F2 = 10
												, F3 = DateTime.Now
											}
										};
					}
				);
			string xml = SerializerHelper.XmlSerializerObjectToXml<List<Entry>>(l, Encoding.UTF8);
			Console.WriteLine(xml);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Data;
	using System.Linq;
	using System.Reflection;
	using System.ComponentModel;
	public static class ExtensionMethodsManager
	{
		public static DataRow[] FullTextSearch(this DataTable dataTable, string[] keyWords)
		{
			return
				dataTable.AsEnumerable().Where<DataRow>
										(
											(x) =>
											{
												return
														keyWords.All
																(
																	(xx) =>
																	{
																		return
																				 x.ItemArray
																						.Select
																							(
																								(xxx) =>
																								{
																									return xxx.ToString();
																								}
																							)
																						.Any<string>
																							(
																								(xxx) =>
																								{
																									return xxx.Contains(xx);
																								}
																							);
																	}
																);
											}
										).ToArray();
		}
		private static List<Type> _typesWhiteList = new List<Type>()
														{
															typeof(int)
															, typeof(int?)
															, typeof(long)
															, typeof(long?)
															, typeof(string)
															, typeof(DateTime)
															, typeof(DateTime?)
														};
		private class PropertyAccessor
		{
			public Func<object, object> Getter;
			public Action<object, object> Setter;
			public PropertyInfo Property;
		}
		private static Dictionary
							<
								Type
								, Dictionary
										<
											string
											, PropertyAccessor
										>
							> _typesPropertiesAccessors = new Dictionary<Type, Dictionary<string, PropertyAccessor>>();
		private static Dictionary<string, PropertyAccessor> GetTypePropertiesAccessors(Type type)
		{
			var properties = type.GetProperties();
			Dictionary<string, PropertyAccessor> dictionary = null;
			Array.ForEach
					(
						properties
						, (x) =>
						{
							if (
									_typesWhiteList.Any
													(
														(xx) =>
														{
															return xx == x.PropertyType;
														}
													)
								)
							{
								var accessor = new PropertyAccessor()
								{
									Getter = DynamicPropertyAccessor.CreateGetPropertyValueFunc(type, x.Name)
									,
									Setter = DynamicPropertyAccessor.CreateSetPropertyValueAction(type, x.Name)
									,
									Property = x
								};
								if (dictionary == null)
								{
									dictionary = new Dictionary<string, PropertyAccessor>();
								}
								dictionary.Add(x.Name, accessor);
							}
						}
					);
			return dictionary;
		}
		public static DataTable ToDataTable<TEntry>(this IEnumerable<TEntry> ie)
		{
			var type = typeof(TEntry);
			var accessors = GetTypePropertiesAccessors(type);
			var accessorsList = accessors.ToList();
			DataTable dataTable = GenerateEmptyDataTable(accessorsList);
			DataColumnCollection dcc = dataTable.Columns;
			if (dataTable != null)
			{
				using (IEnumerator<TEntry> enumerator = ie.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						var row = dataTable.NewRow();
						foreach (DataColumn c in dcc)
						{
							PropertyAccessor accessor = null;
							if (accessors.TryGetValue(c.ColumnName, out accessor))
							{
								object v = accessor.Getter(enumerator.Current);
								if (v == null)
								{
									v = DBNull.Value;
								}
								row[c] = v;
							}
						}
						dataTable.Rows.Add(row);
					}
				}
			}
			return dataTable;
		}
		private static DataTable GenerateEmptyDataTable(List<KeyValuePair<string, PropertyAccessor>> accessorsList)
		{
			DataTable dataTable = null;
			accessorsList
					.ForEach
						(
							(x) =>
							{
								if (dataTable == null)
								{
									dataTable = new DataTable();
								}
								var propertyType = x.Value.Property.PropertyType;
								if (propertyType.IsGenericType && propertyType.GetGenericTypeDefinition().Equals(typeof(Nullable<>)))
								{
									NullableConverter nullableConvert = new NullableConverter(propertyType);
									propertyType = nullableConvert.UnderlyingType;
								}
								var propertyName = x.Value.Property.Name;
								var column = new DataColumn
													(
														propertyName
														, propertyType
													);
								dataTable.Columns.Add(column);
							}
						);
			return dataTable;
		}
		public static DataTable ToDataTable<TEntry>(this List<TEntry> list)
		// where TEntry : new()
		{
			var type = typeof(TEntry);
			var accessors = GetTypePropertiesAccessors(type);
			var accessorsList = accessors.ToList();
			DataTable dataTable = GenerateEmptyDataTable(accessorsList);
			DataColumnCollection dcc = dataTable.Columns;
			if (dataTable != null)
			{
				list.ForEach
						(
							(x) =>
							{
								var row = dataTable.NewRow();
								foreach (DataColumn c in dcc)
								{
									PropertyAccessor accessor = null;
									if (accessors.TryGetValue(c.ColumnName, out accessor))
									{
										object v = accessor.Getter(x);
										if (v == null)
										{ 
											v = DBNull.Value;
										}
										row[c] = v;
									}
								}
								dataTable.Rows.Add(row);
							}
						);
			}
			return dataTable;
		}
		public static List<TEntry> ToList<TEntry>(this DataTable dataTable)
											where TEntry : new()
		{
			var type = typeof(TEntry);
			var columns = dataTable.Columns;
			var actions = new Dictionary<string, Action<object, object>>();
			foreach (DataColumn c in columns)
			{
				var columnName = c.ColumnName;
				var action = DynamicPropertyAccessor.CreateSetPropertyValueAction
												(
													typeof(TEntry)
													, columnName
												);
				actions[columnName] = action;
			}
			List<TEntry> list = null;
			var rows = dataTable.Rows;
			foreach (DataRow r in rows)
			{
				var entry = new TEntry();
				if (list == null)
				{
					list = new List<TEntry>();
				}
				foreach (DataColumn c in columns)
				{
					var columnName = c.ColumnName;
					var v = r[columnName];
					if (!DBNull.Value.Equals(v))
					{
						var action = actions[columnName];
						action(entry, v);
					}
				}
				list.Add(entry);
			}
			return list;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	using System.ComponentModel;
	public class DynamicPropertyAccessor
	{
		private static Assembly GetAssemblyByTypeName(string typeName)
		{
			return AppDomain.CurrentDomain.GetAssemblies().First
														(
															(a) =>
															{
																return a.GetTypes().Any
																					(
																						(t) =>
																						{
																							return (t.FullName == typeName);
																						}
																					);
															}
														);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(Type type, string propertyName)
		{
			
			var target = Expression.Parameter(typeof(object), "p");
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			//Type typeProperty = typeof(object);
			//if (type.IsGenericType && type.GetGenericTypeDefinition().Equals(typeof(Nullable<>)))
			//{
			//	NullableConverter nullableConvert = new NullableConverter(type);
			//	type = nullableConvert.UnderlyingType;
			//}
			
			var castPropertyValue = Expression.Convert(getPropertyValue,typeof(object));
			
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object), "p");
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName, typeof(TProperty));
			var getPropertyValue = Expression.Property(null, property);
			var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var getPropertyValue = Expression.Property(null, property);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object), "p");
			var propertyValue = Expression.Parameter(typeof(object), "p1");
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, object> CreateSetPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object), "p");
			var propertyValue = Expression.Parameter(typeof(TProperty), "p1");
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(object), "p");
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<object> CreateSetStaticPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(TProperty), "p");
			//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, propertyValue);
			var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Json;
	using System.Runtime.Serialization.Formatters.Binary;
	using System.Runtime.Serialization.Formatters.Soap;
	public static class SerializerHelper
	{
		public static T XmlSerializerXmlToObject<T>(string Xml)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			T Object = XmlSerializerXmlToObject<T>(Xml, serializer);
			return Object;
		}
		public static T XmlSerializerXmlToObject<T>(string Xml, XmlSerializer serializer)
		{
			StringReader stringReader = new StringReader(Xml);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			return (T)serializer.Deserialize(xmlReader);
		}
		public static string XmlSerializerObjectToXml<T>
									(
										T Object
										, XmlTextWriter writer
										, XmlSerializer serializer
									)
		{
			serializer.Serialize(writer, Object);
			MemoryStream stream = writer.BaseStream as MemoryStream;
			byte[] bytes = stream.ToArray();
			Encoding e = EncodingHelper.IdentifyEncoding
											(
												bytes
												, Encoding.GetEncoding("gb2312")
				///												, new Encoding[]
				///														{
				///															Encoding.UTF8
				///															, Encoding.Unicode
				///														}
											);
			byte[] buffer = e.GetPreamble();
			int offset = buffer.Length;
			buffer = new byte[bytes.Length - offset];
			Buffer.BlockCopy(bytes, offset, buffer, 0, buffer.Length);
			string s = e.GetString(buffer);
			return s;
		}
		public static string XmlSerializerObjectToXml<T>(T Object, XmlSerializer serializer)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				Encoding e = Encoding.UTF8;
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = XmlSerializerObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static string XmlSerializerObjectToXml<T>(T Object, Encoding e, XmlSerializer serializer)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = XmlSerializerObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static string XmlSerializerObjectToXml<T>(T Object, Encoding e)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				XmlSerializer serializer = new XmlSerializer(typeof(T));
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = XmlSerializerObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static string DataContractSerializerObjectToXml<T>(T Object, DataContractSerializer serializer)
		{
			MemoryStream ms = new MemoryStream();
			serializer.WriteObject(ms, Object);
			byte[] buffer = StreamDataHelper.ReadDataToBytes(ms);
			string xml = Encoding.UTF8.GetString(buffer);
			ms.Close();
			ms.Dispose();
			ms = null;
			return xml;
		}
		public static string DataContractSerializerObjectToXml<T>(T Object)
		{
			DataContractSerializer serializer = new DataContractSerializer(typeof(T));
			string xml = DataContractSerializerObjectToXml<T>(Object, serializer);
			return xml;
		}
		public static T DataContractSerializerXmlToObject<T>(string Xml, DataContractSerializer serializer)
		{
			byte[] buffer = Encoding.UTF8.GetBytes(Xml);
			MemoryStream ms = new MemoryStream(buffer);
			//ms.Position = 0;
			T Object = (T)serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return Object;
		}
		public static T DataContractSerializerXmlToObject<T>(string Xml)
		{
			DataContractSerializer serializer = new DataContractSerializer(typeof(T));
			byte[] buffer = Encoding.UTF8.GetBytes(Xml);
			MemoryStream ms = new MemoryStream(buffer);
			//ms.Position = 0;
			T Object = (T)serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return Object;
		}
		public static string FormatterObjectToSoap<T>
							 (
								 T Object
							 )
		{
			using (MemoryStream stream = new MemoryStream())
			{
				SoapFormatter formatter = new SoapFormatter();
				formatter.Serialize(stream, Object);
				string soap = Encoding.UTF8.GetString(stream.GetBuffer());
				return soap;
			}
		}
		public static T FormatterSoapToObject<T>
									(
										string soap
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				SoapFormatter formater = new SoapFormatter();
				byte[] data = Encoding.UTF8.GetBytes(soap);
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T Object = (T)formater.Deserialize(stream);
				return Object;
			}
		}
		public static byte[] FormatterObjectToBinary<T>
									(
										T Object
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				formater.Serialize(stream, Object);
				byte[] buffer = stream.ToArray();
				return buffer;
			}
		}
		public static string DataContractSerializerObjectToJson<T>(T Object)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			string json = DataContractSerializerObjectToJson<T>(Object);
			return json;
		}
		public static string DataContractSerializerObjectToJson<T>(T Object, DataContractJsonSerializer serializer)
		{
			MemoryStream ms = new MemoryStream();
			serializer.WriteObject(ms, Object);
			string json = Encoding.UTF8.GetString(ms.GetBuffer());
			ms.Close();
			ms.Dispose();
			ms = null;
			return json;
		}
		public static T DataContractSerializerJsonToObject<T>(string json)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			T Object = DataContractSerializerJsonToObject<T>(json, serializer);
			return Object;
		}
		public static T DataContractSerializerJsonToObject<T>(string json, DataContractJsonSerializer serializer)
		{
			MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
			T Object = (T)serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return Object;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	using System.Text;
	using System.Collections.Generic;
	public static class EncodingHelper
	{
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, identifyEncodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
									)
		{
			EncodingInfo[] encodingInfos = Encoding.GetEncodings();
			List<Encoding> list = new List<Encoding>();
			foreach (EncodingInfo info in encodingInfos)
			{
				Encoding e = info.GetEncoding();
				if (e.GetPreamble().Length > 0)
				{
					list.Add(e);
					//System.Console.WriteLine(e.EncodingName);
				}
			}
			Encoding[] encodings = new Encoding[list.Count];
			list.CopyTo(encodings);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, encodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			Encoding encoding = defaultEncoding;
			foreach (Encoding e in identifyEncodings)
			{
				byte[] buffer = e.GetPreamble();
				int l = buffer.Length;
				if (l == 0)
				{
					continue;
				}
				bool flag = false;
				for (int i = 0; i < l; i++)
				{
					if (buffer[i] != data[i])
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				else
				{
					encoding = e;
				}
			}
			return encoding;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=DataTable 序列化反序列化
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Json;
	using System.Runtime.Serialization.Formatters.Soap;
	using System.Data;
	using Test.Share;
	using Microshaoft;
	public class Class1
	{
		static DataTable _wd = null;
		static void Main(string[] args)
		{
			DataTable dt = new DataTable("Temp");
			DataColumnCollection dcc = dt.Columns;
			dcc.Add(new DataColumn("F1", typeof(string)));
			dcc.Add(new DataColumn("F2", typeof(int)));
			dcc.Add(new DataColumn("F3", typeof(DateTime)));
			for (int i = 0; i < 10; i++)
			{
				DataRow dr = dt.NewRow();
				dr[0] = "Microshaoft简体繁w中文";
				dr[1] = i;
				dr[2] = DateTime.Now;
				dt.Rows.Add(dr);
			}
			_wd = dt;
			int iteration = 10000;
			Type t = dt.GetType();
			int length = 0;
			MemoryStream stream = new MemoryStream();
			dt.WriteXml(stream);
			byte[] buf = StreamDataHelper.ReadDataToBytes(stream);
			string ss = Encoding.UTF8.GetString(buf);
			Console.WriteLine(ss);
			DataContractSerializer serializer2 = new DataContractSerializer(t);
			CodeTimer.ParallelTime
						(
							"TestDataContractSerializer"
							, iteration
							, () =>
								{
									length = TestDataContractSerializer(serializer2);
								}
						);
			Console.WriteLine("Length: {0}", length);
			XmlSerializer serializer1 = new XmlSerializer(t);
			CodeTimer.ParallelTime
						(
							"TestXmlSerializer"
							, iteration
							, () =>
								{
									length = TestXmlSerializer(serializer1);
								}
						);
			Console.WriteLine("Length: {0}", length);
			//DataContractJsonSerializer serializer3 = new DataContractJsonSerializer(t);
			//CodeTimer.ParallelTime
			//			(
			//				"TestDataContractJsonSerializer"
			//				, iteration
			//				, () =>
			//					{
			//						//length = TestDataContractJsonSerializer(serializer3);
			//					}
			//			);
			//Console.WriteLine("Length: {0}", length);
			//CodeTimer.ParallelTime
			//			(
			//				"TestSoapFormatter"
			//				, iteration
			//				, () =>
			//					{
			//						//length = TestSoapFormatter();
			//					}
			//			);
			//Console.WriteLine("Length: {0}", length);
			//CodeTimer.ParallelTime
			//			(
			//				"TestBinaryFormatter"
			//				, iteration
			//				, () =>
			//				{
			//					//length = TestBinaryFormatter();
			//				}
			//			);
			Console.WriteLine("Length: {0}", length);
			Console.WriteLine();
			Console.WriteLine();
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		static int TestXmlSerializer(XmlSerializer serializer)
		{
			string xml = string.Empty;
			xml = SerializerHelper.XmlSerializerObjectToXml<DataTable>(_wd, serializer);
			//Console.WriteLine(xml);
			DataTable wd = SerializerHelper.XmlSerializerXmlToObject<DataTable>(xml, serializer);
			return xml.Length;
		}
		static int TestDataContractSerializer(DataContractSerializer serializer)
		{
			string xml = string.Empty;
			xml = SerializerHelper.DataContractSerializerObjectToXml<DataTable>(_wd, serializer);
			//Console.WriteLine(xml);
			DataTable wd = SerializerHelper.DataContractSerializerXmlToObject<DataTable>(xml, serializer);
			return xml.Length;
		}
		static int TestDataContractJsonSerializer(DataContractJsonSerializer serializer)
		{
			string json = string.Empty;
			json = SerializerHelper.DataContractSerializerObjectToJson<DataTable>(_wd, serializer);
			//Console.WriteLine(xml.Length);
			DataTable wd = SerializerHelper.DataContractSerializerJsonToObject<DataTable>(json, serializer);
			return json.Length;
		}
		static int TestSoapFormatter()
		{
			string soap = string.Empty;
			soap = SerializerHelper.FormatterObjectToSoap<DataTable>(_wd);
			//Console.WriteLine(xml.Length);
			DataTable wd = SerializerHelper.FormatterSoapToObject<DataTable>(soap);
			return soap.Length;
		}
		static int TestBinaryFormatter()
		{
			byte[] buffer;
			//xml = SerializerHelper.XmlSerializerObjectToXml<DataTable>(_wd, Encoding.UTF8);
			//DataTable wd = SerializerHelper.XmlSerializerXmlToObject<DataTable>(xml);
			buffer = SerializerHelper.FormatterObjectToBinary<DataTable>(_wd);
			//Console.WriteLine(xml.Length);
			DataTable wd = SerializerHelper.FormatterBinaryToObject<DataTable>(buffer);
			return buffer.Length;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Runtime.InteropServices;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void ParallelTime(string name, int iteration, Action action)
		{
			InternalIterationProcess
					 (
						name
						, iteration
						, () =>
							{
								Parallel.For
										(
											0
											, iteration
											, new ParallelOptions()
													{
														MaxDegreeOfParallelism = 1
														//, TaskScheduler = null
													}
													, i =>
													{
														action();
													}
											);
							}
						);
		}
		private static void InternalIterationProcess(string name, int iteration, Action action)
		{
			if (string.IsNullOrEmpty(name))
			{
				return;
			}
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCycleCount();
			action();
			ulong cpuCycles = GetCycleCount() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine
							(
								"{0}Time Elapsed:{0}{1}ms"
								, "\t"
								, watch.ElapsedMilliseconds.ToString("N0")
							);
			Console.WriteLine
							(
								"{0}CPU Cycles:{0}{1}"
								, "\t"
								, cpuCycles.ToString("N0")
							);
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine
							(
								"{0}Gen {1}: {0}{0}{2}"
								, "\t"
								, i
								, count
							);
			}
			Console.WriteLine();
		}
		public static void Time(string name, int iteration, Action action)
		{
			InternalIterationProcess
								(
									name
									, iteration
									, () =>
									{
										for (int i = 0; i < iteration; i++)
										{
											action();
										}
									}
									);
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
	}
}
namespace Test.Share
{
	using System;
	using System.Xml.Serialization;
	using System.Runtime.Serialization;
	[XmlRoot("WebDirectory")]
	[Serializable]
	[DataContract]
	public class WebDirectory
	{
		[XmlAttribute("Name")]
		[DataMember]
		public string Name;
		[XmlArrayItem("WebFile", typeof(WebFile))]
		[XmlArray("WebFiles")]
		[DataMember]
		public WebFile[] WebFiles;
	}
	[DataContract]
	public enum FlagEnum : uint
	{
		[EnumMember]
		Value1
		,
		[EnumMember]
		Value2
	}
	[Serializable]
	[DataContract]
	public class WebFile
	{
		[XmlAttribute("Name")]
		[DataMember]
		public string Name;
		[XmlAttribute("CreateTime")]
		[DataMember]
		public DateTime CreateTime;
		[XmlAttribute("LastWriteTime")]
		[XmlIgnore()]
		[DataMember]
		public DateTime LastWriteTime;
		[XmlAttribute("Length")]
		[DataMember]
		public long Length;
		//[XmlAttribute("Url")]
		[XmlElement("Url")]
		[DataMember]
		public string Url;
		[XmlAttribute("IsReadOnly")]
		[DataMember]
		public bool IsReadOnly;
		[XmlAttribute("Flag")]
		[DataMember]
		public FlagEnum Flag;
		[XmlElement("Directory")]
		[DataMember]
		public WebDirectory Directory;
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Json;
	using System.Runtime.Serialization.Formatters.Binary;
	using System.Runtime.Serialization.Formatters.Soap;
	public static class SerializerHelper
	{
		public static T XmlSerializerXmlToObject<T>(string Xml)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			T Object = XmlSerializerXmlToObject<T>(Xml, serializer);
			return Object;
		}
		public static T XmlSerializerXmlToObject<T>(string Xml, XmlSerializer serializer)
		{
			StringReader stringReader = new StringReader(Xml);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			return (T) serializer.Deserialize(xmlReader);
		}
		public static string XmlSerializerObjectToXml<T>
									(
										T Object
										, XmlTextWriter writer
										, XmlSerializer serializer
									)
		{
			serializer.Serialize(writer, Object);
			MemoryStream stream = writer.BaseStream as MemoryStream;
			byte[] bytes = stream.ToArray();
			Encoding e = EncodingHelper.IdentifyEncoding
											(
												bytes
												, Encoding.GetEncoding("gb2312")
				///												, new Encoding[]
				///														{
				///															Encoding.UTF8
				///															, Encoding.Unicode
				///														}
											);
			byte[] buffer = e.GetPreamble();
			int offset = buffer.Length;
			buffer = new byte[bytes.Length - offset];
			Buffer.BlockCopy(bytes, offset, buffer, 0, buffer.Length);
			string s = e.GetString(buffer);
			return s;
		}
		public static string XmlSerializerObjectToXml<T>(T Object, XmlSerializer serializer)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				Encoding e = Encoding.UTF8;
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = XmlSerializerObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static string XmlSerializerObjectToXml<T>(T Object, Encoding e, XmlSerializer serializer)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = XmlSerializerObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static string XmlSerializerObjectToXml<T>(T Object, Encoding e)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				XmlSerializer serializer = new XmlSerializer(typeof(T));
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = XmlSerializerObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
			
		}
		public static string DataContractSerializerObjectToXml<T>(T Object, DataContractSerializer serializer)
		{
			MemoryStream ms = new MemoryStream();
			serializer.WriteObject(ms, Object);
			byte[] buffer = StreamDataHelper.ReadDataToBytes(ms);
			string xml = Encoding.UTF8.GetString(buffer);
			ms.Close();
			ms.Dispose();
			ms = null;
			return xml;
		}
		public static string DataContractSerializerObjectToXml<T>(T Object)
		{
			DataContractSerializer serializer = new DataContractSerializer(typeof(T));
			string xml = DataContractSerializerObjectToXml<T>(Object, serializer);
			return xml;
		}
		public static T DataContractSerializerXmlToObject<T>(string Xml, DataContractSerializer serializer)
		{
			byte[] buffer = Encoding.UTF8.GetBytes(Xml);
			MemoryStream ms = new MemoryStream(buffer);
			//ms.Position = 0;
			T Object = (T)serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return Object;
		}
		public static T DataContractSerializerXmlToObject<T>(string Xml)
		{
			DataContractSerializer serializer = new DataContractSerializer(typeof(T));
			byte[] buffer = Encoding.UTF8.GetBytes(Xml);
			MemoryStream ms = new MemoryStream(buffer);
			//ms.Position = 0;
			T Object = (T) serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return Object;
		}
		public static string FormatterObjectToSoap<T>
							 (
								 T Object
							 )
		{
			using (MemoryStream stream = new MemoryStream())
			{
				SoapFormatter formatter = new SoapFormatter();
				formatter.Serialize(stream, Object);
				string soap = Encoding.UTF8.GetString(stream.GetBuffer());
				return soap;
			}
		}
		public static T FormatterSoapToObject<T>
									(
										string soap
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				SoapFormatter formater = new SoapFormatter();
				byte[] data = Encoding.UTF8.GetBytes(soap);
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T Object = (T) formater.Deserialize(stream);
				return Object;
			}
		}
		public static byte[] FormatterObjectToBinary<T>
									(
										T Object
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				formater.Serialize(stream, Object);
				byte[] buffer = stream.ToArray();
				return buffer;
			}
		}
		public static T FormatterBinaryToObject<T>
									(
										byte[] data
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T Object = (T)formater.Deserialize(stream);
				return Object;
			}
		}
		public static string DataContractSerializerObjectToJson<T>(T Object)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			string json = DataContractSerializerObjectToJson<T>(Object);
			return json;
		}
		public static string DataContractSerializerObjectToJson<T>(T Object, DataContractJsonSerializer serializer)
		{
			MemoryStream ms = new MemoryStream();
			serializer.WriteObject(ms, Object);
			string json = Encoding.UTF8.GetString(ms.GetBuffer());
			ms.Close();
			ms.Dispose();
			ms = null;
			return json;
		}
		public static T DataContractSerializerJsonToObject<T>(string json)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			T Object = DataContractSerializerJsonToObject<T>(json, serializer);
			return Object;
		}
		public static T DataContractSerializerJsonToObject<T>(string json, DataContractJsonSerializer serializer)
		{
			MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
			T Object = (T) serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return Object;
		}
	  }
}
namespace Microshaoft
{
	using System.IO;
	using System.Text;
	using System.Collections.Generic;
	public static class EncodingHelper
	{
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, identifyEncodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
									)
		{
			EncodingInfo[] encodingInfos = Encoding.GetEncodings();
			List<Encoding> list = new List<Encoding>();
			foreach (EncodingInfo info in encodingInfos)
			{
				Encoding e = info.GetEncoding();
				if (e.GetPreamble().Length > 0)
				{
					list.Add(e);
					//System.Console.WriteLine(e.EncodingName);
				}
			}
			Encoding[] encodings = new Encoding[list.Count];
			list.CopyTo(encodings);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, encodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			Encoding encoding = defaultEncoding;
			foreach (Encoding e in identifyEncodings)
			{
				byte[] buffer = e.GetPreamble();
				int l = buffer.Length;
				if (l == 0)
				{
					continue;
				}
				bool flag = false;
				for (int i = 0; i < l; i++)
				{
					if (buffer[i] != data[i])
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				else
				{
					encoding = e;
				}
			}
			return encoding;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=DataTableHelper
namespace ConsoleApplication
{
	using System;
	using System.Collections.Generic;
	using System.Data;
	using System.Linq;
	using System.Text;
	using System.Xml.Serialization;
	using Microshaoft;
	public class Class1
	{
		//[STAThread]
		[Serializable]
		public class Entry
		{
			[XmlElement("F1")]
			public string F1 { get; set; }
			[XmlElement("F2")]
			public int F2 { get; set; }
			[XmlAttribute("F3")]
			public DateTime F3 { get; set; }
			public DateTime? FF3 { get; set; }
			[XmlArrayItem("Entry2", typeof(Entry2))]
			[XmlArray("Entry2S")]
			public Entry2[] Entry2S { get; set; }
		};
		public class Entry2
		{
			[XmlElement("F1")]
			public string F1 { get; set; }
			[XmlElement("F2")]
			public int F2 { get; set; }
			[XmlAttribute("F3")]
			public DateTime F3 { get; set; }
			public DateTime? FF3 { get; set; }
		};
		static void Main(string[] args)
		{
			var list = new List<Entry>()
							{
								new Entry() 
									{
										F1 = "a"
										, F2= 1
										, F3 = DateTime.Now
										, FF3 = null
										, Entry2S = new []
														{
															new Entry2 ()
															{
																F1 = "sadasd"
																, F2 = 10
																, F3 = DateTime.Now
															}
															, new Entry2 ()
															{
																F1 = "sadasd"
																, F2 = 10
																, F3 = DateTime.Now
															}
															, new Entry2 ()
															{
																F1 = "sadasd"
																, F2 = 10
																, F3 = DateTime.Now
															}
														}
									}
								,new Entry() 
									{
										F1= "b"
										, F2= 2
										, F3 = DateTime.Now
										, FF3 = null
										, Entry2S = new []
													{
														new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
														, new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
														, new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
													}
									}
								,new Entry() 
									{
										F1= "c"
										, F2= 3
										, F3 = DateTime.Now
										, FF3 = null
										, Entry2S = new []
													{
														new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
														, new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
														, new Entry2 ()
														{
															F1 = "sadasd"
															, F2 = 10
															, F3 = DateTime.Now
														}
													}
									}
							};
			var dataTable = list.ToDataTable<Entry>();
			DataTableHelper.DataTableRowsForEach
								(
									dataTable
									, (x, y) =>
										{
											Console.WriteLine("{1}{0}{2}", " : ", y, x.ColumnName);
											return false;
										}
									, (x) =>
										{
											Console.WriteLine("{1}", " : ", x.Count);
											return false;
										}
									, (x, y, z, w) =>
										{
											Console.WriteLine("{1}{0}{2}{0}{3}{0}{4}", " : ", x.ColumnName, y, z, w);
											return false;
										}
									, (x, y, z) =>
										{
											Console.WriteLine("{1}{0}{2}", " : ", x.Count,  z);
											return false;
										}
								);
			dataTable = DataTableHelper.GenerateEmptyDataTable<Entry>();
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Data;
	using System.Linq;
	using System.Text;
	public static class DataTableHelper
	{
		private static List<Type> _typesWhiteList = new List<Type>()
														{
															typeof(int)
															//, typeof(int?)
															, typeof(long)
															//, typeof(long?)
															, typeof(string)
															, typeof(DateTime)
															//, typeof(DateTime?)
														};
		public static DataTable GenerateEmptyDataTable<T>()
		{ 
			var type = typeof(T);
			return GenerateEmptyDataTable(type);
		}
		public static DataTable GenerateEmptyDataTable(Type type)
		{
			var properties = type.GetProperties().Where
													(
														(x) =>
														{
															return
																_typesWhiteList.Any
																				 (
																					(xx) =>
																					{
																						return x.PropertyType == xx;
																					}
																				 );
														}
													)
													.ToList();
			DataTable dataTable = null;
			DataColumnCollection dataColumnsCollection = null;
			properties.ForEach
						(
							(x) =>
							{
								if (dataTable == null)
								{
									dataTable = new DataTable();
								}
								if (dataColumnsCollection == null)
								{
									dataColumnsCollection = dataTable.Columns;
								}
								dataColumnsCollection.Add
													(
														x.Name
														, x.PropertyType
													);
							}
						);
			return dataTable;
		}
		public static void DataTableRowsForEach
										(
											DataTable dataTable
											, Func<DataColumn,int, bool> processHeaderDataColumnFunc = null
											, Func<DataColumnCollection, bool> processHeaderDataColumnsFunc = null
											, Func<DataColumn, int, object, int, bool> processRowDataColumnFunc = null
											, Func<DataColumnCollection, DataRow, int, bool> processRowFunc = null
										)
		{
			DataColumnCollection dataColumnCollection = null;
			int i = 0;
			bool r = false;
			if (processHeaderDataColumnFunc != null)
			{ 
				dataColumnCollection = dataTable.Columns;
				foreach (DataColumn dc in dataColumnCollection)
				{ 
					i ++;
					r = processHeaderDataColumnFunc(dc, i);
					if (r)
					{
						break;
					}
				}
			}
			if (processHeaderDataColumnsFunc != null)
			{
				if (dataColumnCollection == null)
				{
					dataColumnCollection = dataTable.Columns;
				}
				r = processHeaderDataColumnsFunc(dataColumnCollection);
				if (r)
				{
					return;
				}			
			}
			DataRowCollection drc = null;
			if
				(
					processRowDataColumnFunc != null
					|| processRowFunc != null
				)
			{
				drc = dataTable.Rows;
				if
					(
						(
							processRowDataColumnFunc != null
							|| processRowFunc != null
						)
						&& dataColumnCollection == null
					)
				{
					dataColumnCollection = dataTable.Columns;
				}
				i = 0;
				var j = 0;
				foreach (DataRow dataRow in drc)
				{
					i ++;
					foreach (DataColumn dc in dataColumnCollection)
					{
						if (processRowDataColumnFunc != null)
						{ 
							j ++;
							r = processRowDataColumnFunc
											(
												dc
												, j
												, dataRow[dc]
												, i
											);
							if (r)
							{
								j = 0;
								break;
							}
						}
					}
					if (processRowFunc != null)
					{
						processRowFunc(dataColumnCollection, dataRow, i);
					}
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Data;
	using System.Linq;
	using System.Reflection;
	public static class ExtensionMethodsManager
	{
		private static List<Type> _typesWhiteList = new List<Type>()
														{
															typeof(int)
															//, typeof(int?)
															, typeof(long)
															//, typeof(long?)
															, typeof(string)
															, typeof(DateTime)
															//, typeof(DateTime?)
														};
		private class PropertyAccessor
		{
			public Func<object, object> Getter;
			public Action<object, object> Setter;
			public PropertyInfo Property;
		}
		private static Dictionary
							<
								Type
								, Dictionary
										<
											string
											, PropertyAccessor
										>
							> _typesPropertiesAccessors = new Dictionary<Type, Dictionary<string, PropertyAccessor>>();
		private static Dictionary<string, PropertyAccessor> GetTypePropertiesAccessors(Type type)
		{
			var properties = type.GetProperties();
			Dictionary<string, PropertyAccessor> dictionary = null;
			Array.ForEach
					(
						properties
						, (x) =>
						{
							if (
									_typesWhiteList.Any
													(
														(xx) =>
														{
															return xx == x.PropertyType;
														}
													)
								)
							{
								var accessor = new PropertyAccessor()
								{
									Getter = DynamicPropertyAccessor.CreateGetPropertyValueFunc(type, x.Name)
									 ,
									Setter = DynamicPropertyAccessor.CreateSetPropertyValueAction(type, x.Name)
									 ,
									Property = x
								};
								if (dictionary == null)
								{
									dictionary = new Dictionary<string, PropertyAccessor>();
								}
								dictionary.Add(x.Name, accessor);
							}
						}
					);
			return dictionary;
		}
		public static DataTable ToDataTable<TEntry>(this IEnumerable<TEntry> ie)
		{
			var type = typeof(TEntry);
			var accessors = GetTypePropertiesAccessors(type);
			var accessorsList = accessors.ToList();
			DataTable dataTable = GenerateEmptyDataTable(accessorsList);
			DataColumnCollection dcc = dataTable.Columns;
			if (dataTable != null)
			{
				using (IEnumerator<TEntry> enumerator = ie.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						var row = dataTable.NewRow();
						foreach (DataColumn c in dcc)
						{
							PropertyAccessor accessor = null;
							if (accessors.TryGetValue(c.ColumnName, out accessor))
							{
								row[c] = accessor.Getter(enumerator.Current);
							}
						}
						dataTable.Rows.Add(row);
					}
				}
			}
			return dataTable;
		}
		private static DataTable GenerateEmptyDataTable(List<KeyValuePair<string, PropertyAccessor>> accessorsList)
		{
			DataTable dataTable = null;
			accessorsList
					.ForEach
						(
							(x) =>
							{
								if (dataTable == null)
								{
									dataTable = new DataTable();
								}
								var propertyType = x.Value.Property.PropertyType;
								var propertyName = x.Value.Property.Name;
								var column = new DataColumn
													(
														propertyName
														, propertyType
													);
								dataTable.Columns.Add(column);
							}
						);
			return dataTable;
		}
		public static DataTable ToDataTable<TEntry>(this List<TEntry> list)
		// where TEntry : new()
		{
			var type = typeof(TEntry);
			var accessors = GetTypePropertiesAccessors(type);
			var accessorsList = accessors.ToList();
			DataTable dataTable = GenerateEmptyDataTable(accessorsList);
			DataColumnCollection dcc = dataTable.Columns;
			if (dataTable != null)
			{
				list.ForEach
						(
							(x) =>
							{
								var row = dataTable.NewRow();
								foreach (DataColumn c in dcc)
								{
									PropertyAccessor accessor = null;
									if (accessors.TryGetValue(c.ColumnName, out accessor))
									{
										row[c] = accessor.Getter(x);
									}
								}
								dataTable.Rows.Add(row);
							}
						);
			}
			return dataTable;
		}
		public static List<TEntry> ToList<TEntry>(this DataTable dataTable)
											where TEntry : new()
		{
			var type = typeof(TEntry);
			var columns = dataTable.Columns;
			var actions = new Dictionary<string, Action<object, object>>();
			foreach (DataColumn c in columns)
			{
				var columnName = c.ColumnName;
				var action = DynamicPropertyAccessor.CreateSetPropertyValueAction
												(
													typeof(TEntry)
													, columnName
												);
				actions[columnName] = action;
			}
			List<TEntry> list = null;
			var rows = dataTable.Rows;
			foreach (DataRow r in rows)
			{
				var entry = new TEntry();
				if (list == null)
				{
					list = new List<TEntry>();
				}
				foreach (DataColumn c in columns)
				{
					var columnName = c.ColumnName;
					var action = actions[columnName];
					action(entry, r[columnName]);
				}
				list.Add(entry);
			}
			return list;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public class DynamicPropertyAccessor
	{
		private static Assembly GetAssemblyByTypeName(string typeName)
		{
			return AppDomain.CurrentDomain.GetAssemblies().First
														(
															(a) =>
															{
																return a.GetTypes().Any
																					(
																						(t) =>
																						{
																							return (t.FullName == typeName);
																						}
																					);
															}
														);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object), "p");
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object), "p");
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName, typeof(TProperty));
			var getPropertyValue = Expression.Property(null, property);
			var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var getPropertyValue = Expression.Property(null, property);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object), "p");
			var propertyValue = Expression.Parameter(typeof(object), "p1");
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, object> CreateSetPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object), "p");
			var propertyValue = Expression.Parameter(typeof(TProperty), "p1");
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(object), "p");
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<object> CreateSetStaticPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(TProperty), "p");
			//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, propertyValue);
			var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}

#T=DateTimeHelper 2012-08-12
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Threading;
	using System.Threading.Tasks;
	using System.IO;
	class Program
	{
		static void Main()
		{
			var noww = DateTime.Now;
			var xxx = DateTimeHelper.GetAlignSecondsDateTime(noww, 86400 * 7);
			Console.WriteLine("{1}{0}{2}", ":", xxx, xxx.DayOfWeek);
			string r = string.Empty;
			string rootPath = @"e:\temp4";
			Console.WriteLine("测试项目1");
			Console.WriteLine("按任意键测试该项目, 按\"q\"退出该测试项目");
			while ((r = Console.ReadLine()) != "q")
			{
				DateTime now = new DateTime(2012, 5, 12);
				CodeTimer.Time
					(
						"写文件"
						, 1
						, () =>
							{
								Parallel.For
										(
											0
											, 86400
											, (x) =>
												{
													DateTimeHelper.GetAlignSecondsDateTimes<string>
																			(
																				now.AddSeconds(x)
																				, Tuple.Create<long, Func<DateTime, long, DateTime, string, string>>
																							(
																								24 * 60 * 60
																								, (time, alignSeconds, alignedTime, data) =>
																								{
																									//Console.WriteLine(alignedTime);
																									var directory = alignedTime.ToString("yyyy-MM-dd");
																									var path = (string.IsNullOrEmpty(data) || string.IsNullOrWhiteSpace(data) ? rootPath : data);
																									path = string.Format
																													(
																														"{1}{0}{2}"
																														, @"\"
																														, path.Trim(new char[] { '\\' })
																														, directory
																													);
																									if (!Directory.Exists(path))
																									{
																										Directory.CreateDirectory(path);
																									}
																									return path;
																								}
																							)
																				, Tuple.Create<long, Func<DateTime, long, DateTime, string, string>>
																							(
																								1 * 60 * 60
																								, (time, alignSeconds, alignedTime, data) =>
																								{
																									//Console.WriteLine(alignedTime);
																									var directory = alignedTime.ToString("yyyy-MM-dd_HH");
																									var path = (string.IsNullOrEmpty(data) || string.IsNullOrWhiteSpace(data) ? rootPath : data);
																									path = string.Format
																													(
																														"{1}{0}{2}"
																														, @"\"
																														, path.Trim(new char[] { '\\' })
																														, directory
																													);
																									if (!Directory.Exists(path))
																									{
																										Directory.CreateDirectory(path);
																									}
																									return path;
																								}
																							)
																				, Tuple.Create<long, Func<DateTime, long, DateTime, string, string>>
																							(
																								5 * 60
																								, (time, alignSeconds, alignedTime, data) =>
																								{
																									var directory = DateTimeHelper.GetDateTimeString(alignedTime, "yyyy-MM-dd_HH-mm");
																									var path = (string.IsNullOrEmpty(data) || string.IsNullOrWhiteSpace(data) ? rootPath : data);
																									path = string.Format
																													(
																														"{1}{0}{2}"
																														, @"\"
																														, path.Trim(new char[] { '\\' })
																														, directory
																													);
																									if (!Directory.Exists(path))
																									{
																										Directory.CreateDirectory(path);
																									}
																									if (x % 300 != 0)
																									{
																										return string.Empty;
																									}
																									string file = string.Empty;
																									string s = DateTimeHelper.GetDateTimeString(alignedTime, "yyyyMMdd-HHmmss");
																									file = string.Format
																														(
																															"{1}{0}{2}.{3}.txt"
																															, @"\"
																															, path
																															, s
																															, Guid.NewGuid().ToString("N")
																														);
																									using (StreamWriter sw = new StreamWriter(File.OpenWrite(file)))
																									{
																										sw.WriteLine(s);
																									}
																									return string.Empty;
																								}
																							)
																			);
												}
										);
							}
					);
				Console.WriteLine("ok");
			}
			Console.WriteLine("测试项目2");
			Console.WriteLine("按任意键测试该项目, 按\"q\"退出该测试项目");
			r = string.Empty;
			while ((r = Console.ReadLine()) != "q")
			{
				CodeTimer.ParallelTime
							(
								"GetFiles"
								, 5
								, Environment.ProcessorCount
								, () =>
									{
										//Console.WriteLine(Directory.GetDirectories(@"e:\temp2", "*.*", SearchOption.AllDirectories).Length);
										string[] files = Directory.GetFiles(rootPath, "*.*", SearchOption.AllDirectories);
										var list = files.ToList();
										Parallel.ForEach
													(
														list
														, new ParallelOptions()
															{
																MaxDegreeOfParallelism =
																	//			1
																Environment.ProcessorCount - 0
															}
														, (x) =>
															{
																string s = File.ReadAllText(x);
															}
													);
									}
							);
			}
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Runtime.InteropServices;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void ParallelTime(string name, int iteration, int maxDegreeOfParallelism, Action action)
		{
			InternalIterationProcess
					(
						name
						, iteration
						, () =>
						{
							Parallel.For
										(
											0
											, iteration
											, new ParallelOptions()
											{
												MaxDegreeOfParallelism = maxDegreeOfParallelism
												//, TaskScheduler = null
											}
											, i =>
											{
												action();
											}
										);
						}
					);
		}
		private static void InternalIterationProcess(string name, int iteration, Action action)
		{
			if (string.IsNullOrEmpty(name))
			{
				return;
			}
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCycleCount();
			action();
			ulong cpuCycles = GetCycleCount() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine
							(
								"{0}Time Elapsed:{0}{1}ms"
								, "\t"
								, watch.ElapsedMilliseconds.ToString("N0")
							);
			Console.WriteLine
							(
								"{0}CPU Cycles:{0}{1}"
								, "\t"
								, cpuCycles.ToString("N0")
							);
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine
							(
								"{0}Gen{1}:{0}{0}{2}"
								, "\t"
								, i
								, count
							);
			}
			Console.WriteLine();
		}
		public static void Time(string name, int iteration, Action action)
		{
			InternalIterationProcess
								(
									name
									, iteration
									, () =>
									{
										for (int i = 0; i < iteration; i++)
										{
											action();
										}
									}
									);
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Globalization;
	public static class DateTimeHelper
	{
		public static void GetAlignSecondsDateTimes<T>
								(
									DateTime time
									, params Tuple<long, Func<DateTime, long, DateTime, T, T>>[] processAlignSecondsDateTimesFuncs
								)
		{
			T r = default(T);
			foreach (var x in processAlignSecondsDateTimesFuncs)
			{
				var alignSeconds = x.Item1;
				var alignTime = DateTimeHelper.GetAlignSecondsDateTime(time, alignSeconds);
				if (x.Item2 != null)
				{
					r = x.Item2(time, alignSeconds, alignTime, r);
				}
			}
		}
		public static bool IsVaildateTimestamp(DateTime timeStamp, int timeoutSeconds)
		{
			long l = SecondsDiffNow(timeStamp);
			return ((l > 0) && (l < timeoutSeconds));
		}
		public static long MillisecondsDiffNow(DateTime time)
		{
			long now = DateTime.Now.Ticks;
			long t = time.Ticks;
			return (t - now) / 10000;
		}
		public static long SecondsDiffNow(DateTime time)
		{
			return MillisecondsDiffNow(time) / 1000;
		}
		public static DateTime GetAlignSecondsDateTime(DateTime time, long alignSeconds)
		{
			long ticks = time.Ticks;
			ticks -= ticks % (10000 * 1000 * alignSeconds);
			DateTime dt = new DateTime(ticks);
			return dt;
		}
		public static string GetDateTimeString(DateTime time, string format)
		{
			return time.ToString(format);
		}
		public static DateTime GetPeriodBeginDate(DateTime time, int days)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * days);
			return r;
		}
		public static DateTime GetPeriodEndDate(DateTime time, int days)
		{
			DateTime r = GetPeriodBeginDate(time, days).AddDays(days - 1);
			return r;
		}
		public static DateTime GetWeekMondayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7);
			return r;
		}
		public static DateTime GetWeekTuesdayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(1);
			return r;
		}
		public static DateTime GetWeekWednesdayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(2);
			return r;
		}
		public static DateTime GetWeekThursdayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(3);
			return r;
		}
		public static DateTime GetWeekFridayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(4);
			return r;
		}
		public static DateTime GetWeekSaturdayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(5);
			return r;
		}
		public static DateTime GetWeekSundayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(6);
			return r;
		}
		public static DateTime? ParseExactNullableDateTime(string text, string format)
		{
			DateTime time;
			DateTime? r = DateTime.TryParseExact
										(
											text
											, format
											, DateTimeFormatInfo.InvariantInfo
											, DateTimeStyles.None
											, out time
										) ? time as DateTime? : null;
			return r;
		}
	}
}
#T=Decoder
namespace Microshaoft
{
	using System;
	using System.Text;
	public class Program
	{
		public static void Main()
		{
			// These bytes in UTF-8 correspond to 3 different Unicode
			// characters: space (U+0020), # (U+0023), and the biohazard
			// symbol (U+2623).  Note the biohazard symbol requires 3 bytes
			// in UTF-8 (hexadecimal e2, 98, a3).  Decoders store state across
			// multiple calls to GetChars, handling the case when one char
			// is in multiple byte arrays.
			byte[] bytes1 = { 0x20, 0x23, 0xe2 };
			byte[] bytes2 = { 0x98, 0xa3 };
			char[] chars = new char[3];

			Decoder d = Encoding.UTF8.GetDecoder();
			int charLen = d.GetChars(bytes1, 0, bytes1.Length, chars, 0);
			// The value of charLen should be 2 now.
			charLen += d.GetChars(bytes2, 0, bytes2.Length, chars, charLen);
			foreach(char c in chars)
				Console.Write("U+{0:X4}  ", (ushort)c);
		}
	}
}


#T=Desktop Create Win2000
Desktop Create Win2000
#T=Diameter AVP OCS
namespace OCS
{
	using System;
	using Microshaoft;
	using OCS.AVP.Packetes;
	class Class1
	{
		static void Main()
		{
			
			string s = "[00-22642d]-[03-84001c]-[25-70f61f]-0800450001f0ee664000800605970a0478060a0478fc04d32385c510d923eb9a6e175018ff4706ed0000010001c8c000011000000004bb6e94358a79e4f8000001074000002131302e342e3132302e3234303b313236383631393433313b30000000000001084000001431302e342e3132302e32343000000128400000184368696e6154656c65636f6d2e636f6d000001254000000f73313230323532000000011b400000184368696e6154656c65636f6d2e636f6d000001024000000c00000004000001cd4000002876657273696f6e312e703270736d73406368696e6174656c65636f6d2e636f6d000001a04000000c000000040000019f4000000c000000000000011a400000103132333435363738000000374000000ccf481727000001b44000000c00000000000001bb40000028000001c24000000c00000000000001bc4000001331333330333031303030300000000369800000a0000028af00004fb08000009400013c6800004fb28000001600013c6831323334353132333435000000004fb18000001600013c683534333231353433323100000000501f8000002c00013c68000001c20000000c00000000000001bc00000013313333303330313030303000000050208000002c00013c68000001c20000000c00000000000001bc00000013313333303330313030303100";
			s = "0022642d0384001c2570f61f0800450001f0ee664000800605970a0478060a0478fc04d32385c510d923eb9a6e175018ff4706ed";
			s = "00";
			s = "00";
			s = "010001c8c0000110-[00000004]-[bb6e9435]-[8a79e4f8]-000001074000002131302e342e3132302e3234303b313236383631393433313b30000000000001084000001431302e342e3132302e32343000000128400000184368696e6154656c65636f6d2e636f6d000001254000000f73313230323532000000011b400000184368696e6154656c65636f6d2e636f6d000001024000000c00000004000001cd4000002876657273696f6e312e703270736d73406368696e6174656c65636f6d2e636f6d000001a04000000c000000040000019f4000000c000000000000011a400000103132333435363738000000374000000ccf481727000001b44000000c00000000000001bb40000028000001c24000000c00000000000001bc4000001331333330333031303030300000000369800000a0000028af00004fb08000009400013c6800004fb28000001600013c6831323334353132333435000000004fb18000001600013c683534333231353433323100000000501f8000002c00013c68000001c20000000c00000000000001bc00000013313333303330313030303000000050208000002c00013c68000001c20000000c00000000000001bc00000013313333303330313030303100";
			byte[] data = BytesHelper.HexStringToBytesArray(s);
			Console.WriteLine("Data Length: {0}", data.Length);
			int L = data.Length;
			int p = 0;
			int l = 0;
			l = 4; 
			//Version 8 bits + MessageLength 24 bits
			byte[] buffer = new byte[l];
			Buffer.BlockCopy(data, p, buffer, 0, buffer.Length);
			ushort Version = buffer[0];
			Console.WriteLine("Version: {0}", Version);
			p++;
			buffer = new byte[l];
			Buffer.BlockCopy(data, p, buffer, 1, 3);
			Array.Reverse(buffer);
			uint MessageLength = BitConverter.ToUInt32(buffer, 0);
			Console.WriteLine("MessageLength: {0}", MessageLength);
			p += (l - 1);
			//CommandFlags 8 bits + CommandCode 24 bits
			buffer = new byte[l];
			Buffer.BlockCopy(data, p, buffer, 0, buffer.Length);
			ushort CommandFlags = buffer[0];
			Console.WriteLine("CommandFlags: {0}", CommandFlags);
			p++;
			buffer = new byte[l];
			Buffer.BlockCopy(data, p, buffer, 1, 3);
			Array.Reverse(buffer);
			uint CommandCode = BitConverter.ToUInt32(buffer, 0);
			Console.WriteLine("CommandCode: {0}", CommandCode);
			p += (l - 1);
			//ApplicationID 32 bits uint
			buffer = new byte[l];
			Buffer.BlockCopy(data, p, buffer, 0, buffer.Length);
			Array.Reverse(buffer);
			uint ApplicationID = BitConverter.ToUInt32(buffer, 0);
			Console.WriteLine("ApplicationID: {0}", ApplicationID);
			p += l;
			//Hop-by-Hop Identifier 32 bits uint
			buffer = new byte[l];
			Buffer.BlockCopy(data, p, buffer, 0, buffer.Length);
			Array.Reverse(buffer);
			uint HbHId = BitConverter.ToUInt32(buffer, 0);
			Console.WriteLine("Hop-by-Hop Identifier: {0},{0:X}", HbHId);
			p += l;
			//Hop-by-Hop Identifier 32 bits uint
			buffer = new byte[l];
			Buffer.BlockCopy(data, p, buffer, 0, buffer.Length);
			Array.Reverse(buffer);
			uint E2EId = BitConverter.ToUInt32(buffer, 0);
			Console.WriteLine("End-to-End Identifier: {0},{0:X}", E2EId);
			p += l;
			while (p < data.Length)
			{
				buffer = new byte[AvpDataPacketHeader._avpHeaderLength];
				Buffer.BlockCopy(data,p,buffer,0,buffer.Length);
				AvpDataPacketHeader header = new AvpDataPacketHeader(buffer);
				p += buffer.Length;
				buffer = new byte[header._avpDataLength];
				Buffer.BlockCopy(data,p,buffer,0,buffer.Length);
				AvpDataPacketBody body = new AvpDataPacketBody(header._avpCode, header._avpTag, buffer);
				p += (int) buffer.Length;
				Console.WriteLine
								(
									"{0}avp Code: [{1}]{0}avp Tag: [{2}({3})]{0}avp data: [{4}]{0}"
									, "\n"
									, body._avpCode
									, body._avpTag
									, Convert.ToString(body._avpTag, 2).PadLeft(8, '0')
									, body._avpStringData
								);
				
			}
			Console.ReadLine();
		}
	}
}
namespace OCS.AVP.Packetes
{
	using System;
	using System.Text;
	public class AvpDataPacketHeader
	{
		public uint _avpCode = 0;
		public ushort _avpTag = 0;
		public uint _avpLength = 0;
		
		public uint _avpBodyLength = 0;
		public uint _avpDataLength = 0;
		public uint _avpTotalLength = 0;
		private static readonly int _bufferLength = 4;
		public static readonly uint _avpHeaderLength = 8;
		public AvpDataPacketHeader(byte[] data)
		{
			int p = 0;
			uint mod = 0;
			byte[] buffer = new byte[_bufferLength];
			Buffer.BlockCopy(data, p, buffer, 0, buffer.Length);
			Array.Reverse(buffer);
			_avpCode = BitConverter.ToUInt32(buffer, 0);
			//Console.WriteLine("AVP Code: {0}", _avpCode);
			p += _bufferLength;
			//AVP Tag
			buffer = new byte[_bufferLength];
			Buffer.BlockCopy(data, p, buffer, 0, buffer.Length);
			_avpTag = buffer[0];
			//Console.WriteLine("AVP Tag: {0},VMPrrrrr: {1}", _avpTag, Convert.ToString(_avpTag, 2).PadLeft(8, '0'));
			p++;
			//AVP Length
			buffer = new byte[_bufferLength];
			Buffer.BlockCopy(data, p, buffer, 1, 3);
			Array.Reverse(buffer);
			_avpLength = BitConverter.ToUInt32(buffer, 0);
			_avpDataLength = _avpLength;
			if (_avpDataLength < (uint)_bufferLength * 3)
			{
				_avpDataLength = (uint)_bufferLength * 3;
			}
			else
			{
				_avpDataLength -= (uint)_bufferLength; //减掉 AVP Code
				_avpDataLength -= (uint)_bufferLength; //减掉 AVP Tag + Length
			}
			mod = _avpDataLength % (uint)_bufferLength;
			if (mod != 0)
			{
				_avpDataLength += (uint)(_bufferLength - mod);
			}
			//Console.WriteLine("AVP Length: {0}, AVP data Length {1}", _avpLength, _avpDataLength);
			p += (_bufferLength - 1);
		}
	}
	public class AvpDataPacketBody
	{
		public uint _avpCode = 0;
		public ushort _avpTag = 0;
		public uint _avpDataLength = 0;
		public uint _avpVendorID = 0;
		public string _avpStringData = string.Empty;
		private const int _bufferLength = 4;
		public AvpDataPacketBody(uint avpCode ,ushort avpTag, byte[] data)
		{
			_avpCode = avpCode;
			_avpTag = avpTag;
			_avpStringData = Encoding.UTF8.GetString(data);
			_avpDataLength = (uint) data.Length;
		}
	}
}
namespace Microshaoft
{
	using System;
	public static class BytesHelper
	{
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace("-", "").Replace("[", "").Replace("]", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}

#T=Dictionary 按 value 的某属性排序
namespace Microshaoft
{
	using System;
	using System.Linq;
	public class Class1
	{
		static void Main(string[] args)
		{
			var entrys = new[]
							{
								new
									{
										Name = "Alice"
										, Score = 5
									},
								new
									{
										Name = "Bob"
										, Score = 40
									},
								new
									{
										Name = "Bob"
										, Score = 50
									}
							};
			Console.WriteLine("原始数据");
			var dictionary = entrys.ToDictionary
										(
											entry => Guid.NewGuid() //entry.Name
										);
			dictionary.ToList().ForEach
									(
										entry =>
										{
											Console.WriteLine("Key: {0}, Value: Name: {1}, Score: {2}, ", entry.Key, entry.Value.Name, entry.Value.Score);
										}
									);
			Console.WriteLine("OrderBy方法按单字段排序");
			var result = dictionary.OrderByDescending
										(
											entry => entry.Value.Score
										);
			result.ToList().ForEach
								(
									entry =>
									{
										Console.WriteLine("Key: {0}, Value: Name: {1}, Score: {2}, ", entry.Key, entry.Value.Name, entry.Value.Score);
									}
								);
			Console.WriteLine("Linq 查询按多字段排序");
			result =
						from pair in dictionary
						orderby pair.Value.Name, pair.Value.Score descending
						select pair;
			result.ToList().ForEach
								(
									entry =>
									{
										Console.WriteLine("Key: {0}, Value: Name: {1}, Score: {2}, ", entry.Key, entry.Value.Name, entry.Value.Score);
									}
								);
			Console.ReadLine();
		}
	}
}

#T=Dispose using Exception
namespace Microshaoft
{
	using System;
	class Program
	{
		static void Main(string[] args)
		{
			using (var x = new Class1())
			{
				throw new Exception();
			}
		}
	}
	public class Class1 : IDisposable
	{
		public void Dispose()
		{
			Console.WriteLine("Dispose");
		}
	}
}

#T=DPAPI .Net ProtectedData
namespace Microshaoft
{
	using System;
	using System.Security.Cryptography;

	public class DataProtectionSample
	{
		// Create byte array for additional entropy when using Protect method.
		static byte [] s_aditionalEntropy = { 9, 8, 7, 6, 5 };

		public static void Main()
		{
			// Create a simple byte array containing data to be encrypted.
			byte [] secret = { 0, 1, 2, 3, 4, 1, 2, 3, 4 };

			//Encrypt the data.
			byte [] encryptedSecret = Protect( secret );
			Console.WriteLine("The encrypted byte array is:");
			PrintValues(encryptedSecret);

			// Decrypt the data and store in a byte array.
			byte [] originalData = Unprotect( encryptedSecret );
			Console.WriteLine("{0}The original data is:", Environment.NewLine);
			PrintValues(originalData);

		}

		public static byte [] Protect(byte [] data)
		{
			try
			{
				// Encrypt the data using DataProtectionScope.CurrentUser. The result can be decrypted
				//  only by the same current user.
				return ProtectedData.Protect( data, s_aditionalEntropy, DataProtectionScope.CurrentUser );
			} 
			catch (CryptographicException e)
			{
				Console.WriteLine("Data was not encrypted. An error occurred.");
				Console.WriteLine(e.ToString());
				return null;
			}
		}

		public static byte [] Unprotect(byte [] data)
		{
			try
			{
				//Decrypt the data using DataProtectionScope.CurrentUser.
				return ProtectedData.Unprotect( data, s_aditionalEntropy, DataProtectionScope.CurrentUser );
			}
			catch (CryptographicException e)
			{
				Console.WriteLine("Data was not decrypted. An error occurred.");
				Console.WriteLine(e.ToString());
				return null;
			}
		}

		public static void PrintValues(byte[] myArr)
		{
			foreach (byte i in myArr)
			{
				Console.Write("\t{0}", i);
			}
			Console.WriteLine();
		}
	}
}
#T=DPAPI 加解密
namespace Microshaoft.DataProtection
{
	using System;

	using System.Text;
	using System.Runtime.InteropServices;

	/// <summary>
	/// Summary description for DataProtector.
	/// </summary>
	public class DataProtector
	{
		[
			DllImport
				(
					"Crypt32.dll"
					, SetLastError = true
					, CharSet = CharSet.Auto
				)
		]
		private static extern bool CryptProtectData
						(
							ref DATA_BLOB pDataIn
							, string szDataDescr
							, ref DATA_BLOB pOptionalEntropy
							, IntPtr pvReserved
							, ref CRYPTPROTECT_PROMPTSTRUCT pPromptStruct
							, int dwFlags
							, ref DATA_BLOB pDataOut
						);

		[
			DllImport
				(
					"Crypt32.dll"
					, SetLastError = true
					, CharSet = CharSet.Auto
				)
		]
		private static extern bool CryptUnprotectData
						(
							ref DATA_BLOB pDataIn
							, string szDataDescr
							, ref DATA_BLOB pOptionalEntropy
							, IntPtr pvReserved
							, ref CRYPTPROTECT_PROMPTSTRUCT pPromptStruct
							, int dwFlags
							, ref DATA_BLOB pDataOut
						);

		[
			DllImport
				(
					"kernel32.dll"
					, CharSet = CharSet.Auto
				)
		]
		private unsafe static extern int FormatMessage
						(
							int dwFlags
							, ref IntPtr lpSource
							, int dwMessageId
							, int dwLanguageId
							, ref string lpBuffer
							, int nSize
							, IntPtr* Arguments
						);

		[
			StructLayout
				(
					LayoutKind.Sequential
					, CharSet = CharSet.Unicode
				)
		]
		internal struct DATA_BLOB
		{
			public int cbData;
			public IntPtr pbData;
		}

		[
			StructLayout
				(
					LayoutKind.Sequential
					, CharSet = CharSet.Unicode
				)
		]
		internal struct CRYPTPROTECT_PROMPTSTRUCT
		{
			public int cbSize;
			public int dwPromptFlags;
			public IntPtr hwndApp;
			public string szPrompt;
		}

		private static IntPtr NullPtr = ((IntPtr)((int)(0)));
		private const int CRYPTPROTECT_UI_FORBIDDEN = 0x1;
		private const int CRYPTPROTECT_LOCAL_MACHINE = 0x4;

		public enum Store
		{
			USE_MACHINE_STORE = 1
			, USE_USER_STORE
		};


		private Store store;

		public DataProtector
					(
						Store tempStore
					)
		{
			store = tempStore;
		}

		public byte[] Encrypt
						(
							byte[] plainText
							, byte[] optionalEntropy
						)
		{
			bool retVal = false;

			DATA_BLOB plainTextBlob = new DATA_BLOB();
			DATA_BLOB cipherTextBlob = new DATA_BLOB();
			DATA_BLOB entropyBlob = new DATA_BLOB();

			CRYPTPROTECT_PROMPTSTRUCT prompt = new CRYPTPROTECT_PROMPTSTRUCT();
			InitPromptstruct(ref prompt);

			int dwFlags;
			try
			{
				try
				{
					int bytesSize = plainText.Length;
					plainTextBlob.pbData = Marshal.AllocHGlobal(bytesSize);
					if (IntPtr.Zero == plainTextBlob.pbData)
					{
						throw new Exception("Unable to allocate plaintext buffer.");
					}
					plainTextBlob.cbData = bytesSize;
					Marshal.Copy(plainText, 0, plainTextBlob.pbData, bytesSize);
				}
				catch (Exception ex)
				{
					throw new Exception("Exception marshalling data. " + ex.Message);
				}
				if (Store.USE_MACHINE_STORE == store)
				{
					//Using the machine store, should be providing entropy.
					dwFlags = CRYPTPROTECT_LOCAL_MACHINE | CRYPTPROTECT_UI_FORBIDDEN;
					//Check to see if the entropy is null
					if (null == optionalEntropy)
					{
						//Allocate something
						optionalEntropy = new byte[0];
					}
					try
					{
						int bytesSize = optionalEntropy.Length;
						entropyBlob.pbData = Marshal.AllocHGlobal(optionalEntropy.Length); ;
						if (IntPtr.Zero == entropyBlob.pbData)
						{
							throw new Exception("Unable to allocate entropy data buffer.");
						}
						Marshal.Copy(optionalEntropy, 0, entropyBlob.pbData, bytesSize);
						entropyBlob.cbData = bytesSize;
					}
					catch (Exception ex)
					{
						throw new Exception
										(
											"Exception entropy marshalling data. "
											+ ex.Message
										);
					}
				}
				else
				{
					//Using the user store
					dwFlags = CRYPTPROTECT_UI_FORBIDDEN;
				}
				retVal = CryptProtectData
							(
								ref plainTextBlob
								, ""
								, ref entropyBlob
								, IntPtr.Zero
								, ref prompt
								, dwFlags
								, ref cipherTextBlob
							);
				if (!retVal)
				{
					throw new Exception
									(
										"Encryption failed. "
										+ GetErrorMessage
											(
												Marshal.GetLastWin32Error()
											)
									);
				}
			}
			catch (Exception ex)
			{
				throw new Exception("Exception encrypting. " + ex.Message);
			}
			byte[] cipherText = new byte[cipherTextBlob.cbData];
			Marshal.Copy(cipherTextBlob.pbData, cipherText, 0, cipherTextBlob.cbData);
			return cipherText;
		}

		public byte[] Decrypt
						(
							byte[] cipherText
							, byte[] optionalEntropy
						)
		{
			bool retVal = false;
			DATA_BLOB plainTextBlob = new DATA_BLOB();
			DATA_BLOB cipherBlob = new DATA_BLOB();
			CRYPTPROTECT_PROMPTSTRUCT prompt = new CRYPTPROTECT_PROMPTSTRUCT();
			InitPromptstruct(ref prompt);
			try
			{
				try
				{
					int cipherTextSize = cipherText.Length;
					cipherBlob.pbData = Marshal.AllocHGlobal(cipherTextSize);
					if (IntPtr.Zero == cipherBlob.pbData)
					{
						throw new Exception("Unable to allocate cipherText buffer.");
					}
					cipherBlob.cbData = cipherTextSize;
					Marshal.Copy(cipherText, 0, cipherBlob.pbData, cipherBlob.cbData);
				}
				catch (Exception ex)
				{
					throw new Exception("Exception marshalling data. " + ex.Message);
				}
				DATA_BLOB entropyBlob = new DATA_BLOB();
				int dwFlags;
				if (Store.USE_MACHINE_STORE == store)
				{//Using the machine store, should be providing entropy.
					dwFlags = CRYPTPROTECT_LOCAL_MACHINE | CRYPTPROTECT_UI_FORBIDDEN;
					//Check to see if the entropy is null
					if (null == optionalEntropy)
					{//Allocate something
						optionalEntropy = new byte[0];
					}
					try
					{
						int bytesSize = optionalEntropy.Length;
						entropyBlob.pbData = Marshal.AllocHGlobal(bytesSize);
						if (IntPtr.Zero == entropyBlob.pbData)
						{
							throw new Exception("Unable to allocate entropy buffer.");
						}
						entropyBlob.cbData = bytesSize;
						Marshal.Copy(optionalEntropy, 0, entropyBlob.pbData, bytesSize);
					}
					catch (Exception ex)
					{
						throw new Exception
									(
										"Exception entropy marshalling data. "
										+ ex.Message
									);
					}
				}
				else
				{
					//Using the user store
					dwFlags = CRYPTPROTECT_UI_FORBIDDEN;
				}
				retVal = CryptUnprotectData
							(
								ref cipherBlob
								, null
								, ref entropyBlob
								, IntPtr.Zero
								, ref prompt
								, dwFlags
								, ref plainTextBlob
							);
				if (!retVal)
				{
					throw new Exception("Decryption failed. " +
						GetErrorMessage(Marshal.GetLastWin32Error()));
				}
				//Free the blob and entropy.
				if (IntPtr.Zero != cipherBlob.pbData)
				{
					Marshal.FreeHGlobal(cipherBlob.pbData);
				}
				if (IntPtr.Zero != entropyBlob.pbData)
				{
					Marshal.FreeHGlobal(entropyBlob.pbData);
				}
			}
			catch (Exception ex)
			{
				throw new Exception("Exception decrypting. " + ex.Message);
			}
			byte[] plainText = new byte[plainTextBlob.cbData];
			Marshal.Copy(plainTextBlob.pbData, plainText, 0, plainTextBlob.cbData);
			return plainText;
		}


		private void InitPromptstruct(ref CRYPTPROTECT_PROMPTSTRUCT ps)
		{
			ps.cbSize = Marshal.SizeOf(typeof(CRYPTPROTECT_PROMPTSTRUCT));
			ps.dwPromptFlags = 0;
			ps.hwndApp = NullPtr;
			ps.szPrompt = null;
		}

		private unsafe static string GetErrorMessage(int errorCode)
		{
			int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;
			int FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
			int FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000;
			int messageSize = 255;
			string lpMsgBuf = "";
			int dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;
			IntPtr ptrlpSource = new IntPtr();
			IntPtr prtArguments = new IntPtr();
			int retVal = FormatMessage
				(
					dwFlags
					, ref ptrlpSource
					, errorCode
					, 0
					, ref lpMsgBuf
					, messageSize
					, &prtArguments
				);
			if (0 == retVal)
			{
				throw new Exception
							(
								"Failed to format message for error code "
								+ errorCode + ". "
							);
			}
			return lpMsgBuf;
		}


	}
}

namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using Microshaoft.DataProtection;

	class Program
	{
		static void Main(string[] args)
		{
			byte[] buf = new byte[] { 0, 1 }; 
			Encoding e = Encoding.Unicode;

			DataProtector x = new DataProtector(DataProtector.Store.USE_MACHINE_STORE);
			string s = "!@#$%于溪h";
			Console.WriteLine(s);
			byte[] data = x.Encrypt(e.GetBytes(s), buf);
			s = BytesArrayToHexString(data);
			Console.WriteLine(s);
			// buf = new byte[] { 2, 1 };
			data = x.Decrypt(data, buf);
			s = e.GetString(data);
			Console.WriteLine(s);
			Console.ReadLine();

		}
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}

#T=dynamic ExpandoObject DynamicObject
namespace ConsoleApplication
{
	using System;
	using System.Dynamic;
	using System.Runtime.CompilerServices;
	using Microsoft.CSharp.RuntimeBinder;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	class Program
	{
		static void Main(string[] args)
		{
			dynamic employee, manager;
			employee = new ExpandoObject();
			employee.Name = "John Smith";
			employee.Age = 33;

			manager = new ExpandoObject();
			manager.Name = "Allison Brown";
			manager.Age = 42;
			manager.TeamSize = 10;


			var action = new Action<dynamic>
						(
							(x) =>
							{
								Console.WriteLine
											(
												"{0} is {1} years old."
												, x.Name
												, x.Age
											);
								// The following statement causes an exception
								// if you pass the employee object.
								var y = x as DynamicObject;
								var getMemberBinder = GetDynamicMember(x, "TeamSize");
								object o;
								if (y.TryGetMember(getMemberBinder, out o))
								{
									var z = o as dynamic;
									Console.WriteLine("Manages {0} people", z.TeamSize);
								}
							}
						);

			action(manager);
			action(employee);

			// Creating a dynamic dictionary.
			dynamic person = new DynamicDictionary();

			// Adding new dynamic properties. 
			// The TrySetMember method is called.
			person.FirstName = "Ellen";
			person.LastName = "Adams";

			// Getting values of the dynamic properties.
			// The TryGetMember method is called.
			// Note that property names are case-insensitive.
			Console.WriteLine(person.firstname + " " + person.lastname);

			// Getting the value of the Count property.
			// The TryGetMember is not called, 
			// because the property is defined in the class.
			Console.WriteLine(
				"Number of dynamic properties:" + person.Count);

			// The following statement throws an exception at run time.
			// There is no "address" property,
			// so the TryGetMember method returns false and this causes a
			// RuntimeBinderException.
			// Console.WriteLine(person.address);
		}
		static object GetDynamicMember(object obj, string memberName)
		{
			var binder = Binder.GetMember(CSharpBinderFlags.None, memberName, obj.GetType(),
				new[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) });
			var callsite = CallSite<Func<CallSite, object, object>>.Create(binder);
			return callsite.Target(callsite, obj);
		}
	}
}
namespace Microshaoft
{
	using System.Dynamic;
	using System.Collections.Generic;
	// The class derived from DynamicObject.
	public class DynamicDictionary : DynamicObject
	{
		// The inner dictionary.
		private Dictionary<string, object> _dictionary = new Dictionary<string, object>();

		// This property returns the number of elements
		// in the inner _dictionary.
		public int Count
		{
			get
			{
				return _dictionary.Count;
			}
		}

		// If you try to get a value of a property 
		// not defined in the class, this method is called.
		public override bool TryGetMember
								(
									GetMemberBinder binder
									, out object result
								)
		{
			// Converting the property name to lowercase
			// so that property names become case-insensitive.
			string name = binder.Name.ToLower();
			// If the property name is found in a _dictionary,
			// set the result parameter to the property value and return true.
			// Otherwise, return false.
			return _dictionary.TryGetValue(name, out result);
		}
		// If you try to set a value of a property that is
		// not defined in the class, this method is called.
		public override bool TrySetMember
								(
									SetMemberBinder binder
									, object value
								)
		{
			// Converting the property name to lowercase
			// so that property names become case-insensitive.
			_dictionary[binder.Name.ToLower()] = value;
			// You can always add a value to a _dictionary,
			// so this method always returns true.
			return true;
		}
	}

	class Example
	{
		private static System.Windows.Controls.TextBlock outputBlock;

		public static void Demo(System.Windows.Controls.TextBlock outputBlock)
		{

			Example.outputBlock = outputBlock;
			// Creating a dynamic _dictionary.
			dynamic person = new DynamicDictionary();

			// Adding new dynamic properties. 
			// The TrySetMember method is called.
			person.FirstName = "Ellen";
			person.LastName = "Adams";

			// Getting values of the dynamic properties.
			// The TryGetMember method is called.
			// Note that property names are case-insensitive.
			outputBlock.Text += person.firstname + " " + person.lastname + "\n";

			// Getting the value of the Count property.
			// The TryGetMember is not called, 
			// because the property is defined in the class.
			outputBlock.Text +=
				"Number of dynamic properties:" + person.Count + "\n";

			// The following statement throws an exception at run time.
			// There is no "address" property,
			// so the TryGetMember method returns false and this causes a
			// RuntimeBinderException.
			// outputBlock.Text += person.address + "\n";
		}
	}

	// This example has the following output:
	// Ellen Adams
	// Number of dynamic properties: 2
}
#T=Dynamic PrivateReflectionDynamicObject.WrapObjectIfNeeded
namespace ConsoleApplication
{
	using System;
	using System.Dynamic;
	using System.Diagnostics;
	using Microshaoft;
	using Test;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			var foo = new Foo();
			//dynamicFoo = foo;
			dynamic dynamicFoo = foo.AsDynamic();
			dynamicFoo.SomePrivateString = "SomePrivateStringValue";
			Console.WriteLine(dynamicFoo.SomePrivateString);
			//dynamicFoo.NotExist = "Hello";
			dynamicFoo.SomeInternalInteger = 17;
			// This one is defined on the base type
			var sum = dynamicFoo.AddIntegers(dynamicFoo.SomeInternalInteger, 3);
			//Assert.AreEqual(20, sum);
			//Debug.Assert(20 == sum);
			Console.WriteLine(sum);
			// Different overload defined on the type itself
			sum = dynamicFoo.AddIntegers(dynamicFoo.SomeInternalInteger, 3, 4);
			//Assert.AreEqual(24, sum);
			//Debug.Assert(24 == sum);
			Console.WriteLine(sum);
			dynamicFoo._bar.SomeBarStringProperty = "Blah";
			Console.WriteLine(dynamicFoo._bar.SomeBarStringProperty);
			dynamicFoo["Hello"] = "qqq";
			dynamicFoo["Hello2"] = "qqq2";
			dynamicFoo._dict["Hello"] = "qqq";
			dynamicFoo._dict["Hello2"] = "qqq2";
			Console.WriteLine(dynamicFoo._dict["Hello2"]);
			Console.ReadLine();
		}
	}
}
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	public class FooBase
	{
		private int _somePrivateIntegerField = -1;
		private int AddIntegers(int n1, int n2)
		{
			return n1 + n2;
		}
	}
	public class Foo : FooBase
	{
		private Bar _bar = new Bar();
		private Bar _barNull;
		internal int SomeInternalInteger { get; set; }
		public bool SomePublicBool { get; set; }
		private string SomePrivateString { get; set; }
		private int AddIntegers(int n1, int n2, int n3)
		{
			return n1 + n2 + n3;
		}
		private Dictionary<string, string> _dict = new Dictionary<string, string>();
		internal string this[string s]
		{
			get
			{
				return _dict[s];
			}
			set
			{
				_dict[s] = value;
			}
		}
	}
	internal class Bar
	{
		private string SomeBarStringProperty { get; set; }
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Concurrent;
	using System.Collections.Generic;
	using System.Dynamic;
	using System.Linq;
	using System.Reflection;
	public class PrivateReflectionDynamicObject : DynamicObject
	{
		private static IDictionary<Type, IDictionary<string, IProperty>> _propertiesOnType = new ConcurrentDictionary<Type, IDictionary<string, IProperty>>();
		// Simple abstraction to make field and property access consistent
		interface IProperty
		{
			string Name { get; }
			object GetValue(object obj, object[] index);
			void SetValue(object obj, object val, object[] index);
		}
		// IProperty implementation over a PropertyInfo
		class Property : IProperty
		{
			internal PropertyInfo PropertyInfo { get; set; }
			string IProperty.Name
			{
				get
				{
					return PropertyInfo.Name;
				}
			}
			object IProperty.GetValue(object obj, object[] index)
			{
				return PropertyInfo.GetValue(obj, index);
			}
			void IProperty.SetValue(object obj, object val, object[] index)
			{
				PropertyInfo.SetValue(obj, val, index);
			}
		}
		// IProperty implementation over a FieldInfo
		class Field : IProperty
		{
			internal FieldInfo FieldInfo { get; set; }
			string IProperty.Name
			{
				get
				{
					return FieldInfo.Name;
				}
			}
			object IProperty.GetValue(object obj, object[] index)
			{
				return FieldInfo.GetValue(obj);
			}
			void IProperty.SetValue(object obj, object val, object[] index)
			{
				FieldInfo.SetValue(obj, val);
			}
		}
		private object _realObject { get; set; }
		private const BindingFlags _bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
		internal static object WrapObjectIfNeeded(object o)
		{
			// Don't wrap primitive types, which don't have many interesting internal APIs
			if (o == null || o.GetType().IsPrimitive || o is string)
			{
				return o;
			}
			return new PrivateReflectionDynamicObject()
			{
				_realObject = o
			};
		}
		public override bool TryGetMember(GetMemberBinder binder, out object result)
		{
			IProperty prop = GetProperty(binder.Name);
			// Get the property value
			result = prop.GetValue(_realObject, index: null);
			// Wrap the sub object if necessary. This allows nested anonymous objects to work.
			result = WrapObjectIfNeeded(result);
			return true;
		}
		public override bool TrySetMember(SetMemberBinder binder, object value)
		{
			IProperty prop = GetProperty(binder.Name);
			// Set the property value
			prop.SetValue(_realObject, value, index: null);
			return true;
		}
		public override bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result)
		{
			// The indexed property is always named "Item" in C#
			IProperty prop = GetIndexProperty();
			result = prop.GetValue(_realObject, indexes);
			// Wrap the sub object if necessary. This allows nested anonymous objects to work.
			result = WrapObjectIfNeeded(result);
			return true;
		}
		public override bool TrySetIndex(SetIndexBinder binder, object[] indexes, object value)
		{
			// The indexed property is always named "Item" in C#
			IProperty prop = GetIndexProperty();
			prop.SetValue(_realObject, value, indexes);
			return true;
		}
		// Called when a method is called
		public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)
		{
			result = InvokeMemberOnType(_realObject.GetType(), _realObject, binder.Name, args);
			// Wrap the sub object if necessary. This allows nested anonymous objects to work.
			result = WrapObjectIfNeeded(result);
			return true;
		}
		public override bool TryConvert(ConvertBinder binder, out object result)
		{
			result = Convert.ChangeType(_realObject, binder.Type);
			return true;
		}
		public override string ToString()
		{
			return _realObject.ToString();
		}
		private IProperty GetIndexProperty()
		{
			// The index property is always named "Item" in C#
			return GetProperty("Item");
		}
		private IProperty GetProperty(string propertyName)
		{
			// Get the list of properties and fields for this type
			IDictionary<string, IProperty> typeProperties = GetTypeProperties(_realObject.GetType());
			// Look for the one we want
			IProperty property;
			if (typeProperties.TryGetValue(propertyName, out property))
			{
				return property;
			}
			// The property doesn't exist
			// Get a list of supported properties and fields and show them as part of the exception message
			// For fields, skip the auto property backing fields (which name start with <)
			var propNames = typeProperties.Keys.Where(name => name[0] != '<').OrderBy(name => name);
			throw new ArgumentException(
				String.Format(
				"The property {0} doesn't exist on type {1}. Supported properties are: {2}",
				propertyName, _realObject.GetType(), String.Join(", ", propNames)));
		}
		private static IDictionary<string, IProperty> GetTypeProperties(Type type)
		{
			// First, check if we already have it cached
			IDictionary<string, IProperty> typeProperties;
			if (_propertiesOnType.TryGetValue(type, out typeProperties))
			{
				return typeProperties;
			}
			// Not cache, so we need to build it
			typeProperties = new ConcurrentDictionary<string, IProperty>();
			// First, add all the properties
			foreach (PropertyInfo prop in type.GetProperties(_bindingFlags).Where(p => p.DeclaringType == type))
			{
				typeProperties[prop.Name] = new Property() { PropertyInfo = prop };
			}
			// Now, add all the fields
			foreach (FieldInfo field in type.GetFields(_bindingFlags).Where(p => p.DeclaringType == type))
			{
				typeProperties[field.Name] = new Field() { FieldInfo = field };
			}
			// Finally, recurse on the base class to add its fields
			if (type.BaseType != null)
			{
				foreach (IProperty prop in GetTypeProperties(type.BaseType).Values)
				{
					typeProperties[prop.Name] = prop;
				}
			}
			// Cache it for next time
			_propertiesOnType[type] = typeProperties;
			return typeProperties;
		}
		private static object InvokeMemberOnType(Type type, object target, string name, object[] args)
		{
			try
			{
				// Try to incoke the method
				return type.InvokeMember(
					name,
					BindingFlags.InvokeMethod | _bindingFlags,
					null,
					target,
					args);
			}
			catch (MissingMethodException)
			{
				// If we couldn't find the method, try on the base class
				if (type.BaseType != null)
				{
					return InvokeMemberOnType(type.BaseType, target, name, args);
				}
				throw;
			}
		}
	}
	public static class PrivateReflectionDynamicObjectExtensions
	{
		public static dynamic AsDynamic(this object o)
		{
			return PrivateReflectionDynamicObject.WrapObjectIfNeeded(o);
		}
	}
}

#T=DynamicCallMethodExpressionTreeInvokerHelper 2012-08-13
namespace ConsoleApplication
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Net.Mail;
	using System.Net.Mime;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.WriteLine("生成 eml 文件");
			string html = "<html><body><a href=\"http://www.live.com\"><img src=\"cid:attachment1\"></a>";
			html += "<script src=\"cid:attachment2\"></script>中国字";
			html += "<a href=\"http://www.google.com\"><br><img src=\"cid:attachment1\"></a><script>alert('mail body xss')<script></body></html>";
			AlternateView view = AlternateView.CreateAlternateViewFromString(html, null, MediaTypeNames.Text.Html);
			//LinkedResource picture = new LinkedResource(@"pic.JPG", MediaTypeNames.Image.Jpeg);
			//picture.ContentId = "attachment1";
			//view.LinkedResources.Add(picture);
			//LinkedResource script = new LinkedResource(@"a.js", MediaTypeNames.Text.Plain);
			//script.ContentId = "attachment2";
			//view.LinkedResources.Add(script);
			MailMessage mail = new MailMessage();
			mail.AlternateViews.Add(view);
			mail.From = new MailAddress("test@microshaoft.com", "<script>alert('mail from xss')</script>");
			mail.To.Add(new MailAddress("microshaoft@gmail.com", "<script>alert('mail to xss')</script>"));
			mail.To.Add(new MailAddress("microshaoft@qq.com", "<script>alert('mail to xss')</script>"));
			mail.Subject = "<script>alert('mail subject xss')</script>" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
			byte[] buffer = mail.GetBytes();
			File.WriteAllBytes(@"d:\temp.eml", buffer);
			Console.WriteLine("====================================================================");
			Console.ReadLine();
			Console.WriteLine("计算表达式");
			string formula = "(({0}-{1})/{2}+{3})*{4}";
			string result = JScriptEvaluator.ComputeFormula<double>
													(
														formula
														, 1f
														, 2.1
														, 3.1
														, 4.0
														, 5.0
													);
			Console.WriteLine(result);
			double x;
			x = DataTableColumnExpression.ComputeFormula<double, double>
													(
														formula
														, 1f
														, 2.1
														, 3.1
														, 4.0
														, 5.0
													);
			Console.WriteLine(x);
			//=================================================================================================
			formula = "IIF(1=2, F1, F2) + ((--F1) * F2) + F3";
			var tuples = new Tuple<string, double>[]
											{
												Tuple.Create<string,double>("F1", 1.0)
												, Tuple.Create<string,double>("F2", 2.0)
												, Tuple.Create<string,double>("F3", 3.0)
												, Tuple.Create<string,double>("F4", 4.0)
												, Tuple.Create<string,double>("F3", 2.0)
											};
			x = DataTableColumnExpression.ComputeFormula<double, double>(formula, tuples);
			Console.WriteLine(x);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.CodeDom.Compiler;
	using System.Collections.Generic;
	using System.Data;
	using System.Linq;
	using System.Reflection;
	public class DataTableColumnExpression
	{
		private static MethodInfo _mi = typeof(string).GetMethods().First
																	(
																		m => m.Name.Equals("Format")
																		&& m.GetParameters().Length == 2
																		&& m.IsStatic
																		&& m.GetParameters()[1].Name == "args"
																	);
		private class ObjectEqualityComparer<T> : IEqualityComparer<T>
		{
			private Func<T, T, bool> _onEqualsProcessFunc;
			private Func<T, int> _onGetHashCodeProcessFunc;
			public ObjectEqualityComparer
						(
							Func<T, T, bool> onEqualsProcessFunc
							, Func<T, int> onGetHashCodeProcessFunc
						)
			{
				_onEqualsProcessFunc = onEqualsProcessFunc;
				_onGetHashCodeProcessFunc = onGetHashCodeProcessFunc;
			}
			public bool Equals(T x, T y)
			{
				if (Object.ReferenceEquals(x, y))
				{
					return true;
				}
				if (Object.ReferenceEquals(x, null) || Object.ReferenceEquals(y, null))
				{
					return false;
				}
				return _onEqualsProcessFunc(x, y);
			}
			public int GetHashCode(T x)
			{
				if (Object.ReferenceEquals(x, null))
				{
					return 0;
				}
				return _onGetHashCodeProcessFunc(x);
			}
		}
		public static TResult ComputeFormula<TResult, TParameter>
													(
														string formula
														, params TParameter[] parameters
													)
		{
			var dt = new DataTable();
			var list = parameters.ToList();
			var parametersNames = new List<string>(); ;
			int i = 0;
			Array.ForEach
					(
						parameters
						, (x) =>
						{
							string f = string.Format("F{0}", i++);
							parametersNames.Add(f);
							var dc = new DataColumn(f, typeof(TParameter));
							dt.Columns.Add(dc);
						}
					);
			string expression = string.Format(formula, parametersNames.ToArray());
			dt.Columns.Add(new DataColumn("Microshaoft", typeof(TResult), expression));
			var dr = dt.NewRow();
			i = 0;
			Array.ForEach
			(
				parameters
				, (x) =>
				{
					dr[i++] = x;
				}
			);
			dt.Rows.Add(dr);
			return (TResult)dr["Microshaoft"];
		}
		public static TResult ComputeFormula<TResult, TParameter>
													(
														string formula
														, params Tuple<string, TParameter>[] parameters
													)
		{
			var dt = new DataTable();
			var comparer = new ObjectEqualityComparer<Tuple<string, TParameter>>
											(
												(x, y) =>
												{
													return x.Item1 == y.Item1;
												}
												, (x) =>
												{
													return x.Item1.GetHashCode();
												}
											);
			var list = parameters.Distinct
									(
										comparer
									)
									.ToList();
			list.ForEach
					(
						(x) =>
						{
							var dc = new DataColumn
											(
												x.Item1
												, x.Item2.GetType()
											);
							dt.Columns.Add(dc);
						}
					);
			dt.Columns.Add(new DataColumn("Microshaoft", typeof(TResult), formula));
			var dr = dt.NewRow();
			list.ForEach
					(
						(x) =>
						{
							dr[x.Item1] = x.Item2;
						}
					);
			dt.Rows.Add(dr);
			return (TResult)dr["Microshaoft"];
		}
	}
	public class JScriptEvaluator
	{
		private static MethodInfo _mi = typeof(string).GetMethods().First
																		(
																			m => m.Name.Equals("Format")
																			&& m.GetParameters().Length == 2
																			&& m.IsStatic
																			&& m.GetParameters()[1].Name == "args"
																		);
		private static Func<string, object[], object> _func = null;
		public static string ComputeFormula<TParameter>(string formula, params TParameter[] parameters)
		{
			object[] objects = new object[parameters.Length];
			Array.Copy(parameters, objects, objects.Length);
			string expression1 = string.Format(formula, objects);
			return (string)JScriptEvaluator.Eval(expression1);
			//=====================================================================
			object[] ps = new object[parameters.Length];
			Array.Copy(parameters, 0, ps, 0, ps.Length);
			if (_func == null)
			{
				_func = DynamicCallMethodExpressionTreeInvokerHelper.CreateMethodCallInvokerFunc<string, string>
												(
													typeof(string)
													, () =>
													{
														var methodsInfos = typeof(string).GetMethods();
														var methodInfo = methodsInfos.First
																						(
																							(x) =>
																							{
																								var parametersInfos = x.GetParameters();
																								//Debug.Assert(x.Name.ToLower() == "Format".ToLower());
																								return
																									x.Name.ToLower() == "Format".ToLower()
																									&& x.IsStatic
																									&& parametersInfos[0].ParameterType == typeof(string)
																									&& parametersInfos[1].ParameterType == typeof(object[])
																									&& Attribute.IsDefined
																													(
																														parametersInfos[1]
																														, typeof(ParamArrayAttribute)
																													);
																							}
																						);
														return methodInfo;
													}
												);
			}
			string expression = (string)_mi.Invoke
												(
													null
													, new object[]
															{
																formula
																, ps
															}
												);
			expression = (string) _func
									(
										formula
										, new object[]
													{
														formula
														, ps
													}
									);
			return (string) JScriptEvaluator.Eval(expression);
		}
		public static object Eval(string statement)
		{
			return _evaluatorType.InvokeMember
										(
											"Eval"
											, BindingFlags.InvokeMethod
											, null
											, _evaluator
											, new object[]
													{
														statement
													}
										);
		}
		static JScriptEvaluator()
		{
			CodeDomProvider provider = CodeDomProvider.CreateProvider("JScript");
			CompilerParameters parameters;
			parameters = new CompilerParameters();
			parameters.GenerateInMemory = true;
			CompilerResults results;
			results = provider.CompileAssemblyFromSource(parameters, _JScript);
			Assembly assembly = results.CompiledAssembly;
			_evaluatorType = assembly.GetType("Microshaoft.JScriptEvaluator");
			var constructorInfo = _evaluatorType.GetConstructors().First();
			var func = DynamicCallMethodExpressionTreeInvokerHelper.CreateNewInstanceConstructorInvokerFunc
															(
																_evaluatorType
																, constructorInfo
															);
			_evaluator = func(null);
			//_evaluator = Activator.CreateInstance(_evaluatorType);
		}
		private static object _evaluator = null;
		private static Type _evaluatorType = null;
		/// <summary>
		/// JScript代码
		/// </summary>
		private static readonly string _JScript =
			@"
				package Microshaoft
				{
					class JScriptEvaluator
					{
						public function Eval(statement : String) : String
						{
							return eval(statement);
						}
					}
				}
			";
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public static class DynamicCallMethodExpressionTreeInvokerHelper
	{
		public static Func<object[], object> CreateNewInstanceConstructorInvokerFunc
														(
															Type type
															, Func<ConstructorInfo> getConstructorInfoFunc
														)
		{
			var constructorInfo = getConstructorInfoFunc();
			return CreateNewInstanceConstructorInvokerFunc<object>
														(
															type
															, constructorInfo
														);
		}
		public static Func<object[], T> CreateNewInstanceConstructorInvokerFunc<T>
														(
															Type type
															, Func<ConstructorInfo> getConstructorInfoFunc
														)
		{
			var constructorInfo = getConstructorInfoFunc();
			return CreateNewInstanceConstructorInvokerFunc<T>
														(
															type
															, constructorInfo
														);
		}
		public static Func<object[], object> CreateNewInstanceConstructorInvokerFunc
														(
															Type type
															, ConstructorInfo constructorInfo
														)
		{
			return CreateNewInstanceConstructorInvokerFunc<object>(type, constructorInfo);
		}
		public static Func<object[], T> CreateNewInstanceConstructorInvokerFunc<T>
														(
															Type type
															, ConstructorInfo constructorInfo
														)
		{
			var parametersInfos = constructorInfo.GetParameters();
			var constructorParametersExpressions = new List<ParameterExpression>();
			int i = 0;
			Array.ForEach
					(
						parametersInfos
						, (x) =>
						{
							var parameterExpression = Expression.Parameter
																	(
																		x.ParameterType
																		, "p" + i.ToString()
																	);
							constructorParametersExpressions.Add(parameterExpression);
							i++;
						}
					);
			var newExpression = Expression.New(constructorInfo, constructorParametersExpressions);
			var inner = Expression.Lambda(newExpression, constructorParametersExpressions);
			var args = Expression.Parameter(typeof(object[]), "args");
			var body = Expression.Invoke
									(
										inner
										, constructorParametersExpressions.Select
																	(
																		(p, ii) =>
																		{
																			return Expression.Convert
																							(
																								Expression.ArrayIndex
																												(
																													args
																													, Expression.Constant(ii)
																												)
																								, p.Type
																							);
																		}
																	).ToArray()
									);
			var outer = Expression.Lambda<Func<object[], T>>(body, args);
			var func = outer.Compile();
			return func;
		}
		public static Action<T, object[]> CreateMethodCallInvokerAction<T>
															(
																Type type
																, Func<MethodInfo> getMethodInfoFunc
															)
		{
			var methodInfo = getMethodInfoFunc();
			return CreateMethodCallInvokerAction<T>
												(
													type
													, methodInfo
												);
		}
		public static Action<T, object[]> CreateMethodCallInvokerAction<T>
															(
																Type type
																, MethodInfo methodInfo
															)
		{
			ParameterExpression instanceParameterExpression;
			MethodCallExpression methodCallExpression;
			ParameterExpression argumentsParameterExpression = GetMethodArgumentsParameterExpression
									(
										type
										, methodInfo
										, out instanceParameterExpression
										, out methodCallExpression
									);
			var lambda = Expression.Lambda<Action<T, object[]>>(methodCallExpression, instanceParameterExpression, argumentsParameterExpression);
			var action = lambda.Compile();
			return action;
		}
		public static Func<T, object[], TResult> CreateMethodCallInvokerFunc<T, TResult>
															(
																Type type
																, Func<MethodInfo> getMethodInfoFunc
															)
		{
			var methodInfo = getMethodInfoFunc();
			return
				CreateMethodCallInvokerFunc<T, TResult>
													(
														type
														, methodInfo
													);
		}
		public static Func<T, object[], TResult> CreateMethodCallInvokerFunc<T, TResult>
															(
																Type type
																, MethodInfo methodInfo
															)
		{
			ParameterExpression instanceParameterExpression;
			MethodCallExpression methodCallExpression;
			ParameterExpression argumentsParameterExpression = GetMethodArgumentsParameterExpression
									(
										type
										, methodInfo
										, out instanceParameterExpression
										, out methodCallExpression
									);
			var lambda = Expression.Lambda<Func<T, object[], TResult>>(methodCallExpression, instanceParameterExpression, argumentsParameterExpression);
			var func = lambda.Compile();
			return func;
		}
		private static ParameterExpression GetMethodArgumentsParameterExpression
											(
												Type type
												, MethodInfo methodInfo
												, out ParameterExpression instanceParameterExpression
												, out MethodCallExpression methodCallExpression
											)
		{
			var argumentsParameterExpression = Expression.Parameter(typeof(object[]), "args");
			instanceParameterExpression = Expression.Parameter(type);
			UnaryExpression instanceConvertUnaryExpression = null;
			if (!methodInfo.IsStatic)
			{
				instanceConvertUnaryExpression = Expression.Convert(instanceParameterExpression, type);
			}
			var parametersParameterExpressionList = new List<Expression>();
			int i = 0;
			var parametersInfos = methodInfo.GetParameters();
			Array.ForEach
					(
						parametersInfos
						, (x) =>
						{
							BinaryExpression valueObject = Expression.ArrayIndex
																		(
																			argumentsParameterExpression
																			, Expression.Constant(i)
																		);
							UnaryExpression valueCast = Expression.Convert
																		(
																			valueObject
																			, x.ParameterType
																		);
							parametersParameterExpressionList.Add(valueCast);
							i++;
						}
					);
			methodCallExpression = Expression.Call(instanceConvertUnaryExpression, methodInfo, parametersParameterExpressionList);
			return argumentsParameterExpression;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Net.Mail;
	using System.Reflection;
	public static partial class ExtensionMethodsManager
	{
		public static byte[] GetBytes(this MailMessage mailMessage)
		{
			Assembly assembly = typeof(SmtpClient).Assembly;
			Type type = assembly.GetType("System.Net.Mail.MailWriter");
			var parametersTypes = new[]
									{ 
										typeof(Stream)
									};
			object x = null;
			using (Stream stream = new MemoryStream())
			{
				var constructorInfo = type.GetConstructor
													(
														BindingFlags.Instance | BindingFlags.NonPublic
														, null
														, parametersTypes
														, null
													);
				var func = DynamicCallMethodExpressionTreeInvokerHelper.CreateNewInstanceConstructorInvokerFunc<object>
														(
															type
															, constructorInfo
														);
				x = func(new[] { stream });
				var action = DynamicCallMethodExpressionTreeInvokerHelper.CreateMethodCallInvokerAction<MailMessage>
														(
															typeof(MailMessage)
															, () =>
															{
																var methodInfo = typeof(MailMessage).GetMethod
																						(
																							"Send"
																							, BindingFlags.NonPublic | BindingFlags.Instance
																							, null
																							, new[] { type, typeof(bool) }
																							, null
																						);
																return methodInfo;
															}
														);
				action
					(
						mailMessage
						, new[]
							{
								x
								, true
							}
					);
				byte[] buffer = StreamDataHelper.ReadDataToBytes(stream);
				return buffer;
			}
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=DynamicMethod  iLGenerator Simple Sample
namespace Microshaoft
{
	using System;
	using System.Reflection;
	using System.Reflection.Emit;
	// These classes are for demonstration purposes.
	//
	public class Example
	{
		private int _id = 0;
		public Example(int id)
		{
			this._id = id;
		}
		public int ID
		{
			get
			{
				return _id;
			}
		}
	}
	public class DerivedFromExample : Example
	{
		public DerivedFromExample(int id)
					: base(id)
						{
						}
	}
	// Two delegates are declared: UseLikeInstance treats the dynamic
	// method as if it were an instance method, and UseLikeStatic
	// treats the dynamic method in the ordinary fashion.
	// 
	public delegate int UseLikeInstance(int newID);
	public delegate int UseLikeStatic(Example ex, int newID);
	public class Demo
	{
		public static void Main()
		{
			// This dynamic method changes the private id field. It has
			// no name; it returns the old id value (return type int);
			// it takes two parameters, an instance of Example and 
			// an int that is the new value of id; and it is declared 
			// with Example as the owner type, so it can access all 
			// members, public and private.
			//
			DynamicMethod changeID = new DynamicMethod
											(
												""
												, typeof(int)
												, new []
												{
													typeof(Example)
													, typeof(int)
												}
												, typeof(Example)
											);
			// Get a FieldInfo for the private field 'id'.
			FieldInfo fid = typeof(Example).GetField
												(
													"_id"
													, BindingFlags.NonPublic | BindingFlags.Instance
												);
			ILGenerator ilg = changeID.GetILGenerator();
			// Push the current value of the id field onto the 
			// evaluation stack. It's an instance field, so load the
			// instance of Example before accessing the field.
			ilg.Emit(OpCodes.Ldarg_0);
			ilg.Emit(OpCodes.Ldfld, fid);
			// Load the instance of Example again, load the new value 
			// of id, and store the new field value. 
			ilg.Emit(OpCodes.Ldarg_0);
			ilg.Emit(OpCodes.Ldarg_1);
			ilg.Emit(OpCodes.Stfld, fid);
			// The original value of the id field is now the only 
			// thing on the stack, so return from the call.
			ilg.Emit(OpCodes.Ret);
			// Create a delegate that uses changeID in the ordinary
			// way, as a static method that takes an instance of
			// Example and an int.
			//
			var uls = (UseLikeStatic) changeID.CreateDelegate
													(
														typeof(UseLikeStatic)
													);
			// Create an instance of Example with an id of 42.
			//
			var ex = new Example(42);
			// Create a delegate that is bound to the instance of 
			// of Example. This is possible because the first 
			// parameter of changeID is of type Example. The 
			// delegate has all the parameters of changeID except
			// the first.
			var uli = (UseLikeInstance) changeID.CreateDelegate
													(
														typeof(UseLikeInstance)
														, ex
													);
			// First, change the value of id by calling changeID as
			// a static method, passing in the instance of Example.
			//
			Console.WriteLine
						(
							"Change the value of id; previous value: {0}"
							, uls(ex, 1492)
						);
			// Change the value of id again using the delegate bound
			// to the instance of Example.
			//
			Console.WriteLine
						(
							"Change the value of id; previous value: {0}"
							, uli(2700)
						);
			Console.WriteLine("Final value of id: {0}", ex.ID);
			// Now repeat the process with a class that derives
			// from Example.
			//
			DerivedFromExample dfex = new DerivedFromExample(71);
			uli = (UseLikeInstance) changeID.CreateDelegate
												(
													typeof(UseLikeInstance)
													, dfex
												);
			Console.WriteLine
						(
							"Change the value of id; previous value: {0}"
							, uls(dfex, 73)
						);
			Console.WriteLine
						(
							"Change the value of id; previous value: {0}"
							, uli(79)
						);
			Console.WriteLine("Final value of id: {0}", dfex.ID);
		}
	}
	/* This code example produces the following output:
	Change the value of id; previous value: 42
	Change the value of id; previous value: 1492
	Final value of id: 2700
	Change the value of id; previous value: 71
	Change the value of id; previous value: 73
	Final value of id: 79
	 */
}

#T=DynamicMethod, ilGenerator.Emit 2012-08-13
namespace ConsoleApplication
{
	using System;
	using System.Diagnostics;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			Person person = new Person();
			string word = "hello";
			Person p = null;
			object[] param = new object[] { word, p, 3 };
			Stopwatch watch1 = new Stopwatch();
			//FastInvokeHandler fastInvoker = DynamicMethodHelper.GetDynamicMethodInvoker(methodInfo);
			Person x = null;
			int y = -1;
			DynamicMethodHelper.DynamicMethodFuncInvokeHandler handler1 =
													DynamicMethodHelper.GetDynamicMethodFuncInvoker
																					(
																						person
																						, (mi) =>
																						{
																							return !mi.IsStatic && mi.Name.Equals("Say");
																						}
																					);
			DynamicMethodHelper.DynamicMethodFuncInvokeHandler handler2 =
													DynamicMethodHelper.GetDynamicMethodFuncInvoker<Person>
																					(
																						mi =>
																						{
																							return mi.IsStatic && mi.Name.Equals("Say");
																						}
																					);//.Invoke(person, new object[] { "hihi" });
			CodeTimer.Time
						(
							"串行测试"
							, 1
							, () =>
								{
									var parameters = new object[] { "aaa", x, y };
									handler1.DynamicInvoke(person, parameters);
									Console.WriteLine("实例方法 Say Invoke ref word: {0}, int avi {1}", parameters[0], parameters[2]);
									handler1.Invoke(person, parameters);
									Console.WriteLine("实例方法 Say Invoke ref word: {0}, int avi {1}", parameters[0], parameters[2]);
									string s = (string)handler2.DynamicInvoke(person, new object[] { "bb", x, y });
									Console.WriteLine("静态方法 Say DynamicInvoke return: {0}", s);
									s = (string)handler2.Invoke(person, new object[] { "bb", x, y });
									Console.WriteLine("静态方法 Say Invoke return: {0}", s);
								}
						);
			CodeTimer.ParallelTime
						(
							"并行测试"
							, 1
							, () =>
								{
									var parameters = new object[] { "aaa", x, y };
									handler1.DynamicInvoke(person, parameters);
									Console.WriteLine("实例方法 Say Invoke ref word: {0}, int avi {1}", parameters[0], parameters[2]);
									handler1.Invoke(person, parameters);
									Console.WriteLine("实例方法 Say Invoke ref word: {0}, int avi {1}", parameters[0], parameters[2]);
									string s = (string)handler2.DynamicInvoke(person, new object[] { "bb", x, y });
									Console.WriteLine("静态方法 Say DynamicInvoke return: {0}", s);
									s = (string)handler2.Invoke(person, new object[] { "bb", x, y });
									Console.WriteLine("静态方法 Say Invoke return: {0}", s);
								}
						);
			Console.ReadLine();
		}
	}
	public class Person
	{
		public void Say(ref string word, out Person p, int avi)
		{
			word = "instance " + avi.ToString();
			//Console.WriteLine(word);
			p = new Person();
			//return 100;
		}
		public static string Say(string word)
		{
			//Console.WriteLine("Static Say");
			return "return static " + word;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	using System.Threading;
	using System.Threading.Tasks;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void ParallelTime(string name, int iteration, Action action)
		{
			InternalIterationProcess
					(
						name
						, iteration
						, () =>
							{
								Parallel.For
										(
											0
											, iteration
											, new ParallelOptions()
														{
														MaxDegreeOfParallelism = 4,
														TaskScheduler = null
														}
											, i =>
												{
													action();
												}
										);
							}
					);
		}
		private static void InternalIterationProcess(string name, int iteration, Action action)
		{
			if (string.IsNullOrEmpty(name))
			{
				return;
			}
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCycleCount();
			action();
			ulong cpuCycles = GetCycleCount() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine("\tTime Elapsed:\t" + watch.ElapsedMilliseconds.ToString("N0") + "ms");
			Console.WriteLine("\tCPU Cycles:\t" + cpuCycles.ToString("N0"));
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine("\tGen " + i + ": \t\t" + count);
			}
			Console.WriteLine();
		}
		public static void Time(string name, int iteration, Action action)
		{
			InternalIterationProcess
								(
									name
									, iteration
									, () =>
										{
											for (int i = 0; i < iteration; i++)
											{
												action();
											}
										}
								);
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Reflection;
	using System.Reflection.Emit;
	public class DynamicMethodHelper
	{
		public delegate object DynamicMethodFuncInvokeHandler(object target, object[] parameters);
		public static DynamicMethodFuncInvokeHandler GetDynamicMethodFuncInvoker(string typeName, Func<MethodInfo, bool> predicateFunc)
		{
			MethodInfo methodInfo = Type.GetType(typeName).GetMethods().First
													(
														mi =>
														{
															return predicateFunc(mi);
														}
													);
			DynamicMethod dynamicMethod = GetDynamicMethod(methodInfo);
			return (DynamicMethodFuncInvokeHandler) dynamicMethod.CreateDelegate(typeof(DynamicMethodFuncInvokeHandler));
		}
		public static DynamicMethodFuncInvokeHandler GetDynamicMethodFuncInvoker<TTarget>(Func<MethodInfo, bool> predicateFunc)
		{
			MethodInfo methodInfo = typeof(TTarget).GetMethods().First
													(
														mi =>
														{
															return predicateFunc(mi);
														}
													);
			DynamicMethod dynamicMethod = GetDynamicMethod(methodInfo);
			return (DynamicMethodFuncInvokeHandler) dynamicMethod.CreateDelegate(typeof(DynamicMethodFuncInvokeHandler));
		}
		public static DynamicMethodFuncInvokeHandler GetDynamicMethodFuncInvoker(object target, Func<MethodInfo, bool> predicateFunc)
		{
			MethodInfo methodInfo = target.GetType().GetMethods().First
													(
														mi =>
														{
															return predicateFunc(mi);
														}
													);
			DynamicMethod dynamicMethod = GetDynamicMethod(methodInfo);
			return (DynamicMethodFuncInvokeHandler)dynamicMethod.CreateDelegate(typeof(DynamicMethodFuncInvokeHandler));
		}
		private static DynamicMethod GetDynamicMethod(MethodInfo methodInfo)
		{
			int i = 0;
			var parametersInfos = methodInfo.GetParameters();
			DynamicMethod dynamicMethod = new DynamicMethod
													(
														string.Empty
														, typeof(object)
														, new Type[] 
																{
																	typeof(object)
																	, typeof(object[])
																}
														 , methodInfo.DeclaringType.Module
													  );
			ILGenerator ilg = dynamicMethod.GetILGenerator();
			if (!methodInfo.IsStatic)
			{
				ilg.Emit(OpCodes.Ldarg_0);
			}
			i = 0;
			Array.ForEach
					(
						parametersInfos
						, (pi) =>
						{
							Type pt;
							if (pi.ParameterType.IsByRef)
							{
								pt = pi.ParameterType.GetElementType();
							}
							else
							{
								pt = pi.ParameterType;
							}
							//paramTypes[i] = pt;
							LocalBuilder lb = ilg.DeclareLocal(pt, true);
							ilg.Emit(OpCodes.Ldarg_1);
							EmitFastInt(ilg, i);
							ilg.Emit(OpCodes.Ldelem_Ref);
							EmitCastToReference(ilg, pt);
							ilg.Emit(OpCodes.Stloc, lb);
							if (pi.ParameterType.IsByRef)
							{
								ilg.Emit(OpCodes.Ldloca_S, lb);
								ilg.Emit(OpCodes.Ldarg_1);
								EmitFastInt(ilg, i);
								ilg.Emit(OpCodes.Ldloc, lb);
								if (lb.LocalType.IsValueType)
								{
									ilg.Emit(OpCodes.Box, lb.LocalType);
								}
								ilg.Emit(OpCodes.Stelem_Ref);
							}
							else
							{
								ilg.Emit(OpCodes.Ldloc, lb);
							}
							i++;
						}
					);
			if (methodInfo.IsStatic)
			{
				ilg.EmitCall(OpCodes.Call, methodInfo, null);
			}
			else
			{
				ilg.EmitCall(OpCodes.Callvirt, methodInfo, null);
			}
			if (methodInfo.ReturnType == typeof(void))
			{
				ilg.Emit(OpCodes.Ldnull);
			}
			else
			{
				EmitBoxIfNeeded(ilg, methodInfo.ReturnType);
			}
			ilg.Emit(OpCodes.Ret);
			return dynamicMethod;
		}
		private static void EmitCastToReference(ILGenerator ilg, Type type)
		{
			if (type.IsValueType)
			{
				ilg.Emit(OpCodes.Unbox_Any, type);
			}
			else
			{
				ilg.Emit(OpCodes.Castclass, type);
			}
		}
		private static void EmitBoxIfNeeded(ILGenerator ilg, Type type)
		{
			if (type.IsValueType)
			{
				ilg.Emit(OpCodes.Box, type);
			}
		}
		private static void EmitFastInt(ILGenerator il, int value)
		{
			switch (value)
			{
				case -1:
					il.Emit(OpCodes.Ldc_I4_M1);
					return;
				case 0:
					il.Emit(OpCodes.Ldc_I4_0);
					return;
				case 1:
					il.Emit(OpCodes.Ldc_I4_1);
					return;
				case 2:
					il.Emit(OpCodes.Ldc_I4_2);
					return;
				case 3:
					il.Emit(OpCodes.Ldc_I4_3);
					return;
				case 4:
					il.Emit(OpCodes.Ldc_I4_4);
					return;
				case 5:
					il.Emit(OpCodes.Ldc_I4_5);
					return;
				case 6:
					il.Emit(OpCodes.Ldc_I4_6);
					return;
				case 7:
					il.Emit(OpCodes.Ldc_I4_7);
					return;
				case 8:
					il.Emit(OpCodes.Ldc_I4_8);
					return;
			}
			if (value > -129 && value < 128)
			{
				il.Emit(OpCodes.Ldc_I4_S, (SByte)value);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I4, value);
			}
		}
	}
}

#T=DynamicPropertyAccessor Expression 2012-09-02
namespace ConsoleApplication
{
	using System;
	using System.Linq;
	using Microshaoft;
	using Test.Share;
	public class Class1
	{
		//[STAThread]
		static void Main(string[] args)
		{
			var c = "Test.Share.ComplexType";
			var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																	(
																		(a) =>
																		{
																			return a.GetTypes().Any
																								(
																									(t) =>
																									{
																										return (t.FullName == c);
																									}
																								);
																		}
																	);
			ComplexType.F2 = "01234";
			var o = new ComplexType();
			o.F1 = "56789";
			var typeName = o.GetType().FullName;
			//=======================================================================================
			var getter1 = DynamicPropertyAccessor.CreateGetStaticPropertyValueFunc(typeName, "f2");
			var v1 = getter1();
			Console.WriteLine(v1);
			//=======================================================================================
			var getter2 = DynamicPropertyAccessor.CreateGetStaticPropertyValueFunc<string>(typeName, "f2");
			string v2 = getter2();
			Console.WriteLine(v2);
			//=======================================================================================
			var getter3 = DynamicPropertyAccessor.CreateGetPropertyValueFunc(typeName, "f1");
			var v3 = getter3(o);
			Console.WriteLine(v3);
			//=======================================================================================
			var getter4 = DynamicPropertyAccessor.CreateGetPropertyValueFunc<string>(typeName, "f1");
			var v4 = getter4(o);
			Console.WriteLine(v4);
			//=======================================================================================
			var setter1 = DynamicPropertyAccessor.CreateSetStaticPropertyValueAction(typeName, "f2");
			setter1("ABCD");
			v1 = getter1();
			Console.WriteLine(v1);
			v2 = getter2();
			Console.WriteLine(v2);
			//=======================================================================================
			var setter2 = DynamicPropertyAccessor.CreateSetStaticPropertyValueAction<string>(typeName, "f2");
			setter2("EFFGH");
			v1 = getter1();
			Console.WriteLine(v1);
			v2 = getter2();
			Console.WriteLine(v2);
			//=======================================================================================
			var setter3 = DynamicPropertyAccessor.CreateSetPropertyValueAction(typeName, "f1");
			setter3(o, "IJKL");
			v3 = getter3(o);
			Console.WriteLine(v3);
			v4 = getter4(o);
			Console.WriteLine(v4);
			//=======================================================================================
			var setter4 = DynamicPropertyAccessor.CreateSetPropertyValueAction<string>(typeName, "f1");
			setter4(o, "MNOP");
			v3 = getter3(o);
			Console.WriteLine(v3);
			v4 = getter4(o);
			Console.WriteLine(v4);
			//=======================================================================================
			Console.ReadLine();
		}
	}
}
namespace Test.Share
{
	using System.Threading;
	public class ComplexType
	{
		public string F1
		{
			get;
			set;
		}
		public static string _f2;
		public static string F2
		{
			get
			{
				return _f2;
			}
			set
			{
				Interlocked.Exchange<string>(ref _f2, value);
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public class DynamicPropertyAccessor
	{
		private static Assembly GetAssemblyByTypeName(string typeName)
		{
			return
				AppDomain
					.CurrentDomain
						.GetAssemblies()
							.First
								(
									(a) =>
									{
										return
											a
												.GetTypes()
													.Any
														(
															(t) =>
															{
																return
																	(
																		t.FullName
																		== typeName
																	);
															}
														);
									}
								);
		}
		public static Func<object, object> CreateGetPropertyValueFunc
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc
						(
							Type type
							, string propertyName
						)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Func<TProperty> func = null;
			var property = type.GetProperty(propertyName, typeof(TProperty));
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var getPropertyValue = Expression.Property(null, property);
				var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
				func = lambda.Compile();
			}
			return func;
		}
		public static Func<object> CreateGetStaticPropertyValueFunc
						(
							Type type
							, string propertyName
						)
		{
			Func<object> func = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var getPropertyValue = Expression.Property(null, property);
				var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
				var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
				func = lambda.Compile();
			}
			return func;
		}
		public static Func<object> CreateGetStaticPropertyValueFunc
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction
						(
							Type type
							, string propertyName
						)
		{
			Action<object, object> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var target = Expression.Parameter(typeof(object));
				var propertyValue = Expression.Parameter(typeof(object));
				var castTarget = Expression.Convert(target, type);
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object, object> CreateSetPropertyValueAction
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Action<object, TProperty> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var target = Expression.Parameter(typeof(object));
				var propertyValue = Expression.Parameter(typeof(TProperty));
				var castTarget = Expression.Convert(target, type);
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue);
				action = lambda.Compile();
			}
			return action; 
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction
						(
							Type type
							, string propertyName
						)
		{
			Action<object> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var propertyValue = Expression.Parameter(typeof(object));
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(null, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object> CreateSetStaticPropertyValueAction
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Action<TProperty> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var propertyValue = Expression.Parameter(typeof(TProperty));
				//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(null, getSetMethod, propertyValue);
				var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}

#T=EasyPerformanceCounter CodeTimerPerformance (1) 2013-11-10
//#define NET35
namespace TestConsoleApplication
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Threading.Tasks;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Begin ...");
			Random r = new Random();
			int sleep = 100;
			int iterations = 2000;
			int maxDegreeOfParallelism = 8; // Environment.ProcessorCount;
			var performanceCountersCategoryName = "Microshaoft EasyPerformanceCounters Category";
			var performanceCountersCategoryInstanceName = string.Format
																	(
																		"{2}{0}{3}{1}{4}"
																		, ": "
																		, " @ "
																		, ""
																		, ""
																		, Process.GetCurrentProcess().ProcessName
																	);
			//EasyPerformanceCountersHelper 调用示例
			//调用 EasyPerformanceCountersHelper.AttachPerformanceCountersCategoryInstance 可加载性能计数器
			EasyPerformanceCountersHelper.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, performanceCountersCategoryInstanceName + "-1"
								);
			var enableCounters = MultiPerformanceCountersTypeFlags.ProcessCounter
									| MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
									| MultiPerformanceCountersTypeFlags.ProcessedCounter
									| MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter
									| MultiPerformanceCountersTypeFlags.ProcessingCounter;
			//EasyPerformanceCountersHelper 可以直接使用 比如 用于 ASP.NET page_load 程序中代码中
			EasyPerformanceCountersHelper.CountPerformance
								(
									enableCounters
									, performanceCountersCategoryName
									, performanceCountersCategoryInstanceName + "-1"
									, null
									, () =>
									{
										//需要性能计数器的代码段
										//begin ==============================================
										var x = r.Next(0, 10) * sleep;
										Thread.Sleep(x);
										//end ================================================
									}
									, null
								);
			Parallel.For
						(
							0
							, 99
							, (x) =>
							{
								Stopwatch stopwatch =
									EasyPerformanceCountersHelper.CountPerformanceBegin
												(
													enableCounters
													, performanceCountersCategoryName
													, performanceCountersCategoryInstanceName + "-1"
												);
								//需要性能计数器的代码段
								//begin ==============================================
								var xx = r.Next(0, 10) * sleep;
								Thread.Sleep(xx);
								//end ================================================
								if (stopwatch != null)
								{
									EasyPerformanceCountersHelper.CountPerformanceEnd
												(
													enableCounters
													, performanceCountersCategoryName
													, performanceCountersCategoryInstanceName + "-1"
													, stopwatch
												);
									stopwatch = null;
								}
							}
						);
			//CodeTimerPerformance 调用示例
			//CodeTimerPerformance.AttachPerformanceCountersCategoryInstance 可加载性能计数器
			CodeTimerPerformance.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, performanceCountersCategoryInstanceName + "-2"
								);
			enableCounters =
								MultiPerformanceCountersTypeFlags.ProcessCounter
								| MultiPerformanceCountersTypeFlags.ProcessingCounter
								| MultiPerformanceCountersTypeFlags.ProcessedCounter
								| MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
								| MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter;
			//enableCounters = MultiPerformanceCountersTypeFlags.None;
			CodeTimerPerformance.ParallelTime
						(
							"ParallelTime1"
							, iterations
							, () =>
							{
								//需要性能计数器的代码段
								//begin ==============================================
								var x = r.Next(0, 10) * sleep;
								Thread.Sleep(x);
								//end ================================================
							}
							, maxDegreeOfParallelism
							, enableCounters
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName + "-1"
						);
			CodeTimerPerformance.Time
						(
							"Time2"
							, iterations
							, () =>
							{
								//需要性能计数器的代码段
								//begin ==============================================
								var x = r.Next(0, 10) * sleep;
								Thread.Sleep(x);
								//end ================================================
							}
				//, maxDegreeOfParallelism
							, enableCounters
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName + "-2"
						);
			Console.WriteLine("End ...");
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	using System.Threading;
	using System.Threading.Tasks;
	public static class CodeTimerPerformance
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { }, MultiPerformanceCountersTypeFlags.None, string.Empty, string.Empty);
		}
		public static void AttachPerformanceCountersCategoryInstance
					(
						string performanceCountersCategoryName
						, string performanceCountersCategoryInstanceName
					)
		{
			EasyPerformanceCountersHelper.AttachPerformanceCountersCategoryInstance
					(
						performanceCountersCategoryName
						, performanceCountersCategoryInstanceName
					);
		}
		public static void ParallelTime
								(
									string name
									, int iterations
									, Action actionOnce
									, int maxDegreeOfParallelism //= 1
									, MultiPerformanceCountersTypeFlags enablePerformanceCounters //= false
									, string performanceCountersCategoryName
									, string performanceCountersCategoryInstanceName
								)
		{
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			IntPtr threadID = GetCurrentThreadId();
			Stopwatch watch = Stopwatch.StartNew();
			ulong cycleCount = GetCurrentThreadCycleCount();
			Parallel.For
						(
							0
							, iterations
							, new ParallelOptions()
							{
								MaxDegreeOfParallelism = maxDegreeOfParallelism
								//, TaskScheduler = null
							}
							, (x) =>
							{
								EasyPerformanceCountersHelper.CountPerformance
												(
													enablePerformanceCounters
													, performanceCountersCategoryName
													, performanceCountersCategoryInstanceName
													, null
													, actionOnce
													, null
												);
							}
						);
			ulong cpuCycles = GetCurrentThreadCycleCount() - cycleCount;
			watch.Stop();
			//watch = null;
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine
							(
								"{0}Time Elapsed:{0}{1}ms"
								, "\t"
								, watch.ElapsedMilliseconds.ToString("N0")
							);
			Console.WriteLine
							(
								"{0}CPU Cycles:{0}{1}"
								, "\t"
								, cpuCycles.ToString("N0")
							);
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine
							(
								"{0}Gen{1}:{0}{0}{2}"
								, "\t"
								, i
								, count
							);
			}
			Console.WriteLine();
		}
		public static void Time
							(
								string name
								, int iterations
								, Action actionOnce
								, MultiPerformanceCountersTypeFlags enablePerformanceCounters //= false
								, string performanceCountersCategoryName
								, string performanceCountersCategoryInstanceName
							)
		{
			ParallelTime
						(
							name
							, iterations
							, actionOnce
							, 1
							, enablePerformanceCounters
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName
						);
		}
		private static ulong GetThreadCycleCount(IntPtr threadID)
		{
			ulong cycleCount = 0;
			QueryThreadCycleTime(threadID, ref cycleCount);
			return cycleCount;
		}
		private static ulong GetCurrentThreadCycleCount()
		{
			IntPtr threadID = GetCurrentThread();
			return GetThreadCycleCount(threadID);
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThreadId();
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Diagnostics;
	//using System.Collections.Concurrent;
	public static class EasyPerformanceCountersHelper
	{
		private static Dictionary<string, CommonPerformanceCountersContainer> _dictionary = new Dictionary<string, CommonPerformanceCountersContainer>();
		public static void AttachPerformanceCountersCategoryInstance
							(
								string performanceCountersCategoryName
								, string performanceCountersCategoryInstanceName
							)
		{
			string key = string.Format
									(
										"{1}{0}{2}"
										, "-"
										, performanceCountersCategoryName
										, performanceCountersCategoryInstanceName
									);
			CommonPerformanceCountersContainer container = null;
			if (!_dictionary.TryGetValue(key, out container))
			{
				container = new CommonPerformanceCountersContainer();
				_dictionary.Add
							(
								key
								, container //new CommonPerformanceCountersContainer()
							);
				container.AttachPerformanceCountersToProperties(performanceCountersCategoryInstanceName, performanceCountersCategoryName);
			}
		}
		private static object _lockerObject = new object();
		public static Stopwatch CountPerformanceBegin
									(
										MultiPerformanceCountersTypeFlags enabledPerformanceCounters
										, string performanceCountersCategoryName
										, string performanceCountersCategoryInstanceName
									)
		{
			Stopwatch r = null;
			if (enabledPerformanceCounters != MultiPerformanceCountersTypeFlags.None)
			{
				string key = string.Format
										(
											"{1}{0}{2}"
											, "-"
											, performanceCountersCategoryName
											, performanceCountersCategoryInstanceName
										);
				CommonPerformanceCountersContainer container = null;
				if (!_dictionary.TryGetValue(key, out container))
				{
					lock (_lockerObject)
					{
						container = new CommonPerformanceCountersContainer();
						_dictionary.Add
									(
										key
										, new CommonPerformanceCountersContainer()
									);
						container.AttachPerformanceCountersToProperties
											(
												performanceCountersCategoryInstanceName
												, performanceCountersCategoryName
											);
					}
				}
				var enableProcessCounter =
											(
												(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessCounter)
												!= MultiPerformanceCountersTypeFlags.None
											);
				if (enableProcessCounter)
				{
					container.PrcocessPerformanceCounter.Increment();
				}
				var enableProcessingCounter =
											(
												(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessingCounter)
												!= MultiPerformanceCountersTypeFlags.None
											);
				if (enableProcessingCounter)
				{
					container.ProcessingPerformanceCounter.Increment();
				}
				var enableProcessedAverageTimerCounter =
											(
												(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter)
												!= MultiPerformanceCountersTypeFlags.None
											);
				if (enableProcessedAverageTimerCounter)
				{
					r = Stopwatch.StartNew();
				}
			}
			return r;
		}
		public static void CountPerformanceEnd
									(
										MultiPerformanceCountersTypeFlags enabledPerformanceCounters
										, string performanceCountersCategoryName
										, string performanceCountersCategoryInstanceName
										, Stopwatch stopwatch
									)
		{
			string key = string.Format
						(
							"{1}{0}{2}"
							, "-"
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName
						);
			CommonPerformanceCountersContainer container = null;
			if (!_dictionary.TryGetValue(key, out container))
			{
				return;
			}
			var enableProcessedAverageTimerCounter =
										(
											(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter)
											!= MultiPerformanceCountersTypeFlags.None
										);
			if (enableProcessedAverageTimerCounter)
			{
				if (stopwatch != null)
				{
					PerformanceCounter performanceCounter = container.ProcessedAverageTimerPerformanceCounter;
					PerformanceCounter basePerformanceCounter = container.ProcessedAverageBasePerformanceCounter;
					stopwatch.Stop();
					performanceCounter.IncrementBy(stopwatch.ElapsedTicks);
					basePerformanceCounter.Increment();
					//stopwatch = null;
				}
			}
			var enableProcessingCounter =
										(
											(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessingCounter)
											!= MultiPerformanceCountersTypeFlags.None
										);
			if (enableProcessingCounter)
			{
				container.ProcessingPerformanceCounter.Decrement();
			}
			var enableProcessedPerformanceCounter =
									(
										(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessedCounter)
										!= MultiPerformanceCountersTypeFlags.None
									);
			if (enableProcessedPerformanceCounter)
			{
				container.ProcessedPerformanceCounter.Increment();
			}
			var enableProcessedRateOfCountsPerSecondPerformanceCounter =
						(
							(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter)
							!= MultiPerformanceCountersTypeFlags.None
						);
			if (enableProcessedRateOfCountsPerSecondPerformanceCounter)
			{
				container.ProcessedRateOfCountsPerSecondPerformanceCounter.Increment();
			}
		}
		public static void CountPerformance
									(
										MultiPerformanceCountersTypeFlags enabledPerformanceCounters
										, string performanceCountersCategoryName
										, string performanceCountersCategoryInstanceName
										, Action onBeforeCountPerformanceInnerProcessAction
										, Action onCountPerformanceInnerProcessAction
										, Action onAfterCountPerformanceInnerProcessAction
									)
		{
			if (enabledPerformanceCounters != MultiPerformanceCountersTypeFlags.None)
			{
				if (onCountPerformanceInnerProcessAction != null)
				{
					string key = string.Format
											(
												"{1}{0}{2}"
												, "-"
												, performanceCountersCategoryName
												, performanceCountersCategoryInstanceName
											);
					CommonPerformanceCountersContainer container = null;
					if (!_dictionary.TryGetValue(key, out container))
					{
						lock (_lockerObject)
						{
							container = new CommonPerformanceCountersContainer();
							_dictionary.Add
										(
											key
											, new CommonPerformanceCountersContainer()
										);
							container.AttachPerformanceCountersToProperties
												(
													performanceCountersCategoryInstanceName
													, performanceCountersCategoryName
												);
						}
					}
					var enableProcessCounter =
												(
													(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessCounter)
													!= MultiPerformanceCountersTypeFlags.None
												);
					if (enableProcessCounter)
					{
						container.PrcocessPerformanceCounter.Increment();
					}
					var enableProcessingCounter =
												(
													(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessingCounter)
													!= MultiPerformanceCountersTypeFlags.None
												);
					if (enableProcessingCounter)
					{
						container.ProcessingPerformanceCounter.Increment();
					}
					var enableProcessedAverageTimerCounter =
												(
													(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter)
													!= MultiPerformanceCountersTypeFlags.None
												);
					try
					{
						container.ProcessedAverageTimerPerformanceCounter.ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
																(
																	enableProcessedAverageTimerCounter
																	, container.ProcessedAverageBasePerformanceCounter
																	, () =>
																	{
																		if (onCountPerformanceInnerProcessAction != null)
																		{
																			if (onBeforeCountPerformanceInnerProcessAction != null)
																			{
																				onBeforeCountPerformanceInnerProcessAction();
																			}
																			onCountPerformanceInnerProcessAction();
																			if (onAfterCountPerformanceInnerProcessAction != null)
																			{
																				onAfterCountPerformanceInnerProcessAction();
																			}
																		}
																	}
																	, null
																	, null
																);
					}
					catch (Exception e)
					{
						throw new Exception("ReThrow Exception On Caught Excepion", e);
					}
					finally
					{
						if (enableProcessingCounter)
						{
							container.ProcessingPerformanceCounter.Decrement();
						}
						var enableProcessedPerformanceCounter =
												(
													(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessedCounter)
													!= MultiPerformanceCountersTypeFlags.None
												);
						if (enableProcessedPerformanceCounter)
						{
							container.ProcessedPerformanceCounter.Increment();
						}
						var enableProcessedRateOfCountsPerSecondPerformanceCounter =
												(
													(enabledPerformanceCounters & MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter)
													!= MultiPerformanceCountersTypeFlags.None
												);
						if (enableProcessedRateOfCountsPerSecondPerformanceCounter)
						{
							container.ProcessedRateOfCountsPerSecondPerformanceCounter.Increment();
						}
					}
				}
			}
			else
			{
				if (onCountPerformanceInnerProcessAction != null)
				{
					onCountPerformanceInnerProcessAction();
				}
			}
		}
	}
}
//=========================================================================================

#T=EasyPerformanceCounter CodeTimerPerformance (2) 2013-11-10
//=========================================================================================
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public class CommonPerformanceCountersContainer
	{
		#region PerformanceCounters
		private PerformanceCounter _processPerformanceCounter;
		[PerformanceCounterDefinitionAttribute(CounterType = PerformanceCounterType.NumberOfItems64, CounterName = "01.接收处理笔数(笔)")]
		public PerformanceCounter PrcocessPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _processPerformanceCounter, value, 2);
			}
			get
			{
				return _processPerformanceCounter;
			}
		}
		private PerformanceCounter _processingPerformanceCounter;
		[PerformanceCounterDefinitionAttribute(CounterType = PerformanceCounterType.NumberOfItems64, CounterName = "02.正在处理笔数(笔)")]
		public PerformanceCounter ProcessingPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _processingPerformanceCounter, value, 2);
			}
			get
			{
				return _processingPerformanceCounter;
			}
		}
		private PerformanceCounter _processedPerformanceCounter;
		[PerformanceCounterDefinitionAttribute(CounterType = PerformanceCounterType.NumberOfItems64, CounterName = "03.完成处理笔数(笔)")]
		public PerformanceCounter ProcessedPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _processedPerformanceCounter, value, 2);
			}
			get
			{
				return _processedPerformanceCounter;
			}
		}
		private PerformanceCounter _processedRateOfCountsPerSecondPerformanceCounter;
		[PerformanceCounterDefinitionAttribute(CounterType = PerformanceCounterType.RateOfCountsPerSecond64, CounterName = "04.每秒完成处理笔数(笔/秒)")]
		public PerformanceCounter ProcessedRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _processedRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _processedRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _ProcessedAverageTimerPerformanceCounter;
		[PerformanceCounterDefinitionAttribute(CounterType = PerformanceCounterType.AverageTimer32, CounterName = "05.平均每笔处理耗时秒数(秒/笔)")]
		public PerformanceCounter ProcessedAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _ProcessedAverageTimerPerformanceCounter, value, 2);
			}
			get
			{
				return _ProcessedAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _processedAverageBasePerformanceCounter;
		[PerformanceCounterDefinitionAttribute(CounterType = PerformanceCounterType.AverageBase)]
		public PerformanceCounter ProcessedAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _processedAverageBasePerformanceCounter, value, 2);
			}
			get
			{
				return _processedAverageBasePerformanceCounter;
			}
		}
		#endregion
		// indexer declaration
		public PerformanceCounter this[string name]
		{
			get
			{
				throw new NotImplementedException();
				//return null;
			}
		}
		//private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCountersToProperties
							(
								string instanceName
								, string categoryName
							)
		{
			var type = this.GetType();
			PerformanceCountersHelper.AttachPerformanceCountersToProperties<CommonPerformanceCountersContainer>(instanceName, categoryName, this);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterExtensionMethodsManager
	{
		public static T ChangeCounterValueWithTryCatchExceptionFinally<T>
								(
									this PerformanceCounter performanceCounter
									, bool enabled
									, Func<PerformanceCounter, T> onCounterChangeProcessFunc //= null
									, Action<PerformanceCounter> onCounterChangedProcessAction //= null
									, Func<PerformanceCounter, Exception, bool> onCaughtExceptionProcessFunc //= null
									, Action<PerformanceCounter> onCaughtExceptionFinallyProcessAction //= null
								)
		{
			T r = default(T);
			if (enabled)
			{
				if (onCounterChangeProcessFunc != null)
				{
					var caughtException = false;
					try
					{
						r = onCounterChangeProcessFunc(performanceCounter);
					}
					catch (Exception e)
					{
						caughtException = true;
						var reThrow = true;
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrow = onCaughtExceptionProcessFunc(performanceCounter, e);
						}
						if (reThrow)
						{
							throw new Exception("ReThrow Exception On Caught Excepion", e);
						}
					}
					finally
					{
						if (caughtException)
						{
							if (onCaughtExceptionFinallyProcessAction != null)
							{
								onCaughtExceptionFinallyProcessAction(performanceCounter);
							}
						}
					}
				}
			}
			if (onCounterChangedProcessAction != null)
			{
				var caughtException = false;
				try
				{
					onCounterChangedProcessAction(performanceCounter);
				}
				catch (Exception e)
				{
					caughtException = true;
					var reThrow = true;
					if (onCaughtExceptionProcessFunc != null)
					{
						reThrow = onCaughtExceptionProcessFunc(performanceCounter, e);
					}
					if (reThrow)
					{
						throw new Exception("ReThrow Exception On Caught Excepion", e);
					}
				}
				finally
				{
					if (caughtException)
					{
						if (onCaughtExceptionFinallyProcessAction != null)
						{
							onCaughtExceptionFinallyProcessAction(performanceCounter);
						}
					}
				}
			}
			return r;
		}
		public static void ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
								(
									this PerformanceCounter performanceCounter
									, bool enabled
									, PerformanceCounter basePerformanceCounter
									, Action onCountPerformanceInnerProcessAction //= null
									, Func<PerformanceCounter, Exception, bool> onCaughtExceptionProcessFunc //= null
									, Action<PerformanceCounter, PerformanceCounter> onCaughtExceptionFinallyProcessAction //= null
								)
		{
			if (enabled)
			{
				var stopwatch = Stopwatch.StartNew();
				if (onCountPerformanceInnerProcessAction != null)
				{
					var caughtException = false;
					try
					{
						onCountPerformanceInnerProcessAction();
					}
					catch (Exception e)
					{
						caughtException = true;
						var reThrow = true;
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrow = onCaughtExceptionProcessFunc(performanceCounter, e);
						}
						if (reThrow)
						{
							throw new Exception("ReThrow Exception On Caught Excepion", e);
						}
					}
					finally
					{
						stopwatch.Stop();
						performanceCounter.IncrementBy(stopwatch.ElapsedTicks);
						stopwatch = null;
						basePerformanceCounter.Increment();
						if (caughtException)
						{
							if (onCaughtExceptionFinallyProcessAction != null)
							{
								onCaughtExceptionFinallyProcessAction(performanceCounter, basePerformanceCounter);
							}
						}
					}
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	[FlagsAttribute]
	public enum MultiPerformanceCountersTypeFlags : ushort
	{
		None = 0,
		ProcessCounter = 1,
		ProcessingCounter = 2,
		ProcessedCounter = 4,
		ProcessedAverageTimerCounter = 8,
		ProcessedRateOfCountsPerSecondCounter = 16
	};
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
	public class PerformanceCounterDefinitionAttribute : Attribute
	{
		public PerformanceCounterType CounterType;
		public string CounterName;
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	using System.Linq;
	public static class PerformanceCountersHelper
	{
		public static void AttachPerformanceCountersToProperties<T>
									(
										string performanceCounterInstanceName
										, string category
										, T target //= default(T)
									)
		{
			var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList.Where
												(
													(pi) =>
													{
														var parameters = pi.GetIndexParameters();
														return
															(
																pi.PropertyType == typeof(PerformanceCounter)
																&& (parameters == null ? 0 : parameters.Length) <= 0
															);
													}
												).ToList();
			if (PerformanceCounterCategory.Exists(category))
			{
				propertiesList.ForEach
									(
										(pi) =>
										{
											if (PerformanceCounterCategory.CounterExists(pi.Name, category))
											{
												if (PerformanceCounterCategory.InstanceExists(performanceCounterInstanceName, category))
												{
													//var pc = new PerformanceCounter(category, pi.Name, instanceName, false);
													//pc.InstanceName = instanceName;
													//pc.RemoveInstance();
												}
											}
										}
									);
				//PerformanceCounterCategory.Delete(category);
			}
			if (!PerformanceCounterCategory.Exists(category))
			{
				var ccdc = new CounterCreationDataCollection();
				propertiesList.ForEach
								(
									(pi) =>
									{
										var propertyName = pi.Name;
										var performanceCounterType = PerformanceCounterType.NumberOfItems64;
										var performanceCounterName = propertyName;
										var attribute = pi.GetCustomAttributes(false).FirstOrDefault
																					(
																						(x) =>
																						{
																							return x as PerformanceCounterDefinitionAttribute != null;
																						}
																					) as PerformanceCounterDefinitionAttribute;
										if (attribute != null)
										{
											var counterName = attribute.CounterName;
											if (!string.IsNullOrEmpty(counterName))
											{
												performanceCounterName = counterName;
											}
											var counterType = attribute.CounterType;
											//if (counterType != null)
											{
												performanceCounterType = counterType;
											}
										}
										var ccd = PerformanceCountersHelper.GetCounterCreationData
																				(
																					performanceCounterName
																					, performanceCounterType
																				);
										ccdc.Add(ccd);
									}
								);
				PerformanceCounterCategory.Create
								(
									category,
									string.Format("{0} Category Help.", category),
									PerformanceCounterCategoryType.MultiInstance,
									ccdc
								);
			}
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var performanceCounterType = PerformanceCounterType.NumberOfItems64;
									var performanceCounterName = propertyName;
									var attribute = pi.GetCustomAttributes(false).FirstOrDefault
																				(
																					(x) =>
																					{
																						return x as PerformanceCounterDefinitionAttribute != null;
																					}
																				) as PerformanceCounterDefinitionAttribute;
									if (attribute != null)
									{
										var counterName = attribute.CounterName;
										if (!string.IsNullOrEmpty(counterName))
										{
											performanceCounterName = counterName;
										}
										var counterType = attribute.CounterType;
										//if (counterType != null)
										{
											performanceCounterType = counterType;
										}
									}
									var pc = new PerformanceCounter()
									{
										CategoryName = category
										,
										CounterName = performanceCounterName
										,
										InstanceLifetime = PerformanceCounterInstanceLifetime.Process
										,
										InstanceName = performanceCounterInstanceName
										,
										ReadOnly = false
										,
										RawValue = 0
									};
									if (pi.GetGetMethod().IsStatic)
									{
										var setter = DynamicPropertyAccessor.CreateSetStaticPropertyValueAction<PerformanceCounter>(type, propertyName);
										setter(pc);
									}
									else
									{
										if (target != null)
										{
											var setter = DynamicPropertyAccessor.CreateSetPropertyValueAction<PerformanceCounter>(type, propertyName);
											setter(target, pc);
										}
									}
								}
							);
		}
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			return new CounterCreationData()
			{
				CounterName = counterName
				,
				CounterHelp = string.Format("{0} Help", counterName)
				,
				CounterType = performanceCounterType
			};
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class ReaderWriterLockSlimHelper
	{
		public static bool TryEnterWriterLockSlimWrite<T>
												(
													 ref T target
													, T newValue
													, int enterTimeOutSeconds
												)
													where T : class
		{
			bool r = false;
			var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutSeconds >= 0)
			{
				timeOut = enterTimeOutSeconds * 1000;
			}
			try
			{
				r = (rwls.TryEnterWriteLock(timeOut));
				if (r)
				{
					Interlocked.Exchange<T>(ref target, newValue);
					r = true;
				}
			}
			finally
			{
				if (r)
				{
					rwls.ExitWriteLock();
				}
			}
			return r;
		}
		public static bool TryEnterWriterLockSlim
								(
									Action action
									, int enterTimeOutSeconds
								)
		{
			bool r = false;
			if (action != null)
			{
				var rwls = new ReaderWriterLockSlim();
				int timeOut = Timeout.Infinite;
				if (enterTimeOutSeconds >= 0)
				{
					timeOut = enterTimeOutSeconds * 1000;
				}
				try
				{
					r = (rwls.TryEnterWriteLock(timeOut));
					if (r)
					{
						action();
						r = true;
					}
				}
				finally
				{
					if (r)
					{
						rwls.ExitWriteLock();
					}
				}
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public class DynamicPropertyAccessor
	{
		private static Assembly GetAssemblyByTypeName(string typeName)
		{
			return
				AppDomain
					.CurrentDomain
						.GetAssemblies()
							.First
								(
									(a) =>
									{
										return
											a
												.GetTypes()
													.Any
														(
															(t) =>
															{
																return
																	(
																		t.FullName
																		== typeName
																	);
															}
														);
									}
								);
		}
		public static Func<object, object> CreateGetPropertyValueFunc
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc
						(
							Type type
							, string propertyName
						)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Func<TProperty> func = null;
			var property = type.GetProperty(propertyName, typeof(TProperty));
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var getPropertyValue = Expression.Property(null, property);
				var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
				func = lambda.Compile();
			}
			return func;
		}
		public static Func<object> CreateGetStaticPropertyValueFunc
						(
							Type type
							, string propertyName
						)
		{
			Func<object> func = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var getPropertyValue = Expression.Property(null, property);
				var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
				var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
				func = lambda.Compile();
			}
			return func;
		}
		public static Func<object> CreateGetStaticPropertyValueFunc
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction
						(
							Type type
							, string propertyName
						)
		{
			Action<object, object> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var target = Expression.Parameter(typeof(object));
				var propertyValue = Expression.Parameter(typeof(object));
				var castTarget = Expression.Convert(target, type);
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object, object> CreateSetPropertyValueAction
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Action<object, TProperty> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var target = Expression.Parameter(typeof(object));
				var propertyValue = Expression.Parameter(typeof(TProperty));
				var castTarget = Expression.Convert(target, type);
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue);
				action = lambda.Compile();
			}
			return action; 
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction
						(
							Type type
							, string propertyName
						)
		{
			Action<object> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var propertyValue = Expression.Parameter(typeof(object));
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(null, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object> CreateSetStaticPropertyValueAction
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Action<TProperty> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var propertyValue = Expression.Parameter(typeof(TProperty));
				//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(null, getSetMethod, propertyValue);
				var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}
//以下 only for .NET 3.5 =============================
^#if NET35
namespace System.Threading.Tasks
{
	using System;
	using System.Threading;
	public class ParallelOptions
	{
		public int MaxDegreeOfParallelism
		{
			set;
			get;
		}
	}
	public static class Parallel
	{
		public static void For
						(
							int from
							, int to
							, ParallelOptions options
							, Action<int> action
						)
		{
			var iterations = to - from;
			var threads = options.MaxDegreeOfParallelism;
			var ares = new AutoResetEvent[threads];
			var i = 0;
			var count = 0;
			Array.ForEach
					(
						ares
						, (x) =>
						{
							var are = new AutoResetEvent(false);
							ares[i++] = are;
							new Thread
								(
									new ThreadStart
											(
												() =>
												{
													while (true)
													{
														int j = Interlocked.Increment(ref from);
														if (j <= to)
														{
															Interlocked.Increment(ref count);
															action(j);
														}
														else
														{
															break;
														}
													}
													are.Set();
												}
											)
								).Start();
						}
					);
			WaitHandle.WaitAll(ares);
			Console.WriteLine(count);
		}
	}
}
^#endif

#T=EasyPerformanceCounterHelper (1) 2014-03-18
namespace TestConsoleApplication
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Threading.Tasks;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Begin ...");
			Random r = new Random();
			int sleep = 2;
			int iterations = 10;
			int maxDegreeOfParallelism = 8; // Environment.ProcessorCount;
			var performanceCountersCategoryName = "Microshaoft EasyPerformanceCounters Category";
			var performanceCountersCategoryInstanceName
					= string.Format
							(
								"{2}{0}{3}{1}{4}"
								, ": "
								, " @ "
								, ""
								, ""
								, Process.GetCurrentProcess().ProcessName
							);
			//EasyPerformanceCountersHelper 调用示例
			EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
				.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, performanceCountersCategoryInstanceName + "-1"
								);
			EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
				.AttachPerformanceCountersCategoryInstance
					(
						performanceCountersCategoryName
						, performanceCountersCategoryInstanceName + "-2"
					);
			var enableCounters = MultiPerformanceCountersTypeFlags.ProcessCounter
									| MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
									| MultiPerformanceCountersTypeFlags.ProcessedCounter
									| MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter
									| MultiPerformanceCountersTypeFlags.ProcessingCounter;
			Parallel.For
						(
							0
							, iterations
							, new ParallelOptions()
							{
								MaxDegreeOfParallelism = maxDegreeOfParallelism
							}
							, (x) =>
							{
								EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
									.CountPerformance
										(
											enableCounters
											, performanceCountersCategoryName
											, performanceCountersCategoryInstanceName + "-1"
											, null
											, () =>
											{
												sleep = r.Next(0, 5) * 1000;
												//Thread.Sleep(sleep);
												throw new Exception("sadsad");
											}
											, null
											, (xx) =>
											{
												//Console.WriteLine("Exception {0}", xx.ToString());
												return false;
											}
											, null
										);
							}
						);
						Parallel.For
							(
								0
								, iterations
								, new ParallelOptions()
								{
									MaxDegreeOfParallelism = maxDegreeOfParallelism
								}
								, (x) =>
								{
									Stopwatch stopwatch = null;
									try
									{
										stopwatch =
											EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
												.CountPerformanceBegin
													(
														enableCounters
														, performanceCountersCategoryName
														, performanceCountersCategoryInstanceName + "-2"
													);
										sleep = r.Next(0, 5) * 1000;
										//Thread.Sleep(sleep);
										throw new Exception("Test");
									}
									catch
									{
									}
									finally
									{
										EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
											.CountPerformanceEnd
												(
													enableCounters
													, performanceCountersCategoryName
													, performanceCountersCategoryInstanceName + "-2"
													, stopwatch
												);
									}
								}
							);
			Console.WriteLine("End ...");
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Diagnostics;
	//using System.Collections.Concurrent;
	public static class EasyPerformanceCountersHelper<TPerformanceCountersContainer>
								where TPerformanceCountersContainer : class, IPerformanceCountersContainer, new ()
	{
		private static Dictionary<string, TPerformanceCountersContainer> _dictionary
						= new Dictionary<string, TPerformanceCountersContainer>();
		public static void AttachPerformanceCountersCategoryInstance
							(
								string performanceCountersCategoryName
								, string performanceCountersCategoryInstanceName
							)
		{
			string key = string.Format
									(
										"{1}{0}{2}"
										, "-"
										, performanceCountersCategoryName
										, performanceCountersCategoryInstanceName
									);
			TPerformanceCountersContainer container = null;
			if (!_dictionary.TryGetValue(key, out container))
			{
				container = new TPerformanceCountersContainer();
				_dictionary.Add
							(
								key
								, container
							);
				container
					.AttachPerformanceCountersToProperties
						(
							performanceCountersCategoryInstanceName
							, performanceCountersCategoryName
						);
			}
		}
		private static object _lockerObject = new object();
		public static Stopwatch CountPerformanceBegin
									(
										MultiPerformanceCountersTypeFlags enabledPerformanceCounters
										, string performanceCountersCategoryName
										, string performanceCountersCategoryInstanceName
									)
		{
			Stopwatch r = null;
			if (enabledPerformanceCounters != MultiPerformanceCountersTypeFlags.None)
			{
				string key = string.Format
										(
											"{1}{0}{2}"
											, "-"
											, performanceCountersCategoryName
											, performanceCountersCategoryInstanceName
										);
				TPerformanceCountersContainer container = null;
				if (!_dictionary.TryGetValue(key, out container))
				{
					lock (_lockerObject)
					{
						container = new TPerformanceCountersContainer();
						_dictionary.Add
									(
										key
										, container
									);
						container.AttachPerformanceCountersToProperties
											(
												performanceCountersCategoryInstanceName
												, performanceCountersCategoryName
											);
					}
				}
				var enableProcessCounter =
											(
												(
													enabledPerformanceCounters
													& MultiPerformanceCountersTypeFlags.ProcessCounter
												)
												!= MultiPerformanceCountersTypeFlags.None
											);
				if (enableProcessCounter)
				{
					container.PrcocessPerformanceCounter.Increment();
				}
				var enableProcessingCounter =
											(
												(
													enabledPerformanceCounters
													& MultiPerformanceCountersTypeFlags.ProcessingCounter
												)
												!= MultiPerformanceCountersTypeFlags.None
											);
				if (enableProcessingCounter)
				{
					container.ProcessingPerformanceCounter.Increment();
				}
				var enableProcessedAverageTimerCounter =
											(
												(
													enabledPerformanceCounters
													& MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
												)
												!= MultiPerformanceCountersTypeFlags.None
											);
				if (enableProcessedAverageTimerCounter)
				{
					r = Stopwatch.StartNew();
				}
			}
			return r;
		}
		public static void CountPerformanceEnd
									(
										MultiPerformanceCountersTypeFlags enabledPerformanceCounters
										, string performanceCountersCategoryName
										, string performanceCountersCategoryInstanceName
										, Stopwatch stopwatch
									)
		{
			string key = string.Format
						(
							"{1}{0}{2}"
							, "-"
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName
						);
			TPerformanceCountersContainer container = null;
			if (!_dictionary.TryGetValue(key, out container))
			{
				return;
			}
			var enableProcessedAverageTimerCounter =
										(
											(
												enabledPerformanceCounters
												& MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
											)
											!= MultiPerformanceCountersTypeFlags.None
										);
			if (enableProcessedAverageTimerCounter)
			{
				if (stopwatch != null)
				{
					PerformanceCounter performanceCounter = container.ProcessedAverageTimerPerformanceCounter;
					PerformanceCounter basePerformanceCounter = container.ProcessedAverageBasePerformanceCounter;
					stopwatch.Stop();
					performanceCounter.IncrementBy(stopwatch.ElapsedTicks);
					basePerformanceCounter.Increment();
					//stopwatch = null;
				}
			}
			var enableProcessingCounter =
										(
											(
												enabledPerformanceCounters
												& MultiPerformanceCountersTypeFlags.ProcessingCounter
											)
											!= MultiPerformanceCountersTypeFlags.None
										);
			if (enableProcessingCounter)
			{
				container.ProcessingPerformanceCounter.Decrement();
			}
			var enableProcessedPerformanceCounter =
									(
										(
											enabledPerformanceCounters
											& MultiPerformanceCountersTypeFlags.ProcessedCounter
										)
										!= MultiPerformanceCountersTypeFlags.None
									);
			if (enableProcessedPerformanceCounter)
			{
				container.ProcessedPerformanceCounter.Increment();
			}
			var enableProcessedRateOfCountsPerSecondPerformanceCounter =
						(
							(
								enabledPerformanceCounters
								& MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter
							)
							!= MultiPerformanceCountersTypeFlags.None
						);
			if (enableProcessedRateOfCountsPerSecondPerformanceCounter)
			{
				container.ProcessedRateOfCountsPerSecondPerformanceCounter.Increment();
			}
		}
		public static void CountPerformance
									(
										MultiPerformanceCountersTypeFlags enabledPerformanceCounters
										, string performanceCountersCategoryName
										, string performanceCountersCategoryInstanceName
										, Action onBeforeCountPerformanceInnerProcessAction
										, Action onCountPerformanceInnerProcessAction
										, Action onAfterCountPerformanceInnerProcessAction
										, Func<Exception, bool> onCaughtExceptionProcessFunc
										, Action<bool, Exception> onFinallyProcessAction
									)
		{
			if (enabledPerformanceCounters != MultiPerformanceCountersTypeFlags.None)
			{
				if (onCountPerformanceInnerProcessAction != null)
				{
					string key = string.Format
											(
												"{1}{0}{2}"
												, "-"
												, performanceCountersCategoryName
												, performanceCountersCategoryInstanceName
											);
					TPerformanceCountersContainer container = null;
					if (!_dictionary.TryGetValue(key, out container))
					{
						lock (_lockerObject)
						{
							container = new TPerformanceCountersContainer();
							_dictionary.Add
										(
											key
											, container
										);
							container.AttachPerformanceCountersToProperties
												(
													performanceCountersCategoryInstanceName
													, performanceCountersCategoryName
												);
						}
					}
					var enableProcessCounter =
												(
													(
														enabledPerformanceCounters
														& MultiPerformanceCountersTypeFlags.ProcessCounter
													)
													!= MultiPerformanceCountersTypeFlags.None
												);
					if (enableProcessCounter)
					{
						container.PrcocessPerformanceCounter.Increment();
					}
					var enableProcessingCounter =
												(
													(
														enabledPerformanceCounters
														& MultiPerformanceCountersTypeFlags.ProcessingCounter
													)
													!= MultiPerformanceCountersTypeFlags.None
												);
					if (enableProcessingCounter)
					{
						container.ProcessingPerformanceCounter.Increment();
					}
					var enableProcessedAverageTimerCounter =
												(
													(
														enabledPerformanceCounters
														& MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
													)
													!= MultiPerformanceCountersTypeFlags.None
												);
					var reThrowException = false;
					container
						.ProcessedAverageTimerPerformanceCounter
							.ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
										(
											enableProcessedAverageTimerCounter
											, container.ProcessedAverageBasePerformanceCounter
											, () =>
											{
												if (onCountPerformanceInnerProcessAction != null)
												{
													if (onBeforeCountPerformanceInnerProcessAction != null)
													{
														onBeforeCountPerformanceInnerProcessAction();
													}
													onCountPerformanceInnerProcessAction();
													if (onAfterCountPerformanceInnerProcessAction != null)
													{
														onAfterCountPerformanceInnerProcessAction();
													}
												}
											}
											, (x, y) =>		//catch
											{
												container
													.CaughtExceptionsPerformanceCounter
														.Increment();
												var r = reThrowException;
												if (onCaughtExceptionProcessFunc != null)
												{
													r = onCaughtExceptionProcessFunc(y);
												}
												return r;
											}
											, (x, y, z, w) =>		//Finally
											{
												if (enableProcessingCounter)
												{
													container.ProcessingPerformanceCounter.Decrement();
												}
												var enableProcessedPerformanceCounter =
																		(
																			(
																				enabledPerformanceCounters
																				& MultiPerformanceCountersTypeFlags.ProcessedCounter
																			)
																			!= MultiPerformanceCountersTypeFlags.None
																		);
												if (enableProcessedPerformanceCounter)
												{
													container.ProcessedPerformanceCounter.Increment();
												}
												var enableProcessedRateOfCountsPerSecondPerformanceCounter =
																		(
																			(
																				enabledPerformanceCounters
																				& MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter
																			)
																			!= MultiPerformanceCountersTypeFlags.None
																		);
												if (enableProcessedRateOfCountsPerSecondPerformanceCounter)
												{
													container
														.ProcessedRateOfCountsPerSecondPerformanceCounter
															.Increment();
												}
											}
										);
				}
			}
			else
			{
				if (onCountPerformanceInnerProcessAction != null)
				{
					onCountPerformanceInnerProcessAction();
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	public interface IPerformanceCountersContainer
	{
		PerformanceCounter CaughtExceptionsPerformanceCounter
		{
			get;
		}
		PerformanceCounter PrcocessPerformanceCounter
		{
			get;
		}
		PerformanceCounter ProcessingPerformanceCounter
		{
			get;
		}
		PerformanceCounter ProcessedPerformanceCounter
		{
			get;
		}
		PerformanceCounter ProcessedRateOfCountsPerSecondPerformanceCounter
		{
			get;
		}
		PerformanceCounter ProcessedAverageTimerPerformanceCounter
		{
			get;
		}
		PerformanceCounter ProcessedAverageBasePerformanceCounter
		{
			get;
		}
		void AttachPerformanceCountersToProperties
							(
								string instanceName
								, string categoryName
							);
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public class CommonPerformanceCountersContainer
					: IPerformanceCountersContainer
	{
		#region PerformanceCounters
		private PerformanceCounter _caughtExceptionsPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "99.捕获异常次数(次)"
				)
		]
		public PerformanceCounter CaughtExceptionsPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(
							ref _caughtExceptionsPerformanceCounter
							, value
							, 2
						);
			}
			get
			{
				return _caughtExceptionsPerformanceCounter;
			}
		}
		private PerformanceCounter _processPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "01.接收处理笔数(笔)"
				)
		]
		public PerformanceCounter PrcocessPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(
							ref _processPerformanceCounter
							, value
							, 2
						);
			}
			get
			{
				return _processPerformanceCounter;
			}
		}
		private PerformanceCounter _processingPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "02.正在处理笔数(笔)"
				)
		]
		public PerformanceCounter ProcessingPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(
							ref _processingPerformanceCounter
							, value
							, 2
						);
			}
			get
			{
				return _processingPerformanceCounter;
			}
		}
		private PerformanceCounter _processedPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.NumberOfItems64
					, CounterName = "03.完成处理笔数(笔)"
				)
		]
		public PerformanceCounter ProcessedPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(
							ref _processedPerformanceCounter
							, value
							, 2
						);
			}
			get
			{
				return _processedPerformanceCounter;
			}
		}
		private PerformanceCounter _processedRateOfCountsPerSecondPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.RateOfCountsPerSecond64
					, CounterName = "04.每秒完成处理笔数(笔/秒)"
				)
		]
		public PerformanceCounter ProcessedRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(
							ref _processedRateOfCountsPerSecondPerformanceCounter
							, value
							, 2
						);
			}
			get
			{
				return _processedRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _ProcessedAverageTimerPerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.AverageTimer32
					, CounterName = "05.平均每笔处理耗时秒数(秒/笔)"
				)
		]
		public PerformanceCounter ProcessedAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(
							ref _ProcessedAverageTimerPerformanceCounter
							, value
							, 2
						);
			}
			get
			{
				return _ProcessedAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _processedAverageBasePerformanceCounter;
		[
			PerformanceCounterDefinitionAttribute
				(
					CounterType = PerformanceCounterType.AverageBase
				)
		]
		public PerformanceCounter ProcessedAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<PerformanceCounter>
						(
							ref _processedAverageBasePerformanceCounter
							, value
							, 2
						);
			}
			get
			{
				return _processedAverageBasePerformanceCounter;
			}
		}
		#endregion
		// indexer declaration
		public PerformanceCounter this[string name]
		{
			get
			{
				throw new NotImplementedException();
				//return null;
			}
		}
		//private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCountersToProperties
							(
								string instanceName
								, string categoryName
							)
		{
			var type = this.GetType();
			PerformanceCountersHelper
				.AttachPerformanceCountersToProperties<CommonPerformanceCountersContainer>
					(
						instanceName
						, categoryName
						, this
					);
		}
	}
}
//=========================================================================================

#T=EasyPerformanceCounterHelper (2) 2014-03-18
//=========================================================================================
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterExtensionMethodsManager
	{
		public static void ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
								(
									this PerformanceCounter performanceCounter
									, bool enabled
									, PerformanceCounter basePerformanceCounter
									, Action onCountPerformanceInnerProcessAction //= null
									, Func<PerformanceCounter, Exception, bool> onCaughtExceptionProcessFunc //= null
									, Action<PerformanceCounter, PerformanceCounter, bool, Exception> onFinallyProcessAction //= null
								)
		{
			if (enabled)
			{
				var stopwatch = Stopwatch.StartNew();
				if (onCountPerformanceInnerProcessAction != null)
				{
					bool reThrowException = false;
					TryCatchFinallyProcessHelper
						.TryProcessCatchFinally
							(
								true
								, () =>
								{
									onCountPerformanceInnerProcessAction();
								}
								, reThrowException
								, (x) =>
								{
									var r = reThrowException;
									if (onCaughtExceptionProcessFunc != null)
									{
										r = onCaughtExceptionProcessFunc(performanceCounter, x);
									}
									return r;
								}
								, (x, y) =>
								{
									stopwatch.Stop();
									performanceCounter.IncrementBy(stopwatch.ElapsedTicks);
									stopwatch = null;
									basePerformanceCounter.Increment();
									if (onFinallyProcessAction != null)
									{
										onFinallyProcessAction
											(
												performanceCounter
												, basePerformanceCounter
												, x
												, y
											);
									}
								}
							);
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	[FlagsAttribute]
	public enum MultiPerformanceCountersTypeFlags : ushort
	{
		None = 0,
		ProcessCounter = 1,
		ProcessingCounter = 2,
		ProcessedCounter = 4,
		ProcessedAverageTimerCounter = 8,
		ProcessedRateOfCountsPerSecondCounter = 16
	};
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
	public class PerformanceCounterDefinitionAttribute : Attribute
	{
		public PerformanceCounterType CounterType;
		public string CounterName;
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	using System.Linq;
	public static class PerformanceCountersHelper
	{
		public static void AttachPerformanceCountersToProperties<T>
									(
										string performanceCounterInstanceName
										, string category
										, T target //= default(T)
									)
		{
			var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList.Where
												(
													(pi) =>
													{
														var parameters = pi.GetIndexParameters();
														return
															(
																pi.PropertyType == typeof(PerformanceCounter)
																&& (parameters == null ? 0 : parameters.Length) <= 0
															);
													}
												).ToList();
			if (PerformanceCounterCategory.Exists(category))
			{
				propertiesList.ForEach
									(
										(pi) =>
										{
											if (PerformanceCounterCategory.CounterExists(pi.Name, category))
											{
												if (PerformanceCounterCategory.InstanceExists(performanceCounterInstanceName, category))
												{
													//var pc = new PerformanceCounter(category, pi.Name, instanceName, false);
													//pc.InstanceName = instanceName;
													//pc.RemoveInstance();
												}
											}
										}
									);
				//PerformanceCounterCategory.Delete(category);
			}
			if (!PerformanceCounterCategory.Exists(category))
			{
				var ccdc = new CounterCreationDataCollection();
				propertiesList.ForEach
								(
									(pi) =>
									{
										var propertyName = pi.Name;
										var performanceCounterType = PerformanceCounterType.NumberOfItems64;
										var performanceCounterName = propertyName;
										var attribute = pi.GetCustomAttributes(false).FirstOrDefault
																					(
																						(x) =>
																						{
																							return x as PerformanceCounterDefinitionAttribute != null;
																						}
																					) as PerformanceCounterDefinitionAttribute;
										if (attribute != null)
										{
											var counterName = attribute.CounterName;
											if (!string.IsNullOrEmpty(counterName))
											{
												performanceCounterName = counterName;
											}
											var counterType = attribute.CounterType;
											//if (counterType != null)
											{
												performanceCounterType = counterType;
											}
										}
										var ccd = PerformanceCountersHelper
													.GetCounterCreationData
														(
															performanceCounterName
															, performanceCounterType
														);
										ccdc.Add(ccd);
									}
								);
				PerformanceCounterCategory.Create
								(
									category,
									string.Format("{0} Category Help.", category),
									PerformanceCounterCategoryType.MultiInstance,
									ccdc
								);
			}
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var performanceCounterType = PerformanceCounterType.NumberOfItems64;
									var performanceCounterName = propertyName;
									var attribute =
													pi
														.GetCustomAttributes(false)
															.FirstOrDefault
																(
																	(x) =>
																	{
																		return
																			(
																				(x as PerformanceCounterDefinitionAttribute)
																				!= null
																			);
																	}
																) as PerformanceCounterDefinitionAttribute;
									if (attribute != null)
									{
										var counterName = attribute.CounterName;
										if (!string.IsNullOrEmpty(counterName))
										{
											performanceCounterName = counterName;
										}
										var counterType = attribute.CounterType;
										//if (counterType != null)
										{
											performanceCounterType = counterType;
										}
									}
									var pc = new PerformanceCounter()
									{
										CategoryName = category
										,
										CounterName = performanceCounterName
										,
										InstanceLifetime = PerformanceCounterInstanceLifetime.Process
										,
										InstanceName = performanceCounterInstanceName
										,
										ReadOnly = false
										,
										RawValue = 0
									};
									if (pi.GetGetMethod().IsStatic)
									{
										var setter =
													DynamicPropertyAccessor
														.CreateSetStaticPropertyValueAction<PerformanceCounter>
															(
																type
																, propertyName
															);
										setter(pc);
									}
									else
									{
										if (target != null)
										{
											var setter =
														DynamicPropertyAccessor
															.CreateSetPropertyValueAction<PerformanceCounter>
																(
																	type
																	, propertyName
																);
											setter(target, pc);
										}
									}
								}
							);
		}
		public static CounterCreationData GetCounterCreationData
											(
												string counterName
												, PerformanceCounterType performanceCounterType
											)
		{
			return new CounterCreationData()
			{
				CounterName = counterName
				,
				CounterHelp = string.Format("{0} Help", counterName)
				,
				CounterType = performanceCounterType
			};
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class ReaderWriterLockSlimHelper
	{
		public static bool TryEnterWriterLockSlimWrite<T>
												(
													 ref T target
													, T newValue
													, int enterTimeOutSeconds
												)
													where T : class
		{
			bool r = false;
			var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutSeconds >= 0)
			{
				timeOut = enterTimeOutSeconds * 1000;
			}
			try
			{
				r = (rwls.TryEnterWriteLock(timeOut));
				if (r)
				{
					Interlocked.Exchange<T>(ref target, newValue);
					r = true;
				}
			}
			finally
			{
				if (r)
				{
					rwls.ExitWriteLock();
				}
			}
			return r;
		}
		public static bool TryEnterWriterLockSlim
								(
									Action action
									, int enterTimeOutSeconds
								)
		{
			bool r = false;
			if (action != null)
			{
				var rwls = new ReaderWriterLockSlim();
				int timeOut = Timeout.Infinite;
				if (enterTimeOutSeconds >= 0)
				{
					timeOut = enterTimeOutSeconds * 1000;
				}
				try
				{
					r = (rwls.TryEnterWriteLock(timeOut));
					if (r)
					{
						action();
						r = true;
					}
				}
				finally
				{
					if (r)
					{
						rwls.ExitWriteLock();
					}
				}
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public class DynamicPropertyAccessor
	{
		private static Assembly GetAssemblyByTypeName(string typeName)
		{
			return
				AppDomain
					.CurrentDomain
						.GetAssemblies()
							.First
								(
									(a) =>
									{
										return
											a
												.GetTypes()
													.Any
														(
															(t) =>
															{
																return
																	(
																		t.FullName
																		== typeName
																	);
															}
														);
									}
								);
		}
		public static Func<object, object> CreateGetPropertyValueFunc
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc
						(
							Type type
							, string propertyName
						)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Func<TProperty> func = null;
			var property = type.GetProperty(propertyName, typeof(TProperty));
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var getPropertyValue = Expression.Property(null, property);
				var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
				func = lambda.Compile();
			}
			return func;
		}
		public static Func<object> CreateGetStaticPropertyValueFunc
						(
							Type type
							, string propertyName
						)
		{
			Func<object> func = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var getPropertyValue = Expression.Property(null, property);
				var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
				var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
				func = lambda.Compile();
			}
			return func;
		}
		public static Func<object> CreateGetStaticPropertyValueFunc
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction
						(
							Type type
							, string propertyName
						)
		{
			Action<object, object> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var target = Expression.Parameter(typeof(object));
				var propertyValue = Expression.Parameter(typeof(object));
				var castTarget = Expression.Convert(target, type);
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object, object> CreateSetPropertyValueAction
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Action<object, TProperty> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var target = Expression.Parameter(typeof(object));
				var propertyValue = Expression.Parameter(typeof(TProperty));
				var castTarget = Expression.Convert(target, type);
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction
						(
							Type type
							, string propertyName
						)
		{
			Action<object> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var propertyValue = Expression.Parameter(typeof(object));
				var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(null, getSetMethod, castPropertyValue);
				var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<object> CreateSetStaticPropertyValueAction
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>
						(
							Type type
							, string propertyName
						)
		{
			Action<TProperty> action = null;
			var property = type.GetProperty(propertyName);
			if (property == null)
			{
				property =
							type
								.GetProperties()
									.ToList()
										.FirstOrDefault
											(
												(x) =>
												{
													return
														(
															x.Name.ToLower()
															== propertyName.ToLower()
														);
												}
											);
			}
			if (property != null)
			{
				var propertyValue = Expression.Parameter(typeof(TProperty));
				//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
				var getSetMethod = property.GetSetMethod();
				if (getSetMethod == null)
				{
					getSetMethod = property.GetSetMethod(true);
				}
				var call = Expression.Call(null, getSetMethod, propertyValue);
				var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
				action = lambda.Compile();
			}
			return action;
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>
						(
							string typeName
							, string propertyName
							, bool isTypeFromAssembly = false
						)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Reflection;
	using System.Threading.Tasks;
	public static class TryCatchFinallyProcessHelper
	{
		public static async Task<T> TryProcessCatchFinallyAsync<T>
									(
										bool needTry
										, Func<Task<T>> onTryProcessFunc
										, bool reThrowException = false
										, Func<Exception, bool> onCaughtExceptionProcessFunc = null
										, Action<bool, Exception> onFinallyProcessAction = null
									)
		{
			T r = default(T);
			//if (onTryProcessAction != null)
			{
				if (needTry)
				{
					Exception exception = null;
					var caughtException = false;
					try
					{
						r = await onTryProcessFunc();
						return r;
					}
					catch (Exception e)
					{
						caughtException = true;
						exception = e;
						var currentCalleeMethod = MethodInfo.GetCurrentMethod();
						var currentCalleeType = currentCalleeMethod.DeclaringType;
						StackTrace stackTrace = new StackTrace();
						StackFrame stackFrame = stackTrace.GetFrame(1);
						var callerMethod = stackFrame.GetMethod();
						var callerType = callerMethod.DeclaringType;
						var frame = (stackTrace.FrameCount > 1 ? stackTrace.FrameCount - 1 : 1);
						stackFrame = stackTrace.GetFrame(frame);
						var originalCallerMethod = stackFrame.GetMethod();
						var originalCallerType = originalCallerMethod.DeclaringType;
						var innerExceptionMessage = string.Format
								(
									"Rethrow caught [{1}] Exception{0} at Callee Method: [{2}]{0} at Caller Method: [{3}]{0} at Original Caller Method: [{4}]"
									, "\r\n\t"
									, e.Message
									, string.Format("{1}{0}{2}", "::", currentCalleeType, currentCalleeMethod)
									, string.Format("{1}{0}{2}", "::", callerType, callerMethod)
									, string.Format("{1}{0}{2}", "::", originalCallerType, originalCallerMethod)
								);
						Console.WriteLine(innerExceptionMessage);
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrowException = onCaughtExceptionProcessFunc(e);
						}
						if (reThrowException)
						{
							throw
								new Exception
										(
											innerExceptionMessage
											, e
										);
						}
						return r;
					}
					finally
					{
						if (onFinallyProcessAction != null)
						{
							onFinallyProcessAction(caughtException, exception);
						}
					}
				}
				else
				{
					return await onTryProcessFunc();
				}
			}
		}
		public static void TryProcessCatchFinally
									(
										bool needTry
										, Action onTryProcessAction
										, bool reThrowException = false
										, Func<Exception, bool> onCaughtExceptionProcessFunc = null
										, Action<bool, Exception> onFinallyProcessAction = null
									)
		{
			if (onTryProcessAction != null)
			{
				if (needTry)
				{
					Exception exception = null;
					var caughtException = false;
					try
					{
						onTryProcessAction();
					}
					catch (Exception e)
					{
						caughtException = true;
						exception = e;
						var currentCalleeMethod = MethodInfo.GetCurrentMethod();
						var currentCalleeType = currentCalleeMethod.DeclaringType;
						StackTrace stackTrace = new StackTrace(e, true);
						StackFrame stackFrame = stackTrace.GetFrame(1);
						var callerMethod = stackFrame.GetMethod();
						var callerType = callerMethod.DeclaringType;
						var frame = (stackTrace.FrameCount > 1 ? stackTrace.FrameCount - 1 : 1);
						stackFrame = stackTrace.GetFrame(frame);
						var originalCallerMethod = stackFrame.GetMethod();
						var originalCallerType = originalCallerMethod.DeclaringType;
						var innerExceptionMessage = string.Format
								(
									"Rethrow caught [{1}] Exception{0} at Callee Method: [{2}]{0} at Caller Method: [{3}]{0} at Original Caller Method: [{4}]"
									, "\r\n\t"
									, e.Message
									, string.Format("{1}{0}{2}", "::", currentCalleeType, currentCalleeMethod)
									, string.Format("{1}{0}{2}", "::", callerType, callerMethod)
									, string.Format("{1}{0}{2}", "::", originalCallerType, originalCallerMethod)
								);
						//Console.WriteLine(innerExceptionMessage);
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrowException = onCaughtExceptionProcessFunc(e);
						}
						if (reThrowException)
						{
							throw
								new Exception
										(
											innerExceptionMessage
											, e
										);
						}
					}
					finally
					{
						//Console.WriteLine("Finally");
						if (onFinallyProcessAction != null)
						{
							onFinallyProcessAction(caughtException, exception);
						}
					}
				}
				else
				{
					onTryProcessAction();
				}
			}
		}
	}
}

#T=EasyTimer
namespace Microshaoft
{
	using System;
	using System.Timers;
	public class EasyTimer
	{
		private Timer _timer;
		public void Start()
		{
			if (_timer != null)
			{
				_timer.Start();
			}
		}
		private int _intervalSeconds;
		public EasyTimer
					(
						int intervalSeconds
						, int times
						, Action timerAction
						, Action<Exception> exceptionAction
					)
		{
			if (timerAction == null)
			{
				return;
			}
			_intervalSeconds = intervalSeconds * 1000;
			_timer = new Timer(1);
			_timer.Elapsed += new ElapsedEventHandler
										(
											(x, y) =>
											{
												TimerActionProcess(times, timerAction, exceptionAction);
											}
										);
		}
		private void TimerActionProcess(int times, Action timerAction, Action<Exception> exceptionAction)
		{
			if (_timer.Interval < _intervalSeconds)
			{
				_timer.Interval = _intervalSeconds;
			}
			if (timerAction == null)
			{
				return;
			}
			_timer.Enabled = false;
			_timer.Stop();
			DateTime begin;
			do
			{
				begin = DateTime.Now;
				try
				{
					timerAction();
				}
				catch (Exception e)
				{
					if (exceptionAction != null)
					{
						exceptionAction(e);
					}
				}

			} while (Math.Abs(DateTimeHelper.SecondsDiffNow(begin)) > times * _intervalSeconds);
			_timer.Start();
			_timer.Enabled = true;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Threading;
	using System.Threading.Tasks;
	using System.IO;
	class Program
	{
		static void Main()
		{
			string r = string.Empty;
			string rootPath = @"e:\temp4";
			Console.WriteLine("测试项目1");
			Console.WriteLine("按任意键测试该项目, 按\"q\"退出该测试项目");
			while ((r = Console.ReadLine()) != "q")
			{
				DateTime now = new DateTime(2012, 5, 12);
				CodeTimer.Time
					(
						"写文件"
						, 1
						, () =>
						{
							Parallel.For
									(
										0
										, 86400
										, (x) =>
										{
											DateTimeHelper.GetAlignSecondsDateTimes<string>
																	(
																		now.AddSeconds(x)
																		, Tuple.Create<long, Func<DateTime, long, DateTime, string, string>>
																					(
																						24 * 60 * 60
																						, (time, alignSeconds, alignedTime, data) =>
																						{
																							//Console.WriteLine(alignedTime);
																							var directory = alignedTime.ToString("yyyy-MM-dd");
																							var path = (string.IsNullOrEmpty(data) || string.IsNullOrWhiteSpace(data) ? rootPath : data);
																							path = string.Format
																											(
																												"{1}{0}{2}"
																												, @"\"
																												, path.Trim(new char[] { '\\' })
																												, directory
																											);
																							if (!Directory.Exists(path))
																							{
																								Directory.CreateDirectory(path);
																							}
																							return path;
																						}
																					)
																		, Tuple.Create<long, Func<DateTime, long, DateTime, string, string>>
																					(
																						1 * 60 * 60
																						, (time, alignSeconds, alignedTime, data) =>
																						{
																							//Console.WriteLine(alignedTime);
																							var directory = alignedTime.ToString("yyyy-MM-dd_HH");
																							var path = (string.IsNullOrEmpty(data) || string.IsNullOrWhiteSpace(data) ? rootPath : data);
																							path = string.Format
																											(
																												"{1}{0}{2}"
																												, @"\"
																												, path.Trim(new char[] { '\\' })
																												, directory
																											);
																							if (!Directory.Exists(path))
																							{
																								Directory.CreateDirectory(path);
																							}
																							return path;
																						}
																					)
																		, Tuple.Create<long, Func<DateTime, long, DateTime, string, string>>
																					(
																						5 * 60
																						, (time, alignSeconds, alignedTime, data) =>
																						{
																							var directory = DateTimeHelper.GetDateTimeString(alignedTime, "yyyy-MM-dd_HH-mm");
																							var path = (string.IsNullOrEmpty(data) || string.IsNullOrWhiteSpace(data) ? rootPath : data);
																							path = string.Format
																											(
																												"{1}{0}{2}"
																												, @"\"
																												, path.Trim(new char[] { '\\' })
																												, directory
																											);
																							if (!Directory.Exists(path))
																							{
																								Directory.CreateDirectory(path);
																							}
																							if (x % 300 != 0)
																							{
																								return string.Empty;
																							}
																							string file = string.Empty;
																							string s = DateTimeHelper.GetDateTimeString(alignedTime, "yyyyMMdd-HHmmss");
																							file = string.Format
																												(
																													"{1}{0}{2}.{3}.txt"
																													, @"\"
																													, path
																													, s
																													, Guid.NewGuid().ToString("N")
																												);
																							using (StreamWriter sw = new StreamWriter(File.OpenWrite(file)))
																							{
																								sw.WriteLine(s);
																							}
																							return string.Empty;
																						}
																					)
																	);
										}
									);
						}
					);
				Console.WriteLine("ok");
			}
			Console.WriteLine("测试项目2");
			Console.WriteLine("按任意键测试该项目, 按\"q\"退出该测试项目");
			r = string.Empty;
			while ((r = Console.ReadLine()) != "q")
			{
				CodeTimer.ParallelTime
							(
								"GetFiles"
								, 5
								, Environment.ProcessorCount
								, () =>
								{
									//Console.WriteLine(Directory.GetDirectories(@"e:\temp2", "*.*", SearchOption.AllDirectories).Length);
									string[] files = Directory.GetFiles(rootPath, "*.*", SearchOption.AllDirectories);
									var list = files.ToList();
									Parallel.ForEach
												(
													list
													, new ParallelOptions()
													{
														MaxDegreeOfParallelism =
															//			1
														Environment.ProcessorCount - 0
													}
													, (x) =>
													{
														string s = File.ReadAllText(x);
													}
												);
								}
							);
			}
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Runtime.InteropServices;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void ParallelTime(string name, int iteration, int maxDegreeOfParallelism, Action action)
		{
			InternalIterationProcess
					(
						name
						, iteration
						, () =>
						{
							Parallel.For
										(
											0
											, iteration
											, new ParallelOptions()
											{
												MaxDegreeOfParallelism = maxDegreeOfParallelism
												//, TaskScheduler = null
											}
											, i =>
											{
												action();
											}
										);
						}
					);
		}
		private static void InternalIterationProcess(string name, int iteration, Action action)
		{
			if (string.IsNullOrEmpty(name))
			{
				return;
			}
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCycleCount();
			action();
			ulong cpuCycles = GetCycleCount() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine
							(
								"{0}Time Elapsed:{0}{1}ms"
								, "\t"
								, watch.ElapsedMilliseconds.ToString("N0")
							);
			Console.WriteLine
							(
								"{0}CPU Cycles:{0}{1}"
								, "\t"
								, cpuCycles.ToString("N0")
							);
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine
							(
								"{0}Gen{1}:{0}{0}{2}"
								, "\t"
								, i
								, count
							);
			}
			Console.WriteLine();
		}
		public static void Time(string name, int iteration, Action action)
		{
			InternalIterationProcess
								(
									name
									, iteration
									, () =>
									{
										for (int i = 0; i < iteration; i++)
										{
											action();
										}
									}
									);
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Globalization;
	public static class DateTimeHelper
	{
		public static void GetAlignSecondsDateTimes<T>
								(
									DateTime time
									, params Tuple<long, Func<DateTime, long, DateTime, T, T>>[] processAlignSecondsDateTimesFuncs
								)
		{
			T r = default(T);
			foreach (var x in processAlignSecondsDateTimesFuncs)
			{
				var alignSeconds = x.Item1;
				var alignTime = DateTimeHelper.GetAlignSecondsDateTime(time, alignSeconds);
				if (x.Item2 != null)
				{
					r = x.Item2(time, alignSeconds, alignTime, r);
				}
			}
		}
		public static bool IsVaildateTimestamp(DateTime timeStamp, int timeoutSeconds)
		{
			long l = SecondsDiffNow(timeStamp);
			return ((l > 0) && (l < timeoutSeconds));
		}
		public static long MillisecondsDiffNow(DateTime time)
		{
			long now = DateTime.Now.Ticks;
			long t = time.Ticks;
			return (t - now) / 10000;
		}
		public static long SecondsDiffNow(DateTime time)
		{
			return MillisecondsDiffNow(time) / 1000;
		}
		public static DateTime GetAlignSecondsDateTime(DateTime time, long alignSeconds)
		{
			long ticks = time.Ticks;
			ticks -= ticks % (10000 * 1000 * alignSeconds);
			DateTime dt = new DateTime(ticks);
			return dt;
		}
		public static string GetDateTimeString(DateTime time, string format)
		{
			return time.ToString(format);
		}
		public static DateTime? ParseExactDateTimeNullable(string text, string format)
		{
			DateTime time;
			DateTime? r = DateTime.TryParseExact
										(
											text
											, format
											, DateTimeFormatInfo.InvariantInfo
											, DateTimeStyles.None
											, out time
										) ? time as DateTime? : null;
			return r;
		}
	}
}
#T=echo Server SocketAsyncDataHandler 2012-08-12
//Client.cs
namespace Client
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	using Microshaoft;
	class Class1
	{
		static void Main(string[] args)
		{
			var ipa = IPAddress.Parse("127.0.0.1");
			var socket = new Socket
								(
									AddressFamily.InterNetwork
									, SocketType.Stream
									, ProtocolType.Tcp
								);
			var ipep = new IPEndPoint(ipa, 18180);
			socket.Connect(ipep);
			var handler = new SocketAsyncDataHandler<string>
														(
															socket
															, 1
														);
			var sendEncoding = Encoding.Default;
			var receiveEncoding = Encoding.UTF8;
			receiveEncoding = Encoding.Default;
			var decoder = receiveEncoding.GetDecoder();
			handler.StartReceiveData
							(
								1024 * 8
								, (x, y, z) =>
								{
									var l = decoder.GetCharCount(y, 0, y.Length);
									var chars = new char[l];
									decoder.GetChars(y, 0, y.Length, chars, 0, false);
									var s = new string(chars);
									Console.Write(s);
									return true;
								}
							);
			string input = string.Empty;
			while ((input = Console.ReadLine()) != "q")
			{
				try
				{
					var buffer = sendEncoding.GetBytes(input);
					Array.ForEach
							(
								buffer
								, (x) =>
								{
									handler.SendDataSync(new[] { x });
									Thread.Sleep(100);
								}
							);
				}
				catch (Exception e)
				{
					Console.WriteLine(e.ToString());
				}
			}
		}
	}
}
//===========================================================================================
//Share.cs
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	public class SocketAsyncDataHandler<T>
	{
		private Socket _socket;
		public Socket WorkingSocket
		{
			get
			{
				return _socket;
			}
		}
		public int ReceiveDataBufferLength
		{
			get;
			private set;
		}
		public T ConnectionToken
		{
			get;
			set;
		}
		public IPAddress RemoteIPAddress
		{
			get
			{
				return ((IPEndPoint)_socket.RemoteEndPoint).Address;
			}
		}
		public IPAddress LocalIPAddress
		{
			get
			{
				return ((IPEndPoint)_socket.LocalEndPoint).Address;
			}
		}
		public int SocketID
		{
			get;
			private set;
		}
		public SocketAsyncDataHandler
							(
								Socket socket
								, int socketID
							)
		{
			_socket = socket;
			_sendSocketAsyncEventArgs = new SocketAsyncEventArgs();
			SocketID = socketID;
		}
		private SocketAsyncEventArgs _sendSocketAsyncEventArgs;
		public int HeaderBytesLength
		{
			get;
			private set;
		}
		public int HeaderBytesOffset
		{
			get;
			private set;
		}
		public int HeaderBytesCount
		{
			get;
			private set;
		}
		private bool _isStartedReceiveData = false;
		private bool _isHeader = true;
		public bool StartReceiveWholeDataPackets
							(
								int receiveBufferLength
								, int headerBytesLength
								, int headerBytesOffset
								, int headerBytesCount
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onOneWholeDataPacketReceivedProcessFunc
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onDataPacketReceivedErrorProcessFunc = null
								, Action
									<
										SocketAsyncDataHandler<T>
										, bool
									> onAfterDestoryWorkingSocketProcessAction = null
							)
		{
			if (!_isStartedReceiveData)
			{
				HeaderBytesLength = headerBytesLength;
				HeaderBytesOffset = headerBytesOffset;
				HeaderBytesCount = headerBytesCount;
				var saeaReceive = new SocketAsyncEventArgs();
				int bodyLength = 0;
				saeaReceive.Completed += new EventHandler<SocketAsyncEventArgs>
								(
									(sender, e) =>
									{
										var socket = sender as Socket;
										if (e.BytesTransferred >= 0)
										{
											byte[] buffer = e.Buffer;
											int r = e.BytesTransferred;
											int p = e.Offset;
											int l = e.Count;
											if (r < l)
											{
												p += r;
												e.SetBuffer(p, l - r);
											}
											else if (r == l)
											{
												if (_isHeader)
												{
													byte[] data = new byte[headerBytesCount];
													Buffer.BlockCopy
																(
																	buffer
																	, HeaderBytesOffset
																	, data
																	, 0
																	, data.Length
																);
													byte[] intBytes = new byte[4];
													l = (intBytes.Length < HeaderBytesCount ? intBytes.Length : HeaderBytesCount);
													Buffer.BlockCopy
																(
																	data
																	, 0
																	, intBytes
																	, 0
																	, l
																);
													//Array.Reverse(intBytes);
													bodyLength = BitConverter.ToInt32(intBytes, 0);
													p += r;
													e.SetBuffer(p, bodyLength);
													Console.WriteLine(bodyLength);
													_isHeader = false;
												}
												else
												{
													byte[] data = new byte[bodyLength + HeaderBytesLength];
													bodyLength = 0;
													Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
													_isHeader = true;
													e.SetBuffer(0, HeaderBytesLength);
													if (onOneWholeDataPacketReceivedProcessFunc != null)
													{
														onOneWholeDataPacketReceivedProcessFunc
																						(
																							this
																							, data
																							, e
																						);
													}
												}
											}
											else
											{
												if (onDataPacketReceivedErrorProcessFunc != null)
												{
													byte[] data = new byte[p + r + HeaderBytesLength];
													Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
													bool b = onDataPacketReceivedErrorProcessFunc
																					(
																						this
																						, data
																						, e
																					);
													if (b)
													{
														bool i = DestoryWorkingSocket();
														if (onAfterDestoryWorkingSocketProcessAction != null)
														{
															onAfterDestoryWorkingSocketProcessAction(this, i);
														}
													}
													else
													{
														_isHeader = true;
														e.SetBuffer(0, HeaderBytesLength);
													}
												}
											}
										}
										try
										{
											socket.ReceiveAsync(e);
										}
										catch (Exception exception)
										{
											Console.WriteLine(exception.ToString());
											DestoryWorkingSocket();
										}
									}
								);
				ReceiveDataBufferLength = receiveBufferLength;
				saeaReceive.SetBuffer
								(
									new byte[ReceiveDataBufferLength]
									, 0
									, HeaderBytesLength
								);
				_socket.ReceiveAsync(saeaReceive);
				_isStartedReceiveData = true;
			}
			return _isStartedReceiveData;
		}
		public bool DestoryWorkingSocket()
		{
			bool r = false;
			try
			{
				if (_socket.Connected)
				{
					_socket.Disconnect(false);
				}
				_socket.Shutdown(SocketShutdown.Both);
				_socket.Close();
				_socket.Dispose();
				_socket = null;
				r = true;
			}
			catch (Exception e)
			{
				Console.WriteLine(e.ToString());
				//r = false;
			}
			return r;
		}
		public bool StartReceiveData
							(
								int receiveBufferLength
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onDataReceivedProcessFunc
							)
		{
			if (!_isStartedReceiveData)
			{
				var saeaReceive = new SocketAsyncEventArgs();
				saeaReceive.Completed += new EventHandler<SocketAsyncEventArgs>
												(
													(sender, e) =>
													{
														var socket = sender as Socket;
														int l = e.BytesTransferred;
														if (l > 0)
														{
															byte[] data = new byte[l];
															var buffer = e.Buffer;
															Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
															if (onDataReceivedProcessFunc != null)
															{
																onDataReceivedProcessFunc(this, data, e);
															}
														}
														try
														{
															socket.ReceiveAsync(e);
														}
														catch (Exception exception)
														{
															Console.WriteLine(exception.ToString());
														}
													}
												);
				ReceiveDataBufferLength = receiveBufferLength;
				saeaReceive.SetBuffer
								(
									new byte[ReceiveDataBufferLength]
									, 0
									, ReceiveDataBufferLength
								);
				_socket.ReceiveAsync(saeaReceive);
				_isStartedReceiveData = true;
			}
			return _isStartedReceiveData;
		}
		private object _sendSyncLockObject = new object();
		public int SendDataSync(byte[] data)
		{
			lock (_sendSyncLockObject)
			{
				return _socket.Send(data);
			}
		}
	}
}
//=======================================================================================================
//Server.cs
namespace Server
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using Microshaoft;
	class EchoServer<T>
	{
		//Socket _socketListener;
		private Action<SocketAsyncDataHandler<T>, byte[]> _onReceivedDataProcessAction;
		public EchoServer
					(
						IPEndPoint localPoint
						, Action
							<
								SocketAsyncDataHandler<T>
								, byte[]
							>
							onReceivedDataProcessAction
					)
		{
			_onReceivedDataProcessAction = onReceivedDataProcessAction;
			var listener = new Socket
							(
								localPoint.AddressFamily
								, SocketType.Stream
								, ProtocolType.Tcp
							);
			listener.Bind(localPoint);
			listener.Listen(5);
			AcceptSocketAsyc(listener);
		}
		private void AcceptSocketAsyc(Socket listener)
		{
			var acceptSocketAsyncEventArgs = new SocketAsyncEventArgs();
			acceptSocketAsyncEventArgs.Completed += acceptSocketAsyncEventArgs_AcceptOneCompleted;
			listener.AcceptAsync(acceptSocketAsyncEventArgs);
		}
		private int _socketID = 0;
		void acceptSocketAsyncEventArgs_AcceptOneCompleted(object sender, SocketAsyncEventArgs e)
		{
			e.Completed -= acceptSocketAsyncEventArgs_AcceptOneCompleted;
			var client = e.AcceptSocket;
			var listener = sender as Socket;
			AcceptSocketAsyc(listener);
			var handler = new SocketAsyncDataHandler<T>
														(
															client
															, _socketID++
														);
			handler.StartReceiveData
						(
							1024
							, (x, y, z) =>
							{
								//var s = Encoding.UTF8.GetString(y);
								////Console.WriteLine("SocketID: {1}{0}Length: {2}{0}Data: {2}", "\r\n", x.SocketID, y.Length ,s);
								//Console.Write(s);
								if (_onReceivedDataProcessAction != null)
								{
									_onReceivedDataProcessAction(x, y);
								}
								return true;
							}
						);
			//handler.StartReceiveWholeDataPackets
			//					(
			//						1024 * 1024
			//						, 2
			//						, 0
			//						, 2
			//						, (x, y, z) =>
			//						{
			//							var s = Encoding.UTF8.GetString(y);
			//							//Console.WriteLine("SocketID: {1}{0}Length: {2}{0}Data: {2}", "\r\n", x.SocketID, y.Length ,s);
			//							Console.Write(s);
			//							return true;
			//						}
			//					);
		}
	}
}
namespace Server
{
	using System;
	using System.Net;
	using System.Text;
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			IPAddress ipa;
			IPAddress.TryParse("127.0.0.1", out ipa);
			var receiveEncoding = Encoding.Default;
			var sendEncoding = Encoding.UTF8;
			sendEncoding = Encoding.Default;
			var decoder = receiveEncoding.GetDecoder();
			var es = new EchoServer<string>
							(
								new IPEndPoint(ipa, 18180)
								, (x, y) =>
								{
									var l = decoder.GetCharCount(y, 0, y.Length);
									var chars = new char[l];
									decoder.GetChars(y, 0, y.Length, chars, 0, false);
									var s = new string(chars);
									Console.Write(s);
									//s = string.Format("Echo: {0}{1}{0}", "\r\n", s);
									var buffer = sendEncoding.GetBytes(s);
									x.SendDataSync(buffer);
								}
							);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}
}

#T=Echo Server SocketAsyncEventArgs
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Net.Sockets;
	using System.Net;
	using System.Threading;
	using System.ServiceModel.Channels;
	class EchoServer
	{
		Socket server;
		public EchoServer(IPEndPoint localPoint)
		{
			server = new Socket
							(
								localPoint.AddressFamily
								, SocketType.Stream
								, ProtocolType.Tcp
							);
			server.Bind(localPoint);
			server.Listen(5);
			accept_async();
		}
		private void accept_async()
		{
			var accept = new SocketAsyncEventArgs();
			accept.Completed += accept_Completed;
			server.AcceptAsync(accept);
		}
		int i = 0;
		void accept_Completed(object sender, SocketAsyncEventArgs e)
		{
			accept_async();
			var client = e.AcceptSocket;
			e.UserToken = i ++;
			e.Completed -= accept_Completed;
			e.Completed += receive_Completed;
			var buffer = new byte[1024];
			e.SetBuffer(buffer, 0, buffer.Length);
			client.ReceiveAsync(e);
		}
		void receive_Completed(object sender, SocketAsyncEventArgs e)
		{
			var client = sender as Socket;
			if (e.BytesTransferred == 0)
			{
				Console.WriteLine("socket is closed");
				client.Close();
			}
			else
			{
				//client.Send(e.Buffer, e.BytesTransferred, SocketFlags.None);
				byte[] buffer = new byte[e.BytesTransferred];
				Buffer.BlockCopy(e.Buffer, 0, buffer, 0, buffer.Length);
				string s = Encoding.ASCII.GetString(buffer);
				Console.Write("===={0}UserToken: [{1}]{0}Bytes Transferred:[{2}]{0}Data:[{3}]{0}====", "\r\n", e.UserToken, e.BytesTransferred, s);
				//Console.Write(s);
				client.ReceiveAsync(e);
			}
		}
	}
}
namespace ConsoleApplication
{
	using System;
	using System.Net;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			IPAddress ipa;
			IPAddress.TryParse("127.0.0.1", out ipa);
			EchoServer x = new EchoServer(new IPEndPoint(ipa, 8180));
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}
}

#T=Echo Server SocketAsyncEventArgs and AsynQueue
namespace Test
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	using Microshaoft;
	public class AsyncSocketAsyncDataQueueHandlerEchoServer
	{
		public static void StartListening()
		{
			//IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress;
			IPAddress.TryParse("127.0.0.1", out ipAddress);
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 12021);
			Socket listener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Stream
										, ProtocolType.Tcp
									);
			listener.Bind(localEndPoint);
			Console.WriteLine("Listening ...");
			listener.Listen(10);
			int i = 0;
			while (true)
			{
				int id = i++;
				UserToken token = new UserToken();
				token.ConnectionID = id;
				Socket socket = listener.Accept();
				Console.WriteLine("accept");
				SocketAsyncDataHandler<UserToken> handler = new SocketAsyncDataHandler<UserToken>(socket, token);
				handler.ReceiveDataBufferLength = 1;
				handler.ID = id;
				handler.DataReceivedCompletedAsync +=new SocketAsyncDataHandler<UserToken>.DataReceivedCompletedAsyncEventHandler(DataReceived_CompletedAsync);
					
				handler.StartReceiveData();
			}
		}

		static void DataReceived_CompletedAsync(SocketAsyncDataHandler<UserToken> sender, byte[] data)
		{
			string s = Encoding.ASCII.GetString(data);
			Console.WriteLine("[{0}],[{1}],[{2}]", sender.Token.ConnectionID, s, data.Length);
			sender.SendDataAsync(data);
		}
		public static int Main(String[] args)
		{
			StartListening();
			return 0;
		}
	}
	public class UserToken
	{
		public string UserID;
		public int ConnectionID;
	}
}
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	public class SocketAsyncDataHandler<T>
	{
		private AsyncQueue<byte[]> _sendQueue;
		private AsyncQueue<byte[]> _receiveQueue;
		private T _token;
		public T Token
		{
			get
			{
				return _token;
			}
		}
		public SocketAsyncDataHandler(Socket socket, T token)
		{
			_sendQueue = new AsyncQueue<byte[]>();
			_sendQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(SendQueue_OnDequeue);
			//_sendQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_sendQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_sendQueue.MaxConcurrentThreadsCount = 1024;
			_receiveQueue = new AsyncQueue<byte[]>();
			_receiveQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(ReceiveQueue_OnDequeue);
			//_receiveQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_receiveQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_socket = socket;
			_token = token;

		}
		void Queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		void Queue_OnQueueLog(string logMessage)
		{
			//			Console.WriteLine(logMessage);
		}
		void SendQueue_OnDequeue(byte[] element)
		{
			SendDataAsync(element);
		}

		void ReceiveQueue_OnDequeue(byte[] element)
		{
			if (DataReceivedCompletedAsync != null)
			{
				DataReceivedCompletedAsync(this, element);
			}
		}
		public enum ExceptionHandleAction : int
		{
			Ignore
			,
			ReThrow
			,
			Abort
		}
		private Socket _socket;
		private int _id;
		public int ID
		{
			set
			{
				_id = value;
			}
			get
			{
				return _id;
			}
		}
		private int _receiveDataBufferLength  = 1024;
		public int ReceiveDataBufferLength
		{
			set
			{
				_receiveDataBufferLength = value;
			}
		}
		public void SendData(byte[] data)
		{
			_socket.Send(data);
		}
		public void SendDataAsyncQueue(byte[] data)
		{
			_sendQueue.Enqueue(data);
		}
		public void SendDataAsync(byte[] data)
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.SetBuffer(data, 0, data.Length);
			_socket.SendAsync(e);
		}
		public delegate void DataReceivedCompletedAsyncEventHandler
												(
													SocketAsyncDataHandler<T> sender
													, byte[] data
												);
		public event DataReceivedCompletedAsyncEventHandler DataReceivedCompletedAsync;
		public delegate void ExceptionOccursEventHandler
												(
													SocketAsyncDataHandler<T> sender
													, Exception exception
													, ExceptionHandleAction action
												);
		public ExceptionOccursEventHandler ExceptionOccurs;
		public void StartReceiveData()
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.Completed += new EventHandler<SocketAsyncEventArgs>(ReceivedData_Completed);
			byte[] buffer = new byte[_receiveDataBufferLength];
			e.SetBuffer(buffer, 0, buffer.Length);
			_socket.ReceiveAsync(e);
		}

		void ReceivedData_Completed(object sender, SocketAsyncEventArgs e)
		{
			int l = e.BytesTransferred;
			if (l > 0)
			{
				byte[] data = new byte[l];
				Buffer.BlockCopy(e.Buffer, 0, data, 0, data.Length);
				_receiveQueue.Enqueue(data);
			}
			_socket.ReceiveAsync(e);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Net.Sockets;
	public static class SocketDataHelper
	{
		public static void ReadDataToFixedLengthBytes
								(
									Socket socket,
									ref byte[] buffer
								)
		{
			int p = 0;
			int l = buffer.Length;
			while (p < l)
			{
				int r = socket.Receive
									(
										buffer
										, p
										, l - p
										, SocketFlags.None
									);
				p += r;
			}
		}
		public static byte[] ReadDataToFixedLengthBytes
									(
										int length,
										Socket socket
									)
		{
			int p = 0;
			byte[] data = new byte[length];
			while (p < length)
			{
				int r = socket.Receive
									(
										data
										, p
										, length - p
										, SocketFlags.None
									);
				p += r;
			}
			return data;
		}
		public static byte[] ReadDataToBytes
									(
										int length,
										Socket socket
									)
		{
			byte[] data = new byte[length];
			int r = 0;
			//SocketError error;
			r = socket.Receive
								(
									data
									, 0
									, length
									, SocketFlags.None
				//, out error
								);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref data, r);
			}
			else
			{
				data = null;
			}
			return data;
		}
		public static int ReadDataToBytes
								(
									Socket socket,
									ref byte[] buffer
								)
		{
			int r = 0;
			//SocketError error;
			int l = buffer.Length;
			r = socket.Receive
							(
								buffer
								, 0
								, l
								, SocketFlags.None
				//, out error
							);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref buffer, r);
			}
			else
			{
				buffer = null;
			}
			return r;
		}
	}
	public static class StreamDataHelper
	{
		private static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		private long _EnqueueCount = 0; //入列计数器
		public long EnqueueCount
		{
			get
			{
				return _EnqueueCount;
			}
		}
		private long _DequeueCount = 0; //出列计数器
		public long DequeueCount
		{
			get
			{
				return _DequeueCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}

#T=Echo Server Sync Socket
namespace Test
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	using Microshaoft;
	public class SyncSocketAsyncQueueHandlerEchoServer
	{
		public static void StartListening()
		{
			//IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress;
			IPAddress.TryParse("127.0.0.1", out ipAddress);
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 12021);
			Socket listener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Stream
										, ProtocolType.Tcp
									);
				listener.Bind(localEndPoint);
				Console.WriteLine("Listening ...");
				listener.Listen(10);
				int i = 0;
				while (true)
				{
					int id = i++;
					UserToken token = new UserToken();
					token.ConnectionID = id;
					Socket socket = listener.Accept();
					Console.WriteLine("accept");
					SocketDataHandler<UserToken> handler = new SocketDataHandler<UserToken>(socket, token);
					handler.BufferLength = 10;
					handler.ID = id;
					handler.DataReceivedAsync += new SocketDataHandler<UserToken>.DataReceivedEventHandler(DataReceivedProcessAsync);
					handler.StartReceiveData();
				}
		}
		public static void DataReceivedProcessAsync(SocketDataHandler<UserToken> sender, byte[] data)
		{
			string s = Encoding.ASCII.GetString(data);
			Console.WriteLine("[{0}],[{1}],[{2}]", sender.Token.ConnectionID, s, data.Length);
			sender.SendDataAsync(data);
		}
		public static int Main(String[] args)
		{
			StartListening();
			return 0;
		}
	}
	public class UserToken
	{
		public string UserID;
		public int ConnectionID;
	}
}
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	public class SocketDataHandler<T>
	{
		private AsyncQueue<byte[]> _sendQueue;
		private AsyncQueue<byte[]> _receiveQueue;
		private T _token;
		public T Token
		{
			get
			{
				return _token;
			}
		}
		public SocketDataHandler(Socket socket, T token)
		{
			_sendQueue = new AsyncQueue<byte[]>();
			_sendQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(SendQueue_OnDequeue);
			//_sendQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_sendQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_sendQueue.MaxConcurrentThreadsCount = 1;
			_receiveQueue = new AsyncQueue<byte[]>();
			_receiveQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(ReceiveQueue_OnDequeue);
			//_receiveQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_receiveQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_socket = socket;
			_token = token;
		}
		void Queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		void Queue_OnQueueLog(string logMessage)
		{
//			Console.WriteLine(logMessage);
		}
		void SendQueue_OnDequeue(byte[] element)
		{
			_socket.Send(element);
		}
		void ReceiveQueue_OnDequeue(byte[] element)
		{
			if (DataReceivedAsync != null)
			{
				DataReceivedAsync(this, element);
			}
		}
		public enum ExceptionHandleAction : int
		{
			Ignore
			,
			ReThrow
			,
			Abort
		}
		private Thread _thread;
		private Socket _socket;
		private int _id;
		public int ID
		{
			set
			{
				_id = value;
			}
			get
			{
				return _id;
			}
		}
		private int _bufferLength = 1024;
		public int BufferLength
		{
			set
			{
				_bufferLength = value;
			}
		}
		public void SendDataAsync(byte[] data)
		{
			_sendQueue.Enqueue(data);
		}
		public void SendData(byte[] data)
		{
			_socket.Send(data);
		}
		public delegate void DataReceivedEventHandler
												(
													SocketDataHandler<T> sender
													, byte[] data
												);
		public event DataReceivedEventHandler DataReceived;
		public event DataReceivedEventHandler DataReceivedAsync;
		public delegate void ExceptionOccursEventHandler
												(
													SocketDataHandler<T> sender
													, Exception exception
													, ExceptionHandleAction action
												);
		public ExceptionOccursEventHandler ExceptionOccurs;
		public void StartReceiveData()
		{
			ThreadStart ts = new ThreadStart(RecieveDataThreadProcess);
			_thread = new Thread(ts);
			_thread.Start();
		}
		private void RecieveDataThreadProcess()
		{
			while (true)
			{
				byte[] buffer = null;
				try
				{
					buffer = SocketDataHelper.ReadDataToBytes(_bufferLength, _socket);
				}
				catch (Exception e)
				{
					if (ExceptionOccurs != null)
					{
						ExceptionHandleAction a = ExceptionHandleAction.Ignore;
						ExceptionOccurs(this, e, a);
						if (a == ExceptionHandleAction.ReThrow)
						{
							throw;
						}
						else if (a == ExceptionHandleAction.Abort)
						{
							break;
						}
					}
				}
				if (buffer != null)
				{
					if (buffer.Length > 0)
					{
						_receiveQueue.Enqueue(buffer);
						if (DataReceived != null)
						{
							DataReceived(this, buffer);
						}
					}
				}
				Thread.Sleep(100);
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Net.Sockets;
	public static class SocketDataHelper
	{
		public static void ReadDataToFixedLengthBytes
								(
									Socket socket ,
									ref byte[] buffer
								)
		{
			int p = 0;
			int l = buffer.Length;
			while (p < l)
			{
				int r = socket.Receive
									(
										buffer
										, p
										, l - p
										, SocketFlags.None
									);
				p += r;
			}
		}
		public static byte[] ReadDataToFixedLengthBytes
									(
										int length ,
										Socket socket 
									)
		{
			int p = 0;
			byte[] data = new byte[length];
			while (p < length)
			{
				int r = socket.Receive
									(
										data
										, p
										, length - p
										, SocketFlags.None
									);
				p += r;
			}
			return data;
		}
		public static byte[] ReadDataToBytes
									(
										int length,
										Socket socket
									)
		{
			byte[] data = new byte[length];
			int r = 0;
			//SocketError error;
			r = socket.Receive
								(
									data
									, 0
									, length
									, SocketFlags.None
									//, out error
								);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref data, r);
			}
			else
			{
				data = null;
			}
			return data;
		}
		public static int ReadDataToBytes
								(
									Socket socket ,
									ref byte[] buffer
								)
		{
			int r = 0;
			//SocketError error;
			int l = buffer.Length;
			r = socket.Receive
							(
								buffer
								, 0
								, l
								, SocketFlags.None
								//, out error
							);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref buffer, r);
			}
			else
			{
				buffer = null;
			}
			return r;
		}
	}
	public static class StreamDataHelper
	{
		private static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		private long _EnqueueCount = 0; //入列计数器
		public long EnqueueCount
		{
			get
			{
				return _EnqueueCount;
			}
		}
		private long _DequeueCount = 0; //出列计数器
		public long DequeueCount
		{
			get
			{
				return _DequeueCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}

#T=Effective C# 中文版 改善C#程序的50种方法
一、用属性代替可访问的字段
    1、.NET数据绑定只支持数据绑定，使用属性可以获得数据绑定的好处；
    2、在属性的get和set访问器重可使用lock添加多线程的支持。
二、readonly（运行时常量）和const（编译时常量）
    1、const只可用于基元类型、枚举、字符串，而readonly则可以是任何的类型；
    2、const在编译时将替换成具体的常量，这样如果在引用中同时使用了const和readonly两种值，则对readonly的再次改变将会改变设计的初衷，这是需要重新编译所更改的程序集，以重新引用新的常量值。
    3、const比readonly效率高，但失去了应用的灵活性。
三、is与as
    1、两者都是在运行时进行类型的转换，as操作符只能使用在引用类型，而is可以使用值和引用类型；
    2、通常的做法是用is判断类型，然后选择使用as或强类型转换操作符（用operater定义的转换）有选择地进行。
四、ConditionalAttribute代替#if #endif条件编译
   1、ConditionalAttribute只用于方法级，对其他的如类型、属性等的添加都是无效的；而#if #endif则不受此限制；
   2、ConditionalAttribute可以添加多个编译条件的或（OR）操作，而#if #endif则可以添加与（AND）[这里可以完全定义为另一个单独的符号]；
   3、ConditioanlAttribute定义可以放在一个单独的方法中，使得程序更为灵活。
五、提供ToString（）方法
   1、可以更友好的方式提供用户详细的信息；
   2、使用IFormatter.ToString（）方法提供更灵活的定制，如果添加IFormatProvider 和ICustomFormatter接口则更有意义的定制消息输出。
六、值和引用类型的区别
   1、值类型不支持多态，适合存储应用程序操作的数据，而引用则支持多态，适用于定义应用程序的行为；
   2、对于数组定义为值类型可以显著提高程序的性能；
   3、值类型具有较少的堆内存碎片、内存垃圾和间接访问时间，其在方法中的返回是以复制的方式进行，避免暴露内部结构到外界；
   4、值类型应用在如下的场景中：类型的职责主要是用于数据存储；公共接口完全由一些数据成员存取属性定义；永远没有子类；永远没有多态行为。
七、值类型尽可能实现为常量性和原子性的类型
   1、使我们的代码更易于编写和维护；
   2、初始化常量的三种策略：在构造中；工厂方法；构造一个可变的辅助类（如StringBuilder）。
八、确保0为值得有效状态
   1、值类型的默认状态应为0；
   2、枚举类型的0不应为“无效的状态”；在FlagsAttribute是应确保0值为有效地状态；
   3、在字符串为为空时可以返回一个string.Empty的空字符串；
九、相等判断的多种表示关系
   1、ReferenceEquals（）判断引用相等，需要两个是引用同一个对象时方可返回true；
   2、静态的Equals（）方法先进性引用判断再进行值类型判断的；
   3、对于引用类型的判断可以在使用“值语义”时使用重写Equals（）方法；
   4、重写Equals（）方法时也应当重写GetHashCode（）方法，同时提供operater==（）操作。
十、理解GetHashCode（）方法的缺陷
   1、GetHashCode（）仅应用在基于散列的集合定义键的散列值，如HashTable或Dictionary；
   2、GetHashCode（）应当遵循相应的三条规则：两个相等对象应当返回相同的散列码；应当是一个实例不变式；散列函数应该在所有的整数中产生一个随机的分布；
十一、优先使用foreach循环语句
   1、foreach可以消除编译器对for循环对数组边界的检查；
   2、foreach的循环变量是只读的，且存在一个显式的转换，在集合对象的对象类型不正确时抛出异常；
   3、foreach使用的集合需要有：具备公有的GetEnumberator（）方法；显式实现了IEnumberable接口；实现了IEnumerator接口；
   4、foreach可以带来资源管理的好处，因为如果编译器可以确定IDisposable接口时可以使用优化的try…finally块；
十二、默认字段的初始化优于赋值语句
  1、字段生命默认会将值类型初始化为0，引用类型初始化为null；
  2、对同一个对象进行多次初始化会降低代码的执行效率；
  3、将字段的初始化放到构造器中有利于进行异常处理。
十三、使用静态构造器初始化静态成员
  1、静态构造器会在一个类的任何方法、变量或者属性访问之前执行；
  2、静态字段同样会在静态构造器之前运行，同时静态构造器有利于异常处理。
十四、利用构造器链（在.NET 4.0已经用可选参数解决了这个问题）
  1、用this将初始化工作交给另一个构造器，用base调用基类的构造器；
  2、类型实例的操作顺序是：将所有的静态字段都设置为0；执行静态字段初始化器；执行基类的静态构造器；执行当前类型的静态构造器；
将所有的实例字段设置为0；执行实例字段初始化器；执行合适的基类实例构造器；执行当前类型的实例构造器。
十五、利用using和try/finally语句来清理资源
  在IDisposable接口的Dispose（）方法中用GC.SuppressFinalize()可通知垃圾收集器不再执行终结操作。
十六、尽量减少内存垃圾
  1、分配和销毁一个对上的对象都要花费额外的处理器时间；
  2、减少分配对象数量的技巧：经常使用的局部变量提升为字段；提供一个类，用于存储Singleton对象来表达特定类型的常用实例。
  3、用StringBuilder进行复杂的字符串操作。
十七、尽量减少装箱和拆箱
  1、关注一个类型到System.Object的隐式转换，同时值类型不应该被替换为System.Object类型；
  2、使用接口而不是使用类型可以避免装箱，即将值类型从接口实现，然后通过接口调用成员。
十八、实现标准Dispose模式
  1、使用非内存资源，它必须有一个终结器，垃圾收集器在完成没有终结其的内存对象后会将实现了终结器对象的添加到终结队列中，然后垃圾收集器会启动一个新的线程来运行这些对象上的终结器，这种防御性的变成方式是因为如果用户忘记了调用Dispose（）方法，垃圾回收器总是会调用终结器方法的，这样可以避免出现非托管的内存资源不被释放引起内存泄漏的问题；l
  2、使用IDisposable.Dispose()方法需要做四个方面的工作：释放所有的非托管资源；释放所有的托管资源；设置一个状态标记来表示是否已经执行了Dispose（）；调用GC.SuppressFinalize（this）取消对象的终结操作；
  3、为需要多态的类型添加一个受保护的虚方法Dispose（），派生类通过重写这个方法来释放自己的任务；
  4、在需要IDisoposable接口的类型中，即使我们不需要一个终结器也应该实现一个终结器。
十九、定义并实现接口优于继承类型
  1、不相关的类型可以共同实现一个共同的接口，而且实现接口比继承更容易；
  2、接口比较稳定，他将一组功能封装在一个接口中，作为其他类型的实现合同，而基类则可以随着时间的推移进行扩展。
二十、明辨接口实现和虚方法重写
  1、在基类中实现一个接口时，派生类需要使用new来隐藏对基类方法的使用；
  2、可以将基类接口的方法申明为虚方法，然后再派生类中实现。
二十一、使用委托表达回调
  1、委托对象本身不提供任何异常捕获，所以任何的多播委托调用都会结束整个调用链；
  2、通过显示调用委托链上的每个委托目标可以避免多播委托仅返回最后一个委托的输出。
二十二、使用事件定义外部接口
  1、应当声明为共有的事件，让编译器为我们创建add和renmove方法；
  2、使用System.ComponentModel.EventHandlerList容器来存储各个事件处理器，在类型中包含大量事件时可以使用他来隐藏所有事件的复杂性。
二十三、避免返回内部类对象的引用
  1、由于值类型对象的访问会创建一个该对象的副本，所以定义一个值类型的的属性完全不会改变类型对象内部的状态；
  2、常量类型可以避免改变对象的状态；
  3、定义接口将访问限制在一个子集中从而最小化对对象内部状态的破坏；
  4、定义一个包装器对象来限制另一个对象的访问；
  5、希望客户代码更改内部数据元素时可以实现Observer模式，以使对象可以对更改进行校验或相应。
二十四、声明式编程优于命令式编程
  可以避免在多个类似的手工编写的算法中犯错误的可能性，并提供清晰和可读的代码。
二十五、尽可能将类型实现为可序列化的类型
  1、类型表示的不是UI控件、窗口或者表单，都应使类型支持序列化；
  2、在添加了NonSerializedAttribute的反序列化的属性时可以通过实现IDeserializationCallback的OnDeserialization（）方法装入默认值；
  3、在版本控制中可以使用ISerializable接口来进行灵活的控制，同时提供一个序列化的构造器来根据流中的数据初始化对象，在实现时还要求SerializationFormatter异常的许可。
  4、如果需要创建派生类则需要提供一个挂钩方法供派生类使用。
二十六、使用IComparable和IComparer接口实现排序关系
  1、IComparable接口用于为类型实现最自然的排序关系，重载四个比较操作符，可以提供一个重载版的CompareTo（）方法，让其接受具体类型作为参数；
  2、IComparer用于提供有别于IComparable的排序关系，或者为我们提供类型本身说没有实现的排序关系。
二十七、避免ICloneable接口
  1、对于值类型永远不需要支持ICloneable接口使用默认的赋值操作即可；
  2、对于可能需要支持ICloneable接口的基类，应该为其创造一个受保护的复制构造器，并应当避免支持IConeable接口。
二十八、避免强制转换操作符
   通过使用构造器来代替转换操作符可以使转换工作变得更清晰，由于在转换后使用的临时对象，容易导致一些诡异的BUG。
二十九、只有当新版积累导致问题是才考虑使用new修饰符
三十、尽可能实现CLS兼容的程序集
  1、创建一个兼容的程序集需要遵循两条规则：程序集中所有公有和受保护成员所使用的参数和返回值类型都必须与CLS兼容；任何与CLS不兼容的公有和受保护成员都必须有一个与CLS兼容的替代品；
  2、可以通过显式实现接口来避开CLS兼容类型检查，及CLSCompliantAttribute不会检查私有的成员的CLS兼容性。
三十一、尽可能实现短小简洁的方法
  1、JIT编译器以方法为单位进行编译，没有被调用的方法不会被JIT编译；
  2、如果将较长的Switch中的Case语句的代码替换成一个一个的方法，则JIT编译器所节省的时间将成倍增加；
  3、短小精悍的方法并选择较少的局部变量可以获得优化的寄存器使用；
  4、方法内的控制分支越少，JIT编译器越容易将变量放入寄存器。
三十二、尽可能实现小尺寸、高内聚的程序集
  1、将所有的公有类以及共用的基类放到一些程序集中，把“为公有类提供功能的工具类”也放入同样的程序集中，把相关的公有接口打包到他们自己的程序集中，最后处理遍布应用程序中“水平”位置的类；
  2、原则上创建两种组件：一种为小而聚合、具有某项特定功能的程序集，另一种为大而宽、包含共用功能的程序集。
三十三、限制类型的可见性
  1、使用接口来暴露类型的功能，可以使我们更方便地创建内部类，同时又不会限制他们在程序集外的可用性；
  2、向外暴露的公有类型越少，未来扩展和更改实现所拥有的选择就越多。
三十四、创建大粒度的Web API
  这是在机器之间的交易的频率和载荷都降到最低，将大的操作和细粒度的执行放到服务器执行。
三十五、重写优于事件处理器
  1、一个事件处理器抛出异常，则事件链上的其他处理器将不会被调用，而重写的虚方法则不会出现这种情况；
  2、重写要比关联事件处理器高效得多，事件处理器需要迭代整个请求列表，这样占用了更多的CPU时间；
  3、事件能在运行时响应，具有更多的灵活性，可以对同一个事件关联多个响应；
  4、通行的规则是处理一个派生类的事件是，重写方式较好。
三十六、合理使用.NET运行时诊断
  1、System.Diagnostics.Debug\Trace\EventLog为运行时提供了程序添加诊断信息所需要的所有工具，EventLog提供入口时的应用程序能写到系统事件日志中；
  2、最后不要写自己的诊断库，.NET FCL 已经拥有了我们需要的核心库。
三十七、使用标准配置机制
  1、.NET框架的System.Windows.Application类为我们定义了建立通用配置路径的属性；
  2、Application.LocalAppDataPath和Application.userDataPath 会生成本地数据目录和用户数据的路径名；
  3、不要在ProgramFiles和Windows系统目录中写入数据，这些位置需要更高的安全权限，不要指望用户拥有写入的权限。
三十八、定制和支持数据绑定
  1、BindingMananger和CurrencyManager这两个对象实现了控件和数据源之间的数据传输；
  2、数据绑定的优势：使用数据绑定要比编写自己的代码简单得多；应该将它用于文本数据项之外的范围-其他显示属性也可以被绑定；对于Windowos Forms 数据绑定能够处理多个控件同步的检查相关数据源；
  3、在对象不支持所需的属性时可以通过屏蔽当前的对象然后添加一个想要的对象来支持数据绑定。
三十九、使用.NET验证
  1、ASP.NET中有五种控件来验证有效性，可以用CustomValidator派生一个新类来增加自己的认证器；
  2、Windows验证需要子System.Windows.Forms.Control.Validating些一个事件处理器。
四十、根据需要选用恰当的集合
  1、数组有两个比较明显的缺陷：不能动态的调整大小；调整大小非常耗时；
  2、ArrayList混合了一维数组和链表的特征，Queue和Stack是建立在Array基础上的特殊数组；
  3、当程序更加灵活的添加和删除项时，可以使更加健壮的集合类型，当创建一个模拟集合的类时，应当为其实现索引器和IEnumberable接口。
四十一、DataSet优于自定义结构
  1、DataSet有两个缺点个：使用XML序列化机制的DataSet与非.NET 代码之间的交互不是很好；DataSet是一个非常通用的容器；
  2、强类型的DataSet打破了更多的设计规则，其获得的开发效率要远远高于自己编写的看上去更为优雅的设计。
四十二、利用特性简化反射
  通过设计和实现特性类，强制开发人员用他们来声明可被动态使用的类型、方法和属性，可以减少应用程序的运行时错误，提高软件的用户满意度。
四十三、避免过度使用反射
   1、Invoke成员使用的参数和返回值都是System.Object，在运行时进行类型的转换，但出现问题的可能性也变得更多了；
   2、接口使我们可以得到一个更为清晰、也更具可维护性的系统，反射式一个很强大的晚期绑定机制.NET框架使用它来实现Windows控件和Web控件的数据绑定。
四十四、为应用程序创建特定的异常类
   1、需要不同的异常类的唯一原因是让用户在编写catch处理器时能够方便地对不同的错误采取不同的做法；
   2、可能有不同的修复行为时我们才应该创建多种不同的异常类，通过提供异常基类所支持的所有构造器，可以为应用程序创建功能完整的异常类，使用InnerException属性可以保存更低级别错误条件所产生的所有错误信息。
四十五、优先选择异常安全保证
   1、”强异常保证”在“从异常中恢复”和“简化异常处理”之间提供了最好的平衡，在操作因为异常而中断，程序的状态保留不变；
   2、对将要修改的数据做“防御性的复制”，对这些数据的“防御性复制”进行修改，这中间的操作可能会引发异常，将临时的副本和原对象进行交换；
   3、终结器、Dispose（）方法和委托对象所绑定的目标方法在任何情况下都应当确保他们不会抛出异常。
四十六、最小化互操作
   1、互操作有三个方面的代价：数据在托管堆和非托管堆之间的列举成本，托管代码和非托管代码之间切换的成本，对开发人员来说与混合环境打交道的开发工作；
   2、在interop中使用blittable类型可以有效地在托管和非托管环境中来回复制，而不受对象内部结构的影响；
   3、使用In/Out特性来确保最贴切的不必要的多次复制，通过声明数据如何被列举来提高性能；
   4、使用COM Interop用最简单的方式实现和COM组件的互操作，使用P/Invoke调用Win32 API,或者使用C++编译器的/CLR开关来混合托管和非托管的代码；
四十七、优先选择安全代码
   1、尽可能的避免访问非托管内存，隔离存储不能防止来自托管代码和受信用户的访问；
   2、程序集在Web上运行时可以考虑使用隔离存储，当某些算法确实需要更高的安全许可时，应该将那些代码隔离在一个单独的程序集中。
四十八、掌握相关工具与资源
   1、使用NUnit建立自动单元测试（集成在VS2010 中了）；
   2、FXCop工具会获取程序集中的IL代码，并将其与异族编码规则和最佳实践对照分析，最后报告违例情况；
   3、ILDasm是一个IL反汇编工具，可以帮助我们洞察细节；
   4、Shared Source CLI是一个包含.NET框架内核和C#编译器的实现源码。
四十九、为C#2.0做准备（这个规则现在已经没什么意义了，毕竟现在已经到了4.0 ）
五十、了解ＥＣＭＡ标准

#T=Emit AppDomain DynamicTypeResolve 动态类型解析技术示例 
//动态类型解析技术示例
//TypeResolve.cs

//--------------------------------------------------------------------------------
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
/*========================================================================

  File:	TypeResolve.cs

  Summary: This file implements "type resolution" sample.  This sample
		   demonstrates how hosts can participate in the type resolution
		   process by supplying and event handler that returns an assembly
		   containing the requested type.
			 
========================================================================*/

namespace Microshaoft
{
	using System;
	using System.Reflection;
	using System.Reflection.Emit;
	using System.Threading;
	using System.Runtime.Remoting;


	class App {
	   static Assembly TypeResolveHandler(Object sender, ResolveEventArgs e) {
		  Console.WriteLine("In TypeResolveHandler");

		  AssemblyName assemblyName = new AssemblyName();
		  assemblyName.Name = "DynamicAssem";

		  // Create a new assembly with one module
		  AssemblyBuilder newAssembly =
			 Thread.GetDomain().DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
		  ModuleBuilder newModule = newAssembly.DefineDynamicModule("DynamicModule");

		  // Define a public class named "ANonExistentType" in the assembly.
		  TypeBuilder myType = newModule.DefineType("ANonExistentType", TypeAttributes.Public);

		  // Define a method on the type to call
		  MethodBuilder simpleMethod = myType.DefineMethod("SimpleMethod", MethodAttributes.Public, null, null);
		  ILGenerator il = simpleMethod.GetILGenerator();
		  il.EmitWriteLine("Method called in ANonExistentType");
		  il.Emit(OpCodes.Ret);

		  // Bake the type
		  myType.CreateType();

		  return newAssembly;
	   }

	   static void Main() {
		  // Hook up the event handler
		  Thread.GetDomain().AssemblyResolve +=new ResolveEventHandler(App.TypeResolveHandler);

		  // Find a type that should be in our assembly but isn't
		  ObjectHandle oh = Activator.CreateInstance("DynamicAssem", "ANonExistentType"); 

		  Type mt = oh.Unwrap().GetType();

		  // Construct an instance of a type
		  Object objInstance = Activator.CreateInstance(mt);

		  // Find a method in this type and call it on this object
		  MethodInfo mi = mt.GetMethod("SimpleMethod");
		  mi.Invoke(objInstance, null);
	   }
	}

}
#T=Emit Assembly
/****************************** Module Header ******************************\
* Module Name:	Program.cs
* Project:		CSEmitAssembly
* Copyright (c) Microsoft Corporation.
* 
* This example emits these two classes that are mutually referenced.
* 
* public class ClassA {
*	 // Fields
*	 private ClassB classBField;
*	 private String stringField;
* 
*	 // Methods
*	 public void ClassAMethod()
*	 { this.classBField.ClassBMethod(null); }
* 
*	 // Properties
*	 public ClassB ClassBProperty {
*		 get { return this.classBField; }
*		 set { this.classBField = value; }
*	 }
* }
* 
* public class ClassB {
*	 // Fields
*	 private List<ClassA> classAList;
*	 private ClassA classAField;
* 
*	 // Methods
*	 public void ClassBMethod(List<ClassA> list) {
*		 this.classAField.ClassAMethod();
*	 }
* 
*	 // Properties
*	 public List<ClassA> ClassAList {
*		 get { return this.classAList; }
*		 set { this.classAList.AddRange(value); }
*	 }
* }
* 
* This source is subject to the Microsoft Public License.
* See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
* All other rights reserved.
* 
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
* EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
* WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
\***************************************************************************/

^#region Using directives
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
^#endregion


class Program
{
	static void Main(string[] args)
	{
		/////////////////////////////////////////////////////////////////////
		// Define the assembly and the module.
		// 

		AppDomain appDomain = AppDomain.CurrentDomain;
		AssemblyName assemblyName = new AssemblyName("EmittedAssembly");
		AssemblyBuilder assembly = appDomain.DefineDynamicAssembly(
			assemblyName, AssemblyBuilderAccess.RunAndSave);

		// An assembly is made up of executable modules. For a single-module
		// assembly, the module name and file name are the same as the 
		// assembly name. 

		ModuleBuilder module = assembly.DefineDynamicModule(
			assemblyName.Name, assemblyName.Name + ".dll");


		/////////////////////////////////////////////////////////////////////
		// Declare the types (classes).
		// 

		// Declare the class "ClassA"
		TypeBuilder classA = module.DefineType("ClassA", TypeAttributes.Public);
		// Declare the class "ClassB"
		TypeBuilder classB = module.DefineType("ClassB", TypeAttributes.Public);


		/////////////////////////////////////////////////////////////////////
		// Define the type, ClassA.
		// 

		#region Constructors

		#endregion

		#region Fields

		// Define the fields stringField, classBField
		FieldBuilder stringField = classA.DefineField("stringField",
			typeof(string), FieldAttributes.Private);
		FieldBuilder classBField = classA.DefineField("classBField",
			classB, FieldAttributes.Public);

		#endregion

		#region Properties

		// Define the property ClassBProperty
		PropertyBuilder classBProperty = classA.DefineProperty(
			"ClassBProperty", PropertyAttributes.None, classB, null);

		// The special set of attributes for the property set&get methods
		MethodAttributes getSetAttr = MethodAttributes.Public |
			MethodAttributes.SpecialName | MethodAttributes.HideBySig;

		// Define the "get" accessor method for ClassBProperty
		MethodBuilder classBGetProp = classA.DefineMethod(
			"get_ClassBProperty", getSetAttr, classB, Type.EmptyTypes);
		ILGenerator classBGetIL = classBGetProp.GetILGenerator();
		classBGetIL.Emit(OpCodes.Ldarg_0);
		classBGetIL.Emit(OpCodes.Ldfld, classBField);
		classBGetIL.Emit(OpCodes.Ret);

		// Define the "set" accessor method for ClassBProperty
		MethodBuilder classBSetProp = classA.DefineMethod(
			"set_ClassBProperty", getSetAttr, null, new Type[] { classB });
		ILGenerator sampleSetIL = classBSetProp.GetILGenerator();
		sampleSetIL.Emit(OpCodes.Ldarg_0);
		sampleSetIL.Emit(OpCodes.Ldarg_1);
		sampleSetIL.Emit(OpCodes.Stfld, classBField);
		sampleSetIL.Emit(OpCodes.Ret);

		// Map the get&set methods to PropertyBuilder
		classBProperty.SetGetMethod(classBGetProp);
		classBProperty.SetSetMethod(classBSetProp);

		#endregion

		#region Methods

		// Define a method that uses the classBField
		MethodBuilder classAMethod = classA.DefineMethod("ClassAMethod", 
			MethodAttributes.Public);

		// Define the list generics and ienumerable generic
		Type listOf = typeof(List<>);
		Type enumOf = typeof(IEnumerable<>);
		Type listOfClassA = listOf.MakeGenericType(classA);
		Type enumOfClassA = enumOf.MakeGenericType(classA);

		// Define the method, ClassBMethod, for ClassB
		MethodBuilder classBMethod = classB.DefineMethod("ClassBMethod", 
			MethodAttributes.Public, typeof(void), new Type[] { listOfClassA });
		classBMethod.DefineParameter(1, ParameterAttributes.None, "list");

		// Write the body of ClassAMethod that calls ClassBMethod
		ILGenerator ilgenA = classAMethod.GetILGenerator();
		ilgenA.Emit(OpCodes.Nop);
		ilgenA.Emit(OpCodes.Ldarg_0);
		ilgenA.Emit(OpCodes.Ldfld, classBField);
		ilgenA.Emit(OpCodes.Ldnull);
		ilgenA.Emit(OpCodes.Callvirt, classBMethod);
		ilgenA.Emit(OpCodes.Ret);

		#endregion


		/////////////////////////////////////////////////////////////////////
		// Define the type, ClassB.
		// 

		#region Constructors

		#endregion

		#region Fields

		// Define the fields classAField, classAList
		FieldBuilder classAField = classB.DefineField("classAField", classA, 
			FieldAttributes.Private);
		FieldBuilder classAList = classB.DefineField("classAList", listOfClassA, 
			FieldAttributes.Private);

		#endregion

		#region Properties

		// Define the property ClassAList
		PropertyBuilder classAListProperty = classB.DefineProperty(
			"ClassAList", PropertyAttributes.None, listOfClassA, null);

		// Define the "get" accessor method for ClassAList
		MethodBuilder listGetProp = classB.DefineMethod("get_ClassAList",
			getSetAttr, listOfClassA, null);
		ILGenerator listGetIL = listGetProp.GetILGenerator();
		listGetIL.Emit(OpCodes.Ldarg_0);
		listGetIL.Emit(OpCodes.Ldfld, classAList);
		listGetIL.Emit(OpCodes.Ret);

		// Define the "set" accessor method for ClassAList
		MethodInfo addRangeBaseMethod = listOf.GetMethod("AddRange");
		MethodInfo addRangeMethod = TypeBuilder.GetMethod(
			listOfClassA, addRangeBaseMethod);

		MethodBuilder listSetProp = classB.DefineMethod("set_ClassAList",
			getSetAttr, null, new Type[] { listOfClassA });
		ILGenerator listSetIL = listSetProp.GetILGenerator();
		listSetIL.Emit(OpCodes.Nop);
		listSetIL.Emit(OpCodes.Ldarg_0);
		listSetIL.Emit(OpCodes.Ldfld, classAList);
		listSetIL.Emit(OpCodes.Ldarg_1);
		listSetIL.Emit(OpCodes.Callvirt, addRangeMethod);
		listSetIL.Emit(OpCodes.Ret);

		classAListProperty.SetGetMethod(listGetProp);
		classAListProperty.SetSetMethod(listSetProp);

		#endregion

		#region Methods

		// Write the body of ClassBMethod that calls ClassAMethod
		ILGenerator ilgenB = classBMethod.GetILGenerator();
		ilgenB.Emit(OpCodes.Nop);
		ilgenB.Emit(OpCodes.Ldarg_0);
		ilgenB.Emit(OpCodes.Ldfld, classAField);
		ilgenB.Emit(OpCodes.Callvirt, classAMethod);
		ilgenB.Emit(OpCodes.Ret);

		#endregion


		/////////////////////////////////////////////////////////////////////
		// Create the types.
		// 

		classA.CreateType();
		classB.CreateType();


		/////////////////////////////////////////////////////////////////////
		// Save the assembly.
		// 

		assembly.Save(assemblyName.Name + ".dll");
	}
}

#T=eml Mail MailMessage.GetBytes() 2012-08-13
namespace ConsoleApplication
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Net.Mail;
	using System.Net.Mime;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.WriteLine("生成 eml 文件");
			string html = "<html><body><a href=\"http://www.live.com\"><img src=\"cid:attachment1\"></a>";
			html += "<script src=\"cid:attachment2\"></script>中国字";
			html += "<a href=\"http://www.google.com\"><br><img src=\"cid:attachment1\"></a><script>alert('mail body xss')<script></body></html>";
			AlternateView view = AlternateView.CreateAlternateViewFromString(html, null, MediaTypeNames.Text.Html);
			//LinkedResource picture = new LinkedResource(@"pic.JPG", MediaTypeNames.Image.Jpeg);
			//picture.ContentId = "attachment1";
			//view.LinkedResources.Add(picture);
			//LinkedResource script = new LinkedResource(@"a.js", MediaTypeNames.Text.Plain);
			//script.ContentId = "attachment2";
			//view.LinkedResources.Add(script);
			MailMessage mail = new MailMessage();
			mail.AlternateViews.Add(view);
			mail.From = new MailAddress("test@microshaoft.com", "<script>alert('mail from xss')</script>");
			mail.To.Add(new MailAddress("microshaoft@gmail.com", "<script>alert('mail to xss')</script>"));
			mail.To.Add(new MailAddress("microshaoft@qq.com", "<script>alert('mail to xss')</script>"));
			mail.Subject = "<script>alert('mail subject xss')</script>" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
			byte[] buffer = mail.GetBytes();
			File.WriteAllBytes(@"d:\temp.eml", buffer);
			Console.WriteLine("====================================================================");
			Console.ReadLine();
			Console.WriteLine("计算表达式");
			string formula = "(({0}-{1})/{2}+{3})*{4}";
			string result = JScriptEvaluator.ComputeFormula<double>
													(
														formula
														, 1f
														, 2.1
														, 3.1
														, 4.0
														, 5.0
													);
			Console.WriteLine(result);
			double x;
			x = DataTableColumnExpression.ComputeFormula<double, double>
													(
														formula
														, 1f
														, 2.1
														, 3.1
														, 4.0
														, 5.0
													);
			Console.WriteLine(x);
			//=================================================================================================
			formula = "IIF(1=2, F1, F2) + ((--F1) * F2) + F3";
			var tuples = new Tuple<string, double>[]
											{
												Tuple.Create<string,double>("F1", 1.0)
												, Tuple.Create<string,double>("F2", 2.0)
												, Tuple.Create<string,double>("F3", 3.0)
												, Tuple.Create<string,double>("F4", 4.0)
												, Tuple.Create<string,double>("F3", 2.0)
											};
			x = DataTableColumnExpression.ComputeFormula<double, double>(formula, tuples);
			Console.WriteLine(x);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.CodeDom.Compiler;
	using System.Collections.Generic;
	using System.Data;
	using System.Linq;
	using System.Reflection;
	public class DataTableColumnExpression
	{
		private static MethodInfo _mi = typeof(string).GetMethods().First
																	(
																		m => m.Name.Equals("Format")
																		&& m.GetParameters().Length == 2
																		&& m.IsStatic
																		&& m.GetParameters()[1].Name == "args"
																	);
		private class ObjectEqualityComparer<T> : IEqualityComparer<T>
		{
			private Func<T, T, bool> _onEqualsProcessFunc;
			private Func<T, int> _onGetHashCodeProcessFunc;
			public ObjectEqualityComparer
						(
							Func<T, T, bool> onEqualsProcessFunc
							, Func<T, int> onGetHashCodeProcessFunc
						)
			{
				_onEqualsProcessFunc = onEqualsProcessFunc;
				_onGetHashCodeProcessFunc = onGetHashCodeProcessFunc;
			}
			public bool Equals(T x, T y)
			{
				if (Object.ReferenceEquals(x, y))
				{
					return true;
				}
				if (Object.ReferenceEquals(x, null) || Object.ReferenceEquals(y, null))
				{
					return false;
				}
				return _onEqualsProcessFunc(x, y);
			}
			public int GetHashCode(T x)
			{
				if (Object.ReferenceEquals(x, null))
				{
					return 0;
				}
				return _onGetHashCodeProcessFunc(x);
			}
		}
		public static TResult ComputeFormula<TResult, TParameter>
													(
														string formula
														, params TParameter[] parameters
													)
		{
			var dt = new DataTable();
			var list = parameters.ToList();
			var parametersNames = new List<string>(); ;
			int i = 0;
			Array.ForEach
					(
						parameters
						, (x) =>
						{
							string f = string.Format("F{0}", i++);
							parametersNames.Add(f);
							var dc = new DataColumn(f, typeof(TParameter));
							dt.Columns.Add(dc);
						}
					);
			string expression = string.Format(formula, parametersNames.ToArray());
			dt.Columns.Add(new DataColumn("Microshaoft", typeof(TResult), expression));
			var dr = dt.NewRow();
			i = 0;
			Array.ForEach
			(
				parameters
				, (x) =>
				{
					dr[i++] = x;
				}
			);
			dt.Rows.Add(dr);
			return (TResult)dr["Microshaoft"];
		}
		public static TResult ComputeFormula<TResult, TParameter>
													(
														string formula
														, params Tuple<string, TParameter>[] parameters
													)
		{
			var dt = new DataTable();
			var comparer = new ObjectEqualityComparer<Tuple<string, TParameter>>
											(
												(x, y) =>
												{
													return x.Item1 == y.Item1;
												}
												, (x) =>
												{
													return x.Item1.GetHashCode();
												}
											);
			var list = parameters.Distinct
									(
										comparer
									)
									.ToList();
			list.ForEach
					(
						(x) =>
						{
							var dc = new DataColumn
											(
												x.Item1
												, x.Item2.GetType()
											);
							dt.Columns.Add(dc);
						}
					);
			dt.Columns.Add(new DataColumn("Microshaoft", typeof(TResult), formula));
			var dr = dt.NewRow();
			list.ForEach
					(
						(x) =>
						{
							dr[x.Item1] = x.Item2;
						}
					);
			dt.Rows.Add(dr);
			return (TResult)dr["Microshaoft"];
		}
	}
	public class JScriptEvaluator
	{
		private static MethodInfo _mi = typeof(string).GetMethods().First
																		(
																			m => m.Name.Equals("Format")
																			&& m.GetParameters().Length == 2
																			&& m.IsStatic
																			&& m.GetParameters()[1].Name == "args"
																		);
		private static Func<string, object[], object> _func = null;
		public static string ComputeFormula<TParameter>(string formula, params TParameter[] parameters)
		{
			object[] objects = new object[parameters.Length];
			Array.Copy(parameters, objects, objects.Length);
			string expression1 = string.Format(formula, objects);
			return (string)JScriptEvaluator.Eval(expression1);
			//=====================================================================
			object[] ps = new object[parameters.Length];
			Array.Copy(parameters, 0, ps, 0, ps.Length);
			if (_func == null)
			{
				_func = DynamicCallMethodExpressionTreeInvokerHelper.CreateMethodCallInvokerFunc<string, string>
												(
													typeof(string)
													, () =>
													{
														var methodsInfos = typeof(string).GetMethods();
														var methodInfo = methodsInfos.First
																						(
																							(x) =>
																							{
																								var parametersInfos = x.GetParameters();
																								//Debug.Assert(x.Name.ToLower() == "Format".ToLower());
																								return
																									x.Name.ToLower() == "Format".ToLower()
																									&& x.IsStatic
																									&& parametersInfos[0].ParameterType == typeof(string)
																									&& parametersInfos[1].ParameterType == typeof(object[])
																									&& Attribute.IsDefined
																													(
																														parametersInfos[1]
																														, typeof(ParamArrayAttribute)
																													);
																							}
																						);
														return methodInfo;
													}
												);
			}
			string expression = (string)_mi.Invoke
												(
													null
													, new object[]
															{
																formula
																, ps
															}
												);
			expression = (string) _func
									(
										formula
										, new object[]
													{
														formula
														, ps
													}
									);
			return (string) JScriptEvaluator.Eval(expression);
		}
		public static object Eval(string statement)
		{
			return _evaluatorType.InvokeMember
										(
											"Eval"
											, BindingFlags.InvokeMethod
											, null
											, _evaluator
											, new object[]
													{
														statement
													}
										);
		}
		static JScriptEvaluator()
		{
			CodeDomProvider provider = CodeDomProvider.CreateProvider("JScript");
			CompilerParameters parameters;
			parameters = new CompilerParameters();
			parameters.GenerateInMemory = true;
			CompilerResults results;
			results = provider.CompileAssemblyFromSource(parameters, _JScript);
			Assembly assembly = results.CompiledAssembly;
			_evaluatorType = assembly.GetType("Microshaoft.JScriptEvaluator");
			var constructorInfo = _evaluatorType.GetConstructors().First();
			var func = DynamicCallMethodExpressionTreeInvokerHelper.CreateNewInstanceConstructorInvokerFunc
															(
																_evaluatorType
																, constructorInfo
															);
			_evaluator = func(null);
			//_evaluator = Activator.CreateInstance(_evaluatorType);
		}
		private static object _evaluator = null;
		private static Type _evaluatorType = null;
		/// <summary>
		/// JScript代码
		/// </summary>
		private static readonly string _JScript =
			@"
				package Microshaoft
				{
					class JScriptEvaluator
					{
						public function Eval(statement : String) : String
						{
							return eval(statement);
						}
					}
				}
			";
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public static class DynamicCallMethodExpressionTreeInvokerHelper
	{
		public static Func<object[], object> CreateNewInstanceConstructorInvokerFunc
														(
															Type type
															, Func<ConstructorInfo> getConstructorInfoFunc
														)
		{
			var constructorInfo = getConstructorInfoFunc();
			return CreateNewInstanceConstructorInvokerFunc<object>
														(
															type
															, constructorInfo
														);
		}
		public static Func<object[], T> CreateNewInstanceConstructorInvokerFunc<T>
														(
															Type type
															, Func<ConstructorInfo> getConstructorInfoFunc
														)
		{
			var constructorInfo = getConstructorInfoFunc();
			return CreateNewInstanceConstructorInvokerFunc<T>
														(
															type
															, constructorInfo
														);
		}
		public static Func<object[], object> CreateNewInstanceConstructorInvokerFunc
														(
															Type type
															, ConstructorInfo constructorInfo
														)
		{
			return CreateNewInstanceConstructorInvokerFunc<object>(type, constructorInfo);
		}
		public static Func<object[], T> CreateNewInstanceConstructorInvokerFunc<T>
														(
															Type type
															, ConstructorInfo constructorInfo
														)
		{
			var parametersInfos = constructorInfo.GetParameters();
			var constructorParametersExpressions = new List<ParameterExpression>();
			int i = 0;
			Array.ForEach
					(
						parametersInfos
						, (x) =>
						{
							var parameterExpression = Expression.Parameter
																	(
																		x.ParameterType
																		, "p" + i.ToString()
																	);
							constructorParametersExpressions.Add(parameterExpression);
							i++;
						}
					);
			var newExpression = Expression.New(constructorInfo, constructorParametersExpressions);
			var inner = Expression.Lambda(newExpression, constructorParametersExpressions);
			var args = Expression.Parameter(typeof(object[]), "args");
			var body = Expression.Invoke
									(
										inner
										, constructorParametersExpressions.Select
																	(
																		(p, ii) =>
																		{
																			return Expression.Convert
																							(
																								Expression.ArrayIndex
																												(
																													args
																													, Expression.Constant(ii)
																												)
																								, p.Type
																							);
																		}
																	).ToArray()
									);
			var outer = Expression.Lambda<Func<object[], T>>(body, args);
			var func = outer.Compile();
			return func;
		}
		public static Action<T, object[]> CreateMethodCallInvokerAction<T>
															(
																Type type
																, Func<MethodInfo> getMethodInfoFunc
															)
		{
			var methodInfo = getMethodInfoFunc();
			return CreateMethodCallInvokerAction<T>
												(
													type
													, methodInfo
												);
		}
		public static Action<T, object[]> CreateMethodCallInvokerAction<T>
															(
																Type type
																, MethodInfo methodInfo
															)
		{
			ParameterExpression instanceParameterExpression;
			MethodCallExpression methodCallExpression;
			ParameterExpression argumentsParameterExpression = GetMethodArgumentsParameterExpression
									(
										type
										, methodInfo
										, out instanceParameterExpression
										, out methodCallExpression
									);
			var lambda = Expression.Lambda<Action<T, object[]>>(methodCallExpression, instanceParameterExpression, argumentsParameterExpression);
			var action = lambda.Compile();
			return action;
		}
		public static Func<T, object[], TResult> CreateMethodCallInvokerFunc<T, TResult>
															(
																Type type
																, Func<MethodInfo> getMethodInfoFunc
															)
		{
			var methodInfo = getMethodInfoFunc();
			return
				CreateMethodCallInvokerFunc<T, TResult>
													(
														type
														, methodInfo
													);
		}
		public static Func<T, object[], TResult> CreateMethodCallInvokerFunc<T, TResult>
															(
																Type type
																, MethodInfo methodInfo
															)
		{
			ParameterExpression instanceParameterExpression;
			MethodCallExpression methodCallExpression;
			ParameterExpression argumentsParameterExpression = GetMethodArgumentsParameterExpression
									(
										type
										, methodInfo
										, out instanceParameterExpression
										, out methodCallExpression
									);
			var lambda = Expression.Lambda<Func<T, object[], TResult>>(methodCallExpression, instanceParameterExpression, argumentsParameterExpression);
			var func = lambda.Compile();
			return func;
		}
		private static ParameterExpression GetMethodArgumentsParameterExpression
											(
												Type type
												, MethodInfo methodInfo
												, out ParameterExpression instanceParameterExpression
												, out MethodCallExpression methodCallExpression
											)
		{
			var argumentsParameterExpression = Expression.Parameter(typeof(object[]), "args");
			instanceParameterExpression = Expression.Parameter(type);
			UnaryExpression instanceConvertUnaryExpression = null;
			if (!methodInfo.IsStatic)
			{
				instanceConvertUnaryExpression = Expression.Convert(instanceParameterExpression, type);
			}
			var parametersParameterExpressionList = new List<Expression>();
			int i = 0;
			var parametersInfos = methodInfo.GetParameters();
			Array.ForEach
					(
						parametersInfos
						, (x) =>
						{
							BinaryExpression valueObject = Expression.ArrayIndex
																		(
																			argumentsParameterExpression
																			, Expression.Constant(i)
																		);
							UnaryExpression valueCast = Expression.Convert
																		(
																			valueObject
																			, x.ParameterType
																		);
							parametersParameterExpressionList.Add(valueCast);
							i++;
						}
					);
			methodCallExpression = Expression.Call(instanceConvertUnaryExpression, methodInfo, parametersParameterExpressionList);
			return argumentsParameterExpression;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Net.Mail;
	using System.Reflection;
	public static partial class ExtensionMethodsManager
	{
		public static byte[] GetBytes(this MailMessage mailMessage)
		{
			Assembly assembly = typeof(SmtpClient).Assembly;
			Type type = assembly.GetType("System.Net.Mail.MailWriter");
			var parametersTypes = new[]
									{ 
										typeof(Stream)
									};
			object x = null;
			using (Stream stream = new MemoryStream())
			{
				var constructorInfo = type.GetConstructor
													(
														BindingFlags.Instance | BindingFlags.NonPublic
														, null
														, parametersTypes
														, null
													);
				var func = DynamicCallMethodExpressionTreeInvokerHelper.CreateNewInstanceConstructorInvokerFunc<object>
														(
															type
															, constructorInfo
														);
				x = func(new[] { stream });
				var action = DynamicCallMethodExpressionTreeInvokerHelper.CreateMethodCallInvokerAction<MailMessage>
														(
															typeof(MailMessage)
															, () =>
															{
																var methodInfo = typeof(MailMessage).GetMethod
																						(
																							"Send"
																							, BindingFlags.NonPublic | BindingFlags.Instance
																							, null
																							, new[] { type, typeof(bool) }
																							, null
																						);
																return methodInfo;
															}
														);
				action
					(
						mailMessage
						, new[]
							{
								x
								, true
							}
					);
				byte[] buffer = StreamDataHelper.ReadDataToBytes(stream);
				return buffer;
			}
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=EncodingHelper
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Linq;
	using System.Text;
	using System.Collections.Generic;
	public static class EncodingHelper
	{
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, identifyEncodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
									)
		{

			var list = new List<Encoding>();
			Encoding.GetEncodings().Where
							(
								(x) =>
								{
									var e = x.GetEncoding();
									var r = (e.GetPreamble().Length > 0);
									if (r)
									{
										list.Add(e);
									}
									return r;
								}
							).ToList();
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, list.ToArray()
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			Encoding encoding = defaultEncoding;
			foreach (Encoding e in identifyEncodings)
			{
				byte[] buffer = e.GetPreamble();
				int l = buffer.Length;
				bool b = true;
				int i = 0;
				for (i = 0; i < l; i++)
				{
					if (buffer[i] != data[i])
					{
						b = false;
						break;
					}
				}
				if (i > 0 && b)
				{
					encoding = e;
					break;
				}
			}
			return encoding;
		}
	}
}
//==========================================================================================================
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}
//============================================================================================================

#T=Encrypted XML
namespace Microshaoft
{
	using System;
	using System.Xml;
	using System.Security.Cryptography;
	using System.Security.Cryptography.Xml;
	class Program
	{
		static void Main(string[] args)
		{
			// Create an XmlDocument object.
			XmlDocument xmlDoc = new XmlDocument();
			// Load an XML file into the XmlDocument object.
			try
			{
				xmlDoc.PreserveWhitespace = true;
				xmlDoc.Load("test.xml");
			}
			catch (Exception e)
			{
				Console.WriteLine(e.Message);
			}
			// Create a new TripleDES key. 
			TripleDESCryptoServiceProvider tDESkey = new TripleDESCryptoServiceProvider();
			// Create a new instance of the TrippleDESDocumentEncryption object
			// defined in this sample.
			TrippleDESDocumentEncryption xmlTDES = new TrippleDESDocumentEncryption(xmlDoc, tDESkey);
			
			try
			{
				// Encrypt the "creditcard" element.
				xmlTDES.Encrypt("creditcard");
				// Display the encrypted XML to the console.
				Console.WriteLine("Encrypted XML:");
				Console.WriteLine();
				Console.WriteLine(xmlTDES.Doc.OuterXml);
				// Decrypt the "creditcard" element.
				xmlTDES.Decrypt();
				// Display the encrypted XML to the console.
				Console.WriteLine();
				Console.WriteLine("Decrypted XML:");
				Console.WriteLine();
				Console.WriteLine(xmlTDES.Doc.OuterXml);
			}
			catch (Exception e)
			{
				Console.WriteLine(e.Message);
			}
			finally
			{
				// Clear the TripleDES key.
				xmlTDES.Clear();
			}
		}
	}
	class TrippleDESDocumentEncryption
	{
		protected XmlDocument docValue;
		protected TripleDES algValue;
		public TrippleDESDocumentEncryption(XmlDocument Doc, TripleDES Key)
		{
			if (Doc != null)
			{
				docValue = Doc;
			}
			else
			{
				throw new ArgumentNullException("Doc");
			}
			if (Key != null)
			{
				algValue = Key;
			}
			else
			{
				throw new ArgumentNullException("Key");
			}
		}
		public XmlDocument Doc { set { docValue = value; } get { return docValue; } }
		public TripleDES Alg { set { algValue = value; } get { return algValue; } }
		public void Clear()
		{
			if (algValue != null)
			{
				algValue.Clear();
			}
			else
			{
				throw new Exception("No TripleDES key was found to clear.");
			}
		}
		public void Encrypt(string Element)
		{
			// Find the element by name and create a new
			// XmlElement object.
			XmlElement inputElement = docValue.GetElementsByTagName(Element)[0] as XmlElement;
			// If the element was not found, throw an exception.
			if (inputElement == null)
			{
				throw new Exception("The element was not found.");
			}
			// Create a new EncryptedXml object.
			EncryptedXml exml = new EncryptedXml(docValue);
			// Encrypt the element using the symmetric key.
			byte[] rgbOutput = exml.EncryptData(inputElement, algValue, false);
			// Create an EncryptedData object and populate it.
			EncryptedData ed = new EncryptedData();
			// Specify the namespace URI for XML encryption elements.
			ed.Type = EncryptedXml.XmlEncElementUrl;
			// Specify the namespace URI for the TrippleDES algorithm.
			ed.EncryptionMethod = new EncryptionMethod(EncryptedXml.XmlEncTripleDESUrl);
			// Create a CipherData element.
			ed.CipherData = new CipherData();
			// Set the CipherData element to the value of the encrypted XML element.
			ed.CipherData.CipherValue = rgbOutput;
			// Replace the plaintext XML elemnt with an EncryptedData element.
			EncryptedXml.ReplaceElement(inputElement, ed, false);
		}
		public void Decrypt()
		{
			// XmlElement object.
			XmlElement encryptedElement = docValue.GetElementsByTagName("EncryptedData")[0] as XmlElement;
			// If the EncryptedData element was not found, throw an exception.
			if (encryptedElement == null)
			{
				throw new Exception("The EncryptedData element was not found.");
			}
			// Create an EncryptedData object and populate it.
			EncryptedData ed = new EncryptedData();
			ed.LoadXml(encryptedElement);
			// Create a new EncryptedXml object.
			EncryptedXml exml = new EncryptedXml();
			// Decrypt the element using the symmetric key.
			byte[] rgbOutput = exml.DecryptData(ed, algValue);
			// Replace the encryptedData element with the plaintext XML elemnt.
			exml.ReplaceData(encryptedElement, rgbOutput);
		}
	}
}
#T=ETW
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	 
	/// <summary>
	/// EventProviderTraeListener:
	///   http://msdn.microsoft.com/en-us/library/system.diagnostics.eventing.eventprovidertracelistener.aspx
	/// Trace Switch:
	///   http://msdn.microsoft.com/en-us/library/aa983740.aspx
	/// </summary>
	class ETWSample
	{
		static void Main(string[] args)
		{
			TraceSource myTraceSource = new TraceSource("TraceSourceApp");
			myTraceSource.TraceEvent(TraceEventType.Error, 1, "Tracing Error Message.");
			myTraceSource.TraceEvent(TraceEventType.Warning, 2, "Tracing Warning Message.");
			myTraceSource.TraceEvent(TraceEventType.Information, 3, "Tracing Information.");
			myTraceSource.TraceEvent(TraceEventType.Verbose, 4, "Tracing Verbose Message.");
			myTraceSource.TraceEvent(TraceEventType.Critical, 5, "Tracing Critical Message.");
			myTraceSource.Close();
			Console.ReadLine();
		}
	}
}
/*
<configuration>
  <system.diagnostics>
    <sources>
      <source name="TraceSourceApp" switchName="SourceSwitch" switchType="System.Diagnostics.SourceSwitch">
        <listeners>
          <add name="ConsoleListener"/>
          <add name="ETWListener"/>
          <remove name="Default"/>
        </listeners>
      </source>
    </sources>
 
    <switches>
      <add name="SourceSwitch" value="Verbose" />
    </switches>
 
    <sharedListeners>
      <add name="ConsoleListener" type="System.Diagnostics.ConsoleTraceListener"/>
      <add name="ETWListener" type="System.Diagnostics.Eventing.EventProviderTraceListener, System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
               initializeData="{BA2DC22C-CCCE-4D17-AFC9-9811DD739970}" />
    </sharedListeners>
  </system.diagnostics>
</configuration>
*/
#T=ETW EventSource
namespace Demo1
{
	using System.Diagnostics.Tracing;
	using System.Collections.Generic;
	class MyCompanyEventSource : EventSource
	{
		public static MyCompanyEventSource Log = new MyCompanyEventSource();
		public void Startup() { WriteEvent(1); }
		public void OpenFileStart(string fileName) { WriteEvent(2, fileName); }
		public void OpenFileStop() { WriteEvent(3); }
	}
	class Program
	{
		static void Main(string[] args)
		{
			string name = MyCompanyEventSource.GetName(typeof(MyCompanyEventSource));
			IEnumerable<EventSource> eventSources = MyCompanyEventSource.GetSources();
			MyCompanyEventSource.Log.Startup();
			// ...
			MyCompanyEventSource.Log.OpenFileStart("SomeFile");
			// ...
			MyCompanyEventSource.Log.OpenFileStop();
		}
	}
}
namespace Demo2
{
	using System;
	using System.Diagnostics.Tracing;
	enum MyColor { Red, Yellow, Blue };
	[EventSource(Name = "MyCompany")]
	class MyCompanyEventSource : EventSource
	{
		public class Keywords
		{
			public const EventKeywords Page = (EventKeywords)1;
			public const EventKeywords DataBase = (EventKeywords)2;
			public const EventKeywords Diagnostic = (EventKeywords)4;
			public const EventKeywords Perf = (EventKeywords)8;
		}
		public class Tasks
		{
			public const EventTask Page = (EventTask)1;
			public const EventTask DBQuery = (EventTask)2;
		}
		[Event(1, Message = "Application Failure: {0}", Level = EventLevel.Error, Keywords = Keywords.Diagnostic)]
		public void Failure(string message) { WriteEvent(1, message); }
		[Event(2, Message = "Starting up.", Keywords = Keywords.Perf, Level = EventLevel.Informational)]
		public void Startup() { WriteEvent(2); }
		[Event(3, Message = "loading page {1} activityID={0}", Opcode = EventOpcode.Start, 
			Task = Tasks.Page, Keywords = Keywords.Page, Level = EventLevel.Informational)]
		public void PageStart(int ID, string url) { if (IsEnabled()) WriteEvent(3, ID, url); }
		[Event(4, Opcode = EventOpcode.Stop, Task = Tasks.Page, Keywords = Keywords.Page, Level = EventLevel.Informational)]
		public void PageStop(int ID) { if (IsEnabled()) WriteEvent(4, ID); }
		[Event(5, Opcode = EventOpcode.Start, Task = Tasks.DBQuery, Keywords = Keywords.DataBase, Level = EventLevel.Informational)]
		public void DBQueryStart(string sqlQuery) { WriteEvent(5, sqlQuery); }
		[Event(6, Opcode = EventOpcode.Stop, Task = Tasks.DBQuery, Keywords = Keywords.DataBase, Level = EventLevel.Informational)]
		public void DBQueryStop() { WriteEvent(6); }
		[Event(7, Level = EventLevel.Verbose, Keywords = Keywords.DataBase)]
		public void Mark(int ID) { if (IsEnabled()) WriteEvent(7, ID); }
		[Event(8)]
		public void LogColor(MyColor color) { WriteEvent(8, (int) color); }
		public static MyCompanyEventSource Log = new MyCompanyEventSource();
	}
	class Program
	{
		static void Main(string[] args)
		{
			MyCompanyEventSource.Log.Startup();
			Console.WriteLine("Starting up");
			MyCompanyEventSource.Log.DBQueryStart("Select * from MYTable");
			var url = "http://localhost";
			for (int i = 0; i < 10; i++)
			{
				MyCompanyEventSource.Log.PageStart(i, url);
				MyCompanyEventSource.Log.Mark(i);
				MyCompanyEventSource.Log.PageStop(i);
			}
			MyCompanyEventSource.Log.DBQueryStop();
			MyCompanyEventSource.Log.LogColor(MyColor.Blue);
			MyCompanyEventSource.Log.Failure("This is a failure 1");
			MyCompanyEventSource.Log.Failure("This is a failure 2");
			MyCompanyEventSource.Log.Failure("This is a failure 3");
		}
	}
}
#T=Etw EventSourceProvider_EventsProducer.cs
// EventSourceProvider_EventsProducer.cs
/*
/r:"D:\Microshaoft.Nuget.Packages\Microsoft.Diagnostics.Tracing.EventSource.Redist.1.1.28\lib\net46\Microsoft.Diagnostics.Tracing.EventSource.dll"
*/
namespace Test_EventSourceProvider_EventsProducer
{
	using Microshaoft;
	using Microshaoft.EventListeners;
	using Microshaoft.EventSources;
	using System;
	using System.Diagnostics;
	using System.IO;
	using System.Security.Principal;
	class Program
	{
		static void Main(string[] args)
		{
			Console.Title = Process.GetCurrentProcess().ProcessName;
			// Deploy the app
			var DeploymentFolder = Path
									.Combine
										(
											Environment
												.GetFolderPath
													(
														Environment
															.SpecialFolder
															.CommonApplicationData
													)
											, @"EventSourceSamples"
										);
			RegisterEventSourceWithOperatingSystemHelper
					.SimulateInstall
							(
								@"D:\MyC#\EtwOk\EventSources\bin\Debug"
								, DeploymentFolder
								, EventLogEventSource.Log.Name
							);
			string input = string.Empty;
			using (var listener = new ConsoleEventListener())
			{
				while ("q" != (input = Console.ReadLine()).Trim().ToLower())
				{
					EventLogEventSource
						.Log
						.WriteEvent1Log
							(
								1
								, Guid.NewGuid()
								, WindowsIdentity.GetCurrent().Name
								, "这是一个测试 WriteEvent1Log"
							);
					EventLogEventSource
						.Log
						.WriteEvent2Log
							(
								2
								, Guid.NewGuid()
								, WindowsIdentity.GetCurrent().Name
								, "这是一个测试 WriteEvent2 Log"
							);
				}
			}
			Console.ReadLine();
		}
	}
}
namespace Microshaoft.EventSources
{
	using System;
	using Microsoft.Diagnostics.Tracing;
	//
	// Shows how to use EventSouces to send messages to the Windows EventLog
	//
	// * EventLogEventSource
	//	 * Uses the new 'Channel' attribute to indicate that certain events
	//	   should go to the Windows Event Log.   Note that the EventSource
	//	   has to be registered with the Windows OS for this to work.  
	//	   In this example we send messages to the 'Admin' channel.   
	//
	// * EventLogEventSourceDemo 
	//	 * simulates a deployment step needed to register the event source's 
	//	   manifest on the machine. If running unelevated it will prompt the user
	//	   to allow running wevtutil.exe, the tool that performs the registration.
	//
	//	 * simulates processing multiple requests by calling the methods on 
	//	   EventLogEventSource to fire events.
	//	 * pauses to allow the user to examine the event logs created under 
	//	   'Application and Services Logs/Microsoft/EventSourceDemos/Channeled'
	//
	//	 * undoes the registration steps performed earlier.
	//
	[
		EventSource
			(
				Name = "Microshaoft-EventLogEventSource-001" //"Samples-EventSourceDemos-EventLog"
			)
	]
	public sealed class EventLogEventSource : EventSource
	{
		#region Singleton instance
		public static EventLogEventSource Log = new EventLogEventSource();
		#endregion
		[
			Event
				(
					1
					, ActivityOptions = EventActivityOptions.None
					, Channel = EventChannel.Admin
					, Keywords = Keywords.EventKeyword1
					//, Level = EventLevel.LogAlways
					, Message =
@"
	sequenceID : ""{0}""
	, contextID : ""{1}""
	, operatorID : ""{2}""
	, data : ""{3}""
"
					, Opcode = EventOpcode.Info
					, Tags = EventTags.None
					, Task = EventTasks.EventTask1
					, Version = 1
				)
		]
		public void WriteEvent1Log
					(
						int sequenceID
						, Guid contextID
						, string operatorID
						, string data
					)
		{
			WriteEvent
				(
					1
					, (object)sequenceID
					, (object)contextID
					, (object)operatorID
					, (object)data
				);
		}
		[
			Event
				(
					2
					, ActivityOptions = EventActivityOptions.None
					, Channel = EventChannel.Admin
					, Keywords = Keywords.EventKeyword2
					//, Level = EventLevel.LogAlways
					, Message =
@"
	sequenceID : ""{0}""
	, contextID : ""{1}""
	, operatorID : ""{2}""
	, data : ""{3}""
"
					, Opcode = EventOpcode.Info
					, Tags = Tags.EventTag2
					, Task = EventTasks.EventTask2
					, Version = 1
				)
		]
		public void WriteEvent2Log
			(
				int sequenceID
				, Guid contextID
				, string operatorID
				, string data
			)
		{
			WriteEvent
				(
					2
					, (object)sequenceID
					, (object)contextID
					, (object)operatorID
					, (object)data
				);
		}
		#region Keywords / Tasks / Opcodes
		public class Keywords   // This is a bitvector
		{
			public const EventKeywords EventKeyword1 = (EventKeywords)0x00000001;
			public const EventKeywords EventKeyword2 = (EventKeywords)0x00000002;
		}
		public class EventTasks
		{
			//[1,65534]
			public const EventTask EventTask1 = (EventTask)1;
			public const EventTask EventTask2 = (EventTask)2;
		}
		public class EventOpcodes
		{
			public const EventOpcode EventOpcode_0x0b = (EventOpcode)0x0b;
		}
		public class Tags
		{
			public const EventTags EventTag1 = (EventTags)1;
			public const EventTags EventTag2 = (EventTags)2;
		}
		#endregion
	}
}
namespace Microshaoft.EventListeners
{
	using System;
	using System.IO;
	using System.Linq;
	using Microsoft.Diagnostics.Tracing;
	/// <summary>
	/// An EventListener is the most basic 'sink' for EventSource events.   All other sinks of 
	/// EventSource data can be thought of as 'built in' EventListeners.	In any particular 
	/// AppDomain all the EventSources send messages to any EventListener in the same
	/// AppDomain that have subscribed to them (using the EnableEvents API.
	/// <para>
	/// You create a particular kind of EventListener by subclassing the EventListener class
	/// Here we create an EventListener that 
	///   . Enables all events on any EventSource-derived class created in the appDomain
	///   . Sends all events raised by the event source classes created to the 'Out' textWriter 
	///	 (typically the Console).  
	/// </para>
	/// </summary>
	public class ConsoleEventListener : EventListener
	{
		static TextWriter Out = Console.Out;
		/// <summary>
		/// Override this method to get a list of all the eventSources that exist.  
		/// </summary>
		protected override void OnEventSourceCreated(EventSource eventSource)
		{
			// Because we want to turn on every EventSource, we subscribe to a callback that triggers
			// when new EventSources are created.  It is also fired when the EventListner is created
			// for all pre-existing EventSources.  Thus this callback get called once for every 
			// EventSource regardless of the order of EventSource and EventListener creation.  
			// For any EventSource we learn about, turn it on.   
			//Console.WriteLine(eventSource.GetType());
			EnableEvents
				(
					eventSource
					, EventLevel.LogAlways
					, EventKeywords.All
				);
		}
		/// <summary>
		/// We override this method to get a callback on every event we subscribed to with EnableEvents
		/// </summary>
		/// <param name="eventData"></param>
		protected override void OnEventWritten(EventWrittenEventArgs eventData)
		{
			// report all event information
			Out.Write
					(
						"  Event {0} "
						, eventData.EventName
					);
			// Don't display activity information, as that's not used in the demos
			// Out.Write(" (activity {0}{1}) ", ShortGuid(eventData.ActivityId), 
			//								  eventData.RelatedActivityId != Guid.Empty ? "->" + ShortGuid(eventData.RelatedActivityId) : "");
			// Events can have formatting strings 'the Message property on the 'Event' attribute.  
			// If the event has a formatted message, print that, otherwise print out argument values.  
			if (eventData.Message != null)
			{
				Out.WriteLine
					(
						eventData.Message
						, eventData.Payload != null
							?
							eventData.Payload.ToArray()
							:
							null
					);
			}
			else
			{
				string[] sargs =
									(
										eventData.Payload != null
										?
										eventData
											.Payload
											.Select(o => o.ToString())
											.ToArray()
										:
										null
									);
				Out.WriteLine("({0}).", sargs != null ? string.Join(", ", sargs) : "");
			}
		}
	}
}
namespace Microshaoft
{
	/// <summary>
	/// For the Windows EventLog to listen for EventSources, they must be
	/// registered with the operating system.  This is a deployment step 
	/// (typically done by a installer).   For demo purposes, however we 
	/// have written code run by the demo itself that accomplishes this 
	/// </summary>
	using System;
	using System.IO;
	using System.Diagnostics;
	using System.Threading;
	public static class RegisterEventSourceWithOperatingSystemHelper
	{
		static TextWriter Out = Console.Out;
		/// <summary>
		/// Simulate an installation to 'destFolder' for the named eventSource.  If you don't
		/// specify eventSourceName all eventSources information next to the EXE is registered.
		/// </summary>
		public static void SimulateInstall
								(
									string sourceFolder
									, string destFolder
									, string eventSourceName = ""
									, bool prompt = true
								)
		{
			Out.WriteLine("Simulating the steps needed to register the EventSource with the OS");
			Out.WriteLine("These steps are only needed for Windows Event Log support.");
			Out.WriteLine("Admin privileges are needed to do this, so you will see elevation prompts");
			Out.WriteLine("If you are not already elevated.  Consider running from an admin window.");
			Out.WriteLine();
			if (prompt)
			{
				Out.WriteLine("Press <Enter> to proceed with installation");
				Console.ReadLine();
			}
			Out.WriteLine("Deploying EventSource to {0}", destFolder);
			// create deployment folder if needed
			if (Directory.Exists(destFolder))
			{
				Out.WriteLine("Error: detected a previous deployment.   Cleaning it up.");
				SimulateUninstall(destFolder, false);
				Out.WriteLine("Done Cleaning up orphaned installation.");
			}
			Out.WriteLine("Copying the EventSource manifest and compiled Manifest DLL to target directory.");
			Directory.CreateDirectory(destFolder);
			foreach (var filename in Directory.GetFiles(sourceFolder, "*" + eventSourceName + "*.etwManifest.???"))
			{
				var destPath = Path.Combine(destFolder, Path.GetFileName(filename));
				Out.WriteLine("xcopy \"{0}\" \"{1}\"", filename, destPath);
				File.Copy(filename, destPath, true);
			}
			Out.WriteLine("Registering the manifest with the OS (Need to be elevated)");
			foreach (var filename in Directory.GetFiles(destFolder, "*.etwManifest.man"))
			{
				var commandArgs = string
										.Format
											(
												"im {0} /rf:\"{1}\" /mf:\"{1}\""
												, filename
												, Path.Combine
														(
															destFolder
															, Path.GetFileNameWithoutExtension(filename) + ".dll"
														)
											);
				// as a precaution uninstall the manifest.   It is easy for the demos to not be cleaned up 
				// and the install will fail if the EventSource is already registered.   
				var process = Process
								.Start
									(
										new ProcessStartInfo("wevtutil.exe", "um" + commandArgs.Substring(2))
										{
											Verb = "runAs"
											,
											RedirectStandardOutput = true
											,
											UseShellExecute = false
										}
									);
				Out.WriteLine("  wevtutil " + commandArgs);
				Console.WriteLine
						(
							"wevtutil OUTPUT: {0}"
							, process.StandardOutput.ReadToEnd()
						);
				process.WaitForExit();
				Thread.Sleep(200);		// just in case elevation makes the wait not work.  
										  // The 'RunAs' indicates it needs to be elevated. 
										  // Unfortunately this also makes it problematic to get the output or error code.  
				Out.WriteLine("  wevtutil " + commandArgs);
				process = Process
							.Start
								(
									new ProcessStartInfo("wevtutil.exe", commandArgs)
									{
										Verb = "runAs"
										,
										RedirectStandardOutput = true
										,
										UseShellExecute = false
									}
								);
				Console.WriteLine
						(
							"wevtutil OUTPUT: {0}"
							, process.StandardOutput.ReadToEnd()
						);
				process.WaitForExit();
			}
			Thread.Sleep(1000);
			Out.WriteLine("Done deploying app.");
			Out.WriteLine();
		}
		/// <summary>
		/// Reverses the Install step 
		/// </summary>
		public static void SimulateUninstall(string destFolder, bool prompt = true)
		{
			Out.WriteLine("Uninstalling the EventSoure demos from {0}", destFolder);
			Out.WriteLine("This also requires elevation.");
			Out.WriteLine("Please close the event viewer if you have not already done so!");
			if (prompt)
			{
				Out.WriteLine("Press <Enter> to proceed with uninstall.");
				Console.ReadLine();
			}
			// run wevtutil elevated to unregister the ETW manifests
			Out.WriteLine("Unregistering manifests");
			foreach (var filename in Directory.GetFiles(destFolder, "*.etwManifest.man"))
			{
				var commandArgs = string.Format("um {0}", filename);
				Out.WriteLine("	wevtutil " + commandArgs);
				// The 'RunAs' indicates it needs to be elevated.  
				var process = Process.Start(new ProcessStartInfo("wevtutil.exe", commandArgs) { Verb = "runAs" });
				process.WaitForExit();
			}
			Out.WriteLine("Removing {0}", destFolder);
			// If this fails, it means that something is using the directory.  Typically this is an eventViewer or 
			// a command prompt in that directory or visual studio.	If all else fails, rebooting should fix this.  
			if (Directory.Exists(destFolder))
			{
				Directory.Delete(destFolder, true);
			}
			Out.WriteLine("Done uninstalling app.");
		}
	}
}

#T=Etw OopConsoleTraceEventListenerMonitorController Consumer
// OopConsoleTraceEventListenerMonitor_TraceControllerEventsConsumer.cs
/*
	# Microshaoft
	/r:System.Xaml.dll
	/r:System.Activities.dll
	/r:System.Activities.DurableInstancing.dll
	/r:System.Runtime.DurableInstancing.dll
	/r:"D:\Microshaoft.Nuget.Packages\Newtonsoft.Json.7.0.1\lib\net45\Newtonsoft.Json.dll"
	/r:"D:\Microshaoft.Nuget.Packages\Microsoft.Diagnostics.Tracing.EventSource.Redist.1.1.28\lib\net46\Microsoft.Diagnostics.Tracing.EventSource.dll"
	/r:"D:\Microshaoft.Nuget.Packages\Microsoft.Diagnostics.Tracing.TraceEvent.1.0.40\lib\net40\Microsoft.Diagnostics.Tracing.TraceEvent.dll"
*/
namespace Test_OopConsoleTraceEventListenerMonitor_TraceControllerEventsConsumer
{
	using Microshaoft;
	using Microsoft.Diagnostics.Tracing;
	using Microsoft.Diagnostics.Tracing.Session;
	using System;
	using System.Diagnostics;
	using System.IO;
	using System.Linq;
	class Program
	{
		static TextWriter Out = Console.Out;
		static void Main(string[] args)
		{
			Console.Title = Process.GetCurrentProcess().ProcessName;
			Action<long, TraceEventDispatcher, TraceEventSession, TraceEvent>
					action =
							(id, source, session, data) =>
							{
								var s = data
											.PayloadNames
											.Select
												(
													(x) =>
													{
														return
															string
																.Format
																	(
																		"{1}{0}{2}"
																		, " : "
																		, x
																		, data.PayloadByName(x)
																	);
													}
												)
											.Aggregate
												(
													(x, y) =>
													{
														return
															string
																.Format
																	(
																		"{1}{0}{2}"
																		, "\r\n"
																		, x
																		, y
																	);
													}
												);
								s = string
										.Format
											(
												"{1}{0}{3}{0}{2}"
												, "\r\n"
												, ">>>>>>>>>>"
												, "<<<<<<<<<<"
												, string
													.Format
														(
															"{2}{0}{3}{1}{4}"
															, " : "
															, "\r\n"
															, nameof(data.EventName)
															, string
																.Format
																	(
																		"{0} hits ({1})"
																		, data.EventName
																		, id
																	)
															, s
														)
											);
								Console.WriteLine(s);
								if (session != null)
								{
									Console.WriteLine(session.FileName);
								}
							};
			var providerName = "Microshaoft-EventLogEventSource-001";
			var sessionName = "zTest";
			var tracedFileName = @"D:\EtwLogs\zTest.etl";
			var tracingFileName = string.Empty;
									//@"D:\EtwLogs\zTest3.etl";
									//+ string
									//	 .Format
									//		 (
									//			 "{1}{0}{2}{0}{3}{0}{4}"
									//			 , "."
									//			 , providerName
									//			 , sessionName
									//			 , DateTimeHelper.GetAlignSecondsDateTime(DateTime.Now, 60).ToString("yyyy-MM-dd.HH")
									//			 , "etl"
									//		 );
			var traceEvents = new string[]
									{
										"WriteEvent1Log"
										//, "WriteEvent2Log"
									};
			TraceEventsHelper
				.TraceETWTraceEventSourceAsync
					(
						providerName
						, tracedFileName
						, traceEvents
						, action
						, needCountHits : true
					);
			TraceEventsHelper
					.RealTimeTraceEventSessionAsync
						(
							providerName
							, sessionName + "1"
							, tracingFileName
							, traceEvents
							, action
							, traceEventSourceType: TraceEventSourceType.Session
							, needCountHits: true
						);
			var tracker = new TraceEventsTracker();
			//var tracingFileName = "";
			tracker
				.RealTimeTraceEventSessionAsync
					(
						providerName
						, sessionName + "2"
						, tracingFileName
						, traceEvents
						,
							(
								long id
								, TraceEventDispatcher source
								, TraceEventSession session
								, TraceEvent data
							) =>
						{
							action(id, source, session, data);
						}
						, needCountHits: true
					);
			//tracker = new TraceEventsTracker();
			//tracker
			//	.TraceETWTraceEventSourceAsync
			//		(
			//			providerName
			//			, etlFileName
			//			, traceEvents
			//			, true
			//			,
			//				(
			//					long id
			//					, TraceEventDispatcher source
			//					, TraceEventSession session
			//					, TraceEvent data
			//				) =>
			//				{
			//					action(id, source, session, data);
			//				}
			//		);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using Microsoft.Diagnostics.Tracing;
	using Microsoft.Diagnostics.Tracing.Session;
	//using Diagnostics.Tracing.Parsers;
	using System;
	using System.IO;
	using System.Threading.Tasks;
	using System.Threading;
	public class TraceEventsTracker
	{
		public Task<bool> RealTimeTraceEventSessionAsync
					(
						string providerName
						, string sessionName
						, string tracingFileName = null
						, string[] traceEvents = null
						, Action
								<
									long
									, TraceEventDispatcher
									, TraceEventSession
									, TraceEvent
								> onOneEventTracedOnceProcessAction = null
						, TraceEventProviderOptions traceEventProviderOptions = null
						, TraceEventSessionOptions traceEventSessionOptions = TraceEventSessionOptions.Create
						, TraceEventSourceType traceEventSourceType = TraceEventSourceType.MergeAll
						, TraceEventLevel traceEventLevel = TraceEventLevel.Always
						, ulong matchKeywords = ulong.MaxValue
						, bool needCountHits = false
					)
		{
			return
				Task
					.Factory
					.StartNew<bool>
						(
							() =>
							{
								return
									RealTimeTraceEventSession
										(
											providerName
											, sessionName
											, tracingFileName
											, traceEvents
											, onOneEventTracedOnceProcessAction
											, traceEventProviderOptions
											, traceEventSessionOptions
											, traceEventSourceType
											, traceEventLevel
											, matchKeywords
											, needCountHits
										);
							}
						);
		}
		public bool RealTimeTraceEventSession
			(
				string providerName
				, string sessionName
				, string tracingFileName = null
				, string[] traceEvents = null
				, Action
						<
							long
							, TraceEventDispatcher
							, TraceEventSession
							, TraceEvent
						> onOneEventTracedOnceProcessAction = null
				, TraceEventProviderOptions traceEventProviderOptions = null
				, TraceEventSessionOptions traceEventSessionOptions = TraceEventSessionOptions.Create
				, TraceEventSourceType traceEventSourceType = TraceEventSourceType.MergeAll
				, TraceEventLevel traceEventLevel = TraceEventLevel.Always
				, ulong matchKeywords = ulong.MaxValue
				, bool needCountHits = false)
		{
			
			var r = false;
			if
				(
					traceEvents != null
					&&
					traceEvents.Length > 0
					&&
					onOneEventTracedOnceProcessAction != null
				)
			{
				r = TraceEventsHelper
							.RealTimeTraceEventSession
								(
									providerName
									, sessionName
									, tracingFileName
									, traceEvents
									, onOneEventTracedOnceProcessAction
									, traceEventProviderOptions
									, traceEventSessionOptions
									, traceEventSourceType
									, traceEventLevel
									, matchKeywords
									, needCountHits
								);
			}
			return r;
		}
		public Task<bool> TraceETWTraceEventSourceAsync
					(
						string providerName
						, string tracedFileName
						, string[] traceEvents = null
						, Action
								<
									long
									, TraceEventDispatcher
									, TraceEventSession
									, TraceEvent
								> onOneEventTracedOnceProcessAction = null
						, TraceEventProviderOptions traceEventProviderOptions = null
						, TraceEventSourceType traceEventSourceType = TraceEventSourceType.MergeAll
						, TraceEventLevel traceEventLevel = TraceEventLevel.Always
						, ulong matchKeywords = ulong.MaxValue
						, bool needCountHits = false
					)
		{
			return
				Task
					.Factory
					.StartNew<bool>
						(
							() =>
							{
								return
									TraceETWTraceEventSource
									(
										providerName
										, tracedFileName
										, traceEvents
										, onOneEventTracedOnceProcessAction
										, traceEventProviderOptions
										, traceEventSourceType
										, traceEventLevel
										, matchKeywords
										, needCountHits
									);
							}
						);
		}
		public bool TraceETWTraceEventSource
					(
						string providerName
						, string tracedFileName
						, string[] traceEvents = null
						, Action
								<
									long
									, TraceEventDispatcher
									, TraceEventSession
									, TraceEvent
								> onOneEventTracedOnceProcessAction = null
						, TraceEventProviderOptions traceEventProviderOptions = null
						, TraceEventSourceType traceEventSourceType = TraceEventSourceType.MergeAll
						, TraceEventLevel traceEventLevel = TraceEventLevel.Always
						, ulong matchKeywords = ulong.MaxValue
						, bool needCountHits = false
					)
		{
			var r = false;
			if
				(
					traceEvents != null
					&&
					traceEvents.Length > 0
					&&
					onOneEventTracedOnceProcessAction != null
				)
			{
				r = TraceEventsHelper
							.TraceETWTraceEventSource
								(
									providerName
									, tracedFileName
									, traceEvents
									, onOneEventTracedOnceProcessAction
									, traceEventProviderOptions
									, traceEventSourceType
									, traceEventLevel
									, matchKeywords
									, needCountHits
								);
			}
			return r;
		}
	}
	public static class TraceEventsHelper
	{
		private static TextWriter Out = Console.Out;
		public static Task<bool> TraceETWTraceEventSourceAsync
							 (
								string providerName
								, string tracedFileName
								, string[] traceEvents = null
								, Action
										<
											long
											, TraceEventDispatcher
											, TraceEventSession
											, TraceEvent
										> onOneEventTracedOnceProcessAction = null
								, TraceEventProviderOptions traceEventProviderOptions = null
								, TraceEventSourceType traceEventSourceType = TraceEventSourceType.MergeAll
								, TraceEventLevel traceEventLevel = TraceEventLevel.Always
								, ulong matchKeywords = ulong.MaxValue
								, bool needCountHits = false
							)
		{
			return
				Task
					.Factory
					.StartNew<bool>
						(
							() =>
							{
								return
									TraceETWTraceEventSource
										(
											providerName
											, tracedFileName
											, traceEvents
											, onOneEventTracedOnceProcessAction
											, traceEventProviderOptions
											, traceEventSourceType
											, traceEventLevel
											, matchKeywords
											, needCountHits
										);
							}
							,
								TaskCreationOptions.LongRunning
								|
								TaskCreationOptions.DenyChildAttach
						);
		}
		public static bool TraceETWTraceEventSource
							(
								string providerName
								, string tracedFileName
								, string[] traceEvents = null
								, Action
										<
											long
											, TraceEventDispatcher
											, TraceEventSession
											, TraceEvent
										> onOneEventTracedOnceProcessAction = null
								, TraceEventProviderOptions traceEventProviderOptions = null
								, TraceEventSourceType traceEventSourceType = TraceEventSourceType.MergeAll
								, TraceEventLevel traceEventLevel = TraceEventLevel.Always
								, ulong matchKeywords = ulong.MaxValue
								, bool needCountHits = false
							)
		{
			var r = false;
			if (!(TraceEventSession.IsElevated() ?? false))
			{
				Out.WriteLine("To turn on ETW events you need to be Administrator, please run from an Admin process.");
				return r;
			}
			if
				(
					traceEvents != null
					&&
					traceEvents.Length > 0
					&&
					onOneEventTracedOnceProcessAction != null
				)
			{
					using (var source = new ETWTraceEventSource(tracedFileName, traceEventSourceType))
					{
						//闭包
						long sequence = 0;
						RegisterCallbacks
							(
								providerName
								, traceEvents
								, source
								, null
								, (x, y, z) =>
								{
									long id = 0;
									if (needCountHits)
									{
										id = Interlocked.Increment(ref sequence);
									}
									onOneEventTracedOnceProcessAction
													(
														id
														, x
														, y
														, z
													);
								} 
							);
						source.Process();   // call the callbacks for each event
					}
			}
			return true;
		}
		public static Task<bool> RealTimeTraceEventSessionAsync
							(
								string providerName
								, string sessionName
								, string tracingFileName = null
								, string[] traceEvents = null
								, Action
										<
											long
											, TraceEventDispatcher
											, TraceEventSession
											, TraceEvent
										> onOneEventTracedOnceProcessAction = null
								, TraceEventProviderOptions traceEventProviderOptions = null
								, TraceEventSessionOptions traceEventSessionOptions = TraceEventSessionOptions.Create
								, TraceEventSourceType traceEventSourceType = TraceEventSourceType.MergeAll
								, TraceEventLevel traceEventLevel = TraceEventLevel.Always
								, ulong matchKeywords = ulong.MaxValue
								, bool needCountHits = false
							)
		{
			return
				Task
					.Factory
					.StartNew<bool>
						(
							() =>
							{
								return
									RealTimeTraceEventSession
										(
											providerName
											, sessionName
											, tracingFileName
											, traceEvents
											, onOneEventTracedOnceProcessAction
											, traceEventProviderOptions
											, traceEventSessionOptions
											, traceEventSourceType
											, traceEventLevel
											, matchKeywords
											, needCountHits
										);
							}
							, 
								TaskCreationOptions.LongRunning
								|
								TaskCreationOptions.DenyChildAttach
						);
		}
		public static bool RealTimeTraceEventSession
			(
				string providerName
				, string sessionName
				, string tracingFileName = null
				, string[] traceEvents = null
				, Action
						<
							long
							, TraceEventDispatcher
							, TraceEventSession
							, TraceEvent
						> onOneEventTracedOnceProcessAction = null
				, TraceEventProviderOptions traceEventProviderOptions = null
				, TraceEventSessionOptions traceEventSessionOptions = TraceEventSessionOptions.Create
				, TraceEventSourceType traceEventSourceType = TraceEventSourceType.MergeAll
				, TraceEventLevel traceEventLevel = TraceEventLevel.Always
				, ulong matchKeywords = ulong.MaxValue
				, bool needCountHits = false
			)
		{
			var r = false;
			if (!(TraceEventSession.IsElevated() ?? false))
			{
				Out.WriteLine("To turn on ETW events you need to be Administrator, please run from an Admin process.");
				return r;
			}
			var needTracingFile = !string.IsNullOrEmpty(tracingFileName);
			if
				(
					traceEvents != null
					&&
					traceEvents.Length > 0
					&&
					onOneEventTracedOnceProcessAction != null
				)
			{
					using
						(
							var session =
									(
										needTracingFile
										?
										new TraceEventSession
													(
														sessionName
														, tracingFileName
														, traceEventSessionOptions
													)
										{
											StopOnDispose = true
										}
										:
										new TraceEventSession
													(
														sessionName
														, traceEventSessionOptions
													)
										{
											StopOnDispose = true
										}
									) 
						)
					{
					using
						(
							var source = 
										(
											needTracingFile
											?
											new ETWTraceEventSource(tracingFileName)
											:
											session.Source
										)
							)
						{
							long sequence = 0;
							RegisterCallbacks
								(
									providerName
									, traceEvents
									, source
									, session
									, (x, y, z) =>
									{
										long id = 0;
										if (needCountHits)
										{
											id = Interlocked.Increment(ref sequence);
										}
										onOneEventTracedOnceProcessAction
														(
															id
															, x
															, y
															, z
														);
									}
								);
							var restarted = session
												.EnableProvider
													(
														providerName
														, traceEventLevel
														, matchKeywords
														, traceEventProviderOptions
													);
							source
								.Process();
							r = true;
						}
					}
				
			}
			return r;
		}
		private static void RegisterCallbacks
								(
									string providerName
									, string[] traceEvents
									, TraceEventDispatcher source
									, TraceEventSession session
									, Action
											<
												TraceEventDispatcher
												, TraceEventSession
												, TraceEvent
											> onOneEventTracedOnceProcessAction
								)
		{
			int l = traceEvents.Length;
			for (int i = 0; i < l; i++)
			{
				var eventName = traceEvents[i];
				var action = onOneEventTracedOnceProcessAction;
				if (action != null)
				{
					if (string.Compare(eventName, "*") == 0)
					{
						source
							.Dynamic
							.All +=
									delegate (TraceEvent data)
									{
										action(source, session, data);
									};
					}
					else if (string.Compare(eventName, "UnhandledEvents") == 0)
					{
						source
							.UnhandledEvents
								+= delegate (TraceEvent data)
								{
									action(source, session, data);
								};
					}
					else
					{
						source
							.Dynamic
							.AddCallbackForProviderEvent
								(
									providerName
									, eventName
									, delegate (TraceEvent data)
									{
										action(source, session, data);
									}
								);
					}
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Globalization;
	public static class DateTimeHelper
	{
		public static void GetAlignSecondsDateTimes<T>
								(
									DateTime time
									, params Tuple<long, Func<DateTime, long, DateTime, T, T>>[] processAlignSecondsDateTimesFuncs
								)
		{
			T r = default(T);
			foreach (var x in processAlignSecondsDateTimesFuncs)
			{
				var alignSeconds = x.Item1;
				var alignTime = DateTimeHelper.GetAlignSecondsDateTime(time, alignSeconds);
				if (x.Item2 != null)
				{
					r = x.Item2(time, alignSeconds, alignTime, r);
				}
			}
		}
		public static bool IsVaildateTimestamp(DateTime timeStamp, int timeoutSeconds)
		{
			long l = SecondsDiffNow(timeStamp);
			return ((l > 0) && (l < timeoutSeconds));
		}
		public static long MillisecondsDiffNow(DateTime time)
		{
			long now = DateTime.Now.Ticks;
			long t = time.Ticks;
			return (t - now) / 10000;
		}
		public static long SecondsDiffNow(DateTime time)
		{
			return MillisecondsDiffNow(time) / 1000;
		}
		public static DateTime GetAlignSecondsDateTime(DateTime time, long alignSeconds)
		{
			long ticks = time.Ticks;
			ticks -= ticks % (10000 * 1000 * alignSeconds);
			DateTime dt = new DateTime(ticks);
			return dt;
		}
		public static string GetDateTimeString(DateTime time, string format)
		{
			return time.ToString(format);
		}
		public static DateTime GetPeriodBeginDate(DateTime time, int days)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * days);
			return r;
		}
		public static DateTime GetPeriodEndDate(DateTime time, int days)
		{
			DateTime r = GetPeriodBeginDate(time, days).AddDays(days - 1);
			return r;
		}
		public static DateTime GetWeekMondayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7);
			return r;
		}
		public static DateTime GetWeekTuesdayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(1);
			return r;
		}
		public static DateTime GetWeekWednesdayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(2);
			return r;
		}
		public static DateTime GetWeekThursdayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(3);
			return r;
		}
		public static DateTime GetWeekFridayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(4);
			return r;
		}
		public static DateTime GetWeekSaturdayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(5);
			return r;
		}
		public static DateTime GetWeekSundayDateTime(DateTime time)
		{
			DateTime r = GetAlignSecondsDateTime(time, 86400 * 7).AddDays(6);
			return r;
		}
		public static DateTime? ParseExactNullableDateTime(string text, string format)
		{
			DateTime time;
			DateTime? r = DateTime.TryParseExact
										(
											text
											, format
											, DateTimeFormatInfo.InvariantInfo
											, DateTimeStyles.None
											, out time
										) ? time as DateTime? : null;
			return r;
		}
	}
}

#T=ETW Samples EventSource Listener
/*
/r:"D:\Microshaoft.Nuget.Packages\Microsoft.Diagnostics.Tracing.EventSource.Redist.1.1.28\lib\net46\Microsoft.Diagnostics.Tracing.EventSource.dll"
*/
namespace ConsoleApplication1
{
	using Microshaoft;
	using Microshaoft.EventListeners;
	using Microshaoft.EventSources;
	using System;
	using System.IO;
	using System.Security.Principal;
	class Program
	{
		static void Main(string[] args)
		{
			// Deploy the app
			var DeploymentFolder = Path
									.Combine
										(
											Environment
												.GetFolderPath
													(
														Environment
															.SpecialFolder
															.CommonApplicationData
													)
											, @"EventSourceSamples"
										);
			RegisterEventSourceWithOperatingSystemHelper
					.SimulateInstall
							(
								@"D:\MyC#\EtwOk\EventSources\bin\Debug"
								, DeploymentFolder
								, EventLogEventSource.Log.Name
							);

			string input = string.Empty;
			using (var listener = new ConsoleEventListener())
			{
				while ("q" != (input = Console.ReadLine()).Trim().ToLower())
				{
					EventLogEventSource
						.Log
						.WriteEvent1Log
							(
								1
								, Guid.NewGuid()
								, WindowsIdentity.GetCurrent().Name
								, "这是一个测试 WriteEvent1Log"
							);
					EventLogEventSource
						.Log
						.WriteEvent2Log
							(
								2
								, Guid.NewGuid()
								, WindowsIdentity.GetCurrent().Name
								, "这是一个测试 WriteEvent2 Log"
							);
				}
			}
			Console.ReadLine();
		}
	}
}
namespace Microshaoft.EventSources
{
	using System;
	using Microsoft.Diagnostics.Tracing;
	//
	// Shows how to use EventSouces to send messages to the Windows EventLog
	//
	// * EventLogEventSource
	//	 * Uses the new 'Channel' attribute to indicate that certain events
	//	   should go to the Windows Event Log.   Note that the EventSource
	//	   has to be registered with the Windows OS for this to work.  
	//	   In this example we send messages to the 'Admin' channel.   
	//
	// * EventLogEventSourceDemo 
	//	 * simulates a deployment step needed to register the event source's 
	//	   manifest on the machine. If running unelevated it will prompt the user
	//	   to allow running wevtutil.exe, the tool that performs the registration.
	//
	//	 * simulates processing multiple requests by calling the methods on 
	//	   EventLogEventSource to fire events.
	//	 * pauses to allow the user to examine the event logs created under 
	//	   'Application and Services Logs/Microsoft/EventSourceDemos/Channeled'
	//
	//	 * undoes the registration steps performed earlier.
	//
	[
		EventSource
			(
				Name = "Microshaoft-EventLogEventSource-001" //"Samples-EventSourceDemos-EventLog"
			)
	]
	public sealed class EventLogEventSource : EventSource
	{
		#region Singleton instance
		public static EventLogEventSource Log = new EventLogEventSource();
		#endregion
		[
			Event
				(
					1
					, ActivityOptions = EventActivityOptions.None
					, Channel = EventChannel.Admin
					, Keywords = Keywords.EventKeyword1
					//, Level = EventLevel.LogAlways
					, Message = 
@"
	sequenceID : ""{0}""
	, sessionID : ""{1}""
	, operatorID : ""{2}""
	, data : ""{3}""
"
					, Opcode = EventOpcode.Info
					, Tags = EventTags.None
					, Task = EventTasks.EventTask1
					, Version = 1 
				)
		]
		public void WriteEvent1Log
					(
						int sequenceID
						, Guid sessionID
						, string operatorID
						, string data
					)
		{
			WriteEvent
				(
					1
					, (object) sequenceID
					, (object) sessionID
					, (object) operatorID
					, (object) data
				);
		}
		[
			Event
				(
					2
					, ActivityOptions = EventActivityOptions.None
					, Channel = EventChannel.Admin
					, Keywords = Keywords.EventKeyword2
					//, Level = EventLevel.LogAlways
					, Message =
@"
	sequenceID : ""{0}""
	, sessionID : ""{1}""
	, operatorID : ""{2}""
	, data : ""{3}""
"
					, Opcode = EventOpcode.Info
					, Tags = Tags.EventTag2
					, Task = EventTasks.EventTask2
					, Version = 1
				)
		]
		public void WriteEvent2Log
			(
				int sequenceID
				, Guid sessionID
				, string operatorID
				, string data
			)
		{
			WriteEvent
				(
					2
					, (object)sequenceID
					, (object)sessionID
					, (object)operatorID
					, (object)data
				);
		}
		#region Keywords / Tasks / Opcodes
		public class Keywords   // This is a bitvector
		{
			public const EventKeywords EventKeyword1 = (EventKeywords)0x00000001;
			public const EventKeywords EventKeyword2 = (EventKeywords)0x00000002;
		}
		public class EventTasks
		{
			//[1,65534]
			public const EventTask EventTask1 = (EventTask) 1;
			public const EventTask EventTask2 = (EventTask) 2;
		}
		public class EventOpcodes
		{
			public const EventOpcode EventOpcode_0x0b = (EventOpcode)0x0b;
		}
		public class Tags
		{
			public const EventTags EventTag1 = (EventTags) 1;
			public const EventTags EventTag2 = (EventTags) 2;
		}
		#endregion
	}
}
namespace Microshaoft.EventListeners
{
	using System;
	using System.IO;
	using System.Linq;
	using Microsoft.Diagnostics.Tracing;
	/// <summary>
	/// An EventListener is the most basic 'sink' for EventSource events.   All other sinks of 
	/// EventSource data can be thought of as 'built in' EventListeners.	In any particular 
	/// AppDomain all the EventSources send messages to any EventListener in the same
	/// AppDomain that have subscribed to them (using the EnableEvents API.
	/// <para>
	/// You create a particular kind of EventListener by subclassing the EventListener class
	/// Here we create an EventListener that 
	///   . Enables all events on any EventSource-derived class created in the appDomain
	///   . Sends all events raised by the event source classes created to the 'Out' textWriter 
	///	 (typically the Console).  
	/// </para>
	/// </summary>
	public class ConsoleEventListener : EventListener
	{
		static TextWriter Out = Console.Out;
		/// <summary>
		/// Override this method to get a list of all the eventSources that exist.  
		/// </summary>
		protected override void OnEventSourceCreated(EventSource eventSource)
		{
			// Because we want to turn on every EventSource, we subscribe to a callback that triggers
			// when new EventSources are created.  It is also fired when the EventListner is created
			// for all pre-existing EventSources.  Thus this callback get called once for every 
			// EventSource regardless of the order of EventSource and EventListener creation.  
			// For any EventSource we learn about, turn it on.   
			//Console.WriteLine(eventSource.GetType());
			EnableEvents
				(
					eventSource
					, EventLevel.LogAlways
					, EventKeywords.All
				);
		}
		/// <summary>
		/// We override this method to get a callback on every event we subscribed to with EnableEvents
		/// </summary>
		/// <param name="eventData"></param>
		protected override void OnEventWritten(EventWrittenEventArgs eventData)
		{
			// report all event information
			Out.Write
					(
						"  Event {0} "
						, eventData.EventName
					);
			// Don't display activity information, as that's not used in the demos
			// Out.Write(" (activity {0}{1}) ", ShortGuid(eventData.ActivityId), 
			//								  eventData.RelatedActivityId != Guid.Empty ? "->" + ShortGuid(eventData.RelatedActivityId) : "");
			// Events can have formatting strings 'the Message property on the 'Event' attribute.  
			// If the event has a formatted message, print that, otherwise print out argument values.  
			if (eventData.Message != null)
			{
				Out.WriteLine
					(
						eventData.Message
						, eventData.Payload != null 
							?
							eventData.Payload.ToArray()
							:
							null
					);
			}
			else
			{
				string[] sargs =
									(
										eventData.Payload != null
										?
										eventData
											.Payload
											.Select(o => o.ToString())
											.ToArray()
										:
										null
									);
				Out.WriteLine("({0}).", sargs != null ? string.Join(", ", sargs) : "");
			}
		}
	}
}
namespace Microshaoft
{
	/// <summary>
	/// For the Windows EventLog to listen for EventSources, they must be
	/// registered with the operating system.  This is a deployment step 
	/// (typically done by a installer).   For demo purposes, however we 
	/// have written code run by the demo itself that accomplishes this 
	/// </summary>
	using System;
	using System.IO;
	using System.Diagnostics;
	using System.Threading;
	public static class RegisterEventSourceWithOperatingSystemHelper
	{
		static TextWriter Out = Console.Out;
		/// <summary>
		/// Simulate an installation to 'destFolder' for the named eventSource.  If you don't
		/// specify eventSourceName all eventSources information next to the EXE is registered.
		/// </summary>
		public static void SimulateInstall
								(
									string sourceFolder
									, string destFolder
									, string eventSourceName = ""
									, bool prompt = true
								)
		{
			Out.WriteLine("Simulating the steps needed to register the EventSource with the OS");
			Out.WriteLine("These steps are only needed for Windows Event Log support.");
			Out.WriteLine("Admin privileges are needed to do this, so you will see elevation prompts");
			Out.WriteLine("If you are not already elevated.  Consider running from an admin window.");
			Out.WriteLine();
			if (prompt)
			{
				Out.WriteLine("Press <Enter> to proceed with installation");
				Console.ReadLine();
			}
			Out.WriteLine("Deploying EventSource to {0}", destFolder);
			// create deployment folder if needed
			if (Directory.Exists(destFolder))
			{
				Out.WriteLine("Error: detected a previous deployment.   Cleaning it up.");
				SimulateUninstall(destFolder, false);
				Out.WriteLine("Done Cleaning up orphaned installation.");
			}
			Out.WriteLine("Copying the EventSource manifest and compiled Manifest DLL to target directory.");
			Directory.CreateDirectory(destFolder);
			
			foreach (var filename in Directory.GetFiles(sourceFolder, "*" + eventSourceName + "*.etwManifest.???"))
			{
				var destPath = Path.Combine(destFolder, Path.GetFileName(filename));
				Out.WriteLine("xcopy \"{0}\" \"{1}\"", filename, destPath);
				File.Copy(filename, destPath, true);
			}
			Out.WriteLine("Registering the manifest with the OS (Need to be elevated)");
			foreach (var filename in Directory.GetFiles(destFolder, "*.etwManifest.man"))
			{
				var commandArgs = string
										.Format
											(
												"im {0} /rf:\"{1}\" /mf:\"{1}\""
												, filename
												, Path.Combine
														(
															destFolder
															, Path.GetFileNameWithoutExtension(filename) + ".dll"
														)
											);
				// as a precaution uninstall the manifest.   It is easy for the demos to not be cleaned up 
				// and the install will fail if the EventSource is already registered.   
				var process = Process
								.Start
									(
										new ProcessStartInfo("wevtutil.exe", "um" + commandArgs.Substring(2))
										{
											Verb = "runAs"
											, RedirectStandardOutput = true
											, UseShellExecute = false
										}
									);
				Out.WriteLine("  wevtutil " + commandArgs);
				Console.WriteLine
						(
							"wevtutil OUTPUT: {0}"
							, process.StandardOutput.ReadToEnd()
						);
				process.WaitForExit();
				Thread.Sleep(200);		  // just in case elevation makes the wait not work.  
				// The 'RunAs' indicates it needs to be elevated. 
				// Unfortunately this also makes it problematic to get the output or error code.  
				Out.WriteLine("  wevtutil " + commandArgs);
				process = Process
							.Start
								(
									new ProcessStartInfo("wevtutil.exe", commandArgs)
									{
										Verb = "runAs"
										, RedirectStandardOutput = true
										, UseShellExecute = false
									}
								);
				Console.WriteLine
						(
							"wevtutil OUTPUT: {0}"
							, process.StandardOutput.ReadToEnd()
						);
				process.WaitForExit();
			}
			Thread.Sleep(1000);
			Out.WriteLine("Done deploying app.");
			Out.WriteLine();
		}
		/// <summary>
		/// Reverses the Install step 
		/// </summary>
		public static void SimulateUninstall(string destFolder, bool prompt = true)
		{
			Out.WriteLine("Uninstalling the EventSoure demos from {0}", destFolder);
			Out.WriteLine("This also requires elevation.");
			Out.WriteLine("Please close the event viewer if you have not already done so!");
			if (prompt)
			{
				Out.WriteLine("Press <Enter> to proceed with uninstall.");
				Console.ReadLine();
			}
			// run wevtutil elevated to unregister the ETW manifests
			Out.WriteLine("Unregistering manifests");
			foreach (var filename in Directory.GetFiles(destFolder, "*.etwManifest.man"))
			{
				var commandArgs = string.Format("um {0}", filename);
				Out.WriteLine("	wevtutil " + commandArgs);
				// The 'RunAs' indicates it needs to be elevated.  
				var process = Process.Start(new ProcessStartInfo("wevtutil.exe", commandArgs) { Verb = "runAs" });
				process.WaitForExit();
			}
			Out.WriteLine("Removing {0}", destFolder);
			// If this fails, it means that something is using the directory.  Typically this is an eventViewer or 
			// a command prompt in that directory or visual studio.	If all else fails, rebooting should fix this.  
			if (Directory.Exists(destFolder))
			{
				Directory.Delete(destFolder, true);
			}
			Out.WriteLine("Done uninstalling app.");
		}
	}
}

#T=Eventlog Helper
^#define NET45
namespace Test
{
	using Microshaoft;
	using System;
	using System.Diagnostics;
	using System.IO;
	public class Program
	{
		public static void Main()
		{
^#if NET45
			var files = Directory.EnumerateFiles(@"d:\", "*.gz*", SearchOption.TopDirectoryOnly);
			foreach (var file in files)
			{
				var r = false;
				string path = string.Empty;
				try
				{
					if
						(
							GZipFileHelper
								.Decompress
									(
										file
										, @"d:\temp"
										, (x) =>
										{
											var s = ".Gz";
											int p = x.ToLower().LastIndexOf(s.ToLower());
											if (p > 0)
											{
												x = x.Remove(p, s.Length);
											}
											return x;
										}
										, out path
									)
						)
					{
						r = PathFileHelper
								.MoveFileTo
									(
										path
										, @"d:\Temp"
										, @"d:\Temp2"
										, true
									);
					}
				}
				catch (Exception e)
				{
					string log = string
									.Format
										(
											"Process file: [{1}] caught exception:{0}{2}"
											, "\r\n"
											, file
											, e.ToString()
										);
					Console.Error.WriteLine(log);
					EventLogHelper
						.WriteEventLogEntry
							(
								""
								, log
								, EventLogEntryType.Error
								, 1001
							);
					r = false;
				}
				if (r)
				{
					PathFileHelper
							.MoveFileTo
								(
									file
									, @"d:\"
									, @"d:\Temp3"
									, true
								);
					Console.WriteLine("ok: {0}", file);
				}
				else
				{
					PathFileHelper
								.MoveFileTo
									(
										file
										, @"d:\Temp"
										, @"d:\Temp4"
										, true
									);
				}
			}
			Console.ReadLine();
^#endif
		}
	}
}
^#if NET45
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.IO.Compression;
	public static class GZipFileHelper
	{
		public static bool Decompress
							(
								string originalFileFullPath
								, string targetDirectoryPath
								, Func<string, string> onNamingDecompressedFileProcessFunc
								, out string decompressedFileFullPath
							)
		{
			var r = false;
			using (FileStream originalFileStream = File.OpenRead(originalFileFullPath))
			{
				var originalFileExtensionName = Path.GetExtension(originalFileFullPath);
				var originalDirectoryPath = Path.GetDirectoryName(originalFileFullPath);
				decompressedFileFullPath = PathFileHelper.GetNewPath(originalDirectoryPath, targetDirectoryPath, originalFileFullPath);
				string fileName = Path.GetFileName(decompressedFileFullPath);
				string directory = Path.GetDirectoryName(decompressedFileFullPath);
				if (onNamingDecompressedFileProcessFunc != null)
				{
					fileName = onNamingDecompressedFileProcessFunc(fileName);
				}
				decompressedFileFullPath = Path.Combine(directory, fileName);
				using (FileStream decompressedFileStream = File.Create(decompressedFileFullPath))
				{
					using (GZipStream decompressionStream = new GZipStream(originalFileStream, CompressionMode.Decompress))
					{
						decompressionStream.CopyTo(decompressedFileStream);
						r = true;
					}
				}
			}
			return r;
		}
	}
}
^#endif
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Linq;
	public static class PathFileHelper
	{
		public static bool MoveFileTo
							(
								string sourceFullPathFileName
								, string sourceDirectoryPath
								, string destDirectorytPath
								, bool deleteExistsDestFile = false
							)
		{
			var r = false;
			var destFullPathFileName = GetNewPath(sourceDirectoryPath, destDirectorytPath, sourceFullPathFileName);
			var directory = Path.GetDirectoryName(destFullPathFileName);
			if (File.Exists(directory))
			{
				File.Delete(directory);
			}
			if (!Directory.Exists(directory))
			{
				Directory.CreateDirectory(directory);
			}
			if (deleteExistsDestFile)
			{
				if (File.Exists(destFullPathFileName))
				{
					File.Delete(destFullPathFileName);
				}
			}
			File.Move(sourceFullPathFileName, destFullPathFileName);
			r = true;
			return r;
		}
		public static string GetValidPathOrFileName(string path, string replacement)
		{
			string s = string.Empty;
			var chars = Path.GetInvalidPathChars();
			chars = chars.Union(Path.GetInvalidFileNameChars()).ToArray();
			Array
				.ForEach
					(
						chars
						, (x) =>
						{
							s = s.Replace(x.ToString(), replacement);
						}
					);
			return s;
		}
		public static string GetNewPath(string oldDirectoryPath, string newDirectoryPath, string originalFileFullPath)
		{
			string newPath = newDirectoryPath;
			originalFileFullPath = Path.GetFullPath(originalFileFullPath);
			var directorySeparator = Path.DirectorySeparatorChar.ToString();
			oldDirectoryPath = Path.GetFullPath(oldDirectoryPath);
			newDirectoryPath = Path.GetFullPath(newDirectoryPath);
			if (!oldDirectoryPath.EndsWith(directorySeparator))
			{
				oldDirectoryPath += directorySeparator;
			}
			if (!newDirectoryPath.EndsWith(directorySeparator))
			{
				newDirectoryPath += directorySeparator;
			}
			string relativeDirectoryPath = string.Empty;
			int p = originalFileFullPath
						.ToLower()
						.IndexOf(oldDirectoryPath.ToLower());
			if (p >= 0)
			{
				p += oldDirectoryPath.Length;
				relativeDirectoryPath = originalFileFullPath.Substring(p);
				newPath = Path.Combine(newPath, relativeDirectoryPath);
			}
			newPath = Path.GetFullPath(newPath);
			return newPath;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Diagnostics;
	public static class EventLogHelper
	{
		private static string _processNameID = new Func<string>
												(
													() =>
													{
														var process = Process.GetCurrentProcess();
														return
															string.Format
																	(
																		"{1}{0}({2})"
																		, ""
																		, process.ProcessName
																		, process.Id
																	);
													}
												)();
		public static EventLog[] GetEventLogs()
		{
			var r = EventLog.GetEventLogs();
			return r;
		}
		public static void WriteEventLogEntry
										(
											//string logName,
											string sourceName,
											string logMessage,
											EventLogEntryType logEntryType
											, int eventID
										)
		{
			EventLog eventLog = new EventLog();
			eventLog.Source = sourceName;
			//eventLog.Log = logName;
			logMessage = string.Format
							(
								"{1}{0}Process [{3}] @ {4}{0}{5}{0}{2}"
								, "\r\n"
								, "begin ==========================================="
								, "end ============================================="
								, _processNameID
								, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
								, logMessage
							);
			eventLog.WriteEntry
				(
					logMessage
					, logEntryType
					, eventID
				);
		}
		public static bool TryCreateEventSourceLog
										(
											string logName,
											string sourceName,
											bool allowRecreate = false
										)
		{
			bool r = false;
			if (EventLog.SourceExists(sourceName))
			{
				if (allowRecreate)
				{
					try
					{
						var s = EventLog.LogNameFromSourceName(sourceName, ".");
						if (string.Compare(s, logName, true) != 0)
						{
							EventLog.DeleteEventSource(sourceName);
							EventLog.Delete(logName);
							EventLog.CreateEventSource(sourceName, logName);
							r = true;
						}
					}
					catch// (Exception e)
					{
						r = false;
					}
				}
				else
				{
					r = true;
				}
				
			}
			else
			{
				EventLog.CreateEventSource(sourceName, logName);
				r = true;
			}
			return r;
		}
	}
}

#T=Excel Automation/COM Sample
/*
	/r:"C:\Program Files\Microsoft Visual Studio 9.0\Visual Studio Tools for Office\PIA\Office12\Microsoft.Office.Interop.Excel.dll"
*/
namespace Microshaoft
{
	//-----------------------------------------------------------------------
	//  This file is part of the Microsoft .NET Framework SDK Code Samples.
	// 
	//  Copyright (C) Microsoft Corporation.  All rights reserved.
	// 
	//This source code is intended only as a supplement to Microsoft
	//Development Tools and/or on-line documentation.  See these other
	//materials for detailed information regarding Microsoft code samples.
	// 
	//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
	//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
	//PARTICULAR PURPOSE.
	//-----------------------------------------------------------------------
	using System;
	using System.Reflection; // For Missing.Value and BindingFlags
	using System.Runtime.InteropServices; // For COMException
	using Microsoft.Office.Interop.Excel;

	class AutoExcel {
		public static int Main() {
		
			Console.WriteLine ("Creating new Excel.Application");
			Application app = new Application();
			if (app == null) {
				Console.WriteLine("ERROR: EXCEL couldn't be started!");
				return 0;
			}
			
			Console.WriteLine ("Making application visible");		
			app.Visible = true;
			
			Console.WriteLine ("Getting the workbooks collection");
			Workbooks workbooks = app.Workbooks;

			Console.WriteLine ("Adding a new workbook");
			
			_Workbook workbook = workbooks.Add(XlWBATemplate.xlWBATWorksheet);

			Console.WriteLine ("Getting the worksheets collection");
			Sheets sheets = workbook.Worksheets;

			_Worksheet worksheet = (_Worksheet) sheets.get_Item(1);
			if (worksheet == null) {
				Console.WriteLine ("ERROR: worksheet == null");
			}
			
			Console.WriteLine ("Setting the value for cell");
			
			// This paragraph puts the value 5 to the cell G1
			Range range1 = worksheet.get_Range("G1", Missing.Value);
			if (range1 == null) {
				Console.WriteLine ("ERROR: range == null");
			}
			const int nCells = 5;
			range1.Value2 = nCells;
			
			// This paragraph sends single dimension array to Excel
			Range range2 = worksheet.get_Range("A1", "E1");
			int[] array2 = new int [nCells];
			for (int i=0; i < array2.GetLength(0); i++) {
				array2[i] = i+1;
			}
			range2.Value2 = array2;

			// This paragraph sends two dimension array to Excel
			Range range3 = worksheet.get_Range("A2", "E3");
			int[,] array3 = new int [2, nCells];
			for (int i=0; i < array3.GetLength(0); i++) {
				for (int j=0; j < array3.GetLength(1); j++) {
					array3[i, j] = i*10 + j;
				}
			}
			range3.Value2 = array3;

			// This paragraph reads two dimension array from Excel
			Range range4 = worksheet.get_Range("A2", "E3");
			Object[,] array4;
			array4 = (Object[,])range4.Value2;
			
			for (int i=array4.GetLowerBound(0); i <= array4.GetUpperBound(0); i++) {
				for (int j=array4.GetLowerBound(1); j <= array4.GetUpperBound(1); j++) {
					if ((double)array4[i, j] != array3[i-1, j-1]) {
						Console.WriteLine ("ERROR: Comparison FAILED!");
						return 0;
					}
				}
			}

			// This paragraph fills two dimension array with points for two curves and sends it to Excel
			Range range5 = worksheet.get_Range("A5", "J6");
			double[,] array5 = new double[2, 10];
			for (int j=0; j < array5.GetLength(1); j++) {
				double arg = Math.PI/array5.GetLength(1) * j;
				array5[0, j] = Math.Sin(arg);
				array5[1, j] = Math.Cos(arg);
			}
			range5.Value2 = array5;
			
			// The following code draws the chart
			range5.Select();
			ChartObjects chartobjects = (ChartObjects) worksheet.ChartObjects(Missing.Value);
			
			ChartObject chartobject = (ChartObject) chartobjects.Add(10 /*Left*/, 100 /*Top*/, 450 /*Width*/, 250 /*Height*/);
			_Chart chart = (_Chart) chartobject.Chart;
			
			// Call to chart.ChartWizard() is shown using late binding technique solely for the demonstration purposes
			Object[] args7 = new Object[11];
			args7[0] = range5; // Source
			args7[1] = XlChartType.xl3DColumn; // Gallery
			args7[2] = Missing.Value; // Format
			args7[3] = XlRowCol.xlRows; // PlotBy
			args7[4] = 0; // CategoryLabels
			args7[5] = 0; // SeriesLabels
			args7[6] = true; // HasLegend
			args7[7] = "Sample Chart"; // Title
			args7[8] = "Sample Category Type"; // CategoryTitle
			args7[9] = "Sample Value Type"; // ValueTitle
			args7[10] = Missing.Value; // ExtraTitle
			chart.GetType().InvokeMember("ChartWizard", BindingFlags.InvokeMethod, null, chart, args7);
			
			Console.WriteLine ("Press ENTER to finish the sample:");
			Console.ReadLine();		
			
			try {
				// If user interacted with Excel it will not close when the app object is destroyed, so we close it explicitely
				workbook.Saved = true;
				app.UserControl = false;
				app.Quit();
			} catch (COMException) {
				Console.WriteLine ("User closed Excel manually, so we don't have to do that");
			}
			
			Console.WriteLine ("Sample successfully finished!");
			return 100;
		}
	}
}
#T=Excel Utility
namespace ExcelExtensions
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using Excel = Microsoft.Office.Interop.Excel;
	using System.Reflection;
	abstract class ExcelUtility {
		public static TRet Invoke<TRet>(object Obj, Type ObjType, string MethodName, params object[] CallerParams) where TRet : class{
			MemberInfo[] memberInfo = ObjType.GetMember(MethodName, BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.Instance);
			BindingFlags memberTypeFlag;			
			int paramCount = 0;
			switch (memberInfo[0].MemberType) {
				default:
					return null;
				case MemberTypes.Method:
					MethodInfo methodInfo = ObjType.GetMethod(MethodName, BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.Instance);
					paramCount = methodInfo.GetParameters().Length;
					memberTypeFlag = BindingFlags.InvokeMethod;
					break;
				case MemberTypes.Property:
					PropertyInfo propInfo = ObjType.GetProperty(MethodName, BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.Instance);
					paramCount = propInfo.GetIndexParameters().Length;
					memberTypeFlag = BindingFlags.GetProperty;
					break;
			}
			
			object[] paramArray = new object[paramCount];			
			for (int i = 0; i < paramCount; ++i) {
				paramArray[i] = Missing.Value;
			}
			if (CallerParams != null)
				CallerParams.CopyTo(paramArray, 0);			
			TRet ret = Obj.GetType().InvokeMember(MethodName, memberTypeFlag | BindingFlags.Instance | BindingFlags.Public,
				null, Obj, paramArray) as TRet;
			return ret;
		}

		public static TRet ApplicationInvoke<TRet>(object Obj, string MethodName) where TRet : class {
			return Invoke<TRet>(Obj, typeof(Excel.ApplicationClass), MethodName, null);
		}

		public static TRet ApplicationInvoke<TRet>(object Obj, string MethodName, params object[] Params) where TRet : class {
			return Invoke<TRet>(Obj, typeof(Excel.ApplicationClass), MethodName, Params);
		}

		public static TRet RangeInvoke<TRet>(object Obj, string MethodName) where TRet : class {
			return Invoke<TRet>(Obj, typeof(Excel.Range), MethodName, null);
		}

		public static TRet RangeInvoke<TRet>(object Obj, string MethodName, params object[] Params) where TRet : class {
			return Invoke<TRet>(Obj, typeof(Excel.Range), MethodName, Params);
		}
	}
}

#T=ExceptionDispatchInfo 
namespace ConsoleApplication
{
	using System;
	using System.Runtime.ExceptionServices;
	public class Program
	{
		static void Main(string[] args)
		{
			var a = 100;
			var b = a;
			var c = new
						{
							F1 = "asdsad"
							, F2 = new Func<int,int>
										(
											(x) => { return x + x;} 
										)
						};
			//var $s = string.Empty;
			Console.WriteLine
						(
							$@"Hello World {{1}}{{0}}{a}{0}{c.F2(1)}{0}{{2}}"
							, "\r\n"
							, nameof(a)
							, 9999
							, nameof(c.F2)
						);
			///FormattableString  fs =  new FormattableString
								///(
									///"Hello World {{1}}{{0}}{a}{0}{c.F2(1)}{0}{{2}}"
									///, "\r\n"
									///, nameof(a)
									///, 9999
								///);
			///Console.WriteLine
						///(
							///fs
						///);
		ExceptionDispatchInfo edi = null;
		try
		{
			throw new Exception("test");
		}
		catch (Exception e)
		{
			throw;
			edi = ExceptionDispatchInfo.Capture(e);
		}
		if (edi != null)
		{
			//edi.Throw();
		}
		
			Console.WriteLine(Environment.Version.ToString());
		}	
	}
}

#T=Exec SP
		public static string _ConnectionString = ConfigurationManager.ConnectionStrings["ConnectionString"].ConnectionString;
		public static DataTable Execute_StoreProcedure
								(
									int Parameter1
									, string Parameter2
									, out string Parameter3
								)
		{
			string spName = "";
			SqlConnection connection = new SqlConnection(_ConnectionString);
			SqlCommand command = new SqlCommand(spName, connection);
			command.CommandType = CommandType.StoredProcedure;

			SqlParameter sqlParameter1 = command.Parameters.Add("@Parameter1", SqlDbType.Int);
			sqlParameter1.Value = Parameter1;

			SqlParameter sqlParameter2 = command.Parameters.Add("@Parameter2", SqlDbType.VarChar, 10);
			sqlParameter2.Value = Parameter2;

			SqlParameter sqlParameter3 = command.Parameters.Add("@Parameter3", SqlDbType.VarChar, 10);
			sqlParameter3.Direction = ParameterDirection.Output;

			SqlParameter parameterReturn = new SqlParameter("@RETURN_VALUE", SqlDbType.Int);
			parameterReturn.Direction = ParameterDirection.ReturnValue;

			//command.ExecuteNonQuery();
			SqlDataAdapter sda = new SqlDataAdapter(command);
			DataSet ds = new DataSet();
			sda.Fill(ds);
			connection.Close();

			Parameter3 = null;
			if (sqlParameter3.Value != System.DBNull.Value)
			{
				Parameter3 = ((string)(sqlParameter3.Value));
			}
			//return ((int)(parameterReturn.Value));
			return ds.Tables[0];
		}
#T=Expression Tree lambda
namespace ConsoleApplication
{
	using System;
	using System.Linq.Expressions;
	public class Class1
	{
		static void Main(string[] args)
		{
			// Add the following using directive to your code file:
			// using System.Linq.Expressions;
			// Create an expression tree.
			Expression<Func<int, bool>> expressionTree = num => num < 5;
			// Decompose the expression tree.
			ParameterExpression parameterExpression = (ParameterExpression) expressionTree.Parameters[0];
			BinaryExpression operation = (BinaryExpression) expressionTree.Body;
			ParameterExpression left = (ParameterExpression) operation.Left;
			ConstantExpression right = (ConstantExpression) operation.Right;
			Console.WriteLine
						(
							"Decomposed expression: {0} => {1} {2} {3}"
							, parameterExpression.Name
							, left.Name
							, operation.NodeType
							, right.Value
						);
			// Add the following using directive to your code file: 
			// using System.Linq.Expressions; 
			// Manually build the expression tree for  
			// the lambda expression num => num < 5.
			ParameterExpression numParam = Expression.Parameter(typeof(int), "num");
			ConstantExpression five = Expression.Constant(5, typeof(int));
			BinaryExpression numLessThanFive = Expression.LessThan(numParam, five);
			Expression<Func<int, bool>> lambda1 = Expression.Lambda<Func<int, bool>>
																(
																	numLessThanFive
																	, new ParameterExpression[]
																			{
																				numParam
																			}
																);
			var funcLambda1 = lambda1.Compile();
			// Let the compiler generate the expression tree for 
			// the lambda expression num => num < 5.
			Expression<Func<int, bool>> lambda2 = num => num < 5;
			var funcLambda2 = lambda2.Compile();
			Console.WriteLine(funcLambda1(1));
			Console.WriteLine(funcLambda1(6));
			Console.WriteLine(funcLambda2(1));
			Console.WriteLine(funcLambda2(6));
		}
	}
}

#T=Expression Tree simple Sample
namespace ConsoleApplication
{
	using System;
	using System.Linq.Expressions;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Expression
				<
					Func
						<
							Person
							, bool
						>
				> exp = p => p.Name.Contains("ldp") && p.Birthday.Value.Year > 1990;
			bool r = exp.Compile()
						(
							new Person()
								{
									Name = "ldp"
									, Birthday = DateTime.Now
								}
						);
			Console.WriteLine(r);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
	public class Person
	{
		public string Name { get; set; }
		public DateTime? Birthday { get; set; }
	}
}

#T=Expression 表达式树 lambda
namespace ConsoleApplication
{
	using System;
	using System.Linq.Expressions;
	public class Class1
	{
		static void Main(string[] args)
		{
			Func<int, bool> funcLambda =
										(
											(x) =>
											{
												return (x % 2 == 0);
											}
										);
			Console.WriteLine(funcLambda(10));
			funcLambda = x => x % 2 == 0;
			Expression<Func<int, bool>> expression = x => funcLambda(x);
			var funcLambda2 = expression.Compile();
			Console.WriteLine(funcLambda(9));
			Console.WriteLine(funcLambda2(9));
			Console.WriteLine(funcLambda2(10));
			Console.ReadLine();
		}
	}
}

#T=F5 Is Refresh PostBack (F5 Submit)
<%@ Page language="c#" AutoEventWireup="true"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" >
<HTML>
	<HEAD>
		<title>Check F5 refresh submit post back repeatly</title>
		<meta name="generator" content="editplus" />
		<meta name="author" content="" />
		<meta name="keywords" content="" />
		<meta name="description" content="" />
	<script language="C#" runat="server">
	private bool _IsF5RefreshPostBack;
	protected void Page_Load(object sender, EventArgs ea) 
	{
		if (IsPostBack)
		{
			if (Request.Cookies["cookieTimeStamp"] != null)
			{
				//if (Request.Cookies["cookieTimeStamp"].Value != this.label1.Text)
				//不用ViewState 使用 HiddenField 也可
				if (Request.Cookies["cookieTimeStamp"].Value != (string) ViewState["vsTimeStamp"])
				{
					_IsF5RefreshPostBack = true;
				}
			}
		}
		string timeStamp = DateTime.Now.ToString();
		//this.label1.Text = timeStamp;
		ViewState["vsTimeStamp"] = timeStamp;
		HttpCookie cookie = new HttpCookie("cookieTimeStamp", timeStamp);
		Response.Cookies.Add(cookie);
		
		if (_IsF5RefreshPostBack)
		{
			Response.Write("IsRefreshPostBack(F5) in Page Load<br>" );
		}

	}
	void button1_Click (object sender, EventArgs ea) 
	{
		if (_IsF5RefreshPostBack)
		{
			Response.Write("IsRefreshPostBack(F5) in Button Click<br>" );
		}
	}
</script>
	</HEAD>
	<body>
		<form id="Form1" method="post" runat="server">
				<asp:Button ID="button1" Text="button1" onclick="button1_Click" runat="server" />
		</form>
	</body>
</HTML>
#T=FastInvoke ILGenerator.Emit
// ==================================================================================
// From: http://www.manuelabadia.com/blog
//   by Manuel Abadia
// Which was based on: http://www.codeproject.com/csharp/FastMethodInvoker.asp
//   by Luyan ( http://www.agilelabs.cn )
// ==================================================================================
namespace Pscx.Reflection
{
	using System;
	using System.Collections.Generic;
	using System.Diagnostics;
	using System.Reflection;
	using System.Reflection.Emit;
	/// <summary>Delegate for calling a method that is not known at runtime.</summary>
	/// <param name="target">the object to be called or null if the call is to a static method.</param>
	/// <param name="parameters">the parameters to the method.</param>
	/// <returns>the return value for the method or null if it doesn't return anything.</returns>
	public delegate object FastInvokeHandler(object target, object[] parameters);
	/// <summary>Delegate for creating and object at runtime using the default constructor.</summary>
	/// <returns>the newly created object.</returns>
	public delegate object FastCreateInstanceHandler();
	/// <summary>Delegate to get an arbitraty property at runtime.</summary>
	/// <param name="target">the object instance whose property will be obtained.</param>
	/// <returns>the property value.</returns>
	public delegate object FastPropertyGetHandler(object target);
	/// <summary>Delegate to set an arbitrary property at runtime.</summary>
	/// <param name="target">the object instance whose property will be modified.</param>
	/// <param name="parameter"></param>
	public delegate void FastPropertySetHandler(object target, object parameter);
	/// <summary>Class with helper methods for dynamic invocation generating IL on the fly.</summary>
	public static class DynamicCalls
	{
		public static FastInvokeHandler GetMethodInvoker(MethodInfo methodInfo)
		{
			// generates a dynamic method to generate a FastInvokeHandler delegate
			DynamicMethod dynamicMethod = new DynamicMethod(string.Empty, typeof(object), new Type[] { typeof(object), typeof(object[]) }, methodInfo.DeclaringType.Module);
			ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
			ParameterInfo[] parameters = methodInfo.GetParameters();
			Type[] paramTypes = new Type[parameters.Length];
			// copies the parameter types to an array
			for (int i = 0; i < paramTypes.Length; i++)
			{
				if (parameters[i].ParameterType.IsByRef)
					paramTypes[i] = parameters[i].ParameterType.GetElementType();
				else
					paramTypes[i] = parameters[i].ParameterType;
			}
			LocalBuilder[] locals = new LocalBuilder[paramTypes.Length];
			// generates a local variable for each parameter
			for (int i = 0; i < paramTypes.Length; i++)
			{
				locals[i] = ilGenerator.DeclareLocal(paramTypes[i], true);
			}
			// creates code to copy the parameters to the local variables
			for (int i = 0; i < paramTypes.Length; i++)
			{
				ilGenerator.Emit(OpCodes.Ldarg_1);
				EmitFastInt(ilGenerator, i);
				ilGenerator.Emit(OpCodes.Ldelem_Ref);
				EmitCastToReference(ilGenerator, paramTypes[i]);
				ilGenerator.Emit(OpCodes.Stloc, locals[i]);
			}
			if (!methodInfo.IsStatic)
			{
				// loads the object into the stack
				ilGenerator.Emit(OpCodes.Ldarg_0);
			}
			// loads the parameters copied to the local variables into the stack
			for (int i = 0; i < paramTypes.Length; i++)
			{
				if (parameters[i].ParameterType.IsByRef)
				{
					ilGenerator.Emit(OpCodes.Ldloca_S, locals[i]);
				}
				else
				{
					ilGenerator.Emit(OpCodes.Ldloc, locals[i]);
				}
			}
			// calls the method
			if (!methodInfo.IsStatic)
			{
				ilGenerator.EmitCall(OpCodes.Callvirt, methodInfo, null);
			}
			else
			{
				ilGenerator.EmitCall(OpCodes.Call, methodInfo, null);
			}
			// creates code for handling the return value
			if (methodInfo.ReturnType == typeof(void))
			{
				ilGenerator.Emit(OpCodes.Ldnull);
			}
			else
			{
				EmitBoxIfNeeded(ilGenerator, methodInfo.ReturnType);
			}
			// iterates through the parameters updating the parameters passed by ref
			for (int i = 0; i < paramTypes.Length; i++)
			{
				if (parameters[i].ParameterType.IsByRef)
				{
					ilGenerator.Emit(OpCodes.Ldarg_1);
					EmitFastInt(ilGenerator, i);
					ilGenerator.Emit(OpCodes.Ldloc, locals[i]);
					if (locals[i].LocalType.IsValueType)
					{
						ilGenerator.Emit(OpCodes.Box, locals[i].LocalType);
					}
					ilGenerator.Emit(OpCodes.Stelem_Ref);
				}
			}
			// returns the value to the caller
			ilGenerator.Emit(OpCodes.Ret);
			// converts the DynamicMethod to a FastInvokeHandler delegate to call to the method
			FastInvokeHandler invoker = (FastInvokeHandler)dynamicMethod.CreateDelegate(typeof(FastInvokeHandler));
			return invoker;
		}
		/// <summary>Gets the instance creator delegate that can be use to create instances of the specified type.</summary>
		/// <param name="type">The type of the objects we want to create.</param>
		/// <returns>A delegate that can be used to create the objects.</returns>
		public static FastCreateInstanceHandler GetInstanceCreator(Type type)
		{
			// generates a dynamic method to generate a FastCreateInstanceHandler delegate
			DynamicMethod dynamicMethod = new DynamicMethod(string.Empty, type, new Type[0], typeof(DynamicCalls).Module);
			ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
			// generates code to create a new object of the specified type using the default constructor
			ilGenerator.Emit(OpCodes.Newobj, type.GetConstructor(Type.EmptyTypes));
			// returns the value to the caller
			ilGenerator.Emit(OpCodes.Ret);
			// converts the DynamicMethod to a FastCreateInstanceHandler delegate to create the object
			FastCreateInstanceHandler creator = (FastCreateInstanceHandler)dynamicMethod.CreateDelegate(typeof(FastCreateInstanceHandler));
			return creator;
		}
		public static FastPropertyGetHandler GetPropertyGetter(PropertyInfo propInfo)
		{
			// generates a dynamic method to generate a FastPropertyGetHandler delegate
			DynamicMethod dynamicMethod = new DynamicMethod(string.Empty, typeof(object), new Type[] { typeof(object) }, propInfo.DeclaringType.Module);
			ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
			// loads the object into the stack
			ilGenerator.Emit(OpCodes.Ldarg_0);
			// calls the getter
			ilGenerator.EmitCall(OpCodes.Callvirt, propInfo.GetGetMethod(), null);
			// creates code for handling the return value
			EmitBoxIfNeeded(ilGenerator, propInfo.PropertyType);
			// returns the value to the caller
			ilGenerator.Emit(OpCodes.Ret);
			// converts the DynamicMethod to a FastPropertyGetHandler delegate to get the property
			FastPropertyGetHandler getter = (FastPropertyGetHandler)dynamicMethod.CreateDelegate(typeof(FastPropertyGetHandler));
			return getter;
		}
		public static FastPropertySetHandler GetPropertySetter(PropertyInfo propInfo)
		{
			// generates a dynamic method to generate a FastPropertySetHandler delegate
			DynamicMethod dynamicMethod = new DynamicMethod(string.Empty, null, new Type[] { typeof(object), typeof(object) }, propInfo.DeclaringType.Module);
			ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
			// loads the object into the stack
			ilGenerator.Emit(OpCodes.Ldarg_0);
			// loads the parameter from the stack
			ilGenerator.Emit(OpCodes.Ldarg_1);
			// cast to the proper type (unboxing if needed)
			EmitCastToReference(ilGenerator, propInfo.PropertyType);
			// calls the setter
			ilGenerator.EmitCall(OpCodes.Callvirt, propInfo.GetSetMethod(), null);
			// terminates the call
			ilGenerator.Emit(OpCodes.Ret);
			// converts the DynamicMethod to a FastPropertyGetHandler delegate to get the property
			FastPropertySetHandler setter = (FastPropertySetHandler)dynamicMethod.CreateDelegate(typeof(FastPropertySetHandler));
			return setter;
		}
		/// <summary>Emits the cast to a reference, unboxing if needed.</summary>
		/// <param name="ilGenerator">The MSIL generator.</param>
		/// <param name="type">The type to cast.</param>
		private static void EmitCastToReference(ILGenerator ilGenerator, System.Type type)
		{
			if (type.IsValueType)
			{
				ilGenerator.Emit(OpCodes.Unbox_Any, type);
			}
			else
			{
				ilGenerator.Emit(OpCodes.Castclass, type);
			}
		}
		/// <summary>Boxes a type if needed.</summary>
		/// <param name="ilGenerator">The MSIL generator.</param>
		/// <param name="type">The type.</param>
		private static void EmitBoxIfNeeded(ILGenerator ilGenerator, System.Type type)
		{
			if (type.IsValueType)
			{
				ilGenerator.Emit(OpCodes.Box, type);
			}
		}
		/// <summary>Emits code to save an integer to the evaluation stack.</summary>
		/// <param name="ilGenerator">The MSIL generator.</param>
		/// <param name="value">The value to push.</param>
		private static void EmitFastInt(ILGenerator ilGenerator, int value)
		{
			// for small integers, emit the proper opcode
			switch (value)
			{
				case -1:
					ilGenerator.Emit(OpCodes.Ldc_I4_M1);
					return;
				case 0:
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					return;
				case 1:
					ilGenerator.Emit(OpCodes.Ldc_I4_1);
					return;
				case 2:
					ilGenerator.Emit(OpCodes.Ldc_I4_2);
					return;
				case 3:
					ilGenerator.Emit(OpCodes.Ldc_I4_3);
					return;
				case 4:
					ilGenerator.Emit(OpCodes.Ldc_I4_4);
					return;
				case 5:
					ilGenerator.Emit(OpCodes.Ldc_I4_5);
					return;
				case 6:
					ilGenerator.Emit(OpCodes.Ldc_I4_6);
					return;
				case 7:
					ilGenerator.Emit(OpCodes.Ldc_I4_7);
					return;
				case 8:
					ilGenerator.Emit(OpCodes.Ldc_I4_8);
					return;
			}
			// for bigger values emit the short or long opcode
			if (value > -129 && value < 128)
			{
				ilGenerator.Emit(OpCodes.Ldc_I4_S, (SByte)value);
			}
			else
			{
				ilGenerator.Emit(OpCodes.Ldc_I4, value);
			}
		}
	}
}
#T=Federation 原理
/*
传输过程
断言方
EncryptedData = TempShareSymKey.Encrypt(AssertParty.PrivateKey.SignHash(Data) + Data) + TrustParty.PublicKey.Encrypt(TempShareSymKey)

EncryptedData = AssertParty.PrivateKey.SignHash(Data) + Data

验证过程
信任方
TempShareSymKey = TrustParty.PrivateKey.Decrypt(EncryptedTempShareSymKey)
Signature + Data = TempShareSymKey.Decrypt(EncryptedData)
True ?= AssertParty.PublicKey.VerifyHash(Data, Signature)
*/

namespace Microshaoft
{
	using System;
	using System.Security.Cryptography;
	using System.Text;
	using System.IO;

	class Class1
	{

		static void Main()
		{
			//RSA
			UTF8Encoding e = new UTF8Encoding();

			byte[] dataToEncrypt = e.GetBytes("xxx@microshaoft.com");
			byte[] encryptedData;
			byte[] decryptedData;

			RSACryptoServiceProvider x = new RSACryptoServiceProvider();

			string privateKey = x.ToXmlString(true);
			string publicKey = x.ToXmlString(false);

			encryptedData = Crypto.RSAEncrypt(dataToEncrypt, publicKey, false);

			//公钥加密
			decryptedData = Crypto.RSADecrypt(encryptedData, privateKey, false);

			//私钥解密
			Console.WriteLine("Decrypted plaintext: {0}", e.GetString(decryptedData));


			//私钥签名
			byte[] signature = Crypto.RSASignSHA1(dataToEncrypt, privateKey);
			//公钥验签
			Console.WriteLine(Crypto.RSAVerifySHA1(dataToEncrypt,publicKey,signature));

			Console.WriteLine("MD5");
///			string s = @"G:\abc\cde.iso";
///			using (FileStream fs = File.OpenRead(s))
///			{
///				s = Crypto.BytesArrayToHexString(Crypto.ComputeMD5(fs));
///				
///			}
///			Console.WriteLine(s);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
	public class Crypto
	{

		static public byte[] RSASignSHA1
			(
				byte[] data
				, string privateKey
			)
		{
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			x.FromXmlString(privateKey);
			return x.SignHash
						(
							new SHA1CryptoServiceProvider().ComputeHash(data)
							, "SHA1"
						);
		}

		public static bool RSAVerifySHA1
								(
									byte[] data
									, string publicKey
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.VerifyHash
								(
									new SHA1CryptoServiceProvider().ComputeHash(data)
									, "SHA1"
									, signature
								);
		}

		public static byte[] RSASignMD5
			(
				byte[] data
				, string privateKey
			)
		{
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			x.FromXmlString(privateKey);
			return x.SignHash
						(
							new MD5CryptoServiceProvider().ComputeHash(data)
							, "MD5"
						);
		}

		public static bool RSAVerifyMD5
								(
									byte[] data
									, string publicKey
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.VerifyHash
								(
									new MD5CryptoServiceProvider().ComputeHash(data)
									, "MD5"
									, signature
								);
		}


		public static byte[] RSAEncrypt
								(
									byte[] data
									, string publicKey
									, bool DoOAEPPadding
								)
		{
				RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
				provider.FromXmlString(publicKey);
				return provider.Encrypt(data, DoOAEPPadding);
		}

		public static byte[] RSADecrypt
								(
									byte[] data
									, string privateKey
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKey);
			return provider.Decrypt(data, DoOAEPPadding);
		}



		/// <summary>
		/// Crypto 的摘要说明。
		/// </summary>
		public static byte[] DecryptTripleDES
			(
				byte[] data
				, byte[] Key
				, byte[] IV
			)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
		}

		public static byte[] DecryptTripleDES
			(
				string text
				, string Base64Key
				, string Base64IV
			)
		{
			return DecryptTripleDES
				(
					Convert.FromBase64String(text)
					, Convert.FromBase64String(Base64Key)
					, Convert.FromBase64String(Base64IV)
				);

		}

		public static byte[] DecryptTripleDES
			(
				string text
				, byte[] Key
				, byte[] IV
			)
		{
			return DecryptTripleDES
				(
					Convert.FromBase64String(text)
					, Key
					, IV
				);
		}

		public static string DecryptTripleDES
			(
				string text
				, string Base64Key
				, string Base64IV
				, Encoding e //原文的encoding
			)
		{
			return e.GetString
				(
					DecryptTripleDES
						(
							text
							, Base64Key
							, Base64IV
						)
				);
		}

		public static string DecryptTripleDES
			(
				string text
				, byte[] Key
				, byte[] IV
				, Encoding e //原文的encoding
			)
		{
			return e.GetString
				(
					DecryptTripleDES
						(
							text
							, Key
							, IV
						)
				);
		}

		public static string GenerateTripleDESHexStringKey()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateKey();
			return BytesArrayToHexString(des.Key);
		}
		public static string GenerateTripleDESHexStringIV()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateIV();
			return BytesArrayToHexString(des.IV);
		}

		public static byte[] EncryptTripleDES
			(
				byte[] data
				, byte[] Key
				, byte[] IV
			)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
		}

		public static byte[] EncryptTripleDES
			(
				string text
				, Encoding e
				, byte[] Key
				, byte[] IV
			)
		{
			return EncryptTripleDES
				(
					e.GetBytes(text)
					, Key
					, IV
				);

		}

		public static byte[] EncryptTripleDES
			(
				string text
				, Encoding e
				, string Base64Key
				, string Base64IV
			)
		{
			return EncryptTripleDES
				(
					text
					, e
					, Convert.FromBase64String(Base64Key)
					, Convert.FromBase64String(Base64IV)
				);
		}


		public static byte[] ComputeSHA1(byte[] data)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(data);
		}

		public static byte[] ComputeSHA1(string text, Encoding e)
		{
			return ComputeSHA1(e.GetBytes(text));
		}

		public static byte[] ComputeSHA1(string text)
		{
			return ComputeSHA1(text, Encoding.UTF8);
		}

		public static byte[] ComputeSHA1(Stream stream)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(stream);
		}


		public static byte[] ComputeMD5(byte[] data)
		{
			return new MD5CryptoServiceProvider().ComputeHash(data, 0, data.Length);
		}
		public static byte[] ComputeMD5(string text, Encoding e)
		{
			return ComputeMD5(e.GetBytes(text));
		}
		public static byte[] ComputeMD5(string text)
		{
			return ComputeMD5(text, Encoding.UTF8);
		}

		public static byte[] ComputeMD5(Stream stream)
		{
			return new MD5CryptoServiceProvider().ComputeHash(stream);
		}

		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}

#T=File Security NTFS
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Security.AccessControl;
	class FileSecurityExample
	{
		public static void Main()
		{
			try
			{
				string fileName = "test.xml";

				Console.WriteLine("Adding access control entry for " 
					+ fileName);

				// Add the access control entry to the file.
				AddFileSecurity(fileName, @"DomainName\AccountName",
					FileSystemRights.ReadData, AccessControlType.Allow);

				Console.WriteLine("Removing access control entry from " 
					+ fileName);

				// Remove the access control entry from the file.
				RemoveFileSecurity(fileName, @"DomainName\AccountName", 
					FileSystemRights.ReadData, AccessControlType.Allow);

				Console.WriteLine("Done.");
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
			}
		}

		// Adds an ACL entry on the specified file for the specified account.
		public static void AddFileSecurity(string fileName, string account, 
			FileSystemRights rights, AccessControlType controlType)
		{
			

			// Get a FileSecurity object that represents the 
			// current security settings.
			FileSecurity fSecurity = File.GetAccessControl(fileName);

			// Add the FileSystemAccessRule to the security settings. 
			fSecurity.AddAccessRule(new FileSystemAccessRule(account,
				rights, controlType));

			// Set the new access settings.
			File.SetAccessControl(fileName, fSecurity);

		}

		// Removes an ACL entry on the specified file for the specified account.
		public static void RemoveFileSecurity(string fileName, string account, 
			FileSystemRights rights, AccessControlType controlType)
		{

			// Get a FileSecurity object that represents the 
			// current security settings.
			FileSecurity fSecurity = File.GetAccessControl(fileName);

			// Add the FileSystemAccessRule to the security settings. 
			fSecurity.RemoveAccessRule(new FileSystemAccessRule(account,
				rights, controlType));

			// Set the new access settings.
			File.SetAccessControl(fileName, fSecurity);

		}
	}
}
#T=FileSysWatcher
namespace Microshaoft
{
	using System;
	using System.IO;
	public class Watcher
	{
		public static void Main()
		{
			string[] args = System.Environment.GetCommandLineArgs();
			// If a directory is not specified, exit program.
			string[] a = new string[2];
			if(args.Length != 2)
			{
				// Display the proper way to call the program.
				Console.WriteLine("Usage: Watcher.exe (directory)");
				a[0] = Console.ReadLine();
				a[1] = Console.ReadLine();
			}
			// Create a new FileSystemWatcher and set its properties.
			FileSystemWatcher watcher = new FileSystemWatcher();
			watcher.Path = a[1];
			/* Watch for changes in LastAccess and LastWrite times, and 
			   the renaming of files or directories. */
			watcher.NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;
			// Only watch text files.
			watcher.Filter = "*";

			// Add event handlers.
			watcher.Changed += new FileSystemEventHandler(OnChanged);
			watcher.Created += new FileSystemEventHandler(OnChanged);
			watcher.Deleted += new FileSystemEventHandler(OnChanged);
			watcher.Renamed += new RenamedEventHandler(OnRenamed);

			// Begin watching.
			watcher.EnableRaisingEvents = true;

			// Wait for the user to quit the program.
			Console.WriteLine("Press \'q\' to quit the sample.");
			while(Console.Read()!='q');
		}
		// Define the event handlers.
		private static void OnChanged(object source, FileSystemEventArgs e)
		{
			// Specify what is done when a file is changed, created, or deleted.
			Console.WriteLine("File: " +  e.FullPath + " " + e.ChangeType);
		}
		private static void OnRenamed(object source, RenamedEventArgs e)
		{
			// Specify what is done when a file is renamed.
			Console.WriteLine("File: {0} renamed to {1}", e.OldFullPath, e.FullPath);
		}
	}
}
#T=FilterNoises
//csc.exe /r:C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\microsoft.visualbasic.dll noname1.cs
namespace ConsoleApplication
{
	using System;
	using System.Text;
	using JeffreyZhao;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			int iteration = 10000;// * 1000;
			string noises = "`~!@#$%&*()_+-=\t{}|[]\\:\";'<>?,./\0\r\n ";
			noises += "～！＃￥％……＆×（）――＋・－＝｛｝｜【】＼：“”；‘’＇＜＞？，．／　";
			string s = "B按ａｈ`~!@#$%&*()_+-=\t{}|撒旦撒大[]\\:\";'<>?,./\0\r\n ";
			s += "～！＃￥％……＆×（）――＋・－＝｛｝｜【】＼：“”；‘’＇＜＞？，．／　";
			//int l = noises
			s += "AB按时打算阿斯顿llAA啊ａｈ";
			//s = "asdsad阿斯顿撒ooo";
			CodeTimer.Time
						(
							"1",
							iteration,
							() =>
							{
								StringHelper.FilterNoises(s, noises);
							}
						);
			CodeTimer.Time
						(
							"2",
							iteration,
							() =>
							{
								StringHelper.FilterNoises(s, noises);
							}
						);
			CodeTimer.Time
						(
							"3",
							iteration,
							() =>
							{
								StringHelper.FilterNoises(s);
							}
						);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace JeffreyZhao
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Runtime.InteropServices;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void Time(string name, int iteration, Action action)
		{
			if (String.IsNullOrEmpty(name))
			{
				return;
			}
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCycleCount();
			for (int i = 0; i < iteration; i++)
			{
				action();
			}
			ulong cpuCycles = GetCycleCount() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine("\tTime Elapsed:\t{0:N0}{1}", watch.ElapsedMilliseconds, "ms");
			Console.WriteLine("\tCPU Cycles:\t{0:N0}", cpuCycles);
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine("\tGen {0}:\t\t{1}", i, count);
			}
			Console.WriteLine();
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			//Windows Vista
			//QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
	}
}

//csc.exe /r:C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\microsoft.visualbasic.dll noname1.cs
namespace Microshaoft
{
	using System;
	using Microsoft.VisualBasic;
	using System.Globalization;
	public class StringHelper
	{
		public static string FilterNoises(string text, string noises)
		{
			text = Strings.StrConv(text, VbStrConv.Narrow, 0);
			//Console.WriteLine("[{0}]", text);
			//char[] a = noises.ToCharArray();
			int l = noises.Length;
			for (int i = 0; i < noises.Length; i++)
			{
				string r = noises.Substring(i, 1);
				//text = text.Replace(r, "");
				//text= Strings.Replace(text, r, "");
				//text = Strings.Replace(text, "o", "i");
			}
			///			foreach (char c in a)
			///			{
			///				string s = new string(new char[] {c});
			///				text = text.Replace(s, "");
			///			}
			return text;
		}
		public static string FilterNoises2(string text, string noises)
		{
			text = Strings.StrConv(text, VbStrConv.Narrow, 0);
			//Console.WriteLine("[{0}]", text);
			char[] a = noises.ToCharArray();
			int l = noises.Length;
			///			for (int i = 0; i < noises.Length; i++)
			///			{
			///				string r = noises.Substring(i, 1);
			///				text = text.Replace(r, "");
			///			}
			foreach (char c in a)
			{
				string s = new string(new char[] { c });
				text = text.Replace(s, "");
			}
			return text;
		}
		public static string FilterNoises(string text)
		{
			text = Strings.StrConv(text, VbStrConv.Narrow, 0);
			int l;
			l = text.Length;
			int i = 0;
			if (l > 0)
			{
				do
				{
					UnicodeCategory uc = Char.GetUnicodeCategory(text, i);
					string ucName = Enum.GetName(uc.GetType(), uc).ToLower();
					if (!ucName.Contains("letter"))
					{
						l = text.Length;
						string r = text.Substring(i, 1);
						text = text.Replace(r, "");
						if (l == text.Length)
						{
							break;
						}
					}
					else
					{
						i++;
					}
					if (i >= text.Length)
					{
						break;
					}


				} while (l >= text.Length);
			}
			return text;
		}
	}
}

#T=Find IE Window
namespace Test
{
	using System;
	using mshtml;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			var dom = IEWindowHelper.GetIEWindowDocument<IHTMLDocument5>("百度一下，你就知道");
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;

	public static class Win32API
	{
		[DllImport("user32.dll", EntryPoint = "FindWindow")]
		public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
		[DllImport("user32.dll", EntryPoint = "FindWindowEx")]
		public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);
		[DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
		public static extern uint RegisterWindowMessage(string lpString);
		[DllImport("oleacc.dll", PreserveSig = false)]
		[return: MarshalAs(UnmanagedType.Interface)]
		public static extern object ObjectFromLresult(UIntPtr lResult, [MarshalAs(UnmanagedType.LPStruct)] Guid refiid, IntPtr wParam);
		[DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
		public static extern IntPtr SendMessageTimeout(IntPtr hWnd, uint Msg, UIntPtr wParam, IntPtr lParam, SendMessageTimeoutFlags fuFlags, uint uTimeout, out UIntPtr lpdwResult);

		public enum SendMessageTimeoutFlags : uint
		{
			SMTO_NORMAL = 0x0000,
			SMTO_BLOCK = 0x0001,
			SMTO_ABORTIFHUNG = 0x0002,
			SMTO_NOTIMEOUTIFNOTHUNG = 0x0008
		}
	}

	public static class IEWindowHelper
	{
		public static T GetIEWindowDocument<T>(string ieWindowCaption)
		{
			ieWindowCaption = string.Format("{1}{0}{2}", " - ", ieWindowCaption, "Internet Explorer");
			UIntPtr lRes = new UIntPtr();
			var hWnd = Win32API.FindWindow("IEFrame", ieWindowCaption);
			Console.WriteLine("{0:x}", hWnd.ToInt32());
			hWnd = Win32API.FindWindowEx(hWnd, IntPtr.Zero, "Frame Tab", ""); //需要查找的子窗口的类名，也就是输入框
			Console.WriteLine("{0:x}", hWnd.ToInt32());
			hWnd = Win32API.FindWindowEx(hWnd, IntPtr.Zero, "TabWindowClass", ieWindowCaption); //需要查找的子窗口的类名，也就是输入框
			Console.WriteLine("{0:x}", hWnd.ToInt32());
			hWnd = Win32API.FindWindowEx(hWnd, IntPtr.Zero, "Shell DocObject View", ""); //需要查找的子窗口的类名，也就是输入框
			Console.WriteLine("{0:x}", hWnd.ToInt32());
			hWnd = Win32API.FindWindowEx(hWnd, IntPtr.Zero, "Internet Explorer_Server", ""); //需要查找的子窗口的类名，也就是输入框
			Console.WriteLine("{0:x}", hWnd.ToInt32());

			uint ui = Win32API.RegisterWindowMessage("WM_HTML_GETOBJECT");
			Win32API
				.SendMessageTimeout
					(
						hWnd
						, ui
						, UIntPtr.Zero
						, IntPtr.Zero
						, Win32API
							.SendMessageTimeoutFlags
							.SMTO_NOTIMEOUTIFNOTHUNG
						, 1000
						, out lRes
					);
			T r = (T)Win32API.ObjectFromLresult(lRes, typeof(T).GUID, IntPtr.Zero);
			return r;
		}
	}
}

#T=FindPrivateKey
namespace Microsoft.ChannelSDK.Tools.FindPrivateKey
{
	using System;
	using System.IO;
	using System.Security.Cryptography.X509Certificates;
	using System.Runtime.InteropServices;

	class FindPrivateKey
	{
		static void PrintHelp()
		{
			Console.WriteLine("FindPrivateKey helps user to find the location of the Private Key file of a X.509 Certificate.");
			Console.WriteLine("Usage: FindPrivateKey <storeName> <storeLocation> [{ {-n <subjectName>} | {-t <thumbprint>} } [-f | -d | -a]]");
			Console.WriteLine("	   <subjectName> subject name of the certificate");
			Console.WriteLine("	   <thumbprint>  thumbprint of the certificate (use certmgr.exe to get it)");
			Console.WriteLine("	   -f			output file name only");
			Console.WriteLine("	   -d			output directory only");
			Console.WriteLine("	   -a			output absolute file name");
			Console.WriteLine("e.g. FindPrivateKey My CurrentUser -n \"CN=John Doe\"");
			Console.WriteLine("e.g. FindPrivateKey My LocalMachine -t \"03 33 98 63 d0 47 e7 48 71 33 62 64 76 5c 4c 9d 42 1d 6b 52\" -c");
		}

		static void Main(string[] args)
		{			
			if (args.Length < 2 || args.Length == 3 || args.Length > 5 
				|| (args.Length > 2 && args[2] != "-n" && args[2] != "-t")
				|| (args.Length == 5 && args[4] != "-f" && args[4] != "-d" && args[4] != "-a"))
			{
				PrintHelp();
				return;
			}

			try
			{
				StoreName storeName = (StoreName)Enum.Parse(typeof(StoreName), args[0], true);
				StoreLocation storeLocation = (StoreLocation)Enum.Parse(typeof(StoreLocation), args[1], true);

				X509Certificate2 cert;
				if (args.Length > 2)
				{
					// insert a comma followed by a space for store.Certificates.Find(findType, key, false) 
					// to successful find the certificate
					string key = args[3];
					string[] keys = key.Split(',');
					key = string.Empty;
					for (int i = 0; i < keys.Length; i++)
					{
						key += keys[i];
						if ( i != keys.Length -1 )
						 key += ", ";
					}
					if (args[2] == "-n")
						cert = LoadCertificate(storeName, storeLocation, key, X509FindType.FindBySubjectDistinguishedName);
					else
						cert = LoadCertificate(storeName, storeLocation, key, X509FindType.FindByThumbprint);
				}
				else
				{
					cert = SelectCertificate(storeName, storeLocation);
					if (cert == null)
						return;
				}

				string privateKeyFile = GetKeyFileName(cert);
				string privateKeyDirectory = GetKeyFileDirectory(privateKeyFile);

				if (args.Length == 5)
				{
					if (args[4] == "-f")
						Console.WriteLine(privateKeyFile);
					else if (args[4] == "-d")
						Console.WriteLine(privateKeyDirectory);
					else
						Console.WriteLine("{0}\\{1}", privateKeyDirectory, privateKeyFile);
				}
				else
				{
					Console.WriteLine("Private key directory:");
					Console.WriteLine(privateKeyDirectory);
					Console.WriteLine("Private key file name:");
					Console.WriteLine(privateKeyFile);
				}
			}
			catch (Exception ex)
			{
				Console.WriteLine("FindPrivateKey failed for the following reason:");
				Console.WriteLine(ex.Message);
				Console.WriteLine("\nUse /? option for help");
			}
		}

		static X509Certificate2 SelectCertificate(StoreName storeName, StoreLocation storeLocation)
		{
			X509Certificate2 result;

			X509Store store = new X509Store(storeName, storeLocation);
			store.Open(OpenFlags.ReadOnly);
			try
			{
				X509Certificate2Collection matches;
				matches = X509Certificate2UI.SelectFromCollection(store.Certificates, "Select certificate", "Select the certificate to find the location of the associated private key file:", X509SelectionFlag.SingleSelection);
				if (matches.Count != 1)
					result = null;
				else
					result = matches[0];
			}
			finally
			{
				store.Close();
			}

			return result;
		}

		static X509Certificate2 LoadCertificate(StoreName storeName, StoreLocation storeLocation, string key, X509FindType findType)
		{
			X509Certificate2 result;

			X509Store store = new X509Store(storeName, storeLocation);
			store.Open(OpenFlags.ReadOnly);
			try
			{
				X509Certificate2Collection matches;
				matches = store.Certificates.Find(findType, key, false);
				if (matches.Count > 1)
					throw new InvalidOperationException(String.Format("More than one certificate with key '{0}' found in the store.", key));
				if (matches.Count == 0)
					throw new InvalidOperationException(String.Format("No certificates with key '{0}' found in the store.", key));
				result = matches[0];
			}
			finally
			{
				store.Close();
			}

			return result;
		}

		static string GetKeyFileName(X509Certificate2 cert)
		{
			IntPtr			hProvider	 = IntPtr.Zero; // CSP handle
			bool			  freeProvider  = false;	   // Do we need to free the CSP ?
			uint			   acquireFlags  = 0;
			int			 	  _keyNumber = 0;
			string			  keyFileName = null;
			byte[]			  keyFileBytes = null;

			//
			// Determine whether there is private key information available for this certificate in the key store
			//
			if ( CryptAcquireCertificatePrivateKey(cert.Handle,
				acquireFlags,
				IntPtr.Zero,
				ref hProvider,
				ref _keyNumber,
				ref freeProvider) )
			{
				IntPtr pBytes  = IntPtr.Zero; // Native Memory for the CRYPT_KEY_PROV_INFO structure
				int	cbBytes = 0;		   // Native Memory size

				try
				{
					if ( CryptGetProvParam(hProvider, CryptGetProvParamType.PP_UNIQUE_CONTAINER, IntPtr.Zero, ref cbBytes, 0) )
					{
						pBytes = Marshal.AllocHGlobal(cbBytes);

						if ( CryptGetProvParam(hProvider, CryptGetProvParamType.PP_UNIQUE_CONTAINER, pBytes, ref cbBytes, 0) )
						{
							keyFileBytes = new byte[cbBytes];

							Marshal.Copy(pBytes,keyFileBytes,0,cbBytes);

							// Copy eveything except tailing null byte
							keyFileName = System.Text.Encoding.ASCII.GetString(keyFileBytes, 0, keyFileBytes.Length-1);
						}
					}		
				}
				finally
				{
					if ( freeProvider )
						CryptReleaseContext(hProvider,0);

					//
					// Free our native memory
					//
					if ( pBytes != IntPtr.Zero )
						Marshal.FreeHGlobal(pBytes);

				}
			}

			if (keyFileName == null)
				throw new InvalidOperationException("Unable to obtain private key file name");

			return keyFileName;
		}

		static string GetKeyFileDirectory(string keyFileName)
		{
			// Look up All User profile from environment variable
			string allUserProfile = System.Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);

			// set up searching directory
			string machineKeyDir = allUserProfile + "\\Microsoft\\Crypto\\RSA\\MachineKeys";

			// Seach the key file
			string[] fs = System.IO.Directory.GetFiles(machineKeyDir, keyFileName);

			// If found
			if (fs.Length > 0)
				return machineKeyDir;

			// Next try current user profile
			string currentUserProfile = System.Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

			// seach all sub directory
			string userKeyDir = currentUserProfile + "\\Microsoft\\Crypto\\RSA\\";

			fs = System.IO.Directory.GetDirectories(userKeyDir);
			if (fs.Length > 0)
			{
				// for each sub directory
				foreach (string keyDir in fs)
				{
					fs = System.IO.Directory.GetFiles(keyDir, keyFileName);
					if (fs.Length == 0)
						continue;
					else
						// found
						return keyDir;
				}
			}

			throw new InvalidOperationException("Unable to locate private key file directory");
		}

		[DllImport("crypt32", CharSet = CharSet.Unicode, SetLastError = true)]
		internal extern static bool CryptAcquireCertificatePrivateKey(IntPtr pCert, uint dwFlags, IntPtr pvReserved, ref IntPtr phCryptProv, ref int pdwKeySpec, ref bool pfCallerFreeProv);

		[DllImport("advapi32", CharSet = CharSet.Unicode, SetLastError = true)]
		internal extern static bool CryptGetProvParam(IntPtr hCryptProv, CryptGetProvParamType dwParam, IntPtr pvData, ref int pcbData, uint dwFlags);

		[DllImport("advapi32", SetLastError = true)]
		internal extern static bool CryptReleaseContext(IntPtr hProv, uint dwFlags);

	}

	enum CryptGetProvParamType
	{
		PP_ENUMALGS = 1,
		PP_ENUMCONTAINERS = 2,
		PP_IMPTYPE = 3,
		PP_NAME = 4,
		PP_VERSION = 5,
		PP_CONTAINER = 6,
		PP_CHANGE_PASSWORD = 7,
		PP_KEYSET_SEC_DESCR = 8,	   // get/set security descriptor of keyset
		PP_CERTCHAIN = 9,	  // for retrieving certificates from tokens
		PP_KEY_TYPE_SUBTYPE = 10,
		PP_PROVTYPE = 16,
		PP_KEYSTORAGE = 17,
		PP_APPLI_CERT = 18,
		PP_SYM_KEYSIZE = 19,
		PP_SESSION_KEYSIZE = 20,
		PP_UI_PROMPT = 21,
		PP_ENUMALGS_EX = 22,
		PP_ENUMMANDROOTS = 25,
		PP_ENUMELECTROOTS = 26,
		PP_KEYSET_TYPE = 27,
		PP_ADMIN_PIN = 31,
		PP_KEYEXCHANGE_PIN = 32,
		PP_SIGNATURE_PIN = 33,
		PP_SIG_KEYSIZE_INC = 34,
		PP_KEYX_KEYSIZE_INC = 35,
		PP_UNIQUE_CONTAINER = 36,
		PP_SGC_INFO = 37,
		PP_USE_HARDWARE_RNG = 38,
		PP_KEYSPEC = 39,
		PP_ENUMEX_SIGNING_PROT = 40,
		PP_CRYPT_COUNT_KEY_USE = 41,
	}
}


#T=FindWindow SendMessage
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;

	public class Class1
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			GetAllWindowsHandles
					(
						//use spy++ 检测如下参数
						  "连接 adsl"		//父窗口的 caption
						, "#32770"			//父窗口的 class
						, "Edit"			//用户名的 class
						, "Edit"			//密码的 class
						, "连接(&C)"		//提交按钮的 caption
						, "Button"			//提交按钮的 class
					);

				Console.WriteLine("User Handle:\t\t[{0}]", _hWndUserEdit);
				Console.WriteLine("Password Handle:\t[{0}]", _hWndPasswordEdit);
				Console.WriteLine("Submit Handle:\t\t[{0}]", _hWndSubmitButton);


				Console.WriteLine("User:");
				string s = Console.ReadLine();
				SendMessage
						(
							  _hWndUserEdit
							, WM_SETTEXT
							, 0
							, s
						);
				Console.WriteLine("Password:");
				s = ConsoleReadMaskLine('*', true);
				SendMessage
						(
							  _hWndPasswordEdit
							, WM_SETTEXT
							, 0
							, s
						);
				Console.WriteLine("\nSubmit?");
				Console.ReadLine();
				SendMessage
						(
							  _hWndSubmitButton
							, WM_CLICK
							, 0
							,"0"
						);
		}

		// 平台调用 PInvoke 相关代码开始
		#region 平台调用 PInvoke 相关代码
		const int WM_GETTEXT = 0x000D;
		const int WM_SETTEXT = 0x000C;
		const int WM_CLICK = 0x00F5;

		[DllImport("user32.dll", EntryPoint="FindWindow")]
		private static extern int FindWindow
										(
											  string lpClassName
											, string lpWindowName
										);

		[DllImport("user32.dll", EntryPoint="FindWindowEx")]
		private static extern int FindWindowEx
										(
											  int hwndParent
											, int hwndChildAfter
											, string lpszClass
											, string lpszWindow
										);

		[DllImport("user32.dll", EntryPoint="SendMessage")]
		private static extern int SendMessage
										(
											  int hWnd
											, int Msg
											, int wParam
											, string lParam
										);

		static int _hWndUserEdit = 0;
		static int _hWndPasswordEdit = 0;
		static int _hWndSubmitButton = 0;

		public static void GetAllWindowsHandles
			(
				  string ParentWndCaption
				, string ParentWndClass
				, string UserEditWndClass
				, string PasswordEditWndClass
				, string SubmitButtonCaption
				, string SubmitButtonWndClass
			)
		{
			int _hWndParent = 0;
			_hWndParent = FindWindow(ParentWndClass, ParentWndCaption);

			int _hWndChild = 0;
			if (_hWndParent != 0)
			{
				_hWndChild = FindWindowEx
									(
										  _hWndParent
										, _hWndChild
										, UserEditWndClass
										, ""
									);
				_hWndUserEdit = _hWndChild;

				_hWndChild = FindWindowEx
									(
										  _hWndParent
										, _hWndChild
										, PasswordEditWndClass
										, ""
									);
				_hWndPasswordEdit = _hWndChild;

				_hWndChild = FindWindowEx
									(
										  _hWndParent
										, _hWndChild
										, SubmitButtonWndClass
										, SubmitButtonCaption
									);
				_hWndSubmitButton = _hWndChild;

			}
		}
		#endregion
		// 平台调用 PInvoke 相关代码结束

		//Password Input with Mask
		#region Password Input with Mask
		public static string ConsoleReadMaskLine
			(
				char PasswordChar
				, bool WithMask
			)
		{
			string password = "";
			ConsoleKey ck;
			string s = @"~!@#$%&*()_+`1234567890-="; //可输入字符
			s += @"QWERTYUIOP{}|qwertyuiop[]\";
			s += "ASDFGHJKL:\"asdfghjkl;'";
			s += "ZXCVBNM<>?zxcvbnm,./ ";

			do
			{
				ConsoleKeyInfo cki = Console.ReadKey(true);
				char c = cki.KeyChar;
				ck = cki.Key;
				int p = Console.CursorLeft;
				if (ck == ConsoleKey.Backspace)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p - 1);
					}
					string right = password.Substring(p);
					password  = left + right;
					Console.Write(c);

					string output = right;
					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}

					output += "\0";
					Console.Write(output);
					if (p > 0)
					{
						p --;
					}
				}
				else if (ck == ConsoleKey.Delete)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p);
					}
					string right = "";
					if (p < password.Length)
					{
						right = password.Substring(p + 1);
					}
					password = left + right;
					//Console.Write(right + " ");

					string output = right;

					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}
					output += "\0";

					Console.Write(output);
				}
				else
				{
					if (s.IndexOf(c) >= 0)
					{
						string left = password.Substring(0, p);
						string right = password.Substring(p);
						password = left + c + right;

						string output = c + right;

						if (WithMask)
						{
							output = GetPasswordChars(c + right, PasswordChar);
						}
						Console.Write(output);

						p ++;
					}
					else
					{
						switch (ck)
						{
							case ConsoleKey.LeftArrow :
								if (p > 0)
								{
									p --;
								}
								break;
							case ConsoleKey.RightArrow :
								if (p < password.Length)
								{
									p ++;
								}
								break;
							case ConsoleKey.Home :
								p = 0;
								break;
							case ConsoleKey.End :
								p = password.Length;
								break;
							default :
								Console.Beep();
								break;
						}
					}
				}
				Console.CursorLeft = p;
			} while (ck != ConsoleKey.Enter);
			return password;
		}
		private static string GetPasswordChars(string s, char c)
		{
			string passwordChars = "";
			for (int i = 0; i < s.Length; i++)
			{
				passwordChars += c;
			}
			return passwordChars;
		}
		#endregion
	}
}
#T=FtpWebRequest simple client
//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
namespace Microsoft.Samples.FtpSample
{
	#region Using directives

	using System;
	using System.Text;
	using System.IO;
	using System.Net;
	#endregion

	static class Program
	{
		static void Main(string[] args)
		{
			if (args.Length == 0 || args[0].Equals("/?"))
			{
				DisplayUsage();
			}
			else if (args.Length == 1)
			{
				Download(args[0]);
			}
			else if (args.Length == 2)
			{
				if (args[0].Equals("/list"))
				{
					List(args[1]);
				}
				else
				{
					Upload(args[0], args[1]);
				}
			}
			else
			{
				Console.WriteLine("Unrecognized argument.");
			}
		}


		static void DisplayUsage()
		{
			Console.WriteLine("USAGE:");
			Console.WriteLine("	FtpSample [/? | <FTP download URL> | <local file>");
			Console.WriteLine("			   <FTP upload URL> | /list <FTP list URL>]");
			Console.WriteLine();
			Console.WriteLine("where");
			Console.WriteLine("	FTP download URL   URL of a file to download from an FTP server.");
			Console.WriteLine("	FTP upload URL	 Location on a FTP server to upload a file to.");
			Console.WriteLine("	FTP list URL	   Location on a FTP server to list the contents of.");
			Console.WriteLine("	local file		 A local file to upload to an FTP server.");
			Console.WriteLine();
			Console.WriteLine("	Options:");
			Console.WriteLine("		/?			 Display this help message.");
			Console.WriteLine("		/list		  Specifies the list command.");
			Console.WriteLine();
			Console.WriteLine("EXAMPLES:");
			Console.WriteLine("	Download a file	FtpSample ftp://myserver/download.txt");
			Console.WriteLine("	Upload a file	  FtpSample upload.txt ftp://myserver/upload.txt");
		}

		static void Download(string downloadUrl)
		{
			Stream responseStream = null;
			FileStream fileStream = null;
			StreamReader reader = null;
			try
			{
				FtpWebRequest downloadRequest =
					(FtpWebRequest)WebRequest.Create(downloadUrl);
				FtpWebResponse downloadResponse =
					(FtpWebResponse)downloadRequest.GetResponse();
				responseStream = downloadResponse.GetResponseStream();

				string fileName =
					Path.GetFileName(downloadRequest.RequestUri.AbsolutePath);

				if (fileName.Length == 0)
				{
					reader = new StreamReader(responseStream);
					Console.WriteLine(reader.ReadToEnd());
				}
				else
				{
					fileStream = File.Create(fileName);
					byte[] buffer = new byte[1024];
					int bytesRead;
					while (true)
					{
						bytesRead = responseStream.Read(buffer, 0, buffer.Length);
						if (bytesRead == 0)
						{
							break;
						}
						fileStream.Write(buffer, 0, bytesRead);
					}
				}
				Console.WriteLine("Download complete.");
			}
			catch (UriFormatException ex)
			{
				Console.WriteLine(ex.Message);
			}
			catch (WebException ex)
			{
				Console.WriteLine(ex.Message);
			}
			catch (IOException ex)
			{
				Console.WriteLine(ex.Message);
			}
			finally
			{
				if (reader != null)
				{
					reader.Close();
				}
				else if (responseStream != null)
				{
					responseStream.Close();
				}
				if (fileStream != null)
				{
					fileStream.Close();
				}
			}
		}

		static void Upload(string fileName, string uploadUrl)
		{
			Stream requestStream = null;
			FileStream fileStream = null;
			FtpWebResponse uploadResponse = null;
			try
			{
				FtpWebRequest uploadRequest =
					(FtpWebRequest)WebRequest.Create(uploadUrl);
				uploadRequest.Method = WebRequestMethods.Ftp.UploadFile;

				// UploadFile is not supported through an Http proxy
				// so we disable the proxy for this request.
				uploadRequest.Proxy = null;

				requestStream = uploadRequest.GetRequestStream();
				fileStream = File.Open(fileName, FileMode.Open);

				byte[] buffer = new byte[1024];
				int bytesRead;
				while (true)
				{
					bytesRead = fileStream.Read(buffer, 0, buffer.Length);
					if (bytesRead == 0)
						break;
					requestStream.Write(buffer, 0, bytesRead);
				}
				
				// The request stream must be closed before getting 
				// the response.
				requestStream.Close();

				uploadResponse =
					(FtpWebResponse)uploadRequest.GetResponse();
				Console.WriteLine("Upload complete.");
			}
			catch (UriFormatException ex)
			{
				Console.WriteLine(ex.Message);
			}
			catch (IOException ex)
			{
				Console.WriteLine(ex.Message);
			}
			catch (WebException ex)
			{
				Console.WriteLine(ex.Message);
			}
			finally
			{
				if (uploadResponse != null)
					uploadResponse.Close();
				if (fileStream != null)
					fileStream.Close();
				if (requestStream != null)
					requestStream.Close();
			}
		}

		private static void List(string listUrl)
		{
			StreamReader reader = null;
			try
			{
				FtpWebRequest listRequest =
					(FtpWebRequest)WebRequest.Create(listUrl);
				listRequest.Method = WebRequestMethods.Ftp.ListDirectoryDetails;
				FtpWebResponse listResponse =
					(FtpWebResponse)listRequest.GetResponse();
				reader = new StreamReader(listResponse.GetResponseStream());
				Console.WriteLine(reader.ReadToEnd());
				Console.WriteLine("List complete.");
			}
			catch (UriFormatException ex)
			{
				Console.WriteLine(ex.Message);
			}
			catch (WebException ex)
			{
				Console.WriteLine(ex.Message);
			}
			finally
			{
				if (reader != null)
					reader.Close();
			}
		}
	}
}

#T=GC
using System;
namespace GCCollectIntExample
{
	class MyGCCollectClass
	{
		private const long maxGarbage = 1000;
		static void Main()
		{
			MyGCCollectClass myGCCol = new MyGCCollectClass();
			// Determine the maximum number of generations the system
		// garbage collector currently supports.
			Console.WriteLine("The highest generation is {0}", GC.MaxGeneration);
			myGCCol.MakeSomeGarbage();
			// Determine which generation myGCCol object is stored in.
			Console.WriteLine("Generation: {0}", GC.GetGeneration(myGCCol));
			// Determine the best available approximation of the number 
		// of bytes currently allocated in managed memory.
			Console.WriteLine("Total Memory: {0}", GC.GetTotalMemory(false));
			// Perform a collection of generation 0 only.
			GC.Collect(0);
			// Determine which generation myGCCol object is stored in.
			Console.WriteLine("Generation: {0}", GC.GetGeneration(myGCCol));
			Console.WriteLine("Total Memory: {0}", GC.GetTotalMemory(false));
			// Perform a collection of all generations up to and including 2.
			GC.Collect(2);
			// Determine which generation myGCCol object is stored in.
			Console.WriteLine("Generation: {0}", GC.GetGeneration(myGCCol));
			Console.WriteLine("Total Memory: {0}", GC.GetTotalMemory(false));
			Console.Read();
		}
		void MakeSomeGarbage()
		{
			Version vt;
			for(int i = 0; i < maxGarbage; i++)
			{
				// Create objects and release them to fill up memory
				// with unused objects.
				vt = new Version();
			}
		}
	}
}

#T=Generic 泛型简单样例
/*
什么是泛型? 如何使用和定义泛型?
	泛型是具有占位符(类型参数)的类、结构、接口和方法,
	这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。
	泛型集合类可以将类型参数用作它所存储的对象的类型的占位符;
	类型参数作为其字段的类型和其方法的参数类型出现。
	泛型方法可以将其类型参数用作其返回值的类型或者其形参的类型之一。
	摘自《Microsoft .NET Framework SDK v2.0 文档》
	泛型概述
	ms-help://MS.NETFramework.v20.chs/dv_fxfund/html/c92e7fb8-bc97-4a06-88f9-2066c58431fa.htm
	http://msdn.microsoft.com/zh-cn/library/ms172193(VS.95).aspx
*/
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			//GenericClass<int, string> x = new GenericClass<int, string>();
			GenericClass<int, string, Test> x = new GenericClass<int, string, Test>();
			x.Add<string>(1, "a");
			x.Add<int>(11, "b");
			x.Print<int>();
			x.Print(new Test("aaaaaaaaaaaaaaaaaaa"));
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
		
	}
	class Test : ITest<string, int>
	{
		private string _m = "";
		public Test (string x)
		{
			_m = x;
		}
		public void Aa()
		{
			Console.WriteLine(_m);
		}
		public int Aaa(string x)
		{
			Console.WriteLine(_m);
			return 1;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	public class GenericClass<T1, T2, T5>
								where T5 : ITest<string,int>
								where T2 : class
	{
		private Dictionary<T1, T2> _dictionary = new Dictionary<T1, T2>();
		
		public void Add<T3>(T1 x,T2 y)
		{
			T2 z = null;
			z = default(T2);
			this._dictionary.Add(x, y);
		}
		public T2 Get(T1 x)
		{
			return this._dictionary[x];
		}
		public void Print<T4>()
		{
			foreach(T1 var in this._dictionary.Keys)
			{
				Console.WriteLine("{0},{1}", var, _dictionary[var]);
			}
		}
		public void Print(T5 x)
		{
			x.Aa();
		}
	}
	public interface ITest<in T1, out T2>
	{

		void Aa();
		T2 Aaa(T1 x);
		///void Aaa(Func<T1,T2> x);
		///void Aaaa(Action<T1> x);
	}
}
// CS0403.cs
// CS0304.cs
// compile with: /target:library
class C<T>
		where T : new ()
{
	public void f()
	{
		//T t = null;  // CS0403
		T t2 = default(T);   // OK
		t2 = new T();
	}
}
class D<T> where T
					: class
						, new ()
{
	public void f()
	{
		T t = null;  // OK
		t = new T();
	}
}

class DD<T> where T
					: struct
{
	public void f()
	{
		//T t = null;  // OK
		T t = new T();
	}
}

#T=Global.asax
<%@ Application Language="C#" Inherits="WebApplication1.Global" %>
<%@ Import Namespace="System.Threading" %>
<%@ Import Namespace="System.Data" %>
<%@ Import Namespace="System.Data.SqlClient" %>
<%@ Import Namespace="System.Security.Principal" %>
<%@ Import Namespace="System.IO" %>
<script language="C#" runat="server">
	void Application_Start(object sender, EventArgs e)
	{
	}
	void Application_End(object sender, EventArgs e)
	{
	}
	void Application_Error(object sender, EventArgs e)
	{
	}
	void Application_BeginRequest(object sender, EventArgs e)
	{
		Response.Write("aaaaaaaaaaaaaaa");
	}
</script>
#T=Global.asax.cs
// /r:"C:\Program Files\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\System.Runtime.Caching.dll"
namespace WebApplication1
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Web.Security;
	using System.Web.SessionState;
	using System.Threading;
	using System.Web.Caching;
	using System.Runtime.Caching;
	using Microshaoft;
	public class Global : System.Web.HttpApplication
	{
		void Application_Start(object sender, EventArgs e)
		{
			CacheItemPolicy p = new CacheItemPolicy();
			MemoryCache.Default.Add("data","hi",p);
			// this.Context.Cache.Add("data", "hi", null, Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration,CacheItemPriority.Default,null);
			//string s = (string)HttpContext.Current.Cache["data"];
			// 在应用程序启动时运行的代码
			{
				new Thread
						(
							delegate()
							{
								//AsyncSocketAsyncQueueHandlerProxyServer.Main(null);
								MessageListenerHelper.Run();
							}
						).Start();
			}
		}
		void Application_End(object sender, EventArgs e)
		{
			//  在应用程序关闭时运行的代码
		}
		void Application_Error(object sender, EventArgs e)
		{
			// 在出现未处理的错误时运行的代码
		}
		void Session_Start(object sender, EventArgs e)
		{
			// 在新会话启动时运行的代码
		}
		void Session_End(object sender, EventArgs e)
		{
			// 在会话结束时运行的代码。 
			// 注意: 只有在 Web.config 文件中的 sessionstate 模式设置为
			// InProc 时，才会引发 Session_End 事件。如果会话模式设置为 StateServer 
			// 或 SQLServer，则不会引发该事件。
		}
	}
}
namespace ConsoleApplication
{
	using System;
	
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			MessageListenerHelper.Run();
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}

}

namespace Microshaoft
{
	using System;
	using System.Web;
	using System.Windows.Forms;
	using System.Threading;
	using System.Runtime.Caching;
	//using Microshaoft;
	using Microshaoft.RemotingObjects;
	public static class MessageListenerHelper
	{
		public static int Handle
		{
			get
			{
				return (int)_listener.Handle;
			}
		}
		private static DefWindowsMessageListener _listener;
		public static void Run()
		{
			new Thread
				(
					delegate()
					{
						if (_listener == null)
						{
							_listener = new DefWindowsMessageListener();
							_listener.MessageReceived +=new DefWindowsMessageListener.MessageEventHandler(_listener_MessageReceived);
							//_listener.Show();
						}
						//Handle = (int) _listener.Handle;
						WindowsSendMessageCallbackRemoting x = RemotingHelper.GetRemotingLocalClientProxyObject<WindowsSendMessageCallbackRemoting>("tcp://127.0.0.1:9090/testUrl");
						x.RegisterWindowsHandle((int)_listener.Handle);
						Application.Run();
					}
				).Start();



		}

		static void _listener_MessageReceived(DefWindowsMessageListener sender, Share.MessageData data)
		{

			//string s = (string) HttpContext.;// = data.Data;
			MemoryCache c = MemoryCache.Default;
			c["data"] = data.Data;
			//Console.WriteLine(data.Data);
		}
	}
}

namespace Microshaoft.RemotingObjects
{

	public interface WindowsSendMessageCallbackRemoting
	{
		void RegisterWindowsHandle(int hWnd);


	}
}


namespace Microshaoft
{
	using System;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;

	using Share;
	using Microshaoft;


	public partial class DefWindowsMessageListener : Form
	{
		private const int WM_COPYDATA = 0x004A;
		public delegate void MessageEventHandler(DefWindowsMessageListener sender, MessageData data);
		public event MessageEventHandler MessageReceived;
		protected override void DefWndProc(ref Message m)
		{
			if (MessageReceived != null)
			{
				if (m.Msg == WM_COPYDATA)
				{
					COPYDATASTRUCT buffer = (COPYDATASTRUCT)m.GetLParam(typeof(COPYDATASTRUCT));
					MessageData data = (MessageData)Marshal.PtrToStructure((IntPtr)buffer.lpData, typeof(MessageData));
					MessageReceived(this, data);
					return;
				}
				else
				{
					//Console.WriteLine(m);
				}
			}
			//Console.WriteLine(m);
			base.DefWndProc(ref m);
		}
	}
}

namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	static class WindowsNativeMethods
	{
		[DllImport("user32", EntryPoint = "SendMessageA")]
		public static extern int SendMessage(int Hwnd, int wMsg, int wParam, ref COPYDATASTRUCT lParam);
		public const int WM_COPYDATA = 0x004A;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct COPYDATASTRUCT
	{
		public int dwData;
		public int cbData;
		public int lpData;
	}

}
namespace Share
{
	using System;
	using System.Runtime.InteropServices;
	//定义要传递的Struct
	[StructLayout(LayoutKind.Sequential)]
	public struct MessageData
	{
		//SizeConst指定字符串很重要，后面要用到
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 10)]
		public string Data;
	}
}
//Server.cs
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Text;

	public static class RemotingHelper
	{
		public static void StartRemoting
			(
				Type RemotingType
				, string Url
				, int Port
				, WellKnownObjectMode ServiceMode
			)
		{
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
			IDictionary ht = new Hashtable();
			ht["port"] = Port;
			ht["machineName"] = "localhost";
			TcpChannel tc = new TcpChannel(ht, null, provider);
			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, ServiceMode);
			Console.WriteLine("Remoting Object Started ...");
		}
		public static void StartRemoting<T>
			(
				string Url
				, int Port
				, WellKnownObjectMode Mode
			)
		{
			StartRemoting(typeof(T), Url, Port, Mode);
		}
		public static T GetRemotingLocalClientProxyObject<T>
			(
				string Url
			)
		{
			return (T)Activator.GetObject
									(
										typeof(T)
										, Url
									);
		}
	}
}


#T=GridView DB HealthCheck Web.aspx
<%@ Page language="C#" validaterequest="false" enableviewstate="false"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
	<head>
		<title>
			Web App Health Check
		</title>
		<meta name="generator" content="editplus" />
		<meta name="author" content="" />
		<meta name="keywords" content="" />
		<meta name="description" content="" />
	</head>
<body>
	Client IP:
	<%=
		Request.UserHostAddress
	%>
	<br>
	Server Machine Name:
	<%=
		Environment.MachineName
	%>
	<br>
		<asp:gridview
			id="GridView1" 
			datasourceid="SqlDataSource1" 
			autogeneratecolumns="true"
			allowpaging="true"
			pagesize="20"
			runat="server"
		>
		</asp:gridview>
		<!-- to do -->
		<asp:sqldatasource
			id="SqlDataSource1"
			selectcommand=
							"
								select
									getdate() as [getdate()]
									, @@ServerName as [@@ServerName]
									, @@ServiceName as [@@ServiceName]
									, suser_name() as [suser_name()]
									, suser_id() as [suser_id()]
									, user_name() as [user_name()]
									, host_name() as [host_name()]
									--, @@version as [@@version]
							"
			connectionstring="Application Name=HealthCheckApp;Persist Security Info=False;Data Source=CS00BSDB01;SSPI=true"
			runat="server"
		>
		</asp:sqldatasource>

		<br/>

		<asp:gridview
			id="GridView2" 
			datasourceid="SqlDataSource2" 
			autogeneratecolumns="true"
			allowpaging="true"
			pagesize="20"
			runat="server"
		>
		</asp:gridview>
		<!-- to do -->
		<asp:sqldatasource
			id="SqlDataSource2"
			selectcommand=
							"
								select
									getdate() as [getdate()]
									, @@ServerName as [@@ServerName]
									, @@ServiceName as [@@ServiceName]
									, suser_name() as [suser_name()]
									, suser_id() as [suser_id()]
									, user_name() as [user_name()]
									, host_name() as [host_name()]
									--, @@version as [@@version]
							"
			connectionstring="Application Name=HealthCheckApp;Persist Security Info=False;Data Source=CS00BPDB01;SSPI=true"
			runat="server"
		>
		</asp:sqldatasource>
		<br/>

		<asp:gridview
			id="GridView3" 
			datasourceid="SqlDataSource3" 
			autogeneratecolumns="true"
			allowpaging="true"
			pagesize="20"
			runat="server"
		>
		</asp:gridview>
		<!-- to do -->
		<asp:sqldatasource
			id="SqlDataSource3"
			selectcommand=
							"
								select
									getdate() as [getdate()]
									, @@ServerName as [@@ServerName]
									, @@ServiceName as [@@ServiceName]
									, suser_name() as [suser_name()]
									, suser_id() as [suser_id()]
									, user_name() as [user_name()]
									, host_name() as [host_name()]
									--, @@version as [@@version]
							"
			connectionstring="Application Name=HealthCheckApp;Persist Security Info=False;Data Source=CS00BLDB01;SSPI=true"
			runat="server"
		>
		</asp:sqldatasource>
		<br/>


</body>
</html>




#T=GridView DetailsView Query Edit ASPX
<%@ Page language="C#" validaterequest="false" enableviewstate="false"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
	<head>
		<title>
			DetailsView GridView Query Edit Example
		</title>
		<meta name="generator" content="editplus" />
		<meta name="author" content="" />
		<meta name="keywords" content="" />
		<meta name="description" content="" />
	</head>
<body>
	<form id="form1" runat="server">
			<asp:DetailsView
				ID="DetailsView1"
				runat="server"
				AutoGenerateRows="false"
				DefaultMode="Insert"
				DataKeyNames="RowID"
				DataSourceID="SqlDataSource1"
			>
				<Fields>
					<asp:BoundField
						DataField="Field01"
						HeaderText="Field01"
					/>
					<asp:BoundField
						DataField="Field02"
						HeaderText="Field02"
					/>
					<asp:BoundField
						DataField="Field03"
						HeaderText="Field03"
					/>
					<asp:TemplateField
						ShowHeader="False"
					>
						<InsertItemTemplate>
							<asp:Button
								ID="Button1"
								runat="server"
								CausesValidation="True" 
								CommandName="Insert"
								Text="插入"
								OnClientClick="return confirm('add?')"
							/>
							<input type="reset" />
						</InsertItemTemplate>
					</asp:TemplateField>
				</Fields>
			</asp:DetailsView>
		<BR>
		Field01: 
		<asp:TextBox
			ID="TextBox1"
			runat="server"
		/>
		<asp:Button
			ID="Button1"
			runat="server"
			Text="查询"
		/>
		<BR>
		<asp:gridview
			id="GridView1" 
			datasourceid="SqlDataSource1" 
			autogeneratecolumns="true"
			allowpaging="true"
			pagesize="20"
			datakeynames="RowID"
			runat="server"
		>
			<Columns>
				<asp:TemplateField
					ShowHeader="False"
				>
					<ItemTemplate>
						<asp:LinkButton
							ID="LinkButton1"
							runat="server"
							CausesValidation="False" 
							CommandName="Delete"
							Text="删除"
							OnClientClick="return confirm('delete?')"
						/>
					</ItemTemplate>
				</asp:TemplateField>
				<asp:TemplateField
					ShowHeader="False"
				>
					<EditItemTemplate>
						<asp:LinkButton
							ID="LinkButton2"
							runat="server"
							CausesValidation="True" 
							CommandName="Update"
							Text="更新"
							OnClientClick="return confirm('update?')"
						/>
						&nbsp;
						<asp:LinkButton
							ID="LinkButton3"
							runat="server"
							CausesValidation="False" 
							CommandName="Cancel"
							Text="取消"
						/>
					</EditItemTemplate>
					<ItemTemplate>
						<asp:LinkButton
							ID="LinkButton4"
							runat="server"
							CausesValidation="False" 
							CommandName="Edit"
							Text="编辑"
						/>
					</ItemTemplate>
				</asp:TemplateField>
			</Columns>
		</asp:gridview>
		<!-- to do -->
		<asp:sqldatasource
			id="SqlDataSource1"
			selectcommand="execute xsp_TableName_SelectAll @Field01"
			updatecommand="execute xsp_TableName_UpdateByRowID @RowID,@Field01,@Field02,@Field03"
			insertcommand="execute xsp_TableName_Insert @Field01,@Field02,@Field03"
			deletecommand="execute xsp_TableName_DeleteByRowID @RowID"
			connectionstring="Application Name=AppTest;Integrated Security=SSPI;Persist Security Info=False;Data Source=SQLServerName;database=DataBaseName"
			runat="server"
		>
			<SelectParameters>
				<asp:ControlParameter
					ControlID="TextBox1"
					Name="Field01"
					PropertyName="Text"
					DefaultValue=" "
					DbType="String"
				/>
			</SelectParameters>
		</asp:sqldatasource>
	</form>
</body>
</html>

#T=GridView 小计行 ASP.NET
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Data" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script runat="server">
	protected void Page_Load(object sender, EventArgs e)
	{
		DataTable dataTable1 = new DataTable("BlogUser");
		DataRow dr;
		dataTable1.Columns.Add(new DataColumn("Type", typeof(System.String)));
		dataTable1.Columns.Add(new DataColumn("Count1", typeof(System.Int32)));
		dataTable1.Columns.Add(new DataColumn("Count2", typeof(System.Int32)));
		Random r = new Random();
		for (int i = 0; i < 8; i++)
		{
			dr = dataTable1.NewRow();
			if (i < 8)
			{
				dr[0] = "C";
			}
			if (i < 6)
			{
				dr[0] = "B";
			}
			if (i < 3)
			{
				dr[0] = "A";
			}
			dr[1] = r.Next(0, 100);
			dr[2] = r.Next(0, 100);
			dataTable1.Rows.Add(dr);
		}
		DataView dv = dataTable1.DefaultView;
		DataTable dataTable2 = dv.ToTable(true, "Type");
		DataTable dataTable3 = dataTable1.Clone();
		int totalCount1 = 0, totalCount2 = 0;
		for (int i = 0; i < dataTable2.Rows.Count; i++)
		{
			string type = dataTable2.Rows[i][0].ToString();
			DataRow[] rs = dataTable1.Select("Type='" + type + "'");
			int count1 = 0, count2 = 0;

			for (int j = 0; j < rs.Length; j++)
			{
				count1 += Convert.ToInt32(rs[j]["Count1"]);
				count2 += Convert.ToInt32(rs[j]["Count2"]);
				dataTable3.ImportRow(rs[j]);
			}
			dr = dataTable3.NewRow();
			dr[0] = "合计";
			dr[1] = count1;
			dr[2] = count2;
			totalCount1 += count1;
			totalCount2 += count2;
			dataTable3.Rows.Add(dr);
		}
		dr = dataTable3.NewRow();
		dr[0] = "总合计";
		dr[1] = totalCount1;
		dr[2] = totalCount2;
		dataTable3.Rows.Add(dr);
		this.GridView1.DataSource = dataTable3;
		this.GridView1.DataBind();
	}
	protected void GridView1_RowDataBound(object sender, GridViewRowEventArgs e)
	{
		if (e.Row.Cells[0].Text.Trim().Equals("合计"))
		{
			e.Row.Style.Add("color", "#d00");
		}
		else if (e.Row.Cells[0].Text.Trim().Equals("总合计"))
		{
			e.Row.Style.Add("color", "#00d");
			e.Row.Style.Add("background", "#f33");
		}
	}
</script>
<html xmlns="http://www.w3.org/1999/xhtml">
<head id="Head1" runat="server">
<title></title>
</head>
<body>
	<form id="form1" runat="server">
		<asp:GridView ID="GridView1" runat="server" OnRowDataBound="GridView1_RowDataBound">
		</asp:GridView>
	</form>
</body>
</html>

#T=Groove Manage Login.aspx
<%@ Import Namespace="System.Web.Security " %>

<html>


  <script language="C#" runat=server>

    void Login_Click(Object sender, EventArgs E) {

      // authenticate user: this samples accepts only one user with
      // a name of someone@www.contoso.com and a password of 'password'

      if ((UserEmail.Value == "admin") && (UserPass.Value == "admin")) {
        FormsAuthentication.RedirectFromLoginPage(UserEmail.Value, false);
      }
      else {
        Msg.Text = "Invalid Credentials: Please try again";
      }
    }

  </script>
<head>
<STYLE> /* Rule 23 of /library/mnp/2/aspx/css.aspx?locale=zh-cn&name=Menu&static=PageTools&static=Page */ BODY {	MARGIN: 0px} /* Rule 1 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ BODY {	MARGIN: 0px} /* Rule 27 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviFooter {	BORDER-TOP: #ee6d23 1px solid;	FONT: 70% Tahoma, Helvetica;	/*POSITION: absolute*/} /* Rule 40 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviFooter {	FONT: 70% Arial, Helvetica} /* Rule 28 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviFooter TD {	FONT-SIZE: 100%} /* Rule 30 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviGlobalFooter {	PADDING-LEFT: 10px;	PADDING-BOTTOM: 13px;	MARGIN: 0px;	PADDING-TOP: 10px} /* Rule 34 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviFooter NOBR {	COLOR: #a9a9a9;	MARGIN-RIGHT: 5px} /* Rule 20 of /china/mnp_utility.mspx/templatecss?template=%2flibrary%2fgallery%2ftemplates%2fMNP2.GenericArticle&shell=%2fchina%2foffice%2fpreview%2fConfiguration.xml&locale=zh-cn */ A {	COLOR: #0033cc} /* Rule 21 of /china/mnp_utility.mspx/templatecss?template=%2flibrary%2fgallery%2ftemplates%2fMNP2.GenericArticle&shell=%2fchina%2foffice%2fpreview%2fConfiguration.xml&locale=zh-cn */ A:link {	COLOR: #0033cc} /* Rule 31 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviFooter A {	FONT-WEIGHT: normal;	BACKGROUND: none transparent scroll repeat 0% 0%;	COLOR: #03c;	MARGIN-RIGHT: 2px} /* Rule 29 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviLocalFooter {	PADDING-LEFT: 10px;	MARGIN: 0px;	PADDING-TOP: 8px} #msviMastheadHR {	BACKGROUND: #ee6d23;	OVERFLOW: hidden;	HEIGHT: 1px} /* Rule 9 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviGlobalSearch {	PADDING-RIGHT: 15px;	PADDING-LEFT: 6px;	FONT: 65% Verdana;	COLOR: #000000;	PADDING-TOP: 5px;	TEXT-ALIGN: left} /* Rule 35 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviGlobalSearch {	FONT: 70% Arial} /* Rule 10 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviSearchForm {	MARGIN: -1px 0px 0px} /* Rule 12 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviGoButton {	PADDING-RIGHT: 0.2em;	PADDING-LEFT: 0.2em;	PADDING-BOTTOM: 0em;	FONT: 110% Tahoma;	MARGIN-LEFT: 6px;	PADDING-TOP: 0em;	POSITION: relative;	TOP: 0px} /* Rule 37 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviGoButton {	FONT: 100% Tahoma} /* Rule 11 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviSearchBox {	FONT: 110% Tahoma;	WIDTH: 247px;	xheight: 18px} /* Rule 36 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviSearchBox {	FONT: 100% Tahoma} /* Rule 20 of /china/mnp_utility.mspx/templatecss?template=%2flibrary%2fgallery%2ftemplates%2fMNP2.GenericArticle&shell=%2fchina%2foffice%2fpreview%2fConfiguration.xml&locale=zh-cn */ A {	COLOR: #0033cc} /* Rule 21 of /china/mnp_utility.mspx/templatecss?template=%2flibrary%2fgallery%2ftemplates%2fMNP2.GenericArticle&shell=%2fchina%2foffice%2fpreview%2fConfiguration.xml&locale=zh-cn */ A:link {	COLOR: #0033cc} /* Rule 3 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviGlobalToolbar {	PADDING-LEFT: 1px} /* Rule 42 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ .msviPPSpace {	PADDING-RIGHT: 87px} /* Rule 5 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ .gt0 {	BORDER-RIGHT: #ff9610 1px solid;	PADDING-RIGHT: 4px;	BORDER-TOP: #ff9610 1px solid;	PADDING-LEFT: 4px;	FONT-SIZE: 100%;	PADDING-BOTTOM: 2px;	BORDER-LEFT: #ff9610 1px solid;	PADDING-TOP: 0px;	BORDER-BOTTOM: #ff9610 1px solid} /* Rule 4 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviGlobalToolbar A {	FONT: 65% Verdana;	COLOR: #ffffff;	TEXT-DECORATION: none} /* Rule 38 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ #msviGlobalToolbar A {	FONT: 70% Arial} /* Rule 7 of /library/toolbar/3.0/css.aspx?c=/china/office/preview/Configuration.xml */ .gtsep {	PADDING-RIGHT: 1px;	PADDING-LEFT: 1px;	PADDING-BOTTOM: 2px;	FONT: 65% Verdana;	COLOR: #ffdcbb;	PADDING-TOP: 0px}
</STYLE>
</head>
  <body style="background-color:#f7f6f3">
  <DIV id="msviMasthead"><TABLE cellSpacing="0" cellPadding="0" width="100%" border="0"><TBODY><TR><TD width="100%"><TABLE height="22" cellSpacing="0" cellPadding="0" width="100%" border="0"><TBODY><TR><TD id="msviRegionIdGraphic" bgColor="#ffffff"><IMG title="" height="22" alt="China" src="http://www.microsoft.com/library/toolbar/3.0/text.aspx?text=Q2hpbmE%3d&fore=5D5D5D&b=FFFFFF&font=Segoe+Semibold%2c+10pt&h=22&a=0&l=1&v=0&c=haqT5g7t%2f3M%2fqI6%2bUiu%2bZOYFiRE%3d" border="0" /></TD><TD id="msviRegionGradient1" style="FILTER: progid:DXImageTransform.Microsoft.Gradient(startColorStr='#FFFFFF', endColorStr='#FFC287', gradientType='1')" width="50%"></TD><TD id="msviRegionGradient2" style="FILTER: progid:DXImageTransform.Microsoft.Gradient(startColorStr='#FFC287', endColorStr='#FF9610', gradientType='1')" width="50%"></TD></TR></TBODY></TABLE></TD><TD id="msviGlobalToolbar" dir="ltr" noWrap align="left" bgColor="#ff9610" height="22"><TABLE cellSpacing="0" cellPadding="0" border="0"><TBODY><TR><TD class="gt0" id="panelTd" noWrap><A href="javascript:void(0)">Quick Links&nbsp;</A><SCRIPT> document.write('<img src="/library/mnp/2/gif/ql.gif" width="11px" height="4px" alt="">');</SCRIPT><IMG height="4" alt="" src="http://www.microsoft.com/library/mnp/2/gif/ql.gif" width="11" /><DIV id="panelDiv" style="Z-INDEX: 100; VISIBILITY: hidden; POSITION: absolute"></DIV></TD><TD class="gtsep">|</TD><TD class="gt0" onmouseover="this.className='gt1'" onmouseout="this.className='gt0'" noWrap><A href="http://www.microsoft.com/china/">Micosoft</A></TD><TD class="gtsep">|</TD><TD class="gt0" onmouseover="this.className='gt1'" onmouseout="this.className='gt0'" noWrap><A href="http://www.microsoft.com/worldwide/">Wordwide</A></TD><TD class="msviPPSpace"></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><TABLE cellSpacing="0" cellPadding="0" width="100%" border="0"><TBODY><TR vAlign="top"><TD width="100%"><TABLE style="HEIGHT: 42px; ; HEIGHT: expression(parentElement.parentElement.parentElement.parentElement.offsetHeight)" height="42" cellSpacing="0" cellPadding="0" width="100%" border="0"><TBODY><TR vAlign="top"><TD id="msviBrandBanner" bgColor="#ffffff"><A href="http://office.microsoft.com/"><IMG title="" height="42" alt="Office" src="http://www.microsoft.com/library/toolbar/3.0/images/banners/office_masthead_ltr.gif" width="225" border="0" /></A></TD><TD style="FILTER: progid:DXImageTransform.Microsoft.Gradient(startColorStr='#FFFFFF', endColorStr='#FFD87B', gradientType='1')" width="100%"></TD></TR></TBODY></TABLE></TD><TD id="msviGlobalSearch" bgColor="#ffd87b">Search In Microsoft.com :<BR /><FORM id="msviSearchForm" action="/library/toolbar/3.0/search.aspx" target="_top"><INPUT type="hidden" name="View" value="zh-cn" /><INPUT type="hidden" name="charset" value="gb2312" /><NOBR><DIV style="HEIGHT: 18px"><INPUT id="msviSearchBox" maxLength="255" name="qu" value="" /><INPUT id="msviGoButton" type="submit" value="Go" /></DIV></NOBR></FORM></TD></TR></TBODY></TABLE><DIV id="msviMastheadHR"></DIV></DIV>
  <div style="text-align:center">
<div style="margin-top:70px;background-image:url(images/groove.gif);width:416px;height:216px;background-repeat:no-repeat;text-align:center"></div>
    <form runat=server>
      <h3><font face="Verdana">Groove Manage Server Administration Portal</font></h3>
	  <div style="width=500px;height=140px;margin-left:auto;margin-right:auto;">
      <table style="background-color:#f7f6f3">
        <tr>
          <td style="font-size:14px;font-family:Verdana;FONT-WEIGHT: bold" align="right">UserName:</td>
          <td><input id="UserEmail" type="text" runat=server/></td>
          <td><ASP:RequiredFieldValidator ControlToValidate="UserEmail" Display="Static" ErrorMessage="*" runat=server/></td>
        </tr>
        <tr>
          <td style="font-size:14px;font-family:Verdana;font-family:Verdana;FONT-WEIGHT: bold" align="right">Password:</td>
          <td><input id="UserPass" type=password runat=server/></td>
          <td><ASP:RequiredFieldValidator ControlToValidate="UserPass" Display="Static" ErrorMessage="*" runat=server/></td>
        </tr>
      </table>
      <asp:button text="Login" OnClick="Login_Click" style="font-size:14px;font-family:Verdana;font-family:Verdana;FONT-WEIGHT: bold" runat=server/>
      <p>
      <asp:Label id="Msg" ForeColor="red" Font-Name="Verdana" Font-Size="10" runat=server />
	  </div>
    </form>
	<TABLE id="msviFooter" cellSpacing="0" cellPadding="0" width="100%"><TBODY><TR vAlign="bottom"><TD id="msviFooter2" style="filter:progid:DXImageTransform.Microsoft.Gradient(startColorStr='#FFFFFF', endColorStr='#FF8610', gradientType='1')"><DIV id="msviLocalFooter"><NOBR><A href="https://profile.microsoft.com/RegSysProfileCenter/Infodefault.aspx?LCID=2052" target="_top">Personal Information Center</A> |</NOBR><WBR></WBR></WBR><//WBR><NOBR><A href="http://go.microsoft.com/?linkid=2367274" target="_parent">Contact Us</A></NOBR></DIV><DIV id="msviGlobalFooter"><SPAN dir="ltr">?2007 Microsoft Corporation. @Copyright. &nbsp;</SPAN><NOBR><A href="http://www.microsoft.com/china/info/cpyright.mspx" target="_top">All Rights Reserved.</A> |</NOBR><WBR></WBR></WBR><//WBR><NOBR><A href="http://www.microsoft.com/library/toolbar/3.0/trademarks/zh-cn.mspx" target="_top">Trademarks</A> |</NOBR><WBR></WBR></WBR><//WBR><NOBR><A href="http://go.microsoft.com/fwlink/?LinkId=81184&clcid=0x804" target="_parent">Privacy Statement</A></NOBR></DIV></TD><TD width="105" bgColor="#ff8610"><IMG title="" height="29" alt="Microsoft" src="http://www.microsoft.com/library/toolbar/3.0/text.aspx?text=TQ%3d%3d&fore=FFFFFF&b=FF8610&font=Microsoft+Logo+95%2c+13pt&w=105&h=29&a=0&l=0&v=0&c=IO9l5cI96OotD4qXO203vLes5yg%3d" width="105" border="0" /></TD></TR></TBODY></TABLE>
  </body>

</html>

#T=GSM Modem 短信猫
/*----------------------------------------------------------------
 * Copyright (C) 2010 刘中原
 * 版权所有。 
 * 
 * 文件名： GSMModem.cs
 * 
 * 文件功能描述：   完成短信猫设备的打开关闭，短信的发送与接收以及
 *			  其他相应功能
 *				  文件包含两个类GSMModem和PDUEncoding，PDUEncod-
 *			  ing为私有类，完成PDU格式的编码与解码
 *			  
 * 创建标识：   刘中原20101104
 * 
 * 修改标识：
 * 修改描述：
 * 
 * 修改标识：
 * 修改描述：
**----------------------------------------------------------------*/
namespace GSMMODEM
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.IO.Ports;
	using System.Threading;
	/// <summary>
	/// “猫”设备类，完成短信发送 接收等
	/// </summary>
	public class GSMModem
	{
		/// <summary>
		/// 无参数构造函数 完成有关初始化工作
		/// </summary>
		public GSMModem()
		{
			sp = new SerialPort();
			sp.ReadTimeout = 2500;	  //读超时时间 发送短信时间的需要
			sp.RtsEnable = true;		//必须为true 这样串口才能接收到数据
			sp.DataReceived += new SerialDataReceivedEventHandler(sp_DataReceived);
		}
		/// <summary>
		/// 构造函数
		/// </summary>
		/// <param name="comPort">串口号</param>
		/// <param name="baudRate">波特率</param>
		public GSMModem(string comPort, int baudRate)
		{
			sp = new SerialPort();
			sp.PortName = comPort;	  //
			sp.BaudRate = baudRate;
			sp.ReadTimeout = 2500;	  //读超时时间 发送短信时间的需要
			sp.RtsEnable = true;		//必须为true 这样串口才能接收到数据
			sp.DataReceived += new SerialDataReceivedEventHandler(sp_DataReceived);
		}
		private SerialPort sp;		  //私有字段 串口对象
		public int NewMsgIndex { get; set; }		//新消息序号
		/// <summary>
		/// 串口号 运行时只读 设备打开状态写入将引发异常
		/// 提供对串口端口号的访问
		/// </summary>
		public string ComPort
		{
			get
			{
				return sp.PortName;
			}
			set
			{
				try
				{
					sp.PortName = value;
				}
				catch (Exception ex)
				{
					throw ex;
				}
			}
		}
		/// <summary>
		/// 波特率 可读写
		/// 提供对串口波特率的访问
		/// </summary>
		public int BaudRate
		{
			get
			{
				return sp.BaudRate;
			}
			set
			{
				sp.BaudRate = value;
			}
		}
		/// <summary>
		/// 设备是否打开
		/// 对串口IsOpen属性访问
		/// </summary>
		public bool IsOpen
		{
			get
			{
				return sp.IsOpen;
			}
		}
		/// <summary>
		/// 创建事件收到信息的委托
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		public delegate void OnRecievedHandler(object sender, EventArgs e);
		/// <summary>
		/// 收到短信息事件 OnRecieved 
		/// 收到短信将引发此事件
		/// </summary>
		public event OnRecievedHandler OnRecieved;
		/// <summary>
		/// 从串口收到数据 串口事件
		/// 程序未完成需要的可自己添加
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		void sp_DataReceived(object sender, SerialDataReceivedEventArgs e)
		{
			string temp = sp.ReadLine();
			if (temp.Length > 8)
			{
				if (temp.Substring(0, 6) == "+CMTI:")
				{
					NewMsgIndex = Convert.ToInt32(temp.Split(',')[1]);
					OnRecieved(this, e);
				}
			}
		}
		/// <summary>
		/// 设备打开函数，无法时打开将引发异常
		/// </summary>
		public void Open()
		{
			try
			{
				sp.Open();
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		/// <summary>
		/// 设备关闭函数
		/// </summary>
		public void Close()
		{
			try
			{
				sp.Close();
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
		/// <summary>
		/// 发送AT指令 逐条发送AT指令 调用一次发送一条指令
		/// 能返回一个OK或ERROR算一条指令
		/// </summary>
		/// <param name="ATCom">AT指令</param>
		/// <returns>发送指令后返回的字符串</returns>
		public string SendAT(string ATCom)
		{
			string result = string.Empty;
			//忽略接收缓冲区内容，准备发送
			sp.DiscardInBuffer();
			//注销事件关联，为发送做准备
			sp.DataReceived -= sp_DataReceived;
			//发送AT指令
			try
			{
				sp.Write(ATCom + "\r");
			}
			catch (Exception ex)
			{
				sp.DataReceived += sp_DataReceived;
				throw ex;
			}
			//接收数据 循环读取数据 直至收到“OK”或“ERROR”
			try
			{
				string temp = string.Empty;
				while (temp.Trim() != "OK" && temp.Trim() != "ERROR")
				{
					temp = sp.ReadLine();
					result += temp;
				}
				return result;
			}
			catch (Exception ex)
			{
				throw ex;
			}
			finally
			{
				//事件重新绑定 正常监视串口数据
				sp.DataReceived += sp_DataReceived;
			}
		}
		/// <summary>
		/// 发送短信
		/// 发送失败将引发异常
		/// </summary>
		/// <param name="phone">手机号码</param>
		/// <param name="msg">短信内容</param>
		public void SendMsg(string phone, string msg)
		{
			PDUEncoding pe = new PDUEncoding();
			string temp = pe.PDUEncoder(phone, msg);
			int len = (temp.Length - Convert.ToInt32(temp.Substring(0, 2), 16) * 2 - 2) / 2;  //计算长度
			try
			{
				temp = SendAT("AT+CMGS=" + len.ToString() + "\r" + temp + (char)(26));  //26 Ctrl+Z ascii码
			}
			catch (Exception)
			{
				throw new Exception("短信发送失败");
			}
			if (temp.Substring(temp.Length - 4, 3).Trim() == "OK")
			{
				return;
			}
			throw new Exception("短信发送失败");
		}
		//void ReadNewMsg(out string msgCenter, out string phone, out string msg, out string time)
		//{
		//	Char[] temp = null;
		//	sp.Read(temp, 0, 2);
		//}
		/// <summary>
		/// 按序号读取短信
		/// </summary>
		/// <param name="index">序号</param>
		/// <param name="msgCenter">短信中心</param>
		/// <param name="phone">发送方手机号码</param>
		/// <param name="msg">短信内容</param>
		/// <param name="time">时间字符串</param>
		public void ReadMsgByIndex(int index, out string msgCenter, out string phone, out string msg, out string time)
		{
			string temp = string.Empty;
			PDUEncoding pe = new PDUEncoding();
			try
			{
				temp = SendAT("AT+CMGR=" + index.ToString() + "\r");
			}
			catch (Exception ex)
			{
				throw ex;
			}
			if (temp.Trim() == "ERROR")
			{
				throw new Exception("没有此短信");
			}
			temp = temp.Split((char)(13))[2];	   //取出PDU串(char)(13)为0x0a即\r 按\r分为多个字符串 第3个是PDU串
			pe.PDUDecoder(temp, out msgCenter, out phone, out msg, out time);
		}
		public void DeleteMsgByIndex(int index)
		{
			if (SendAT("AT+CMGD=" + index.ToString() + "\r").Trim() == "OK")
			{
				return;
			}
			throw new Exception("删除失败");
		}
	}
	/// <summary>
	/// PDU编解码类，完成PDU短信格式的编码与解码
	/// 目前只能发送接收USC2编码（中文编码）的
	/// 代码不是很安全，投入使用的话需要一定的改动 
	/// 短信右7bit编码格式，我没有做判断 可能会引发异常
	/// 私有类，只能命名空间内部使用 调试此类时须设为公有 完成后去掉public
	/// </summary>
	class PDUEncoding
	{
		private string serviceCenterAddress = "00";
		/// <summary>
		/// 消息服务中心(1-12个8位组)
		/// </summary>
		public string ServiceCenterAddress
		{
			get
			{
				int len = 2 * Convert.ToInt32(serviceCenterAddress.Substring(0, 2));
				string result = serviceCenterAddress.Substring(4, len - 2);
				result = ParityChange(result);
				result = result.TrimEnd('F', 'f');
				return result;
			}
			set				 //
			{
				if (value == null || value.Length == 0)	  //号码为空
				{
					serviceCenterAddress = "00";
				}
				else
				{
					if (value[0] == '+')
					{
						value = value.TrimStart('+');
					}
					if (value.Substring(0, 2) != "86")
					{
						value = "86" + value;
					}
					value = "91" + ParityChange(value);
					serviceCenterAddress = (value.Length / 2).ToString("X2") + value;
				}
				
			}
		}
		private string protocolDataUnitType = "11";
		/// <summary>
		/// 协议数据单元类型(1个8位组)
		/// </summary>
		public string ProtocolDataUnitType
		{
			set
			{
			}
			get
			{
				return "11";
			}
		}
		private string messageReference = "00";
		/// <summary>
		/// 所有成功的短信发送参考数目（0..255）
		/// (1个8位组)
		/// </summary>
		public string MessageReference
		{
			get
			{
				return "00";
			}
		}
		private string originatorAddress = "00";
		/// <summary>
		/// 发送方地址（手机号码）(2-12个8位组)
		/// </summary>
		public string OriginatorAddress
		{
			get
			{
				int len = Convert.ToInt32(originatorAddress.Substring(0, 2),16);	//十六进制字符串转为整形数据
				string result = string.Empty;
				if (len % 2 == 1)	   //号码长度是奇数，长度加1 编码时加了F
				{
					len++;
				}
				result = originatorAddress.Substring(4, len);
				result = ParityChange(result).TrimEnd('F', 'f');	//奇偶互换，并去掉结尾F
				return result;
			}
		}
		private string destinationAddress = "00";
		/// <summary>
		/// 接收方地址（手机号码）(2-12个8位组)
		/// </summary>
		public string DestinationAddress
		{
			set
			{
				if (value == null || value.Length == 0)	  //号码为空
				{
					destinationAddress = "00";
				}
				else
				{
					if (value[0] == '+')
					{
						value = value.TrimStart('+');
					} 
					if (value.Substring(0, 2) == "86")
					{
						value = value.TrimStart('8', '6');
					}
					int len = value.Length;
					value = ParityChange(value);
					destinationAddress = len.ToString("X2") + "A1" + value;
				}
			}
		}
		private string protocolIdentifer = "00";
		/// <summary>
		/// 参数显示消息中心以何种方式处理消息内容
		/// （比如FAX,Voice）(1个8位组)
		/// </summary>
		public string ProtocolIdentifer
		{
			get
			{
				return protocolIdentifer;
			}
			set
			{
			}
		}
		private string dataCodingScheme = "08";	 //暂时仅支持国内USC2编码
		/// <summary>
		/// 参数显示用户数据编码方案(1个8位组)
		/// </summary>
		public string DataCodingScheme
		{
			get
			{
				return dataCodingScheme;
			}
		}
		private string serviceCenterTimeStamp = "";
		/// <summary>
		/// 消息中心收到消息时的时间戳(7个8位组)
		/// </summary>
		public string ServiceCenterTimeStamp
		{
			get
			{
				string result = ParityChange(serviceCenterTimeStamp);
				result = "20" + result.Substring(0, 12);			//年加开始的“20”
				return result;
			}
		}
		private string validityPeriod = "C4";	   //暂时固定有效期
		/// <summary>
		/// 短消息有效期(0,1,7个8位组)
		/// </summary>
		public string ValidityPeriod
		{
			get
			{
				return "C4";
			}
		}
		private string userDataLenghth = "";
		/// <summary>
		/// 用户数据长度(1个8位组)
		/// </summary>
		public string UserDataLenghth
		{
			get
			{
				return (userData.Length / 2).ToString("X2");
			}
		}
		private string userData = "";
		/// <summary>
		/// 用户数据(0-140个8位组)
		/// </summary>
		public string UserData
		{
			get
			{
				int len = Convert.ToInt32(userDataLenghth, 16) * 2;
				string result = string.Empty;
				//四个一组，每组译为一个USC2字符
				for (int i = 0; i < len; i += 4)
				{
					string temp = userData.Substring(i , 4);
					int byte1 = Convert.ToInt16(temp, 16);
					result += ((char)byte1).ToString();
				}
				return result;
			}
			set
			{
				userData = string.Empty;
				Encoding encodingUTF = Encoding.BigEndianUnicode;
				byte[] Bytes = encodingUTF.GetBytes(value);
				for (int i = 0; i < Bytes.Length; i++)
				{
					userData += BitConverter.ToString(Bytes, i, 1);
				}
				userDataLenghth = (userData.Length / 2).ToString("X2");
			}
		}
		/// <summary>
		/// 奇偶互换 (+F)
		/// </summary>
		/// <param name="str">要被转换的字符串</param>
		/// <returns>转换后的结果字符串</returns>
		private string ParityChange(string str)
		{
			string result = string.Empty;
			if (str.Length % 2 != 0)		 //奇字符串 补F
			{
				str += "F";
			}
			for (int i = 0; i < str.Length; i += 2)
			{
				result += str[i + 1];
				result += str[i];
			}
			return result;
		}
		/// <summary>
		/// PDU编码器，完成PDU编码(USC2编码，最多70个字)
		/// </summary>
		/// <param name="phone">目的手机号码</param>
		/// <param name="Text">短信内容</param>
		/// <returns>编码后的PDU字符串</returns>
		public string PDUEncoder(string phone, string Text)
		{
			if (Text.Length > 70)
			{
				throw (new Exception("短信字数超过70"));
			}
			DestinationAddress = phone;
			UserData = Text;
			return serviceCenterAddress + protocolDataUnitType
				+ messageReference + destinationAddress + protocolIdentifer
				+ dataCodingScheme + validityPeriod + userDataLenghth + userData;
		}
		/// <summary>
		/// 完成手机或短信猫收到PDU格式短信的解码 暂时仅支持中文编码
		/// 未用DCS部分
		/// </summary>
		/// <param name="strPDU">短信PDU字符串</param>
		/// <param name="msgCenter">短消息服务中心 输出</param>
		/// <param name="phone">发送方手机号码 输出</param>
		/// <param name="msg">短信内容 输出</param>
		/// <param name="time">时间字符串 输出</param>
		public void PDUDecoder(string strPDU, out string msgCenter, out string phone, out string msg, out string time)
		{
			int lenSCA = Convert.ToInt32(strPDU.Substring(0, 2), 16) * 2 + 2;	   //短消息中心占长度
			serviceCenterAddress = strPDU.Substring(0, lenSCA);
			int lenOA = Convert.ToInt32(strPDU.Substring(lenSCA + 2, 2),16);		   //OA占用长度
			if (lenOA % 2 == 1)													 //奇数则加1 F位
			{
				lenOA++;
			}
			lenOA += 4;				 //加号码编码的头部长度
			originatorAddress = strPDU.Substring(lenSCA + 2, lenOA);
			serviceCenterTimeStamp = strPDU.Substring(lenSCA + lenOA + 6, 14);
			userDataLenghth = strPDU.Substring(lenSCA + lenOA + 20, 2);
			int lenUD = Convert.ToInt32(userDataLenghth, 16) * 2;
			userData = strPDU.Substring(lenSCA + lenOA + 22, lenUD);
			msgCenter = ServiceCenterAddress;
			phone = OriginatorAddress;
			msg = UserData;
			time = ServiceCenterTimeStamp;
		}
	}
}
namespace 测试
{
	using System;
	using System.Collections.Generic;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}
namespace 测试
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;
	using GSMMODEM;
	public partial class Form1 : Form
	{
		public Form1()
		{
			InitializeComponent();
		}
		GSMModem gm = new GSMModem("COM3", 9600);
		private void button1_Click(object sender, EventArgs e)
		{
			try
			{
				gm.SendMsg(textBox3.Text, textBox4.Text);
			}
			catch (Exception ex)
			{
				textBox4.Text = ex.Message;
				return;
			}
			textBox4.Text = "发送成功";
		}
		private void textBox1_TextChanged(object sender, EventArgs e)
		{
		}
		private void Form1_Load(object sender, EventArgs e)
		{
			gm.Open();
			gm.SendAT("ATE0");
			gm.OnRecieved += new GSMModem.OnRecievedHandler(gm_OnRecieved);
		}
		void gm_OnRecieved(object sender, EventArgs e)
		{
			string s1, s2, s3, s4;
			gm.ReadMsgByIndex(gm.NewMsgIndex, out s1, out s2, out s3, out s4);
			textBox1.Text = s1 + s2 + s3 + s4;  //此处引发异常（此处不属于主进程）  须回调函数才能改变此属性
		}
		private void button2_Click(object sender, EventArgs e)
		{
			string s1, s2, s3, s4;gm.ReadMsgByIndex(18,out s1,out s2,out s3,out s4);
			textBox1.Text = s1 + s2 + s3 + s4;
			/*try
			{
				gm.DeleteMsgByIndex(1);
			}
			catch (Exception ex)
			{
				textBox1.Text = ex.Message;
				return;
			}
			textBox1.Text = "删除成功";*/
		}
	}
}
namespace 测试
{
	partial class Form1
	{
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		/// <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要
		/// 使用代码编辑器修改此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.button2 = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.textBox3 = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.textBox4 = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(29, 103);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(75, 23);
			this.button1.TabIndex = 0;
			this.button1.Text = "发送";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// textBox1
			// 
			this.textBox1.Location = new System.Drawing.Point(164, 162);
			this.textBox1.Multiline = true;
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(219, 100);
			this.textBox1.TabIndex = 1;
			this.textBox1.TextChanged += new System.EventHandler(this.textBox1_TextChanged);
			// 
			// button2
			// 
			this.button2.Location = new System.Drawing.Point(13, 219);
			this.button2.Name = "button2";
			this.button2.Size = new System.Drawing.Size(75, 23);
			this.button2.TabIndex = 2;
			this.button2.Text = "测试";
			this.button2.UseVisualStyleBackColor = true;
			this.button2.Click += new System.EventHandler(this.button2_Click);
			// 
			// label2
			// 
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(27, 16);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(53, 12);
			this.label2.TabIndex = 5;
			this.label2.Text = "手机号码";
			// 
			// textBox3
			// 
			this.textBox3.Location = new System.Drawing.Point(94, 13);
			this.textBox3.Name = "textBox3";
			this.textBox3.Size = new System.Drawing.Size(149, 21);
			this.textBox3.TabIndex = 6;
			// 
			// label3
			// 
			this.label3.AutoSize = true;
			this.label3.Location = new System.Drawing.Point(68, 56);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(65, 12);
			this.label3.TabIndex = 7;
			this.label3.Text = "要发送内容";
			// 
			// textBox4
			// 
			this.textBox4.Location = new System.Drawing.Point(164, 53);
			this.textBox4.Multiline = true;
			this.textBox4.Name = "textBox4";
			this.textBox4.Size = new System.Drawing.Size(200, 91);
			this.textBox4.TabIndex = 8;
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(422, 290);
			this.Controls.Add(this.textBox4);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.textBox3);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.textBox1);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new System.EventHandler(this.Form1_Load);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		#endregion
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.TextBox textBox1;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.TextBox textBox3;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.TextBox textBox4;
	}
}

#T=GZipFileHelper
^#define NET45
namespace Test
{
	using Microshaoft;
	using System;
	using System.Diagnostics;
	using System.IO;
	public class Program
	{
		public static void Main()
		{
^#if NET45
			var files = Directory.EnumerateFiles(@"d:\", "*.gz*", SearchOption.TopDirectoryOnly);
			foreach (var file in files)
			{
				var r = false;
				string path = string.Empty;
				try
				{
					if
						(
							GZipFileHelper
								.Decompress
									(
										file
										, @"d:\temp"
										, (x) =>
										{
											var s = ".Gz";
											int p = x.ToLower().LastIndexOf(s.ToLower());
											if (p > 0)
											{
												x = x.Remove(p, s.Length);
											}
											return x;
										}
										, out path
									)
						)
					{
						r = PathFileHelper
								.MoveFileTo
									(
										path
										, @"d:\Temp"
										, @"d:\Temp2"
										, true
									);
					}
				}
				catch (Exception e)
				{
					string log = string
									.Format
										(
											"Process file: [{1}] caught exception:{0}{2}"
											, "\r\n"
											, file
											, e.ToString()
										);
					Console.Error.WriteLine(log);
					EventLogHelper
						.WriteEventLogEntry
							(
								""
								, log
								, EventLogEntryType.Error
								, 1001
							);
					r = false;
				}
				if (r)
				{
					PathFileHelper
							.MoveFileTo
								(
									file
									, @"d:\"
									, @"d:\Temp3"
									, true
								);
					Console.WriteLine("ok: {0}", file);
				}
				else
				{
					PathFileHelper
								.MoveFileTo
									(
										file
										, @"d:\Temp"
										, @"d:\Temp4"
										, true
									);
				}
			}
			Console.ReadLine();
^#endif
		}
	}
}
^#if NET45
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.IO.Compression;
	public static class GZipFileHelper
	{
		public static bool Decompress
							(
								string originalFileFullPath
								, string targetDirectoryPath
								, Func<string, string> onNamingDecompressedFileProcessFunc
								, out string decompressedFileFullPath
							)
		{
			var r = false;
			using (FileStream originalFileStream = File.OpenRead(originalFileFullPath))
			{
				var originalFileExtensionName = Path.GetExtension(originalFileFullPath);
				var originalDirectoryPath = Path.GetDirectoryName(originalFileFullPath);
				decompressedFileFullPath = PathFileHelper.GetNewPath(originalDirectoryPath, targetDirectoryPath, originalFileFullPath);
				string fileName = Path.GetFileName(decompressedFileFullPath);
				string directory = Path.GetDirectoryName(decompressedFileFullPath);
				if (onNamingDecompressedFileProcessFunc != null)
				{
					fileName = onNamingDecompressedFileProcessFunc(fileName);
				}
				decompressedFileFullPath = Path.Combine(directory, fileName);
				using (FileStream decompressedFileStream = File.Create(decompressedFileFullPath))
				{
					using (GZipStream decompressionStream = new GZipStream(originalFileStream, CompressionMode.Decompress))
					{
						decompressionStream.CopyTo(decompressedFileStream);
						r = true;
					}
				}
			}
			return r;
		}
	}
}
^#endif
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Linq;
	public static class PathFileHelper
	{
		public static bool MoveFileTo
							(
								string sourceFullPathFileName
								, string sourceDirectoryPath
								, string destDirectorytPath
								, bool deleteExistsDestFile = false
							)
		{
			var r = false;
			var destFullPathFileName = GetNewPath(sourceDirectoryPath, destDirectorytPath, sourceFullPathFileName);
			var directory = Path.GetDirectoryName(destFullPathFileName);
			if (File.Exists(directory))
			{
				File.Delete(directory);
			}
			if (!Directory.Exists(directory))
			{
				Directory.CreateDirectory(directory);
			}
			if (deleteExistsDestFile)
			{
				if (File.Exists(destFullPathFileName))
				{
					File.Delete(destFullPathFileName);
				}
			}
			File.Move(sourceFullPathFileName, destFullPathFileName);
			r = true;
			return r;
		}
		public static string GetValidPathOrFileName(string path, string replacement)
		{
			string s = string.Empty;
			var chars = Path.GetInvalidPathChars();
			chars = chars.Union(Path.GetInvalidFileNameChars()).ToArray();
			Array
				.ForEach
					(
						chars
						, (x) =>
						{
							s = s.Replace(x.ToString(), replacement);
						}
					);
			return s;
		}
		public static string GetNewPath(string oldDirectoryPath, string newDirectoryPath, string originalFileFullPath)
		{
			string newPath = newDirectoryPath;
			originalFileFullPath = Path.GetFullPath(originalFileFullPath);
			var directorySeparator = Path.DirectorySeparatorChar.ToString();
			oldDirectoryPath = Path.GetFullPath(oldDirectoryPath);
			newDirectoryPath = Path.GetFullPath(newDirectoryPath);
			if (!oldDirectoryPath.EndsWith(directorySeparator))
			{
				oldDirectoryPath += directorySeparator;
			}
			if (!newDirectoryPath.EndsWith(directorySeparator))
			{
				newDirectoryPath += directorySeparator;
			}
			string relativeDirectoryPath = string.Empty;
			int p = originalFileFullPath
						.ToLower()
						.IndexOf(oldDirectoryPath.ToLower());
			if (p >= 0)
			{
				p += oldDirectoryPath.Length;
				relativeDirectoryPath = originalFileFullPath.Substring(p);
				newPath = Path.Combine(newPath, relativeDirectoryPath);
			}
			newPath = Path.GetFullPath(newPath);
			return newPath;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Diagnostics;
	public static class EventLogHelper
	{
		private static string _processNameID = new Func<string>
												(
													() =>
													{
														var process = Process.GetCurrentProcess();
														return
															string.Format
																	(
																		"{1}{0}({2})"
																		, ""
																		, process.ProcessName
																		, process.Id
																	);
													}
												)();
		public static EventLog[] GetEventLogs()
		{
			var r = EventLog.GetEventLogs();
			return r;
		}
		public static void WriteEventLogEntry
										(
											//string logName,
											string sourceName,
											string logMessage,
											EventLogEntryType logEntryType
											, int eventID
										)
		{
			EventLog eventLog = new EventLog();
			eventLog.Source = sourceName;
			//eventLog.Log = logName;
			logMessage = string.Format
							(
								"{1}{0}Process [{3}] @ {4}{0}{5}{0}{2}"
								, "\r\n"
								, "begin ==========================================="
								, "end ============================================="
								, _processNameID
								, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
								, logMessage
							);
			eventLog.WriteEntry
				(
					logMessage
					, logEntryType
					, eventID
				);
		}
		public static bool TryCreateEventSourceLog
										(
											string logName,
											string sourceName,
											bool allowRecreate = false
										)
		{
			bool r = false;
			if (EventLog.SourceExists(sourceName))
			{
				if (allowRecreate)
				{
					try
					{
						var s = EventLog.LogNameFromSourceName(sourceName, ".");
						if (string.Compare(s, logName, true) != 0)
						{
							EventLog.DeleteEventSource(sourceName);
							EventLog.Delete(logName);
							EventLog.CreateEventSource(sourceName, logName);
							r = true;
						}
					}
					catch// (Exception e)
					{
						r = false;
					}
				}
				else
				{
					r = true;
				}
				
			}
			else
			{
				EventLog.CreateEventSource(sourceName, logName);
				r = true;
			}
			return r;
		}
	}
}

#T=HandleProcessCorruptedStateExceptions <legacyCorruptedStateExceptionsPolicy>
namespace ConsoleApplication
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.ExceptionServices;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		//[HandleProcessCorruptedStateExceptions]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine(Environment.Version.ToString());
			try
			{
				AccessViolation();
				Run();
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
			}
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
			Console.WriteLine("Bye World");
		}
		//[HandleProcessCorruptedStateExceptions]
		public static unsafe void AccessViolation()
		{
			byte b = *(byte*) (8762765876);
		}
		//[HandleProcessCorruptedStateExceptions]
		public static void Run()
		{
			var obj = new byte[1];
			var pin = GCHandle.Alloc(obj, GCHandleType.Pinned);
			unsafe
			{
				byte* p = (byte*)pin.AddrOfPinnedObject();
				for (int ix = 0; ix < 256; ++ix) *p-- = 0;
				GC.Collect();   // kaboom
			}
		}
	}
}
// exe.config
/*
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<runtime>
		<legacyCorruptedStateExceptionsPolicy enabled="false"/>
	</runtime>
</configuration>
*/
#T=HD硬盘序列号
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			string s = AtapiDevice.GetHddInfo(0).SerialNumber;
			Console.WriteLine(s);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	using System.Text;
	[Serializable]
	public struct HardDiskInfo
	{
		/// <summary>
		/// 型号
		/// </summary>
		public string ModuleNumber;
		/// <summary>
		/// 固件版本
		/// </summary>
		public string Firmware;
		/// <summary>
		/// 序列号
		/// </summary>
		public string SerialNumber;
		/// <summary>
		/// 容量，以M为单位
		/// </summary>
		public uint Capacity;
	}
	#region Internal Structs
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	internal struct GetVersionOutParams
	{
		public byte bVersion;
		public byte bRevision;
		public byte bReserved;
		public byte bIDEDeviceMap;
		public uint fCapabilities;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public uint[] dwReserved; // For future use.
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	internal struct IdeRegs
	{
		public byte bFeaturesReg;
		public byte bSectorCountReg;
		public byte bSectorNumberReg;
		public byte bCylLowReg;
		public byte bCylHighReg;
		public byte bDriveHeadReg;
		public byte bCommandReg;
		public byte bReserved;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	internal struct SendCmdInParams
	{
		public uint cBufferSize;
		public IdeRegs irDriveRegs;
		public byte bDriveNumber;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public byte[] bReserved;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public uint[] dwReserved;
		public byte bBuffer;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	internal struct DriverStatus
	{
		public byte bDriverError;
		public byte bIDEStatus;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public byte[] bReserved;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public uint[] dwReserved;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	internal struct SendCmdOutParams
	{
		public uint cBufferSize;
		public DriverStatus DriverStatus;
		public IdSector bBuffer;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1, Size = 512)]
	internal struct IdSector
	{
		public ushort wGenConfig;
		public ushort wNumCyls;
		public ushort wReserved;
		public ushort wNumHeads;
		public ushort wBytesPerTrack;
		public ushort wBytesPerSector;
		public ushort wSectorsPerTrack;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public ushort[] wVendorUnique;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
		public byte[] sSerialNumber;
		public ushort wBufferType;
		public ushort wBufferSize;
		public ushort wECCSize;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] sFirmwareRev;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 40)]
		public byte[] sModelNumber;
		public ushort wMoreVendorUnique;
		public ushort wDoubleWordIO;
		public ushort wCapabilities;
		public ushort wReserved1;
		public ushort wPIOTiming;
		public ushort wDMATiming;
		public ushort wBS;
		public ushort wNumCurrentCyls;
		public ushort wNumCurrentHeads;
		public ushort wNumCurrentSectorsPerTrack;
		public uint ulCurrentSectorCapacity;
		public ushort wMultSectorStuff;
		public uint ulTotalAddressableSectors;
		public ushort wSingleWordDMA;
		public ushort wMultiWordDMA;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
		public byte[] bReserved;
	}
	#endregion
	/// <summary>
	/// ATAPI驱动器相关
	/// </summary>
	public class AtapiDevice
	{
		#region DllImport
		[DllImport("kernel32.dll", SetLastError = true)]
		static extern int CloseHandle(IntPtr hObject);
		[DllImport("kernel32.dll", SetLastError = true)]
		static extern IntPtr CreateFile
								(
									string lpFileName ,
									uint dwDesiredAccess ,
									uint dwShareMode ,
									IntPtr lpSecurityAttributes ,
									uint dwCreationDisposition ,
									uint dwFlagsAndAttributes ,
									IntPtr hTemplateFile
								);
		[DllImport("kernel32.dll")]
		static extern int DeviceIoControl
								(
									IntPtr hDevice ,
									uint dwIoControlCode ,
									IntPtr lpInBuffer ,
									uint nInBufferSize ,
									ref GetVersionOutParams lpOutBuffer ,
									uint nOutBufferSize ,
									ref uint lpBytesReturned ,
									[Out] IntPtr lpOverlapped
								);
		[DllImport("kernel32.dll")]
		static extern int DeviceIoControl
								(
									IntPtr hDevice ,
									uint dwIoControlCode ,
									ref SendCmdInParams lpInBuffer ,
									uint nInBufferSize ,
									ref SendCmdOutParams lpOutBuffer ,
									uint nOutBufferSize ,
									ref uint lpBytesReturned ,
									[Out] IntPtr lpOverlapped
								);
		const uint DFP_GET_VERSION = 0x00074080;
		const uint DFP_SEND_DRIVE_COMMAND = 0x0007c084;
		const uint DFP_RECEIVE_DRIVE_DATA = 0x0007c088;
		const uint GENERIC_READ = 0x80000000;
		const uint GENERIC_WRITE = 0x40000000;
		const uint FILE_SHARE_READ = 0x00000001;
		const uint FILE_SHARE_WRITE = 0x00000002;
		const uint CREATE_NEW = 1;
		const uint OPEN_EXISTING = 3;
		#endregion
		#region GetHddInfo
		/// <summary>
		/// 获得硬盘信息
		/// </summary>
		/// <param name="driveIndex">硬盘序号</param>
		/// <returns>硬盘信息</returns>
		/// <remarks>
		/// 参考lu0的文章：http://lu0s1.3322.org/App/2k1103.html
		/// by sunmast for everyone
		/// thanks lu0 for his great works
		/// 在Windows 98/ME中，S.M.A.R.T并不缺省安装，请将SMARTVSD.VXD拷贝到%SYSTEM%\IOSUBSYS目录下。
		/// 在Windows 2000/2003下，需要Administrators组的权限。
		/// </remarks>
		/// <example>
		/// AtapiDevice.GetHddInfo()
		/// </example>
		public static HardDiskInfo GetHddInfo(byte driveIndex)
		{
			switch (Environment.OSVersion.Platform)
			{
				case PlatformID.Win32Windows:
					return GetHddInfo9x(driveIndex);
				case PlatformID.Win32NT:
					return GetHddInfoNT(driveIndex);
				case PlatformID.Win32S:
					throw new NotSupportedException("Win32s is not supported.");
				case PlatformID.WinCE:
					throw new NotSupportedException("WinCE is not supported.");
				default:
					throw new NotSupportedException("Unknown Platform.");
			}
		}
		#region GetHddInfo9x
		private static HardDiskInfo GetHddInfo9x(byte driveIndex)
		{
			GetVersionOutParams vers = new GetVersionOutParams();
			SendCmdInParams inParam = new SendCmdInParams();
			SendCmdOutParams outParam = new SendCmdOutParams();
			uint bytesReturned = 0;
			IntPtr hDevice = CreateFile
								(
									@"\\.\Smartvsd" ,
									0 ,
									0 ,
									IntPtr.Zero ,
									CREATE_NEW ,
									0 ,
									IntPtr.Zero
								);
			if (hDevice == IntPtr.Zero)
			{
				throw new Exception("Open smartvsd.vxd failed.");
			}
			if (0 == DeviceIoControl
							(
								hDevice ,
								DFP_GET_VERSION ,
								IntPtr.Zero ,
								0 ,
								ref vers ,
								(uint) Marshal.SizeOf(vers) ,
								ref bytesReturned ,
								IntPtr.Zero
							)
				)
			{
				CloseHandle(hDevice);
				throw new Exception("DeviceIoControl failed:DFP_GET_VERSION");
			}
			// If IDE identify command not supported, fails
			if (0 == (vers.fCapabilities & 1))
			{
				CloseHandle(hDevice);
				throw new Exception("Error: IDE identify command not supported.");
			}
			if (0 != (driveIndex & 1))
			{
				inParam.irDriveRegs.bDriveHeadReg = 0xb0;
			}
			else
			{
				inParam.irDriveRegs.bDriveHeadReg = 0xa0;
			}
			if (0 != (vers.fCapabilities & (16 >> driveIndex)))
			{
				// We don''t detect a ATAPI device.
				CloseHandle(hDevice);
				throw new Exception(string.Format("Drive {0} is a ATAPI device, we don''t detect it", driveIndex + 1));
			}
			else
			{
				inParam.irDriveRegs.bCommandReg = 0xec;
			}
			inParam.bDriveNumber = driveIndex;
			inParam.irDriveRegs.bSectorCountReg = 1;
			inParam.irDriveRegs.bSectorNumberReg = 1;
			inParam.cBufferSize = 512;
			if (0 == DeviceIoControl
						(
							hDevice ,
							DFP_RECEIVE_DRIVE_DATA ,
							ref inParam ,
							(uint) Marshal.SizeOf(inParam) ,
							ref outParam,
							(uint) Marshal.SizeOf(outParam) ,
							ref bytesReturned ,
							IntPtr.Zero
						)
				)
			{
				CloseHandle(hDevice);
				throw new Exception("DeviceIoControl failed: DFP_RECEIVE_DRIVE_DATA");
			}
			CloseHandle(hDevice);
			return GetHardDiskInfo(outParam.bBuffer);
		}
		#endregion
		#region GetHddInfoNT
		private static HardDiskInfo GetHddInfoNT(byte driveIndex)
		{
			GetVersionOutParams vers = new GetVersionOutParams();
			SendCmdInParams inParam = new SendCmdInParams();
			SendCmdOutParams outParam = new SendCmdOutParams();
			uint bytesReturned = 0;
			// We start in NT/Win2000
			IntPtr hDevice = CreateFile(
			string.Format(@"\\.\PhysicalDrive{0}", driveIndex),
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			IntPtr.Zero,
			OPEN_EXISTING,
			0,
			IntPtr.Zero);
			if (hDevice == IntPtr.Zero)
			{
				throw new Exception("CreateFile faild.");
			}
			if (0 == DeviceIoControl
							(
								hDevice ,
								DFP_GET_VERSION ,
								IntPtr.Zero ,
								0 ,
								ref vers ,
								(uint) Marshal.SizeOf(vers) ,
								ref bytesReturned ,
								IntPtr.Zero
							)
				)
			{
				CloseHandle(hDevice);
				throw new Exception(string.Format("Drive {0} may not exists.", driveIndex + 1));
			}
			// If IDE identify command not supported, fails
			if (0 == (vers.fCapabilities & 1))
			{
				CloseHandle(hDevice);
				throw new Exception("Error: IDE identify command not supported.");
			}
			// Identify the IDE drives
			if (0 != (driveIndex & 1))
			{
				inParam.irDriveRegs.bDriveHeadReg = 0xb0;
			}
			else
			{
				inParam.irDriveRegs.bDriveHeadReg = 0xa0;
			}
			if (0 != (vers.fCapabilities & (16 >> driveIndex)))
			{
				// We don''t detect a ATAPI device.
				CloseHandle(hDevice);
				throw new Exception(string.Format("Drive {0} is a ATAPI device, we don''t detect it.", driveIndex + 1));
			}
			else
			{
				inParam.irDriveRegs.bCommandReg = 0xec;
			}
			inParam.bDriveNumber = driveIndex;
			inParam.irDriveRegs.bSectorCountReg = 1;
			inParam.irDriveRegs.bSectorNumberReg = 1;
			inParam.cBufferSize = 512;
			if (0 == DeviceIoControl
							(
								hDevice ,
								DFP_RECEIVE_DRIVE_DATA ,
								ref inParam ,
								(uint)Marshal.SizeOf(inParam) ,
								ref outParam ,
								(uint)Marshal.SizeOf(outParam) ,
								ref bytesReturned ,
								IntPtr.Zero
							)
				)
			{
				CloseHandle(hDevice);
				throw new Exception("DeviceIoControl failed: DFP_RECEIVE_DRIVE_DATA");
			}
			CloseHandle(hDevice);
			return GetHardDiskInfo(outParam.bBuffer);
		}
		#endregion
		private static HardDiskInfo GetHardDiskInfo(IdSector phdinfo)
		{
			HardDiskInfo hddInfo = new HardDiskInfo();
			ChangeByteOrder(phdinfo.sModelNumber);
			hddInfo.ModuleNumber = Encoding.ASCII.GetString(phdinfo.sModelNumber).Trim();
			ChangeByteOrder(phdinfo.sFirmwareRev);
			hddInfo.Firmware = Encoding.ASCII.GetString(phdinfo.sFirmwareRev).Trim();
			ChangeByteOrder(phdinfo.sSerialNumber);
			hddInfo.SerialNumber = Encoding.ASCII.GetString(phdinfo.sSerialNumber).Trim();
			hddInfo.Capacity = phdinfo.ulTotalAddressableSectors / 2 / 1024;
			return hddInfo;
		}
		private static void ChangeByteOrder(byte[] charArray)
		{
			byte temp;
			for (int i = 0; i < charArray.Length; i += 2)
			{
				temp = charArray[i];
				charArray[i] = charArray[i + 1];
				charArray[i + 1] = temp;
			}
		}
		#endregion
	}
}

#T=Health Check Aspx
<%@ Page language="C#" validaterequest="false" enableviewstate="false"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
	<head>
		<title>
			DetailsView GridView Query Edit Example
		</title>
		<meta name="generator" content="editplus" />
		<meta name="author" content="" />
		<meta name="keywords" content="" />
		<meta name="description" content="" />
	</head>
<body>
	Client IP:
	<%=
		Request.UserHostAddress
	%>
	<br>
	Server Machine Name:
	<%=
		Environment.MachineName
	%>
	<br>
	<form id="form1" runat="server">
		<asp:gridview
			id="GridView1" 
			datasourceid="SqlDataSource1" 
			autogeneratecolumns="true"
			allowpaging="true"
			pagesize="20"
			runat="server"
		>
		</asp:gridview>
		<!-- to do -->
		<asp:sqldatasource
			id="SqlDataSource1"
			selectcommand=
							"
								select
									getdate() as [getdate()]
									, @@ServerName as [@@ServerName]
									, @@ServiceName as [@@ServiceName]
									, suser_name() as [suser_name()]
									, suser_id() as [suser_id()]
									, user_name() as [user_name()]
									, host_name() as [host_name()]
									--, @@version as [@@version]
							"
			connectionstring="Application Name=HealthCheckApp;Persist Security Info=False;Data Source=ServerName;user=sa;password=password"
			runat="server"
		>
		</asp:sqldatasource>
		<br/>
		<asp:gridview
			id="GridView2" 
			datasourceid="SqlDataSource2" 
			autogeneratecolumns="true"
			allowpaging="true"
			pagesize="20"
			runat="server"
		>
		</asp:gridview>
		<!-- to do -->
		<asp:sqldatasource
			id="SqlDataSource2"
			selectcommand=
							"
								select
									getdate() as [getdate()]
									, @@ServerName as [@@ServerName]
									, @@ServiceName as [@@ServiceName]
									, suser_name() as [suser_name()]
									, suser_id() as [suser_id()]
									, user_name() as [user_name()]
									, host_name() as [host_name()]
									--, @@version as [@@version]
							"
			connectionstring="Application Name=HealthCheckApp;Persist Security Info=False;Data Source=ServerName;user=sa;password=password"
			runat="server"
		>
		</asp:sqldatasource>
		<br/>
	</form>
</body>
</html>

#T=Helper 集锦 2008-10-31
namespace Microsoft.Common
{
	using System;
	using System.Net.Sockets;

	using System.Globalization;
	
	public static class DateTimeHelper
	{
		public static string Get_MMddHHmmss_String(DateTime time)
		{
			return time.ToString("MMddHHmmss");
		}
		public static string Get_yyyyMMddHHmmss_String(DateTime time)
		{
			return time.ToString("yyyyMMddHHmmss");
		}
		public static string Get_yyyyMMdd_String(DateTime time)
		{
			return time.ToString("yyyyMMdd");
		}
		public static DateTime Parse_yyyyMMddHHmmss(string text)
		{
			DateTime time = DateTime.TryParseExact
								(
									text
									, "yyyyMMddHHmmss"
									, DateTimeFormatInfo.InvariantInfo
									, DateTimeStyles.None
									, out time
								) ? time : DateTime.MinValue;
			return time;
		}
		public static DateTime Parse_MMddHHmmss(int year, string text)
		{
			return Parse_yyyyMMddHHmmss(year.ToString("0000") + text);
		}
	}
 }
namespace Microsoft.Common
{
	using System;
   
	public static class MessagePrinterHelper1
	{
		public static void Print(ILogable message)
		{
			Print(message, ConsoleColor.Red);
		}
		public static void Print(ILogable message, ConsoleColor foregroundColor)
		{
			ConsoleColor cc = Console.ForegroundColor;
			Console.ForegroundColor = foregroundColor;
			Console.WriteLine(message.ToString());
			Console.ForegroundColor = cc;
		}
	}
}
namespace Microsoft.Common
{
	using System;
	public static class StringHelper
	{
		public static bool IsValidString(string text)
		{
			return (text != string.Empty && text != null && text.Trim().Length > 0);
		}
	}
}

namespace Microsoft.Common
{
	using System;
	public static class IntegerHelper
	{
		public static int Int32Parse(string text)
		{
			int i = int.TryParse
							(
								text
								, out i
							) ? i : int.MinValue;
			return i;
		}
		public static uint UInt32Parse(string text)
		{
			uint i = uint.TryParse
							(
								text
								, out i
							) ? i : uint.MaxValue;
			return i;
		}
		public static short Int16Parse(string text)
		{
			short i = short.TryParse
							(
								text
								, out i
							) ? i : short.MinValue;
			return i;
		}
		public static ushort UInt16Parse(string text)
		{
			ushort i = ushort.TryParse
							(
								text
								, out i
							) ? i : ushort.MaxValue;
			return i;
		}
		public static long Int64Parse(string text)
		{
			long i = long.TryParse
							(
								text
								, out i
							) ? i : long.MinValue;
			return i;
		}
		public static ulong UInt64Parse(string text)
		{
			ulong i = ulong.TryParse
							(
								text
								, out i
							) ? i : ulong.MaxValue;
			return i;
		}
	}
}
namespace Microsoft.Common
{
	using System;
	using System.Net.Sockets;

	using System.Globalization;
	public static class SocketDataHelper
	{
		public static void ReadDataToBytes
						(
							Socket socket
							, ref byte[] buffer
						)
		{
			int p = 0;
			int l = buffer.Length;
			while (p < l)
			{
				int r = socket.Receive
									(
										buffer
										, p
										, l - p
										, SocketFlags.None
									);
				p += r;
			}
		}

		public static byte[] ReadDataToBytes(int length, Socket socket)
		{
			int i;
			byte[] bytes = new byte[length];
			for (int r = socket.Receive(bytes); r < length; r += i)
			{
				byte[] buffer = new byte[length - r];
				i = socket.Receive(buffer);
				Buffer.BlockCopy(buffer, 0, bytes, r, i);
			}
			return bytes;
		}
	}
}
namespace Microsoft.Common
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;

			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}

			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;

		}
	}
}

namespace Microsoft.Common
{
	using System;
	using System.Security.Cryptography;
	using System.Text;
	using System.IO;
	class Class1
	{
		static void Main1()
		{
			//RSA
			UTF8Encoding e = new UTF8Encoding();
			byte[] data = e.GetBytes("测试@microshaoft.com");
			byte[] encryptedData;

			string sss = "asdasdasdazzzzzzzzzzzzzzzzzzzzzsdas";
			byte[] bf;
			bf = CryptoHelper.ComputeMD5(sss);
			Console.WriteLine(bf.Length);
			//byte[] decryptedData;
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			string privateKey = x.ToXmlString(true);
			string publicKey = x.ToXmlString(false);
			//公钥加密
			encryptedData = CryptoHelper.RSAEncrypt(data, publicKey, false);
			//私钥解密
			data = CryptoHelper.RSADecrypt(encryptedData, privateKey, false);

			Console.WriteLine("Decrypted plaintext: {0}", e.GetString(data));

			//私钥签名
			byte[] signature = CryptoHelper.RSASignSHA1(data, privateKey);
			//公钥验签
			Console.WriteLine(CryptoHelper.RSAVerifySHA1(data, publicKey, signature));
			Console.WriteLine(Environment.Version.ToString());
		}
	}
	public class CryptoHelper
	{
		static public byte[] RSASignSHA1
			(
				byte[] data
				, string privateKey
			)
		{
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			x.FromXmlString(privateKey);
			return x.SignHash
						(
							ComputeSHA1(data)
							, "SHA1"
						);
		}
		public static bool RSAVerifySHA1
								(
									byte[] data
									, string publicKey
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.VerifyHash
								(
									ComputeSHA1(data)
									, "SHA1"
									, signature
								);
		}
		public static byte[] RSASignMD5
			(
				byte[] data
				, string privateKey
			)
		{
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			x.FromXmlString(privateKey);
			return x.SignHash
						(
							ComputeMD5(data)
							, "MD5"
						);
		}
		public static bool RSAVerifyMD5
								(
									byte[] data
									, string publicKey
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.VerifyHash
								(
									ComputeMD5(data)
									, "MD5"
									, signature
								);
		}

		public static byte[] RSAEncrypt
								(
									byte[] data
									, string publicKey
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.Encrypt(data, DoOAEPPadding);
		}
		public static byte[] RSADecrypt
								(
									byte[] data
									, string privateKey
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKey);
			return provider.Decrypt(data, DoOAEPPadding);
		}

		/// <summary>
		/// Crypto 的摘要说明。
		/// </summary>
		public static byte[] TripleDESDecrypt
			(
				byte[] data
				, byte[] Key
				, byte[] IV
			)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
		}
		public static byte[] TripleDESDecrypt
			(
				string text
				, string Base64Key
				, string Base64IV
			)
		{
			return TripleDESDecrypt
				(
					Convert.FromBase64String(text)
					, Convert.FromBase64String(Base64Key)
					, Convert.FromBase64String(Base64IV)
				);
		}
		public static byte[] TripleDESDecrypt
			(
				string text
				, byte[] Key
				, byte[] IV
			)
		{
			return TripleDESDecrypt
				(
					Convert.FromBase64String(text)
					, Key
					, IV
				);
		}
		public static string TripleDESDecrypt
			(
				string text
				, string Base64Key
				, string Base64IV
				, Encoding e //原文的encoding
			)
		{
			return e.GetString
				(
					TripleDESDecrypt
						(
							text
							, Base64Key
							, Base64IV
						)
				);
		}
		public static string TripleDESDecrypt
			(
				string text
				, byte[] Key
				, byte[] IV
				, Encoding e //原文的encoding
			)
		{
			return e.GetString
				(
					TripleDESDecrypt
						(
							text
							, Key
							, IV
						)
				);
		}
		public static string GenerateTripleDESHexStringKey()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateKey();
			return BytesArrayToHexString(des.Key);
		}
		public static string GenerateTripleDESHexStringIV()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateIV();
			return BytesArrayToHexString(des.IV);
		}
		public static byte[] TripleDESEncrypt
			(
				byte[] data
				, byte[] Key
				, byte[] IV
			)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
		}
		public static byte[] TripleDESEncrypt
			(
				string text
				, Encoding e
				, byte[] Key
				, byte[] IV
			)
		{
			return TripleDESEncrypt
				(
					e.GetBytes(text)
					, Key
					, IV
				);
		}
		public static byte[] TripleDESEncrypt
			(
				string text
				, Encoding e
				, string Base64Key
				, string Base64IV
			)
		{
			return TripleDESEncrypt
				(
					text
					, e
					, Convert.FromBase64String(Base64Key)
					, Convert.FromBase64String(Base64IV)
				);
		}

		public static byte[] ComputeSHA1(byte[] data)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(data);
		}
		public static byte[] ComputeSHA1(string text, Encoding e)
		{
			return ComputeSHA1(e.GetBytes(text));
		}
		public static byte[] ComputeSHA1(string text)
		{
			return ComputeSHA1(text, Encoding.UTF8);
		}
		public static byte[] ComputeSHA1(Stream stream)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(stream);
		}

		public static byte[] ComputeMD5(byte[] data)
		{
			return new MD5CryptoServiceProvider().ComputeHash(data, 0, data.Length);
		}
		public static byte[] ComputeMD5(string text, Encoding e)
		{
			return ComputeMD5(e.GetBytes(text));
		}
		public static byte[] ComputeMD5(string text)
		{
			return ComputeMD5(text, Encoding.UTF8);
		}
		public static byte[] ComputeMD5(Stream stream)
		{
			return new MD5CryptoServiceProvider().ComputeHash(stream);
		}
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}

namespace Microsoft.Common
{
	using System;
	using System.Collections.Specialized;
	using System.Text;

	public static class HttpHelper
	{
		public static string GenerateFormHTML
								(
									NameValueCollection httpRequestFields
									, string formName
									, string httpMethod
									, string actionUrl
								)
		{
			StringBuilder sb = new StringBuilder();
			sb.Append(string.Format("<form name=\"{0}\" method=\"{1}\" action=\"{2}\"><br>", formName, httpMethod, actionUrl));
			foreach (string var in httpRequestFields.AllKeys)
			{
				string s = string.Format
									(
										"{0} <input type=\"text\" name=\"{0}\" value=\"{1}\" /><br>"
										, var
										, httpRequestFields[var]
									);
				if (StringHelper.IsValidString(s))
				{
					sb.Append(s);
				}
			}
			sb.Append("<input type=\"submit\" />");
			sb.Append("</form>");
			//sb.Append(string.Format("<script type=\"text/javascript\">alert('asda');{0}.submit()</script>", formName));
			return sb.ToString();
		}
	}
}
//logHelper
namespace Microsoft.Common
{
	using System;
	using System.IO;
	using System.Text;

	/// <summary>
	/// Utility 的摘要说明。
	/// </summary>
	public class LogHelper
	{
		public static void PrintMessage(ILogable message)
		{
			PrintMessage(message, ConsoleColor.Red);
		}
		public static void PrintMessage(ILogable message, ConsoleColor foregroundColor)
		{
			ConsoleColor cc = Console.ForegroundColor;
			Console.ForegroundColor = foregroundColor;
			Console.WriteLine(message.ToString());
			Console.ForegroundColor = cc;
		}
		public static void WriteFile
			(
				string fileName
				, string content
				, Encoding encoding
			)
		{

			string path = System.IO.Path.GetDirectoryName(fileName);

			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}

			using (FileStream fs = new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite))
			{
				StreamWriter sw = new StreamWriter(fs, encoding);
				sw.BaseStream.Seek(0, SeekOrigin.End);
				sw.WriteLine("\nBegin:==============================================");
				sw.WriteLine(content);
				sw.WriteLine("\nEnd;================================================");
				sw.Flush();
				sw.Close();
			}
		}
		public static void WriteLog
			(
				string fileName
				, string content
				, string logType
			)
		{

			WriteLog(fileName, content, logType, "\r\n", Encoding.GetEncoding("gb2312"));
		}
		public static void WriteLog
			(
				string fileName
				, string content
				, string logType
				, string delimiter
				, Encoding encoding
			)
		{

			string s = string.Format
				(
					"{1}: {0}{2}{0}{3}"
					, delimiter
					, logType
					, DateTime.Now.ToString()
					, content
				);

			WriteFile(fileName, s, encoding);
		}
	}
}
namespace Microsoft.Common
{
	using System;
	using System.Text;
	using System.IO;
	using System.IO.Compression;
	public class CompressHelper
	{
		public static byte[] ReadStreamToBytes1(Stream stream)
		{
			byte[] buffer = new byte[64 * 2];
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			MemoryStream ms = new MemoryStream();
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
		public static byte[] GZipCompress(byte[] DATA)
		{
			MemoryStream ms = new MemoryStream();
			GZipStream stream = new GZipStream(ms, CompressionMode.Compress, true);
			stream.Write(DATA, 0, DATA.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			byte[] buffer = StreamDataHelper.ReadDataToBytes(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return buffer;
		}
		public static byte[] GZipDecompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream(data);
			GZipStream stream = new GZipStream(ms, CompressionMode.Decompress);
			byte[] buffer = StreamDataHelper.ReadDataToBytes(stream);
			ms.Close();
			ms.Dispose();
			ms = null;
			stream.Close();
			stream.Dispose();
			stream = null;
			return buffer;
		}
		public static Stream GZipCompress(Stream DATA)
		{
			byte[] buffer = StreamDataHelper.ReadDataToBytes(DATA);
			MemoryStream ms = new MemoryStream();
			GZipStream stream = new GZipStream(ms, CompressionMode.Compress, true);
			stream.Write(buffer, 0, buffer.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			if (ms.CanSeek)
			{
				ms.Position = 0;
			}
			return ms;
		}
		public static Stream GZipDecompress(Stream data)
		{
			byte[] buffer = StreamDataHelper.ReadDataToBytes(data);
			MemoryStream ms = new MemoryStream(buffer);
			GZipStream stream = new GZipStream(ms, CompressionMode.Decompress);
			if (stream.CanSeek)
			{
				stream.Position = 0;
			}
			return stream;
		}
		public static byte[] DeflateCompress(byte[] DATA)
		{
			MemoryStream ms = new MemoryStream();
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true);
			stream.Write(DATA, 0, DATA.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			byte[] buffer = StreamDataHelper.ReadDataToBytes(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return buffer;
		}
		public static byte[] DeflateDecompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream(data);
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Decompress);
			byte[] buffer = StreamDataHelper.ReadDataToBytes(stream);
			ms.Close();
			ms.Dispose();
			ms = null;
			stream.Close();
			stream.Dispose();
			stream = null;
			return buffer;
		}
		public static Stream DeflateCompress(Stream DATA)
		{
			byte[] buffer = StreamDataHelper.ReadDataToBytes(DATA);
			MemoryStream ms = new MemoryStream();
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true);
			stream.Write(buffer, 0, buffer.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			if (ms.CanSeek)
			{
				ms.Position = 0;
			}
			return ms;
		}
		public static Stream DeflateDecompress(Stream data)
		{
			byte[] buffer = StreamDataHelper.ReadDataToBytes(data);
			MemoryStream ms = new MemoryStream(buffer);
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Decompress);
			if (stream.CanSeek)
			{
				stream.Position = 0;
			}
			return stream;
		}
	}
}
namespace Microsoft.Common
{
	//using System;
	public interface ILogable
	{
		string ToString();
		byte[] ToBytes();
	}

}

#T=HTML editor KindEditor+WebBrowser
/*
	KindEditor
	http://www.kindsoft.net/view.php?bbsid=3&postid=4531
*/
namespace WebBrowserHTMLEditor
{
	using System;
	using System.Collections.Generic;
	using System.Windows.Forms;

	static class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}
namespace WebBrowserHTMLEditor
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;

	[ComVisible(true)]
	public partial class Form1 : Form
	{
		string content = "";
		public Form1()
		{
			InitializeComponent();
			this.webBrowser1.Url = new System.Uri(Application.StartupPath + "\\kindeditor\\e.html", System.UriKind.Absolute);
			this.webBrowser1.ObjectForScripting = this;

		}
		public void SetDetailContent()
		{

			webBrowser1.Document.InvokeScript("setContent", new object[] { content });
		}
		public string GetContent()
		{
			return content;
		}
		public void RequestContent(string str)
		{
			content = str;
			richTextBox1.Text = content;
		}

		private void richTextBox1_TextChanged(object sender, EventArgs e)
		{
			if (richTextBox1.Focused)
			{
				content = richTextBox1.Text;
				SetDetailContent();
			}
		}

		private void webBrowser1_Resize(object sender, EventArgs e)
		{
			this.webBrowser1.Refresh();
		}
	}
}

namespace WebBrowserHTMLEditor
{
	partial class Form1
	{
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		/// <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows 窗体设计器生成的代码

		/// <summary>
		/// 设计器支持所需的方法 - 不要
		/// 使用代码编辑器修改此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.webBrowser1 = new System.Windows.Forms.WebBrowser();
			this.richTextBox1 = new System.Windows.Forms.RichTextBox();
			this.SuspendLayout();
			// 
			// webBrowser1
			// 
			this.webBrowser1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
						| System.Windows.Forms.AnchorStyles.Left)
						| System.Windows.Forms.AnchorStyles.Right)));
			this.webBrowser1.Location = new System.Drawing.Point(2, 102);
			this.webBrowser1.MinimumSize = new System.Drawing.Size(20, 20);
			this.webBrowser1.Name = "webBrowser1";
			this.webBrowser1.Size = new System.Drawing.Size(466, 346);
			this.webBrowser1.TabIndex = 0;
			this.webBrowser1.Resize += new System.EventHandler(this.webBrowser1_Resize);
			// 
			// richTextBox1
			// 
			this.richTextBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
						| System.Windows.Forms.AnchorStyles.Right)));
			this.richTextBox1.Location = new System.Drawing.Point(2, 0);
			this.richTextBox1.Name = "richTextBox1";
			this.richTextBox1.Size = new System.Drawing.Size(466, 96);
			this.richTextBox1.TabIndex = 1;
			this.richTextBox1.Text = "";
			this.richTextBox1.TextChanged += new System.EventHandler(this.richTextBox1_TextChanged);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(469, 448);
			this.Controls.Add(this.richTextBox1);
			this.Controls.Add(this.webBrowser1);
			this.Name = "Form1";
			this.Text = "WebBrowserHTMLEditor";
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.WebBrowser webBrowser1;
		private System.Windows.Forms.RichTextBox richTextBox1;
	}
}


#T=HttpClient WebAPI Get Post Json
/*
rem curl Post Json
D:\curl\curl-7.33.0-win64\bin\curl.exe -i -X POST -H "Accept: application/json" -H "Content-Type: application/json; charset=utf-8" -d "[{Name:'curl1',\"Age\":0,'Height':1,'Weight':2},{'Name':\"curl2\",'Age':0,'Height':1,'Weight':2}]" "http://api.asp.net.local/services/restful/api/persons/" -v
*/
namespace ClientTest
{
	using Microshaoft;
	using Microshaoft.Models;
	using System;
	using System.Collections.Generic;
	using System.Net.Http;
	using System.Net.Http.Headers;
	class Program
	{
		static void Main(string[] args)
		{
			string url = @"http://api.asp.net.local/services/restful/api/Persons/";
			HttpClient client = new HttpClient();
			client
				.DefaultRequestHeaders
					.Accept
						.Add
							(
								new MediaTypeWithQualityHeaderValue("application/json")
							);
			Console.WriteLine("Get test:");
			var result = client.GetJsonObjects<Person>(url);
			foreach (var i in result)
			{
				Console.WriteLine(i);
			}
			Console.WriteLine("Post test:");
			HttpResponseMessage response
				= client.PostJsonObjects<Person>
						(
							url
							, new Person[]
							{
								new Person()
								{
									Name = "c1"
									, Height = 1
									, Weight = 2
								}
								,
								 new Person()
								{
									Name = "c2"
									, Height = 1
									, Weight = 2
								}
							}
						);
			Console.WriteLine(response.IsSuccessStatusCode);
			if (response.IsSuccessStatusCode)
			{
				result = response.Content.ReadAsAsync<IEnumerable<Person>>().Result;
				foreach (var i in result)
				{
					Console.WriteLine(i);
				}
			}
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System.Collections.Generic;
	using System.Net.Http;
	public static partial class HttpClientExtensionsMethodsManager
	{
		public static IEnumerable<T> GetJsonObjects<T>(this HttpClient httpClient, string url)
		{
			HttpResponseMessage response
						= httpClient.GetAsync(url).Result;
			var result = response.Content.ReadAsAsync<IEnumerable<T>>().Result;
			return result;
		}
		public static HttpResponseMessage PostJsonObjects<T>
											(
												this HttpClient httpClient
												, string url
												, T[] jsonObjects
											)
		{
			HttpResponseMessage response = httpClient.PostAsJsonAsync(url, jsonObjects).Result;
			return response;
		}
	}
}
// Models.cs
namespace Microshaoft.Models
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Runtime.Serialization;
	public static class PersonsManager
	{
		public static List<Person> _persons = new Person[]
								{
									new Person("张嘀", 71, 178, 49)
									, new Person("章子怡", 23, 177, 33)
									, new Person("周迅", 12, 180, 80)
									, new Person("徐静蕾", 12, 150, 70)
									, new Person("赵薇", 23, 166, 60)
									, new Person("宋丹丹", 50, 183, 50)
									, new Person("翠花儿", 23, 177, 34)
									, new Person("赵丽蓉", 50, 184, 40)
									, new Person("郭晶晶", 50, 184, 41)
								}.ToList();
		public static List<Person> Persons
		{
			get
			{
				return _persons;
			}
		}
	}
	[DataContract]
	public class Person : IComparable<Person>
	{
		[DataMember]
		public string Name
		{
			get;
			set;
		}
		[DataMember]
		public int Age
		{
			get;
			set;
		}
		[DataMember]
		public int Height
		{
			get;
			set;
		}
		[DataMember]
		public int Weight
		{
			get;
			set;
		}
		public Person(string name, int age, int height, int weight)
		{
			Name = name;
			Age = age;
			Height = height;
			Weight = weight;
		}
		public Person()
		{
		}
		public override string ToString()
		{
			return
				string.Format
						(
							"姓名:{0}, 年龄:{1:N}, 体重:{2:N}, 身高:{3:N}"
							, Name
							, Age
							, Height
							, Weight
						);
		}
		public int CompareTo(Person other)
		{
			int r = 0;
			r = Age - other.Age;
			if (r == 0)
			{
				r = Height - other.Height;
				if (r == 0)
				{
					r = Weight - other.Weight;
				}
			}
			return r;
		}
	}
}
#T=HttpHandler 图片切割 ASHX
<%@ WebHandler Language="c#" Class="Microshaoft.ImgCropper_WebHandler" Debug="true" %>
namespace Microshaoft
{
	using System;
	using System.Web;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.IO;

	public class ImgCropper_WebHandler : IHttpHandler
	{
		public void ProcessRequest(HttpContext context)
		{
			string Pic = Convert.ToString(context.Request["p"]);
			int PointX = Convert.ToInt32(context.Request["x"]);
			int PointY = Convert.ToInt32(context.Request["y"]);
			int CutWidth = Convert.ToInt32(context.Request["w"]);
			int CutHeight = Convert.ToInt32(context.Request["h"]);
			int PicWidth = Convert.ToInt32(context.Request["pw"]);
			int PicHeight = Convert.ToInt32(context.Request["ph"]);

			context.Response.ContentType = "image/jpeg";
			ResetImg
				(
					HttpContext.Current.Server.MapPath(Pic)
					, PicWidth
					, PicHeight
					, PointX
					, PointY
					, CutWidth
					, CutHeight
				).WriteTo
					(
						context.Response.OutputStream
					);
		}
		
		public MemoryStream ResetImg(string ImgFile, int PicWidth, int PicHeight, int PointX, int PointY, int CutWidth, int CutHeight)
		{
			Image imgPhoto = Image.FromFile(ImgFile);
			Bitmap bmPhoto = new Bitmap(CutWidth, CutHeight, System.Drawing.Imaging.PixelFormat.Format24bppRgb);

			Graphics gbmPhoto = Graphics.FromImage(bmPhoto);
			gbmPhoto.DrawImage
						(
							imgPhoto
							, new Rectangle(0, 0, CutWidth, CutHeight)
							, PointX * imgPhoto.Width / PicWidth, PointY * imgPhoto.Height / PicHeight
							, CutWidth * imgPhoto.Width / PicWidth, CutHeight * imgPhoto.Height / PicHeight
							, GraphicsUnit.Pixel
						);

			MemoryStream ms2 = new MemoryStream();
			bmPhoto.Save(ms2, ImageFormat.Jpeg);

			imgPhoto.Dispose();
			gbmPhoto.Dispose();
			bmPhoto.Dispose();

			return ms2;
		}
		public bool IsReusable
		{
		get
		{
			return false;
		}
		}
	}
}
#T=HttpHelper
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine(StringHelper.IsValidString(null));
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}

}
namespace Microshaoft
{
	using System;
	public static class StringHelper
	{
		public static bool IsValidString(string text)
		{
			return (text != string.Empty && text != null && text.Trim().Length > 0);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Specialized;
	using System.Text;

	public static class HttpHelper
	{
		public static string GenerateFormHTML
								(
									NameValueCollection httpRequestFields
									, string formName
									, string httpMethod
									, string actionUrl
								)
		{
			StringBuilder sb = new StringBuilder();
			sb.Append(string.Format("<form name=\"{0}\" method=\"{1}\" action=\"{2}\"><br>", formName, httpMethod, actionUrl));
			foreach (string var in httpRequestFields.AllKeys)
			{
				string s = string.Format
									(
										"{0} <input type=\"text\" name=\"{0}\" value=\"{1}\" /><br>" 
										, var
										, httpRequestFields[var]
									);
				if (StringHelper.IsValidString(s))
				{
					sb.Append(s);
				}
			}
			sb.Append("<input type=\"submit\" />");
			sb.Append("</form>");
			//sb.Append(string.Format("<script type=\"text/javascript\">alert('asda');{0}.submit()</script>", formName));
			return sb.ToString();
		}
	}
}

#T=HttpListener
//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------

// The HttpRequestListener example demonstrates how to add the ability to 
// process HTTP requests from within a client application.
namespace Microsoft.Samples.HttpListener
{
	using System;
	using System.Net;
	using System.IO;
	using System.Text;
	using System.Globalization;
	static class HttpRequestListener
	{
		public static void Main()
		{
			string[] prefixes = new string[1];
			prefixes[0] = "http://*:8080/HttpListener/";
			ProcessRequests(prefixes);
		}
		private static void ProcessRequests(string[] prefixes)
		{
			if (!System.Net.HttpListener.IsSupported)
			{
				Console.WriteLine(
					"Windows XP SP2, Server 2003, or higher is required to " +
					"use the HttpListener class.");
				return;
			}
			// URI prefixes are required,
			if (prefixes == null || prefixes.Length == 0)
				throw new ArgumentException("prefixes");

			// Create a listener and add the prefixes.
			System.Net.HttpListener listener = new System.Net.HttpListener();
			foreach (string s in prefixes)
			{
				listener.Prefixes.Add(s);
			}

			try
			{
				// Start the listener to begin listening for requests.
				listener.Start();
				Console.WriteLine("Listening...");

				// Set the number of requests this application will handle.
				int numRequestsToBeHandled = 10;

				for (int i = 0; i < numRequestsToBeHandled; i++)
				{
					HttpListenerResponse response = null;
					try
					{
						// Note: GetContext blocks while waiting for a request.
						HttpListenerContext context = listener.GetContext();

						// Create the response.
						response = context.Response;
						string responseString =
							"<HTML><BODY>The time is currently " +
							DateTime.Now.ToString(
							DateTimeFormatInfo.CurrentInfo) +
							"</BODY></HTML>";
						byte[] buffer =
							System.Text.Encoding.UTF8.GetBytes(responseString);
						response.ContentLength64 = buffer.Length;
						System.IO.Stream output = response.OutputStream;
						output.Write(buffer, 0, buffer.Length);
					}
					catch (HttpListenerException ex)
					{
						Console.WriteLine(ex.Message);
					}
					finally
					{
						if (response != null)
							response.Close();
					}
				}
			}
			catch (HttpListenerException ex)
			{
				Console.WriteLine(ex.Message);
			}
			finally
			{
				// Stop listening for requests.
				listener.Close();
				Console.WriteLine("Done Listening.");
			}
		}
	}
}

#T=httpModule AuthenticateRequest
namespace Microshaoft
{
	using System;
	using System.Web;
	using System.Threading;
	using System.Collections.Specialized;
	public class AuthenticationPreProcessHttpModule : IHttpModule
	{
		HttpApplication _application;
		HttpContext _context;

		public void Init(HttpApplication application)
		{
			_application = application;
			_context = _application.Context;

			_application.AuthenticateRequest += new EventHandler(_application_AuthenticateRequest);
			_application.EndRequest +=new EventHandler(_application_EndRequest);
		}

		void _application_EndRequest(object sender, EventArgs e)
		{
			//_context.Response.AddHeader
			//					(
			//							"WWW-Authenticate"
			//							, string.Format(@"Basic realm =""{0}""", "Microshaoft")
			//						);
			if (_needRedirect)
			{
				RedirectToBasicAuthentication();
			}
		}

		private bool _needRedirect = false;
			 
		void _application_AuthenticateRequest(object sender, EventArgs e)
		{
			NameValueCollection nvc = _context.Request.Headers;


///			foreach (string k in nvc.AllKeys)
///			{
///				_context.Response.Write(k + "<br>");
///				_context.Response.Write(nvc[k] + "<br>");
///			}

			//to do 根据 header信息判断是否 集成登录 已经

			if (_context.Request.Headers["Authorization"] != null)
			{
				if (!_context.Request.Headers["Authorization"].Contains("Negotiate"))
				{
					_needRedirect = true;
				}
			}
			//throw new NotImplementedException();
		}
		private void RedirectToBasicAuthentication()
		{
			try
			{
				if (_needRedirect)
				{
					_context.Response.Redirect("http://baidu.com");
				}
				
			}
			catch (ThreadAbortException tae)
			{

			}
		}




		public void Dispose()
		{
			// 
			// Do nothing here 
			// 
		}
	}
}
#T=HttpModule iis7+ 集成模式
/*
csc.exe /t:library StrConvHttpModule.cs /r:C:\windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.VisualBasic.dll 
	<system.webServer>
		<modules>
			<add name="ResponseFilterHttpModule" type="Microshaoft.HttpModules.StrConvHttpModule, noname1" />
		</modules>
	</system.webServer>
	<system.web>
		<httpModules>
			<add name="ResponseFilterHttpModule" type="Microshaoft.HttpModules.StrConvHttpModule, noname1" />
		</httpModules>
	</system.web>
*/
namespace Microshaoft.HttpModules
{
	using System;
	using System.Web; 
	using System.Threading;
	using System.Collections;

	using Microshaoft;

	public class ResponseFilterHttpModule : IHttpModule
	{
		public string ModuleName
		{
			get
			{
				return "ResponseFilterHttpModule";
			}
		}
		public void Init(HttpApplication application)
		{
			application.BeginRequest += (new EventHandler(this.Application_BeginRequest));
		}
		private void Application_BeginRequest(object sender, EventArgs e)
		{
			HttpApplication application = (HttpApplication) sender;
			HttpContext context = application.Context;
			HttpRequest request = context.Request;
			HttpResponse response = context.Response;
			//if (response.ContentType == "text/html")
			{
				response.Filter = new ResponseFilterStream
												(
													response.Filter
													, application
												);
			}
			
		}
		public void Dispose()
		{
		}
	}
}

namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Web;
	using System.Text;
	using System.Globalization;

	using Microsoft.VisualBasic;

	public class ResponseFilterStream : Stream
	{
		private Stream _sink;
		private long _position;
		private HttpApplication _application;
		private HttpContext _context;
		private HttpRequest _request;
		private HttpResponse _response;

		public ResponseFilterStream
						(
							Stream sink
							, HttpApplication application
						)
		{
			_application = application;
			_context = application.Context;
			_request = _context.Request;
			_response = _context.Response;
			_sink = sink;
		}

		public override bool CanRead
		{
			get
			{
				return true;
			}
		}

		public override bool CanSeek
		{
			get
			{
				return true;
			}
		}

		public override bool CanWrite
		{
			get
			{
				return true;
			}
		}

		public override long Length
		{
			get
			{
				return 0;
			}
		}

		public override long Position
		{
			get
			{
				return this._position;
			}
		set
			{
				this._position = value;
			}
		}

		public override long Seek(long offset, SeekOrigin direction)
		{
			return this._sink.Seek(offset, direction);
		}

		public override void SetLength(long length)
		{
			this._sink.SetLength(length);
		}

		public override void Close()
		{
			this._sink.Close();
		}

		public override void Flush()
		{
			this._sink.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return this._sink.Read(buffer, offset, count);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_response.ContentType == "text/html")
			{
				Encoding e = Encoding.GetEncoding(HttpContext.Current.Response.Charset);
				string s = e.GetString(buffer, offset, count);
				s = Strings.StrConv(s, VbStrConv.TraditionalChinese, CultureInfo.CurrentCulture.LCID);
				this._sink.Write(e.GetBytes(s), 0, e.GetByteCount(s));
			}
			else
			{
				this._sink.Write(buffer, offset, count);
			}
		}
	}
}
#T=HttpModule 简繁转换
/*
csc.exe /t:library StrConvHttpModule.cs /r:C:\windows\Microsoft.NET\Framework\v1.1.4322\Microsoft.VisualBasic.dll 

	<httpModules>
		<add name="StrConvHttpModule" type="Microshaoft.HttpModules.StrConvHttpModule, StrConvHttpModule" />
	</httpModules>
*/
namespace Microshaoft.HttpModules
{
	using System;
	using System.Web; 
	using System.Collections;

	using Microshaoft.IO;

	public class StrConvHttpModule : IHttpModule
	{
		public string ModuleName
		{
			get
			{
				return "StrConvHttpModule";
			}
		}

		public void Init(HttpApplication application)
		{
			application.BeginRequest += (new EventHandler(this.Application_BeginRequest));
		}
		
		private void Application_BeginRequest(object sender, EventArgs e)
		{
			HttpApplication application = (HttpApplication) sender;
			HttpContext context = application.Context;
			context.Response.Filter = new StrConvFilterStream(context.Response.Filter);
		}

		public void Dispose()
		{
		}
	}
}

namespace Microshaoft.IO
{
	using System;
	using System.IO;
	using System.Web;
	using System.Text;
	using System.Globalization;

	using Microsoft.VisualBasic;

	public class StrConvFilterStream : Stream
	{
		private Stream _sink;
		private long _position;

		public StrConvFilterStream(Stream sink)
		{
			this._sink = sink;
		}

		public override bool CanRead
		{
			get
			{
				return true;
			}
		}

		public override bool CanSeek
		{
			get
			{
				return true;
			}
		}

		public override bool CanWrite
		{
			get
			{
				return true;
			}
		}

		public override long Length
		{
			get
			{
				return 0;
			}
		}

		public override long Position
		{
			get
			{
				return this._position;
			}
		set
			{
				this._position = value;
			}
		}

		public override long Seek(long offset, SeekOrigin direction)
		{
			return this._sink.Seek(offset, direction);
		}

		public override void SetLength(long length)
		{
			this._sink.SetLength(length);
		}

		public override void Close()
		{
			this._sink.Close();
		}

		public override void Flush()
		{
			this._sink.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return this._sink.Read(buffer, offset, count);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (HttpContext.Current.Response.ContentType == "text/html")
			{
				Encoding e = Encoding.GetEncoding(HttpContext.Current.Response.Charset);
				string s = e.GetString(buffer, offset, count);
				s = Strings.StrConv(s, VbStrConv.TraditionalChinese, CultureInfo.CurrentCulture.LCID);
				this._sink.Write(e.GetBytes(s), 0, e.GetByteCount(s));
			}
			else
			{
				this._sink.Write(buffer, offset, count);
			}
		}
	}
}
#T=HttpModule/Application Page Life Cycle Events Sequence Test
/*
http://msdn.microsoft.com/zh-cn/library/bb470252
http://msdn.microsoft.com/zh-cn/library/ms178472
*/
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using System.Threading;
	using System.Reflection;
	public class TestHttpModule : IHttpModule
	{
		/// <summary>
		/// 您将需要在您网站的 web.config 文件中配置此模块，
		/// 并向 IIS 注册此模块，然后才能使用。有关详细信息，
		/// 请参见下面的链接: http://go.microsoft.com/?linkid=8101007
		/// </summary>
		#region IHttpModule Members
		public void Dispose()
		{
			//此处放置清除代码。
		}
		//private HttpContext _httpContext;
		//private HttpRequest _httpRequest;
		//private HttpResponse _httpResponse;
		public void Init(HttpApplication httpApplication)
		{
			// 下面是如何处理 LogRequest 事件并为其
			// 提供自定义日志记录实现的示例
			var httpContext = httpApplication.Context;
			//return;
			var eventsInfosNamesBlackList = new List<string>()
														{
															"MapRequestHandler"
															, "LogRequest"
														};
			var eventsInfos = typeof(HttpApplication)
										.GetEvents()
										.ToList()
										.Where
											(
												(x) =>
												{
													return
														!eventsInfosNamesBlackList.Any
																					(
																						(xx) =>
																						{
																							return x.Name.ToLower().Contains(xx.ToLower());
																						}
																					);
														;
												}
											).ToArray();
			//Exception Details: System.PlatformNotSupportedException: This operation requires IIS integrated pipeline mode.
			///			httpApplication.MapRequestHandler += new EventHandler(HttpApplication_EventHandlerProcess);
			///			httpApplication.PostMapRequestHandler += new EventHandler(HttpApplication_EventHandlerProcess);
			///			httpApplication.LogRequest += new EventHandler(HttpApplication_EventHandlerProcess);
			///			httpApplication.PostLogRequest += new EventHandler(HttpApplication_EventHandlerProcess);
			long i = 1;
			Array.ForEach
					(
						eventsInfos
						,
						(x) =>
						{
							Console.WriteLine(x.Name);
							x.AddEventHandler
							(
								httpApplication
								, new EventHandler
										(
											(xx, y) =>
											{
												Console.WriteLine(x.Name);
												var application = xx as HttpApplication;
												//var application = sender as HttpApplication;
												var context = application.Context;
												var request = context.Request;
												var response = context.Response;
												//Exception Details: System.PlatformNotSupportedException: This operation requires IIS integrated pipeline mode.
												//response.Write(context.CurrentNotification + "<br>");
												var s = string.Format
																(
																	"{1}{0}{2}{0}{3}"
																	, " : "
																	, "HttpModule"
																	, i++
																	, x.Name
																);
												response.Write(s + "<br>");
												HttpApplication_EventHandlerProcess
																		(
																			xx
																			, y
																			, x.Name
																		);
												try
												{
													//application.Response.End();
												}
												catch (ThreadAbortException tae)
												{
												}
											}
										)
							);
						}
					);
		}
		void HttpApplication_EventHandlerProcess
										(
											object sender
											, EventArgs e
											, string remark = null		//string.Empty
										)
		{
			var application = sender as HttpApplication;
			//var application = sender as HttpApplication;
			var context = application.Context;
			var request = context.Request;
			var response = context.Response;
			//response.Write("Remark: " + remark + "<br>");
			//response.Write(context.CurrentNotification + "<br>");
		}
		#endregion
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Threading;
	using System.Web;
	using System.Web.UI;
	public partial class PageLifeCycleTest : Page
	{
		static long _f1;
		long _f2;
		override protected void OnInit(EventArgs e)
		{
			_f1++;
			_f2++;
			var eventsInfosNamesBlackList = new List<string>()
														{
															"MapRequestHandler"
															, "LogRequest"
															, "Unload"
														};
			var eventsInfos = typeof(Page)
										.GetEvents()
										.ToList()
										.Where
											(
												(x) =>
												{
													return
														!eventsInfosNamesBlackList.Any
																					(
																						(xx) =>
																						{
																							return x.Name.ToLower().Contains(xx.ToLower());
																						}
																					);
												}
											).ToArray();
			short i = 1;
			Array.ForEach
					(
						eventsInfos
						,
						(x) =>
						{
							Console.WriteLine(x.Name);
							x.AddEventHandler
							(
								this
								, new EventHandler
										(
											(xx, y) =>
											{
												Console.WriteLine(x.Name);
												var page = xx as Page;
												//Exception Details: System.PlatformNotSupportedException: This operation requires IIS integrated pipeline mode.
												//response.Write(context.CurrentNotification + "<br>");
												var s = string.Format
																(
																	"{1}{0}{2}{0}{3}"
																	, " : "
																	, "Page"
																	, i++
																	, x.Name
																);
												//if (Response != null)
												{
													Response.Write(s + "<br>");
													//Response.Write("static: " + _f1 + "<br>");
												}
												s = string.Format
																(
																	"{1}{0}{2}{0}{3}{0}{4}"
																	, " : "
																	, "Page Static Member"
																	, _f1
																	, "Page Instance Member"
																	, _f2
																);
												//if (Response != null)
												{
													Response.Write(s + "<br>");
													//Response.Write("static: " + _f1 + "<br>");
												}
												try
												{
													//application.Response.End();
												}
												catch (ThreadAbortException tae)
												{
												}
											}
										)
							);
						}
					);
			base.OnInit(e);
		}
		
	}
}
/* http://local.asp.net/pagelifecycletest.aspx
<%@ Page
	ValidateRequest="false"
	Debug="true"
	ContentType="text/html;charset=UTF-8"
%>
	<%@ Import Namespace="System" %>
	<%@ Import Namespace="System.Linq" %>
	<%@ Import Namespace="System.Threading" %>
	<%@ Import Namespace="System.Web" %>
	<%@ Import Namespace="System.Web.UI" %>
	<script language="C#" runat="server">
		static long _f1;
		long _f2;
		override protected void OnInit(EventArgs e)
		{
			_f1 ++;
			_f2 ++;
			var eventsInfosNamesBlackList = new List<string>()
														{
															"MapRequestHandler"
															, "LogRequest"
															, "Unload"
														};
			var eventsInfos = typeof(Page)
										.GetEvents()
										.ToList()
										.Where
											(
												(x) =>
												{
													return
														!eventsInfosNamesBlackList.Any
																					(
																						(xx) =>
																						{
																							return x.Name.ToLower().Contains(xx.ToLower());
																						}
																					);
												}
											).ToArray();
			short i = 1;
			Array.ForEach
					(
						eventsInfos
						,
						(x) =>
						{
							Console.WriteLine(x.Name);
							x.AddEventHandler
							(
								this
								, new EventHandler
										(
											(xx, y) =>
											{
												Console.WriteLine(x.Name);
												var page = xx as Page;
												//Exception Details: System.PlatformNotSupportedException: This operation requires IIS integrated pipeline mode.
												//response.Write(context.CurrentNotification + "<br>");
												var s = string.Format
																(
																	"{1}{0}{2}{0}{3}"
																	, " : "
																	, "Page"
																	, i++
																	, x.Name
																);
												//if (Response != null)
												{
													Response.Write(s + "<br>");
													//Response.Write("static: " + _f1 + "<br>");
												}
												s = string.Format
																(
																	"{1}{0}{2}{0}{3}{0}{4}"
																	, " : "
																	, "Page Static Member"
																	, _f1
																	, "Page Instance Member"
																	, _f2
																);
												//if (Response != null)
												{
													Response.Write(s + "<br>");
													//Response.Write("static: " + _f1 + "<br>");
												}
												try
												{
													//application.Response.End();
												}
												catch (ThreadAbortException tae)
												{
												}
											}
										)
							);
						}
					);
			base.OnInit(e);
		}
	</script>
*/
/* http://local.asp.net/pagelifecycletest1.aspx
<%@ Page
	ValidateRequest="false"
	Debug="true"
	Inherits="Microshaoft.PageLifeCycleTest"
	ContentType="text/html;charset=UTF-8"
%>
*/
/* http://local.asp.net/pagelifecycletest1.aspx
<%@ Page
	ValidateRequest="false"
	Debug="true"
	Inherits="Microshaoft.PageLifeCycleTest"
	ContentType="text/html;charset=UTF-8"
%>
*/
/* Web.Config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<system.webServer>
		<modules>
			<add name="TestHttpModule" type="Microshaoft.TestHttpModule, TestHttpModule" />
		</modules>
	</system.webServer>
	<system.web>
		<httpModules>
			<add name="TestHttpModule" type="Microshaoft.TestHttpModule, TestHttpModule" />
		</httpModules>
	</system.web>
</configuration>
*/
#T=https/SSL WebRequest/Response
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
//
//  Copyright (C) Microsoft Corporation.  All rights reserved.
//
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
//
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------
namespace Microsoft.Samples.QuickStart.HowTo.Net.WebRequests
{
	using System;
	using System.Net;
	using System.IO;
	using System.Text;
	using System.Security.Cryptography.X509Certificates;
	using System.Net.Security;
	static class ClientGETwithSSL
	{
		private static bool bShow;
		public static void Main(string[] args)
		{
			if (args.Length < 1)
			{
				ShowUsage();
			}
			else
			{
				if (args.Length > 1)
					bShow = false;
				else
					bShow = true;
				GetPage(args[0]);
			}
			Console.WriteLine();
			Console.WriteLine("Press Enter to continue...");
			Console.ReadLine();
			return;
		}
		private static void ShowUsage()
		{
			Console.WriteLine("Attempts to GET a URL");
			Console.WriteLine();
			Console.WriteLine("Usage:");
			Console.WriteLine("ClientGETwithSSL URL");
			Console.WriteLine();
			Console.WriteLine("Examples:");
			Console.WriteLine("ClientGETwithSSL https://www.microsoft.com/net/");
		}
		public static bool ValidateServerCertificate
							(
								object sender
								, X509Certificate certificate
								, X509Chain chain
								, SslPolicyErrors sslPolicyErrors
							)
		{
			Console.WriteLine(certificate.Subject);
			return (sslPolicyErrors == SslPolicyErrors.None);
		}
		private static void GetPage(String url)
		{
			WebResponse response = null;
			StreamReader reader = null;
			try
			{
				ServicePointManager.ServerCertificateValidationCallback = new RemoteCertificateValidationCallback(ValidateServerCertificate);
				WebRequest request = WebRequest.Create(url);
				response = request.GetResponse();
				Stream responseStream = response.GetResponseStream();
				reader = new StreamReader(responseStream);
				Console.WriteLine("\r\nResponse stream received");
				if (bShow)
				{
					Char[] buffer = new Char[256];
					int count = reader.Read(buffer, 0, buffer.Length);
					Console.WriteLine("HTML...\r\n");
					while (count > 0)
					{
						//Console.Write(new String(buffer, 0, count));
						count = reader.Read(buffer, 0, buffer.Length);
					}
					Console.WriteLine("");
				}
			}
			catch (UriFormatException)
			{
				Console.WriteLine("\r\nThe request URI was malformed.");
			}
			catch (WebException)
			{
				Console.WriteLine("\r\nThe request URI could not be found.");
			}
			catch (IOException)
			{
				Console.WriteLine("\r\nThe request URI could not be retrieved.");
			}
			finally
			{
				if (response != null)
				{
					response.Close();
				}
				if (reader != null)
				{
					reader.Close();
				}
			}
		}
	}
}

#T=HttpTaskAsyncHandler
namespace Microshaoft
{
	using System;
	using System.Threading.Tasks;
	using System.Web;
	public class HttpTaskAsyncHandler : IHttpAsyncHandler
	{
		public bool IsReusable
		{
			get { return false; }
		}
		public void ProcessRequest(HttpContext context)
		{
			throw new NotSupportedException();
		}
		public Task ProcessRequestAsync(HttpContextBase context)
		{
		   // Microshaoft.
			//TaskAsyncHelper.
			return null;
		}
		IAsyncResult IHttpAsyncHandler.BeginProcessRequest(HttpContext context, AsyncCallback cb, object extraData)
		{
			Task task = ProcessRequestAsync(new HttpContextWrapper(context));
			var retVal = new TaskWrapperAsyncResult(task, extraData);
			if (task == null)
			{
				// No task, so just let ASP.NET deal with it
				return null;
			}
			if (cb != null)
			{
				// The callback needs the same argument that the Begin method returns, which is our special wrapper, not the original Task.
				task.ContinueWith(_ => cb(retVal));
			}
			return retVal;
		}
		void IHttpAsyncHandler.EndProcessRequest(IAsyncResult result)
		{
			if (result == null)
			{
				throw new ArgumentNullException("result");
			}
			// The End* method doesn't actually perform any actual work, but we do need to maintain two invariants:
			// 1. Make sure the underlying Task actually *is* complete.
			// 2. If the Task encountered an exception, observe it here.
			// (The Wait method handles both of those.)
			var castResult = (TaskWrapperAsyncResult)result;
			castResult.Task.Wait();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	internal sealed class TaskWrapperAsyncResult : IAsyncResult
	{
		internal TaskWrapperAsyncResult(Task task, object asyncState)
		{
			Task = task;
			AsyncState = asyncState;
		}
		public object AsyncState
		{
			get;
			private set;
		}
		public WaitHandle AsyncWaitHandle
		{
			get { return ((IAsyncResult)Task).AsyncWaitHandle; }
		}
		public bool CompletedSynchronously
		{
			get { return ((IAsyncResult)Task).CompletedSynchronously; }
		}
		public bool IsCompleted
		{
			get { return ((IAsyncResult)Task).IsCompleted; }
		}
		public Task Task
		{
			get;
			private set;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Linq;
	using System.Reflection;
	using System.Threading;
	using System.Threading.Tasks;
	public static class TaskAsyncHelper
	{
		private static readonly Task _emptyTask = MakeEmpty();
		private static Task MakeEmpty()
		{
			return FromResult<object>(null);
		}
		public static Task Empty
		{
			get
			{
				return _emptyTask;
			}
		}
		public static TTask Catch<TTask>(this TTask task) where TTask : Task
		{
			if (task != null && task.Status != TaskStatus.RanToCompletion)
			{
				task.ContinueWith(innerTask =>
				{
					var ex = innerTask.Exception;
					// observe Exception
#T=HttpWorkerRequest
<%@ Application Language="C#" Inherits="WebApplication1.Global" %>
<%@ Import Namespace="System.Threading" %>
<%@ Import Namespace="System.Data" %>
<%@ Import Namespace="System.Data.SqlClient" %>
<%@ Import Namespace="System.Security.Principal" %>
<%@ Import Namespace="System.IO" %>
<script language="C#" runat="server">
	void Application_Start(object sender, EventArgs e)
	{
	}
	void Application_End(object sender, EventArgs e)
	{
	}
	void Application_Error(object sender, EventArgs e)
	{
	}
	//application.BeginRequest += (new EventHandler(this.Application_BeginRequest));
	protected void Application_BeginRequest(object sender, EventArgs e) 
	{ 
		HttpApplication ha = sender as HttpApplication; 
		HttpContext context = ha.Context;
		if (ha.Context.Request.ContentLength > 1000)//1000 is the max size 
		{ 
			IServiceProvider provider = (IServiceProvider)context; 
			HttpWorkerRequest wr = (HttpWorkerRequest)provider.GetService(typeof(HttpWorkerRequest)); 
			//FileStream fs = null; 
			// Check if body contains data 
			if (wr.HasEntityBody()) 
			{ 
				// get the total body length 
				int requestLength = wr.GetTotalEntityBodyLength(); 
				// Get the initial bytes loaded 
				int initialBytes = 0; //wr.GetPreloadedEntityBody().Length;
				if (!wr.IsEntireEntityBodyIsPreloaded()) 
				{ 
					byte[] buffer = new byte[100]; 
					// Set the received bytes to initial bytes before start reading 
					int receivedBytes = initialBytes; 
					while (requestLength - receivedBytes >= initialBytes) 
					{ 
						// Read another set of bytes 
						initialBytes = wr.ReadEntityBody(buffer, buffer.Length); 
						// Write the chunks to the physical file
						// Update the received bytes 
						receivedBytes += initialBytes; 
					} 
					initialBytes = wr.ReadEntityBody(buffer, requestLength - receivedBytes);
				} 
			} 
			//fs.Flush(); 
			//fs.Close(); 
		} 
	}
</script>
#T=Impersonate Logon
namespace TestApplication
{
	using System;
	using System.Security.Principal;

	using Microshaoft.Win32;

	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{

			Console.WriteLine(WindowsIdentity.GetCurrent().Name);
			Console.WriteLine("pls input your username:");
			string user;
			user = Console.ReadLine();
			Console.WriteLine("pls input your password:");
			string password;
			password = ConsoleReadMaskLine('*', true);
			Console.WriteLine();
			Console.WriteLine("pls input your domain:");
			string domain;
			domain = Console.ReadLine();

			LogonImpersonate x = new LogonImpersonate
											(
												user
												, password
												, domain
											);
			Console.WriteLine("Hello {0}", WindowsIdentity.GetCurrent().Name);
		}
		public static string ConsoleReadMaskLine
			(
				char PasswordChar
				, bool WithMask
			)
		{
			string password = "";
			ConsoleKey ck;
			string s = @"~!@#$%&*()_+`1234567890-="; //可输入字符
			s += @"QWERTYUIOP{}|qwertyuiop[]\";
			s += "ASDFGHJKL:\"asdfghjkl;'";
			s += "ZXCVBNM<>?zxcvbnm,./ ";

			do
			{
				ConsoleKeyInfo cki = Console.ReadKey(true);
				char c = cki.KeyChar;
				ck = cki.Key;
				int p = Console.CursorLeft;
				if (ck == ConsoleKey.Backspace)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p - 1);
					}
					string right = password.Substring(p);
					password  = left + right;
					Console.Write(c);

					string output = right;
					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}

					output += "\0";
					Console.Write(output);
					if (p > 0)
					{
						p --;
					}
				}
				else if (ck == ConsoleKey.Delete)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p);
					}
					string right = "";
					if (p < password.Length)
					{
						right = password.Substring(p + 1);
					}
					password = left + right;
					//Console.Write(right + " ");

					string output = right;

					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}
					output += "\0";

					Console.Write(output);
				}
				else
				{
					if (s.IndexOf(c) >= 0)
					{
						string left = password.Substring(0, p);
						string right = password.Substring(p);
						password = left + c + right;

						string output = c + right;

						if (WithMask)
						{
							output = GetPasswordChars(c + right, PasswordChar);
						}
						Console.Write(output);

						p ++;
					}
					else
					{
						switch (ck)
						{
							case ConsoleKey.LeftArrow :
								if (p > 0)
								{
									p --;
								}
								break;
							case ConsoleKey.RightArrow :
								if (p < password.Length)
								{
									p ++;
								}
								break;
							case ConsoleKey.Home :
								p = 0;
								break;
							case ConsoleKey.End :
								p = password.Length;
								break;
							default :
								Console.Beep();
								break;
						}
					}
				}
				Console.CursorLeft = p;
			} while (ck != ConsoleKey.Enter);
			//Console.WriteLine("[" + password + "]");
			return password;
		}
		private static string GetPasswordChars(string s, char c)
		{
			string passwordChars = "";
			for (int i = 0; i < s.Length; i++)
			{
				passwordChars += c;
			}
			return passwordChars;
		}
	}
}

namespace Microshaoft.Win32
{
	using System;
	using System.Runtime.InteropServices;
	using System.Security.Principal;
	public class LogonImpersonate : IDisposable
	{
		static public string DefaultDomain
		{
			get
			{
				return ".";
			}
		}

		#region DynamicInvoke
		static public object DynamicInvoke
			(
				string username
				, string password
				, Delegate handler
				, object[] args
			)
		{
			if(handler == null)
			{
				throw(new ArgumentNullException("handler"));
			}
			using(new LogonImpersonate(username,password))
			{
				return handler.DynamicInvoke(args);
			}
		}
		static public object DynamicInvoke
			(
				string username
				, string password
				, string domain
				, Delegate handler
				, object[] args
			)
		{
			if(handler == null)
			{
				throw(new ArgumentNullException("handler"));
			}

			using(new LogonImpersonate(username,password,domain))
			{
				return handler.DynamicInvoke(args);
			}
		}
		static public void DynamicInvoke(string username,string password,EventHandler handler,object sender,EventArgs e)
		{
			if(handler == null)
			{
				throw(new ArgumentNullException("handler"));
			}

			using(new LogonImpersonate(username,password))
			{
				handler(sender,e);
			}
		}
		static public void DynamicInvoke
			(
				string username
				, string password
				, string domain
				, EventHandler handler
				, object sender
				, EventArgs e
			)
		{
			if(handler == null)
			{
				throw(new ArgumentNullException("handler"));
			}

			using(new LogonImpersonate(username,password,domain))
			{
				handler(sender, e);
			}
		}
		#endregion

		#region PInvoke
		const int LOGON32_LOGON_INTERACTIVE=2;
		const int LOGON32_PROVIDER_DEFAULT=0;

		[DllImport("Kernel32.dll")]
		extern static int FormatMessage
			(
				int flag
				, ref IntPtr source
				, int msgid
				, int langid
				, ref string buf
				,int size
				, ref IntPtr args
			);

		[DllImport("Kernel32.dll")]
		extern static bool CloseHandle(IntPtr handle);

		[DllImport("Advapi32.dll",SetLastError=true)]
		extern static bool LogonUser
			(
				string lpszUsername
				, string lpszDomain
				, string lpszPassword
				, int dwLogonType
				, int dwLogonProvider
				, ref IntPtr phToken
			);
		#endregion

		IntPtr token;
		WindowsImpersonationContext context;

		public LogonImpersonate(string username,string password)
		{
			if(username == null)
			{
				throw(new ArgumentNullException("username"));
			}
			if (password == null)
			{
				throw(new ArgumentNullException("password"));
			}
			if(username.IndexOf("\\") == -1)
			{
				Init(username, password, DefaultDomain);
			}
			else
			{
				string[] pair = username.Split(new char[]{'\\'},2);
				Init(pair[1],password,pair[0]);
			}
		}
		public LogonImpersonate(string username,string password,string domain)
		{
			if (username == null) throw (new ArgumentNullException("username"));
			if (password == null) throw (new ArgumentNullException("password"));
			if (domain == null) throw(new ArgumentNullException("domain"));

			Init(username, password, domain);
		}
		void Init
			(
				string username
				, string password
				, string domain
			)
		{
			if (
					LogonUser
						(
							username
							, domain
							, password
							, LOGON32_LOGON_INTERACTIVE
							, LOGON32_PROVIDER_DEFAULT
							, ref token
						)
				)
			{
				bool error=true;
				try
				{
					context = WindowsIdentity.Impersonate(token);
					error = false;
				}
				finally
				{
					if(error)
					{
						CloseHandle(token);
					}
				}
			}
			else
			{
				int err = Marshal.GetLastWin32Error();
			
				IntPtr tempptr = IntPtr.Zero;
				string msg = null;

				FormatMessage
						(
							0x1300
							, ref tempptr
							, err
							, 0
							, ref msg
							, 255
							, ref tempptr
						);

				throw(new Exception(msg));
			}
		}
		~LogonImpersonate()
		{
			Dispose();
		}
		public void Dispose()
		{
			if (context != null)
			{
				try
				{
					context.Undo();
				}
				finally
				{
					CloseHandle(token);
					context=null;
				}
			}
		}
	}
}
#T=Impersonate WindowsImpersonationContext 
// This sample demonstrates the use of the WindowsIdentity class to impersonate a user.
// IMPORTANT NOTES:
// This sample requests the user to enter a password on the console screen.
// Because the console window does not support methods allowing the password to be masked,
// it will be visible to anyone viewing the screen.
// On Windows Vista and later this sample must be run as an administrator. 
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	using System.Security.Principal;
	using System.Security.Permissions;
	using Microsoft.Win32.SafeHandles;
	using System.Runtime.ConstrainedExecution;
	using System.Security;
	public class ImpersonationDemo
	{
		[DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
		public static extern bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword,
			int dwLogonType, int dwLogonProvider, out SafeTokenHandle phToken);
		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		public extern static bool CloseHandle(IntPtr handle);
		// Test harness.
		// If you incorporate this code into a DLL, be sure to demand FullTrust.
		[PermissionSetAttribute(SecurityAction.Demand, Name = "FullTrust")]
		public static void Main(string[] args)
		{
			SafeTokenHandle safeTokenHandle;
			try
			{
				string userName, domainName;
				// Get the user token for the specified user, domain, and password using the
				// unmanaged LogonUser method.
				// The local machine name can be used for the domain name to impersonate a user on this machine.
				Console.Write("Enter the name of the domain on which to log on: ");
				domainName = Console.ReadLine();
				Console.Write("Enter the login of a user on {0} that you wish to impersonate: ", domainName);
				userName = Console.ReadLine();
				Console.Write("Enter the password for {0}: ", userName);
				const int LOGON32_PROVIDER_DEFAULT = 0;
				//This parameter causes LogonUser to create a primary token.
				const int LOGON32_LOGON_INTERACTIVE = 2;
				// Call LogonUser to obtain a handle to an access token.
				bool returnValue = LogonUser(userName, domainName, Console.ReadLine(),
					LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,
					out safeTokenHandle);
				Console.WriteLine("LogonUser called.");
				if (false == returnValue)
				{
					int ret = Marshal.GetLastWin32Error();
					Console.WriteLine("LogonUser failed with error code : {0}", ret);
					throw new System.ComponentModel.Win32Exception(ret);
				}
				using (safeTokenHandle)
				{
					Console.WriteLine("Did LogonUser Succeed? " + (returnValue ? "Yes" : "No"));
					Console.WriteLine("Value of Windows NT token: " + safeTokenHandle);
					// Check the identity.
					Console.WriteLine("Before impersonation: "
						+ WindowsIdentity.GetCurrent().Name);
					// Use the token handle returned by LogonUser.
					WindowsIdentity newId = new WindowsIdentity(safeTokenHandle.DangerousGetHandle());
					using (WindowsImpersonationContext impersonatedUser = newId.Impersonate())
					{
						// Check the identity.
						Console.WriteLine("After impersonation: "
							+ WindowsIdentity.GetCurrent().Name);
					}
					// Releasing the context object stops the impersonation
					// Check the identity.
					Console.WriteLine("After closing the context: " + WindowsIdentity.GetCurrent().Name);
				}
			}
			catch (Exception ex)
			{
				Console.WriteLine("Exception occurred. " + ex.Message);
			}
		}
	}
	public sealed class SafeTokenHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private SafeTokenHandle()
			: base(true)
		{
		}
		[DllImport("kernel32.dll")]
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
		[SuppressUnmanagedCodeSecurity]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool CloseHandle(IntPtr handle);
		protected override bool ReleaseHandle()
		{
			return CloseHandle(handle);
		}
	}
}
#T=ImpersonateHelper
namespace TestApplication
{
	using Microshaoft.Win32;
	using System;
	using System.Security.Principal;
	using System.Threading;
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			Console.WriteLine(WindowsIdentity.GetCurrent().Name);
			Console.WriteLine("pls input your username:");
			string user;
			user = Console.ReadLine();
			Console.WriteLine("pls input your password:");
			string password;
			password = ConsoleReadMaskLine('*', true);
			Console.WriteLine();
			Console.WriteLine("pls input your domain:");
			string domain;
			domain = Console.ReadLine();
			var errorMessage = string.Empty;
			if
				(
					!ImpersonateHelper
						.RunAs
							(
								user
								, password
								, out errorMessage
								, (x) =>
								{
									Console.WriteLine("Impersonate ManagedThreadId: {0}", Thread.CurrentThread.ManagedThreadId);
									Console.WriteLine("Impersonate WindowsIdentity.GetCurrent().Name: {0}", WindowsIdentity.GetCurrent().Name);
									Console.WriteLine("Impersonate Thread.CurrentPrincipal.Identity.Name: {0}", Thread.CurrentPrincipal.Identity.Name);
								}
								, domain
							)
				)
			{
				Console.WriteLine(errorMessage);
			}
			Console.WriteLine(WindowsIdentity.GetCurrent().Name);
			Console.ReadLine();
		}
		public static string ConsoleReadMaskLine
			(
				char PasswordChar
				, bool WithMask
			)
		{
			string password = "";
			ConsoleKey ck;
			string s = @"~!@#$%&*()_+`1234567890-="; //可输入字符
			s += @"QWERTYUIOP{}|qwertyuiop[]\";
			s += "ASDFGHJKL:\"asdfghjkl;'";
			s += "ZXCVBNM<>?zxcvbnm,./ ";
			do
			{
				ConsoleKeyInfo cki = Console.ReadKey(true);
				char c = cki.KeyChar;
				ck = cki.Key;
				int p = Console.CursorLeft;
				if (ck == ConsoleKey.Backspace)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p - 1);
					}
					string right = password.Substring(p);
					password = left + right;
					Console.Write(c);
					string output = right;
					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}
					output += "\0";
					Console.Write(output);
					if (p > 0)
					{
						p--;
					}
				}
				else if (ck == ConsoleKey.Delete)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p);
					}
					string right = "";
					if (p < password.Length)
					{
						right = password.Substring(p + 1);
					}
					password = left + right;
					//Console.Write(right + " ");
					string output = right;
					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}
					output += "\0";
					Console.Write(output);
				}
				else
				{
					if (s.IndexOf(c) >= 0)
					{
						string left = password.Substring(0, p);
						string right = password.Substring(p);
						password = left + c + right;
						string output = c + right;
						if (WithMask)
						{
							output = GetPasswordChars(c + right, PasswordChar);
						}
						Console.Write(output);
						p++;
					}
					else
					{
						switch (ck)
						{
							case ConsoleKey.LeftArrow:
								if (p > 0)
								{
									p--;
								}
								break;
							case ConsoleKey.RightArrow:
								if (p < password.Length)
								{
									p++;
								}
								break;
							case ConsoleKey.Home:
								p = 0;
								break;
							case ConsoleKey.End:
								p = password.Length;
								break;
							default:
								Console.Beep();
								break;
						}
					}
				}
				Console.CursorLeft = p;
			} while (ck != ConsoleKey.Enter);
			//Console.WriteLine("[" + password + "]");
			return password;
		}
		private static string GetPasswordChars(string s, char c)
		{
			string passwordChars = "";
			for (int i = 0; i < s.Length; i++)
			{
				passwordChars += c;
			}
			return passwordChars;
		}
	}
}
namespace Microshaoft.Win32
{
	using System;
	using System.Runtime.InteropServices;
	using System.Security.Principal;
	public static class ImpersonateHelper
	{
		public static bool RunAs
						(
							string userName
							, string userPassword
							, out string errorMessage
							, Action<IntPtr> onImpersonatingProcessAction = null
							, string userDomain = "."
							
						)
		{
			bool r = false;
			errorMessage = string.Empty;
			if (onImpersonatingProcessAction != null)
			{
				IntPtr token = IntPtr.Zero;
				if
					(
						LogonUser
							(
								userName
								, userDomain
								, userPassword
								, LOGON32_LOGON_INTERACTIVE
								, LOGON32_PROVIDER_DEFAULT
								, ref token
							)
					)
				{
					WindowsImpersonationContext windowsImpersonationContext = null;
					try
					{
						windowsImpersonationContext = WindowsIdentity.Impersonate(token);
						onImpersonatingProcessAction(token);
						r = true;
					}
					finally
					{
						if (windowsImpersonationContext != null)
						{
							try
							{
								windowsImpersonationContext.Undo();
							}
							finally
							{
								CloseHandle(token);
								windowsImpersonationContext = null;
							}
						}
					}
				}
				else
				{
					r = false;
					int error = Marshal.GetLastWin32Error();
					IntPtr intPtr = IntPtr.Zero;
					FormatMessage
							(
								0x1300
								, ref intPtr
								, error
								, 0
								, ref errorMessage
								, 255
								, ref intPtr
							);
					//Console.Error.WriteLine(message);
				}
			}
			return r;
		}
		#region PInvoke
		const int LOGON32_LOGON_INTERACTIVE = 2;
		const int LOGON32_PROVIDER_DEFAULT = 0;
		[DllImport("Kernel32.dll")]
		extern static int FormatMessage
			(
				int flag
				, ref IntPtr source
				, int msgid
				, int langid
				, ref string buf
				, int size
				, ref IntPtr args
			);
		[DllImport("Kernel32.dll")]
		extern static bool CloseHandle(IntPtr handle);
		[DllImport("Advapi32.dll", SetLastError = true)]
		extern static bool LogonUser
			(
				string lpszUsername
				, string lpszDomain
				, string lpszPassword
				, int dwLogonType
				, int dwLogonProvider
				, ref IntPtr phToken
			);
		#endregion
	}
}
#T=InfoPath
namespace Microshaoft
{
	using Microsoft.Office.InfoPath;
	using System;
	using System.Xml;
	using System.Xml.XPath;
	//using System.Windows.Forms;
	using System.Collections.Generic;
	//using mshtml;
	using CommunicatorAPI;
	//using System.Security.Permissions;
	using mshtml;
	using WindowsAPI;
	public partial class FormCode
	{
		// 启用浏览器功能的表单不支持成员变量。
		// 请使用代码从 FormState 词典
		// 写入和读取这些值，如下所示:
		//
		// private object _memberVariable
		// {
		//	 get
		//	 {
		//		 return FormState["_memberVariable"];
		//	 }
		//	 set
		//	 {
		//		 FormState["_memberVariable"] = value;
		//	 }
		// }
		// 注意: 以下是 Microsoft InfoPath 所需的过程。
		// 可以使用 Microsoft InfoPath 对其进行修改。
		XPathNavigator tb_Contributor;
		
		private Messenger _messenger;
		public void InternalStartup()
		{
			_messenger = new Messenger();
			XPathNavigator nav = MainDataSource.CreateNavigator();
			tb_Contributor = nav.SelectSingleNode("/my:myFields/my:tb_Contributor", NamespaceManager);
			((ButtonEvent)EventManager.ControlEvents["button_ChatWithContributor"]).Clicked += new ClickedEventHandler(button_ChatWithContributor_Clicked);
			((ButtonEvent)EventManager.ControlEvents["buttons_ChatWithCommenter"]).Clicked += new ClickedEventHandler(buttons_ChatWithCommenter_Clicked);
			((ButtonEvent)EventManager.ControlEvents["button_ChatWithAll"]).Clicked += new ClickedEventHandler(button_ChatWithAll_Clicked);
		}
		public void button_ChatWithContributor_Clicked(object sender, ClickedEventArgs e)
		{
			// 在此处编写代码。
			string contributor = tb_Contributor.Value;
			string text = string.Empty;
			text = string.Format("hi {1}{0}","<br>", contributor);
			object[] sipUris = { string.Format("microshaoft@msn.com", "yu.xiyue") };
			SendIM(text ,sipUris);
			//MessageBox.Show(s);
			
		}
		private void SendIM(string text, object[] contacts)
		{
			string myStatus = Enum.GetName(typeof(MISTATUS), _messenger.MyStatus);
			if (_messenger.MyStatus != MISTATUS.MISTATUS_OFFLINE)
			{
				IMessengerAdvanced ma = _messenger as IMessengerAdvanced;
				object[] sipUris = contacts;
				object conversationWindow = ma.StartConversation
													(
														CONVERSATION_TYPE.CONVERSATION_TYPE_IM,
														contacts,
														null,
														"Testing",
														"1",
													   ""
													);
				if (string.IsNullOrEmpty(text.Trim()))
				{
					return;
				}
				long hWnd = long.Parse(conversationWindow.ToString());
				IHTMLDocument2 historyDoc;
				IHTMLWindow2 historyWin;
				int hHistory = 0;
				IHTMLDocument2 inputDoc;
				IHTMLWindow2 inputWin;
				int hInput = 0;
				OCHelper.GetHistoryAndInput
									(
										hWnd
										, out hHistory
										, out historyDoc
										, out historyWin
										, out hInput
										, out inputDoc
										, out inputWin
									);
				if (inputDoc != null)
				{
					if (inputDoc.body != null)
					{
						string senderName = contacts[0].ToString();
						string html =
						html = text;
						inputDoc.body.innerHTML += html;
						inputWin.scrollTo(0, short.MaxValue);
					}
				}
				
			}
		}
		public void buttons_ChatWithCommenter_Clicked(object sender, ClickedEventArgs e)
		{
			XPathNavigator nav = e.Source;
			string s = nav.SelectSingleNode("my:tb_CommentTime", NamespaceManager).Value;
			s = nav.SelectSingleNode("my:tb_Commenter", NamespaceManager).Value;
			string text = string.Empty;
			text = string.Format("hi {1}{0}","<br>", s);
			object[] sipUris = { string.Format("{0}", s) };
			SendIM(text ,sipUris);
		}
		public void button_ChatWithAll_Clicked(object sender, ClickedEventArgs e)
		{
			// 在此处编写代码。
			XPathNodeIterator iterator = MainDataSource.CreateNavigator().Select("/my:myFields/my:Group_Comments/my:Group_RepeatSection_Comments", NamespaceManager);
			List<object> list = new List<object>();
			foreach (XPathNavigator nav in iterator)
			{
				XPathNavigator n = nav.SelectSingleNode("my:tb_Commenter", NamespaceManager);
				list.Add(n.Value);
			}
			object[] sipUris = list.ToArray();
			SendIM("hi all", sipUris);
		}
	}
}
//------------------------------------------------------------------------------
// <auto-generated>
//	 此代码由工具生成。
//	 运行时版本:2.0.50727.4952
//
//	 对此文件的更改可能会导致不正确的行为，并且如果
//	 重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
namespace Microshaoft {
	
	
	/// 
	[Microsoft.VisualStudio.Tools.Applications.Contract.EntryPointAttribute(0)]
	public sealed partial class FormCode : Microsoft.Office.InfoPath.XmlFormHostItem {
		
		internal Microsoft.Office.InfoPath.Application Application;
		
		internal Microsoft.Office.InfoPath.EventManager EventManager;
		
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
		public FormCode(System.AddIn.Contract.Collections.IRemoteArgumentArrayContract initArgs) : 
				base(initArgs) {
		}
		
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
		protected override string PrimaryCookie {
			get {
				return "XmlForm";
			}
		}
		
		public event System.EventHandler Startup;
		
		public event System.EventHandler Shutdown;
		
		/// 
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
		protected override void OnStartup() {
			base.OnStartup();
			Application = ((Microsoft.Office.InfoPath.Application)(this.GetHostObject("Microsoft.Office.InfoPath.Application", "Application")));
			EventManager = ((Microsoft.Office.InfoPath.EventManager)(this.GetHostObject("Microsoft.Office.InfoPath.EventManager", "EventManager")));
		}
		
		/// 
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
		protected override void FinishInitialization() {
			base.FinishInitialization();
			this.InternalStartup();
			if ((this.Startup != null)) {
				this.Startup(this, System.EventArgs.Empty);
			}
		}
		
		/// 
		[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
		protected override void OnShutdown() {
			if ((this.Shutdown != null)) {
				this.Shutdown(this, System.EventArgs.Empty);
			}
			base.OnShutdown();
		}
	}
}
namespace Microshaoft
{
	using System;
	using mshtml;
	using WindowsAPI;
	public static class OCHelper
	{
		public static void GetHistoryAndInput
							   (
								   long hWndConversation
								   , out int history_hWnd
								   , out IHTMLDocument2 history_document
								   , out IHTMLWindow2 history_window
								   , out int input_hWnd
								   , out IHTMLDocument2 input_document
								   , out IHTMLWindow2 input_window
							   )
		{
			Console.WriteLine(hWndConversation);
			IntPtr hDirectUIHWND = IntPtr.Zero;
			IntPtr hHistory = IntPtr.Zero;
			IntPtr hInput = IntPtr.Zero;
			hDirectUIHWND = NativeMethods.FindWindowEx(new IntPtr(hWndConversation), IntPtr.Zero, "DirectUIHWND", IntPtr.Zero);
			Console.WriteLine(hDirectUIHWND);
			hHistory = NativeMethods.FindWindowEx(hDirectUIHWND, IntPtr.Zero, "Internet Explorer_Server", IntPtr.Zero);
			Console.WriteLine(hHistory);
			///					Console.WriteLine(hInput);
			//mshtml.IHTMLWindow2 ihtmlwin;
			history_hWnd = hHistory.ToInt32();
			IEHelper.GetIEDocumentFromWindowHandle(hHistory, out history_document, out history_window);
			hInput = NativeMethods.FindWindowEx(hDirectUIHWND, hHistory, "Internet Explorer_Server", IntPtr.Zero);
			input_hWnd = hInput.ToInt32();
			IEHelper.GetIEDocumentFromWindowHandle(hInput, out input_document, out input_window);
		}
	}
}
namespace WindowsAPI
{
	using System;
	using System.Runtime.InteropServices;
	using mshtml;
	public static class IEHelper
	{
		[ComImport]
		[Guid("6d5140c1-7436-11ce-8034-00aa006009fa")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		interface IServiceProvider
		{
			void QueryService(ref Guid guidService, ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object ppvObject);
		}
		public static void GetIEDocumentFromWindowHandle
								(
									IntPtr hWnd
									, out IHTMLDocument2 document
									, out IHTMLWindow2 window
								)
		{
			document = null;
			window = null;
			Guid IID_IHTMLDocument2 = typeof(IHTMLDocument2).GUID;
			Guid IID_IHTMLWindow2 = typeof(IHTMLWindow2).GUID;
			//IHTMLDocument2 htmlDocument = null;
			if (hWnd != IntPtr.Zero)
			{
				uint lMsg = NativeMethods.RegisterWindowMessage("WM_HTML_GETOBJECT");
				UIntPtr lResult;
				NativeMethods.SendMessageTimeout
								(
									hWnd
									, lMsg
									, UIntPtr.Zero
									, IntPtr.Zero
									, SendMessageTimeoutFlags.SMTO_ABORTIFHUNG
									, 1000
									, out lResult
								 );
				if (lResult != UIntPtr.Zero)
				{
					document = NativeMethods.ObjectFromLresult(lResult, IID_IHTMLDocument2, IntPtr.Zero) as IHTMLDocument2;
					IServiceProvider provider = document as IServiceProvider;
					object htmlWindow;
					provider.QueryService(ref IID_IHTMLWindow2, ref IID_IHTMLWindow2, out htmlWindow);
					window = htmlWindow as IHTMLWindow2;
				}
			}
		}
	}
}
namespace WindowsAPI
{
	using System;
	using System.Runtime.InteropServices;
	[Flags]
	public enum SendMessageTimeoutFlags : uint
	{
		SMTO_NORMAL = 0x0,
		SMTO_BLOCK = 0x1,
		SMTO_ABORTIFHUNG = 0x2,
		SMTO_NOTIMEOUTIFNOTHUNG = 0x8
	}
	public enum GWL : int
	{
		GWL_WNDPROC = (-4),
		GWL_HINSTANCE = (-6),
		GWL_HWNDPARENT = (-8),
		GWL_STYLE = (-16),
		GWL_EXSTYLE = (-20),
		GWL_USERDATA = (-21),
		GWL_ID = (-12)
	}
	public static class NativeMethods
	{
		[DllImport("user32.dll", EntryPoint = "FindWindow", SetLastError = true)]
		public static extern IntPtr FindWindowByCaption(IntPtr ZeroOnly, string lpWindowName);
		[DllImport("user32.dll", SetLastError = true)]
		public static extern IntPtr FindWindowEx(IntPtr parentHandle, IntPtr childAfter, string className, IntPtr windowTitle);
		[DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
		public static extern uint RegisterWindowMessage(string lpString);
		[DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
		public static extern IntPtr SendMessageTimeout
										(
											IntPtr hWnd,
											uint Msg,
											UIntPtr wParam,
											IntPtr lParam,
											SendMessageTimeoutFlags fuFlags,
											uint uTimeout,
											out UIntPtr lpdwResult
										);
		[DllImport("oleacc.dll", PreserveSig = false)]
		[return: MarshalAs(UnmanagedType.Interface)]
		public static extern object ObjectFromLresult(UIntPtr lResult, [MarshalAs(UnmanagedType.LPStruct)] Guid refiid, IntPtr wParam);
		[DllImport("user32.dll")]
		public static extern int GetWindowLong(int hWnd, int nIndex);
		[DllImport("user32.dll")]
		public static extern int SetWindowLong(int hWnd, int nIndex, int dwNewLong);
		[DllImport("user32.dll")]
		public static extern int CallWindowProc(int lpPrevWndFunc, int hWnd, int Msg, int wParam, int lParam);
		[DllImport("User32.dll", EntryPoint = "GetWindowLong", SetLastError = true)]
		public static extern IntPtr GetWindowLongPtr(IntPtr hWnd, int index);
		[DllImport("hhctrl.ocx", CharSet = CharSet.Unicode, EntryPoint = "HtmlHelpW")]
		public static extern int HtmlHelp(int caller, String file, uint command, String str);
		[DllImport("kernel32.dll")]
		public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
	}
}
#T=INI Util
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using Microshaoft.Win32;
	class Program
	{
		static void Main(string[] args)
		{
			IniFile iniFile = new IniFile("TestIniFile.ini");

			//Write a int32 value
			iniFile.WriteValue("section1", "key1", 42);

			//Write a string value
			iniFile.WriteValue("section1", "key2", "This is a test");

			//Write a double value
			iniFile.WriteValue("section2", "key3", 16.84);

			//Read section/key names
			Console.WriteLine("File sections/keys");
			Console.WriteLine("-------------------");

			string[] sections = iniFile.GetSectionNames();
			foreach (string section in sections)
			{
				Console.WriteLine("[" + section + "]");

				string[] keys = iniFile.GetKeyNames(section);

				foreach (string key in keys)
				{
					Console.WriteLine(key);
				}
			}

			Console.WriteLine("\n-------------------\n");

			//Read int32 value.
			int value1 = iniFile.GetInt32("section1", "key1", 0);
			Console.WriteLine("key1 = " + value1);

			//Read string value.
			string value2 = iniFile.GetString("section1", "key2", "test");
			Console.WriteLine("key2 = " + value2);

			//Read double value.
			double value3 = iniFile.GetDouble("section2", "key3", 0.0);
			Console.WriteLine("key3 = " + value3);

			Console.WriteLine("\n-------------------\n");

			//Delete value key2
			Console.WriteLine("Deleting section1/key2");
			iniFile.DeleteKey("section1", "key2");

			value2 = iniFile.GetString("section1", "key2", "");
			Console.WriteLine("key2=" + value2);

			//Delete section2
			Console.WriteLine("Deleting section2");
			iniFile.DeleteSection("section2");

			value3 = iniFile.GetDouble("section2", "key3", 0.0);
			Console.WriteLine("key3=" + value3);

			Console.WriteLine("\n-------------------\n");

			//Test that calling WriteValue with null section, keyName, or 
			//value causes a exception
			try
			{
				iniFile.WriteValue(null, "key1", "test");
				Console.WriteLine("*** No exception on invalid section name ***");
			}
			catch (ArgumentNullException)
			{
				Console.WriteLine("WriteValue correctly threw an exception on null sectionName.");	
			}

			try
			{
				iniFile.WriteValue("section1", null, "test");
				Console.WriteLine("*** No exception on invalid key name ***");
			}
			catch (ArgumentNullException)
			{
				Console.WriteLine("WriteValue correctly threw an exception on null keyName.");
			}

			try
			{
				iniFile.WriteValue("section1", "key2", null);
				Console.WriteLine("*** No exception on invalid value ***");
			}
			catch (ArgumentNullException)
			{
				Console.WriteLine("WriteValue correctly threw an exception on null value.");
			}	  
		}
	}
}

namespace Microshaoft.Win32
{
	using System;
	using System.Text;
	using System.Runtime.InteropServices;
	using System.Globalization;
	using System.Collections.Generic;


	/// <summary>
	/// Provides methods for reading and writing to an INI file.
	/// </summary>
	public class IniFile
	{
		/// <summary>
		/// The maximum size of a section in an ini file.
		/// </summary>
		/// <remarks>
		/// This property defines the maximum size of the buffers 
		/// used to retreive data from an ini file.  This value is 
		/// the maximum allowed by the win32 functions 
		/// GetPrivateProfileSectionNames() or 
		/// GetPrivateProfileString().
		/// </remarks>
		public const int MaxSectionSize = 32767; // 32 KB

		//The path of the file we are operating on.
		private string m_path;

		#region P/Invoke declares

		/// <summary>
		/// A static class that provides the win32 P/Invoke signatures 
		/// used by this class.
		/// </summary>
		/// <remarks>
		/// Note:  In each of the declarations below, we explicitly set CharSet to 
		/// Auto.  By default in C#, CharSet is set to Ansi, which reduces 
		/// performance on windows 2000 and above due to needing to convert strings
		/// from Unicode (the native format for all .Net strings) to Ansi before 
		/// marshalling.  Using Auto lets the marshaller select the Unicode version of 
		/// these functions when available.
		/// </remarks>
		[System.Security.SuppressUnmanagedCodeSecurity]
		private static class NativeMethods
		{
			[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
			public static extern int GetPrivateProfileSectionNames(IntPtr lpszReturnBuffer,
																   uint nSize,
																   string lpFileName);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
			public static extern uint GetPrivateProfileString(string lpAppName,
															  string lpKeyName,
															  string lpDefault,
															  StringBuilder lpReturnedString,
															  int nSize,
															  string lpFileName);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
			public static extern uint GetPrivateProfileString(string lpAppName,
															  string lpKeyName,
															  string lpDefault,
															  [In, Out] char[] lpReturnedString,
															  int nSize,
															  string lpFileName);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
			public static extern int GetPrivateProfileString(string lpAppName,
															 string lpKeyName,
															 string lpDefault,
															 IntPtr lpReturnedString,
															 uint nSize,
															 string lpFileName);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
			public static extern int GetPrivateProfileInt(string lpAppName,
														  string lpKeyName,
														  int lpDefault,
														  string lpFileName);

			[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
			public static extern int GetPrivateProfileSection(string lpAppName,
															  IntPtr lpReturnedString,
															  uint nSize,
															  string lpFileName);

			//We explicitly enable the SetLastError attribute here because
			// WritePrivateProfileString returns errors via SetLastError.
			// Failure to set this can result in errors being lost during 
			// the marshal back to managed code.
			[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			public static extern bool WritePrivateProfileString(string lpAppName,
																string lpKeyName, 
																string lpString, 
																string lpFileName);


		}
		#endregion

		/// <summary>
		/// Initializes a new instance of the <see cref="IniFile"/> class.
		/// </summary>
		/// <param name="path">The ini file to read and write from.</param>
		public IniFile(string path)
		{
			//Convert to the full path.  Because of backward compatibility, 
			// the win32 functions tend to assume the path should be the 
			// root Windows directory if it is not specified.  By calling 
			// GetFullPath, we make sure we are always passing the full path
			// the win32 functions.
			m_path = System.IO.Path.GetFullPath(path);
		}

		/// <summary>
		/// Gets the full path of ini file this object instance is operating on.
		/// </summary>
		/// <value>A file path.</value>
		public string Path
		{
			get
			{
				return m_path;
			}
		}

		#region Get Value Methods

		/// <summary>
		/// Gets the value of a setting in an ini file as a <see cref="T:System.String"/>.
		/// </summary>
		/// <param name="sectionName">The name of the section to read from.</param>
		/// <param name="keyName">The name of the key in section to read.</param>
		/// <param name="defaultValue">The default value to return if the key
		/// cannot be found.</param>
		/// <returns>The value of the key, if found.  Otherwise, returns 
		/// <paramref name="defaultValue"/></returns>
		/// <remarks>
		/// The retreived value must be less than 32KB in length.
		/// </remarks>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> are 
		/// a null reference  (Nothing in VB)
		/// </exception>
		public string GetString(string sectionName,
								string keyName,
								string defaultValue)
		{
			if (sectionName == null)
				throw new ArgumentNullException("sectionName");

			if (keyName == null)
				throw new ArgumentNullException("keyName");

			StringBuilder retval = new StringBuilder(IniFile.MaxSectionSize);

			NativeMethods.GetPrivateProfileString(sectionName, 
												  keyName, 
												  defaultValue, 
												  retval,
												  IniFile.MaxSectionSize, 
												  m_path);

			return retval.ToString();
		}

		/// <summary>
		/// Gets the value of a setting in an ini file as a <see cref="T:System.Int16"/>.
		/// </summary>
		/// <param name="sectionName">The name of the section to read from.</param>
		/// <param name="keyName">The name of the key in section to read.</param>
		/// <param name="defaultValue">The default value to return if the key
		/// cannot be found.</param>
		/// <returns>The value of the key, if found.  Otherwise, returns 
		/// <paramref name="defaultValue"/>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> are 
		/// a null reference  (Nothing in VB)
		/// </exception>
		public int GetInt16(string sectionName,
							string keyName,
							short  defaultValue)
		{
			int retval = GetInt32(sectionName, keyName, defaultValue);

			return Convert.ToInt16(retval);
		}

		/// <summary>
		/// Gets the value of a setting in an ini file as a <see cref="T:System.Int32"/>.
		/// </summary>
		/// <param name="sectionName">The name of the section to read from.</param>
		/// <param name="keyName">The name of the key in section to read.</param>
		/// <param name="defaultValue">The default value to return if the key
		/// cannot be found.</param>
		/// <returns>The value of the key, if found.  Otherwise, returns 
		/// <paramref name="defaultValue"/></returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> are 
		/// a null reference  (Nothing in VB)
		/// </exception>
		public int GetInt32(string sectionName,
							string keyName,
							int defaultValue)
		{
			if (sectionName == null)
				throw new ArgumentNullException("sectionName");

			if (keyName == null)
				throw new ArgumentNullException("keyName");

			
			return NativeMethods.GetPrivateProfileInt(sectionName, keyName, defaultValue, m_path);
		}

		/// <summary>
		/// Gets the value of a setting in an ini file as a <see cref="T:System.Double"/>.
		/// </summary>
		/// <param name="sectionName">The name of the section to read from.</param>
		/// <param name="keyName">The name of the key in section to read.</param>
		/// <param name="defaultValue">The default value to return if the key
		/// cannot be found.</param>
		/// <returns>The value of the key, if found.  Otherwise, returns 
		/// <paramref name="defaultValue"/></returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> are 
		/// a null reference  (Nothing in VB)
		/// </exception>
		public double GetDouble(string sectionName,
								string keyName,
								double defaultValue)
		{
			string retval = GetString(sectionName, keyName, "");

			if (retval == null || retval.Length == 0)
			{
				return defaultValue;
			}

			return Convert.ToDouble(retval, CultureInfo.InvariantCulture);
		}

		#endregion

		#region GetSectionValues Methods

		/// <summary>
		/// Gets all of the values in a section as a list.
		/// </summary>
		/// <param name="sectionName">
		/// Name of the section to retrieve values from.
		/// </param>
		/// <returns>
		/// A <see cref="List{T}"/> containing <see cref="KeyValuePair{T1, T2}"/> objects 
		/// that describe this section.  Use this verison if a section may contain
		/// multiple items with the same key value.  If you know that a section 
		/// cannot contain multiple values with the same key name or you don't 
		/// care about the duplicates, use the more convenient 
		/// <see cref="GetSectionValues"/> function.
		/// </returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> is a null reference  (Nothing in VB)
		/// </exception>
		public List<KeyValuePair<string, string>> GetSectionValuesAsList(string sectionName)
		{
			List<KeyValuePair<string, string>> retval;
			string[] keyValuePairs;
			string key, value;
			int equalSignPos;

			if (sectionName == null)
				throw new ArgumentNullException("sectionName");

			//Allocate a buffer for the returned section names.
			IntPtr ptr = Marshal.AllocCoTaskMem(IniFile.MaxSectionSize);

			try
			{
				//Get the section key/value pairs into the buffer.
				int len = NativeMethods.GetPrivateProfileSection(sectionName,
																 ptr,
																 IniFile.MaxSectionSize,
																 m_path);

				keyValuePairs = ConvertNullSeperatedStringToStringArray(ptr, len);
			}
			finally
			{
				//Free the buffer
				Marshal.FreeCoTaskMem(ptr);
			}

			//Parse keyValue pairs and add them to the list.
			retval = new List<KeyValuePair<string, string>>(keyValuePairs.Length);

			for (int i = 0; i < keyValuePairs.Length; ++i)
			{
				//Parse the "key=value" string into its constituent parts
				equalSignPos = keyValuePairs[i].IndexOf('=');

				key = keyValuePairs[i].Substring(0, equalSignPos);

				value = keyValuePairs[i].Substring(equalSignPos + 1, 
												   keyValuePairs[i].Length - equalSignPos - 1);

				retval.Add( new KeyValuePair<string, string>(key, value) );
			}

			return retval;
		}

		/// <summary>
		/// Gets all of the values in a section as a dictionary.
		/// </summary>
		/// <param name="sectionName">
		/// Name of the section to retrieve values from.
		/// </param>
		/// <returns>
		/// A <see cref="Dictionary{T, T}"/> containing the key/value 
		/// pairs found in this section.  
		/// </returns>
		/// <remarks>
		/// If a section contains more than one key with the same name, 
		/// this function only returns the first instance.  If you need to 
		/// get all key/value pairs within a section even when keys have the 
		/// same name, use <see cref="GetSectionValuesAsList"/>.
		/// </remarks>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> is a null reference  (Nothing in VB)
		/// </exception>
		public Dictionary<string, string> GetSectionValues(string sectionName)
		{
			List<KeyValuePair<string, string>> keyValuePairs;
			Dictionary<string, string> retval;

			keyValuePairs = GetSectionValuesAsList(sectionName);

			//Convert list into a dictionary.
			retval = new Dictionary<string, string>(keyValuePairs.Count);

			foreach (KeyValuePair<string, string> keyValuePair in keyValuePairs)
			{
				//Skip any key we have already seen.
				if (!retval.ContainsKey(keyValuePair.Key))
				{
					retval.Add(keyValuePair.Key, keyValuePair.Value);
				}
			}

			return retval;
		}

		#endregion

		#region Get Key/Section Names

		/// <summary>
		/// Gets the names of all keys under a specific section in the ini file.
		/// </summary>
		/// <param name="sectionName">
		/// The name of the section to read key names from.
		/// </param>
		/// <returns>An array of key names.</returns>
		/// <remarks>
		/// The total length of all key names in the section must be 
		/// less than 32KB in length.
		/// </remarks>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> is a null reference  (Nothing in VB)
		/// </exception>
		public string[] GetKeyNames(string sectionName)
		{
			int len;
			string[] retval;

			if (sectionName == null)
				throw new ArgumentNullException("sectionName");
			
			//Allocate a buffer for the returned section names.
			IntPtr ptr = Marshal.AllocCoTaskMem(IniFile.MaxSectionSize);

			try
			{
				//Get the section names into the buffer.
				len = NativeMethods.GetPrivateProfileString(sectionName, 
															null, 
															null, 
															ptr,
															IniFile.MaxSectionSize, 
															m_path);

				retval = ConvertNullSeperatedStringToStringArray(ptr, len);
			}
			finally
			{
				//Free the buffer
				Marshal.FreeCoTaskMem(ptr);
			}

			return retval;
		}

		/// <summary>
		/// Gets the names of all sections in the ini file.
		/// </summary>
		/// <returns>An array of section names.</returns>
		/// <remarks>
		/// The total length of all section names in the section must be 
		/// less than 32KB in length.
		/// </remarks>
		public string[] GetSectionNames()
		{
			string[] retval;
			int len;

			//Allocate a buffer for the returned section names.
			IntPtr ptr = Marshal.AllocCoTaskMem(IniFile.MaxSectionSize);

			try
			{
				//Get the section names into the buffer.
				len = NativeMethods.GetPrivateProfileSectionNames(ptr, 
					IniFile.MaxSectionSize, m_path);

				retval = ConvertNullSeperatedStringToStringArray(ptr, len);
			}
			finally
			{
				//Free the buffer
				Marshal.FreeCoTaskMem(ptr);
			}
			
			return retval;
		}

		/// <summary>
		/// Converts the null seperated pointer to a string into a string array.
		/// </summary>
		/// <param name="ptr">A pointer to string data.</param>
		/// <param name="valLength">
		/// Length of the data pointed to by <paramref name="ptr"/>.
		/// </param>
		/// <returns>
		/// An array of strings; one for each null found in the array of characters pointed
		/// at by <paramref name="ptr"/>.
		/// </returns>
		private static string[] ConvertNullSeperatedStringToStringArray(IntPtr ptr, int valLength)
		{
			string[] retval;

			if (valLength == 0)
			{
				//Return an empty array.
				retval = new string[0];
			}
			else
			{
				//Convert the buffer into a string.  Decrease the length 
				//by 1 so that we remove the second null off the end.
				string buff = Marshal.PtrToStringAuto(ptr, valLength - 1);

				//Parse the buffer into an array of strings by searching for nulls.
				retval = buff.Split('\0');
			}

			return retval;
		}

		#endregion

		#region Write Methods

		/// <summary>
		/// Writes a <see cref="T:System.String"/> value to the ini file.
		/// </summary>
		/// <param name="sectionName">The name of the section to write to .</param>
		/// <param name="keyName">The name of the key to write to.</param>
		/// <param name="value">The string value to write</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">
		/// The write failed.
		/// </exception>
		private void WriteValueInternal(string sectionName, string keyName, string value)
		{
			if (!NativeMethods.WritePrivateProfileString(sectionName, keyName, value, m_path))
			{
				throw new System.ComponentModel.Win32Exception();
			}
		}

		/// <summary>
		/// Writes a <see cref="T:System.String"/> value to the ini file.
		/// </summary>
		/// <param name="sectionName">The name of the section to write to .</param>
		/// <param name="keyName">The name of the key to write to.</param>
		/// <param name="value">The string value to write</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">
		/// The write failed.
		/// </exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> or 
		/// <paramref name="value"/>  are a null reference  (Nothing in VB)
		/// </exception>
		public void WriteValue(string sectionName, string keyName, string value)
		{
			if (sectionName == null)
				throw new ArgumentNullException("sectionName");

			if (keyName == null)
				throw new ArgumentNullException("keyName");

			if (value == null)
				throw new ArgumentNullException("value");

			WriteValueInternal(sectionName, keyName, value);
		}

		/// <summary>
		/// Writes an <see cref="T:System.Int16"/> value to the ini file.
		/// </summary>
		/// <param name="sectionName">The name of the section to write to .</param>
		/// <param name="keyName">The name of the key to write to.</param>
		/// <param name="value">The value to write</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">
		/// The write failed.
		/// </exception>
		public void WriteValue(string sectionName, string keyName, short value)
		{
			WriteValue(sectionName, keyName, (int)value);
		}

		/// <summary>
		/// Writes an <see cref="T:System.Int32"/> value to the ini file.
		/// </summary>
		/// <param name="sectionName">The name of the section to write to .</param>
		/// <param name="keyName">The name of the key to write to.</param>
		/// <param name="value">The value to write</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">
		/// The write failed.
		/// </exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> are 
		/// a null reference  (Nothing in VB)
		/// </exception>
		public void WriteValue(string sectionName, string keyName, int value)
		{
			WriteValue(sectionName, keyName, value.ToString(CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Writes an <see cref="T:System.Single"/> value to the ini file.
		/// </summary>
		/// <param name="sectionName">The name of the section to write to .</param>
		/// <param name="keyName">The name of the key to write to.</param>
		/// <param name="value">The value to write</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">
		/// The write failed.
		/// </exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> are 
		/// a null reference  (Nothing in VB)
		/// </exception>
		public void WriteValue(string sectionName, string keyName, float value)
		{
			WriteValue(sectionName, keyName, value.ToString(CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Writes an <see cref="T:System.Double"/> value to the ini file.
		/// </summary>
		/// <param name="sectionName">The name of the section to write to .</param>
		/// <param name="keyName">The name of the key to write to.</param>
		/// <param name="value">The value to write</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">
		/// The write failed.
		/// </exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> are 
		/// a null reference  (Nothing in VB)
		/// </exception>
		public void WriteValue(string sectionName, string keyName, double value)
		{
			WriteValue(sectionName, keyName, value.ToString(CultureInfo.InvariantCulture));
		}

		#endregion

		#region Delete Methods

		/// <summary>
		/// Deletes the specified key from the specified section.
		/// </summary>
		/// <param name="sectionName">
		/// Name of the section to remove the key from.
		/// </param>
		/// <param name="keyName">
		/// Name of the key to remove.
		/// </param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> or <paramref name="keyName"/> are 
		/// a null reference  (Nothing in VB)
		/// </exception>
		public void DeleteKey(string sectionName, string keyName)
		{
			if (sectionName == null)
				throw new ArgumentNullException("sectionName");

			if (keyName == null)
				throw new ArgumentNullException("keyName");

			WriteValueInternal(sectionName, keyName, null);
		}

		/// <summary>
		/// Deletes a section from the ini file.
		/// </summary>
		/// <param name="sectionName">
		/// Name of the section to delete.
		/// </param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="sectionName"/> is a null reference (Nothing in VB)
		/// </exception>
		public void DeleteSection(string sectionName)
		{
			if (sectionName == null)
				throw new ArgumentNullException("sectionName");

			WriteValueInternal(sectionName, null, null);
		}

		#endregion
	}
}
#T=Internetsetcookie WebBrowser
// /r:"C:\Program Files\Microsoft.NET\Primary Interop Assemblies\Microsoft.mshtml.dll";"C:\Program Files\Microsoft.NET\Primary Interop Assemblies\Interop.SHDocVw.dll"
namespace Microshaoft
{
	using System;
	using System.ComponentModel;
	using System.Drawing;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
	public partial class Form1 : Form
	{

		[DllImport("wininet.dll", CharSet=CharSet.Auto, SetLastError=true)]
		static extern bool InternetSetCookie(string lpszUrl, string lpszCookieName, string lpszCookieData);

		public Form1()
		{
			InitializeComponent();

			this.webBrowser1.Navigated += new WebBrowserNavigatedEventHandler(webBrowser1_Navigated);
		}
		void _AxWebBrowser_NewWindow2(ref object ppDisp, ref bool Cancel)
		{
			throw new NotImplementedException();
		}
		void _AxWebBrowser_NewWindow3(ref object ppDisp, ref bool Cancel, uint dwFlags, string bstrUrlContext, string bstrUrl)
		{
			throw new NotImplementedException();
		}
		private void button1_Click(object sender, EventArgs e)
		{
			InternetSetCookie("http://www.testactivity.com", "cookieName", DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
			this.webBrowser1.Navigate(@"http://www.testactivity.com");
		}
		void webBrowser1_Navigated(object sender, WebBrowserNavigatedEventArgs e)
		{
			MessageBox.Show("webBrowser1_Navigated");
		}
	}
	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.webBrowser1 = new WebBrowser();
			this.button1 = new Button();
			this.SuspendLayout();
			// 
			// webBrowser1
			// 
			this.webBrowser1.Dock = DockStyle.Bottom;
			this.webBrowser1.Location = new Point(0, 91);
			this.webBrowser1.MinimumSize = new Size(20, 20);
			this.webBrowser1.Name = "webBrowser1";
			this.webBrowser1.Size = new Size(292, 182);
			this.webBrowser1.TabIndex = 0;
			// 
			// button1
			// 
			this.button1.Location = new Point(41, 34);
			this.button1.Name = "button1";
			this.button1.Size = new Size(75, 23);
			this.button1.TabIndex = 1;
			this.button1.Text = "button1";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new EventHandler(this.button1_Click);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new SizeF(6F, 12F);
			this.AutoScaleMode = AutoScaleMode.Font;
			this.ClientSize = new Size(292, 273);
			this.Controls.Add(this.button1);
			this.Controls.Add(this.webBrowser1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.ResumeLayout(false);
		}
		#endregion
		private WebBrowser webBrowser1;
		private Button button1;
	}
}

#T=IOCP API Test
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	using System.Threading;
	using Microsoft.Win32.SafeHandles;

	[StructLayout(LayoutKind.Sequential)]
	class PER_IO_DATA
	{
		public string Data;
	}

	public class IOCPApiTest
	{
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern SafeFileHandle CreateIoCompletionPort(IntPtr FileHandle, IntPtr ExistingCompletionPort, IntPtr CompletionKey, uint NumberOfConcurrentThreads);
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool GetQueuedCompletionStatus(SafeFileHandle CompletionPort,
			out uint lpNumberOfBytesTransferred, out IntPtr lpCompletionKey,
			out IntPtr lpOverlapped, uint dwMilliseconds);
		[DllImport("Kernel32", CharSet = CharSet.Auto)]
		private static extern bool PostQueuedCompletionStatus(SafeFileHandle CompletionPort, uint dwNumberOfBytesTransferred, IntPtr dwCompletionKey, IntPtr lpOverlapped);

		public static unsafe void TestIOCPApi()
		{
			var CompletionPort = CreateIoCompletionPort(new IntPtr(-1), IntPtr.Zero, IntPtr.Zero, 1);
			if(CompletionPort.IsInvalid)
			{
				Console.WriteLine("CreateIoCompletionPort 出错:{0}",Marshal.GetLastWin32Error());
			}
			var thread = new Thread(ThreadProc);
			thread.Start(CompletionPort);

			var PerIOData = new PER_IO_DATA() ;
			var gch = GCHandle.Alloc(PerIOData);
			PerIOData.Data = "hi,我是蛙蛙王子，你是谁？";
			Console.WriteLine("{0}-主线程发送数据",Thread.CurrentThread.GetHashCode());
			PostQueuedCompletionStatus(CompletionPort, (uint)sizeof(IntPtr), IntPtr.Zero, (IntPtr)gch);

			var PerIOData2 = new PER_IO_DATA();
			var gch2 = GCHandle.Alloc(PerIOData2);
			PerIOData2.Data = "关闭工作线程吧";
			Console.WriteLine("{0}-主线程发送数据", Thread.CurrentThread.GetHashCode());
			PostQueuedCompletionStatus(CompletionPort, 4, IntPtr.Zero, (IntPtr)gch2);
			Console.WriteLine("主线程执行完毕");
			Console.ReadKey();
		}
		static void ThreadProc(object CompletionPortID)
		{
			var CompletionPort = (SafeFileHandle)CompletionPortID;

			while (true)
			{
				uint BytesTransferred;
				IntPtr PerHandleData;
				IntPtr lpOverlapped;
				Console.WriteLine("{0}-工作线程准备接受数据",Thread.CurrentThread.GetHashCode());
				GetQueuedCompletionStatus(CompletionPort, out BytesTransferred,
										  out PerHandleData, out lpOverlapped, 0xffffffff);
				if(BytesTransferred <= 0)
					continue;
				GCHandle gch = GCHandle.FromIntPtr(lpOverlapped);
				var per_HANDLE_DATA = (PER_IO_DATA)gch.Target;
				Console.WriteLine("{0}-工作线程收到数据：{1}", Thread.CurrentThread.GetHashCode(), per_HANDLE_DATA.Data);
				gch.Free();
				if (per_HANDLE_DATA.Data != "关闭工作线程吧") continue;
				Console.WriteLine("收到退出指令，正在退出");
				CompletionPort.Dispose();
				break;
			}
		}

		public static int Main(String[] args)
		{
			TestIOCPApi();
			return 0;
		}
	}
}
#T=IOCP Remoting Async to Sync
/*
csc /t:library Share.cs
*/
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	public static class RemotingHelper
	{
		public static void StartRemoting
								(
									Type RemotingType
									, string Url
									, int Port
									, WellKnownObjectMode ServiceMode
								)
		{
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
			IDictionary ht = new Hashtable();
			ht["port"] = Port;
			TcpChannel tc = new TcpChannel(ht, null, provider);
			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, ServiceMode);
			Console.WriteLine("Remoting Object Started ...");
		}
		public static void StartRemoting<T>
								(
									string Url
									, int Port
									, WellKnownObjectMode Mode
								)
		{
			StartRemoting(typeof(T), Url, Port, Mode);
		}
		public static T GetRemotingLocalClientProxyObject<T>
			(
				string Url
			)
		{
			return (T) Activator.GetObject
									(
										typeof(T)
										, Url
									);
		}
	}
}
namespace Microshaoft.RemotingObjects.Share
{
	using System;
	public interface IRemotingIoCP
	{
		void BeginSyncWaitFor(string command);
		void SendCommand(string command);
	}
}
/*
csc /r:Share.dll Server.cs
*/
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Runtime.InteropServices;
	using Microsoft.Win32.SafeHandles;
	using Microshaoft.Win32;
	public class IocpHandler<TSessionData, TIocpData>
	{
		public delegate void DataReceivedEventHandler
												(
													IocpHandler<TSessionData, TIocpData> sender
													, TIocpData iocp
												);
		public event DataReceivedEventHandler DataReceived;
		private bool _running = false;
		private SafeFileHandle _completionPort;
		public void CompleteHandle()
		{
			_running = false;
			_completionPort.Dispose();
		}
		public void SendData(TIocpData data)
		{
			GCHandle gch = GCHandle.Alloc(data);
			unsafe
			{
				NativeMethods.PostQueuedCompletionStatus
													(
														_completionPort
														, (uint) sizeof(IntPtr)
														, IntPtr.Zero
														, (IntPtr) gch
													);
			}
		}
		private TSessionData _sessionData;
		public TSessionData SessionData
		{
			get
			{
				return _sessionData;
			}
		}
		public void BeginSyncWait(TSessionData session)
		{
			_sessionData = session;
			_completionPort = NativeMethods.CreateIoCompletionPort
													(
														new IntPtr(-1)
														, IntPtr.Zero
														, IntPtr.Zero
														, 1
													);
			if(!_completionPort.IsInvalid)
			{
				_running = true;
///				Thread thread = new Thread(Run);
///				thread.Start();
				Run();
			}
		}
		private void Run()
		{
			while (_running)
			{
				uint r = 0;
				IntPtr PerHandleData;
				IntPtr lpOverlapped;
				NativeMethods.GetQueuedCompletionStatus
										(
											_completionPort
											, out r
											, out PerHandleData
											, out lpOverlapped
											, 0xffffffff
										);
				Console.WriteLine("GetQueuedCompletionStatus ... ");
				if(r > 0)
				{
					GCHandle gch = GCHandle.FromIntPtr(lpOverlapped);
					TIocpData data = (TIocpData) gch.Target;
					gch.Free();
					if (DataReceived != null)
					{
						DataReceived(this, data);
					}
				}
			}
		}
	}
}
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Runtime.InteropServices;
	using Microshaoft;
	public class IocpProcessor
	{
		private IocpHandler<UserSessionData, IocpData> _iocpHandler;
		public IocpProcessor()
		{
			_iocpHandler = new IocpHandler<UserSessionData, IocpData>();
			_iocpHandler.DataReceived += new IocpHandler<UserSessionData, IocpData>.DataReceivedEventHandler(_iocpHandler_DataReceived);
		}
		public void BeginSyncWaitFor(string command)
		{
			UserSessionData session = new UserSessionData();
			session.CompleteCommand = command;
			_iocpHandler.BeginSyncWait(session);
		}
		public void SendData(IocpData data)
		{
			_iocpHandler.SendData(data);
		}
		void _iocpHandler_DataReceived(IocpHandler<UserSessionData , IocpData> sender, IocpData data)
		{
			if (sender.SessionData.CompleteCommand == data.Text)
			{
				sender.CompleteHandle();
			}
		}
	}
	public class UserSessionData
	{
		public string UserName;
		public string CompleteCommand;
	}
	//[StructLayout(LayoutKind.Sequential)]
	public class IocpData
	{
		public string Text;
	}
}
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Security.Principal;
	using System.Configuration.Install;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using Microshaoft;
	using Microshaoft.Win32;
	using Microshaoft.RemotingObjects;
	public class ServiceHost : ServiceBase
	{
		public static readonly string serviceName = "RemotingSyncIocpAsycInvokeService";
		private static IocpProcessor _IocpProcessor;
		public static IocpProcessor IocpProcessor
		{
			get
			{
				return _IocpProcessor;
			}
		}
		static void Main(string[] args)
		{
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
				}
				Console.Title = "Server"; //不能以服务运行
				Console.WriteLine("Console");
				service.OnStart(null);
				Console.ReadLine();
				return;
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			_IocpProcessor = new IocpProcessor();
			RemotingHelper.StartRemoting<RemotingIoCP>
											(
												"iocp"
												, 8080
												, WellKnownObjectMode.SingleCall
											);
			Console.WriteLine("Server . , Press Enter key to exit.");
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.Win32
{
	using System;
	using Microsoft.Win32.SafeHandles;
	using System.Runtime.InteropServices;
	public static class NativeMethods
	{
		[
			DllImport
				(
					"kernel32.dll"
				)
		]
		public static extern bool AllocConsole();
		[
			DllImport
				(
					"kernel32.dll"
				)
		]
		public static extern bool FreeConsole();
		[
			DllImport
				(
					"kernel32.dll"
					, CharSet = CharSet.Auto
					, SetLastError = true
				)
		]
		public static extern SafeFileHandle CreateIoCompletionPort
													(
														IntPtr FileHandle
														, IntPtr ExistingCompletionPort
														, IntPtr CompletionKey
														, uint NumberOfConcurrentThreads
													);
		[
			DllImport
				(
					"kernel32.dll"
					, CharSet = CharSet.Auto
					, SetLastError = true
				)
		]
		public static extern bool GetQueuedCompletionStatus
													(
														SafeFileHandle CompletionPort
														, out uint lpNumberOfBytesTransferred
														, out IntPtr lpCompletionKey
														, out IntPtr lpOverlapped
														, uint dwMilliseconds
													);
		[
			DllImport
				(
					"Kernel32"
					, CharSet = CharSet.Auto
				)
		]
		public static extern bool PostQueuedCompletionStatus
													(
														SafeFileHandle CompletionPort
														, uint dwNumberOfBytesTransferred
														, IntPtr dwCompletionKey
														, IntPtr lpOverlapped
													);
	}
}
namespace Microshaoft.RemotingObjects
{
	using System;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.RemotingObjects.Server;
	public class RemotingIoCP : MarshalByRefObject, IRemotingIoCP
	{
		public void BeginSyncWaitFor(string command)
		{
			ServiceHost.IocpProcessor.BeginSyncWaitFor(command);
		}
		public void SendCommand(string command)
		{
			IocpData data = new IocpData();
			data.Text= command;
			ServiceHost.IocpProcessor.SendData(data);
		}
	}
}
/*
csc /r:Share.dll Client.cs
*/
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.Title = "Client";
			Class1 a = new Class1();
			a.Run();
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		public void Run()
		{
			IRemotingIoCP _proxy = RemotingHelper.GetRemotingLocalClientProxyObject<IRemotingIoCP>("tcp://127.0.0.1:8080/iocp");
			string s;
			while ((s = Console.ReadLine()) != "q")
			{
				Console.WriteLine("BeginSyncWaitFor: {0} at {1} blocking ...", s, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
				_proxy.BeginSyncWaitFor(s);
				Console.WriteLine("EndSyncWaitFor: {0} at {1}", s, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
			}
		}
	}
}
/*
csc /r:Share.dll ControlerClient.cs
*/
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.Title = "Controler Client";
			Class1 a = new Class1();
			a.Run();
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		public void Run()
		{
			IRemotingIoCP _proxy = RemotingHelper.GetRemotingLocalClientProxyObject<IRemotingIoCP>("tcp://127.0.0.1:8080/iocp");
			string s;
			while ((s = Console.ReadLine()) != "q")
			{
				_proxy.SendCommand(s);
				Console.WriteLine("SendCommand end: [{0}] at {1}", s, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
			}
		}
	}
}
#T=IOCP ThreadPool
namespace Sample
{
	using System;
	using System.Threading;  // Included for the Thread.Sleep call
	using Continuum.Threading;
	//============================================
	/// <summary> Sample class for the threading class </summary>
	public class UtilThreadingSample
	{
		//*******************************************
		/// <summary> Test Method </summary>
		static void Main()
		{
			// Create the MSSQL IOCP Thread Pool
			IOCPThreadPool pThreadPool = new IOCPThreadPool(0, 5, 10, new IOCPThreadPool.USER_FUNCTION(IOCPThreadFunction));
			pThreadPool.PostEvent(10);
			Thread.Sleep(100);
			pThreadPool.Dispose();
		}
		//*****************************************
		/// <summary> Function to be called by the IOCP thread pool.  Called when
		///           a command is posted for processing by the SocketManager </summary>
		/// <param name="iValue"> The value provided by the thread posting the event </param>
		static public void IOCPThreadFunction(Int32 iValue)
		{
			try
			{
				Console.WriteLine("Value: {0}", iValue);
			}
			catch (Exception pException)
			{
				Console.WriteLine(pException.Message);
			}
		}
	}
}


namespace Continuum.Threading
{
	using System;
	using System.Threading;
	using System.Runtime.InteropServices;
	// Structures
	//==========================================
	/// <summary> This is the WIN32 OVERLAPPED structure </summary>
	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
	public unsafe struct OVERLAPPED
	{
		UInt32* ulpInternal;
		UInt32* ulpInternalHigh;
		Int32   lOffset;
		Int32   lOffsetHigh;
		UInt32  hEvent;
	}
	// Classes
	//============================================
	/// <summary> This class provides the ability to create a thread pool to manage work.  The
	///           class abstracts the Win32 IOCompletionPort API so it requires the use of
	///           unmanaged code.  Unfortunately the .NET framework does not provide this functionality </summary>
	public sealed class IOCPThreadPool
	{
		// Win32 Function Prototypes
		/// <summary> Win32Func: Create an IO Completion Port Thread Pool </summary>
		[DllImport("Kernel32", CharSet=CharSet.Auto)]
		private unsafe static extern UInt32 CreateIoCompletionPort(UInt32 hFile, UInt32 hExistingCompletionPort, UInt32* puiCompletionKey, UInt32 uiNumberOfConcurrentThreads);

		/// <summary> Win32Func: Closes an IO Completion Port Thread Pool </summary>
		[DllImport("Kernel32", CharSet=CharSet.Auto)]
		private unsafe static extern Boolean CloseHandle(UInt32 hObject);

		/// <summary> Win32Func: Posts a context based event into an IO Completion Port Thread Pool </summary>
		[DllImport("Kernel32", CharSet=CharSet.Auto)]
		private unsafe static extern Boolean PostQueuedCompletionStatus(UInt32 hCompletionPort, UInt32 uiSizeOfArgument, UInt32* puiUserArg, OVERLAPPED* pOverlapped);

		/// <summary> Win32Func: Waits on a context based event from an IO Completion Port Thread Pool.
		///           All threads in the pool wait in this Win32 Function </summary>
		[DllImport("Kernel32", CharSet=CharSet.Auto)]
		private unsafe static extern Boolean GetQueuedCompletionStatus(UInt32 hCompletionPort, UInt32* pSizeOfArgument, UInt32* puiUserArg, OVERLAPPED** ppOverlapped, UInt32 uiMilliseconds);

		// Constants
		/// <summary> SimTypeConst: This represents the Win32 Invalid Handle Value Macro </summary>
		private const UInt32 INVALID_HANDLE_VALUE = 0xffffffff;

		/// <summary> SimTypeConst: This represents the Win32 INFINITE Macro </summary>
		private const UInt32 INIFINITE = 0xffffffff;

		/// <summary> SimTypeConst: This tells the IOCP Function to shutdown </summary>
		private const Int32 SHUTDOWN_IOCPTHREAD = 0x7fffffff;

		// Delegate Function Types
		/// <summary> DelType: This is the type of user function to be supplied for the thread pool </summary>
		public delegate void USER_FUNCTION(Int32 iValue);

		// Private Properties
		private UInt32 m_hHandle;
		/// <summary> SimType: Contains the IO Completion Port Thread Pool handle for this instance </summary>
		private UInt32 GetHandle { get { return m_hHandle; } set { m_hHandle = value; } }

		private Int32 m_uiMaxConcurrency;
		/// <summary> SimType: The maximum number of threads that may be running at the same time </summary>
		private Int32 GetMaxConcurrency { get { return m_uiMaxConcurrency; } set { m_uiMaxConcurrency = value; } }

		private Int32 m_iMinThreadsInPool;
		/// <summary> SimType: The minimal number of threads the thread pool maintains </summary>
		private Int32 GetMinThreadsInPool { get { return m_iMinThreadsInPool; } set { m_iMinThreadsInPool = value; } }

		private Int32 m_iMaxThreadsInPool;
		/// <summary> SimType: The maximum number of threads the thread pool maintains </summary>
		private Int32 GetMaxThreadsInPool { get { return m_iMaxThreadsInPool; } set { m_iMaxThreadsInPool = value; } }

		private Object m_pCriticalSection;
		/// <summary> RefType: A serialization object to protect the class state </summary>
		private Object GetCriticalSection { get { return m_pCriticalSection; } set { m_pCriticalSection = value; } }

		private USER_FUNCTION m_pfnUserFunction;
		/// <summary> DelType: A reference to a user specified function to be call by the thread pool </summary>
		private USER_FUNCTION GetUserFunction { get { return m_pfnUserFunction; } set { m_pfnUserFunction = value; } }
		
		private Boolean m_bDisposeFlag;
		/// <summary> SimType: Flag to indicate if the class is disposing </summary>
		private Boolean IsDisposed { get { return m_bDisposeFlag; } set { m_bDisposeFlag = value; } }

		// Public Properties
		private Int32 m_iCurThreadsInPool;
		/// <summary> SimType: The current number of threads in the thread pool </summary>
		public Int32 GetCurThreadsInPool { get { return m_iCurThreadsInPool; } set { m_iCurThreadsInPool = value; } }
		/// <summary> SimType: Increment current number of threads in the thread pool </summary>
		private Int32 IncCurThreadsInPool() { return Interlocked.Increment(ref m_iCurThreadsInPool); }
		/// <summary> SimType: Decrement current number of threads in the thread pool </summary>
		private Int32 DecCurThreadsInPool() { return Interlocked.Decrement(ref m_iCurThreadsInPool); }
		private Int32 m_iActThreadsInPool;
		/// <summary> SimType: The current number of active threads in the thread pool </summary>
		public Int32 GetActThreadsInPool { get { return m_iActThreadsInPool; } set { m_iActThreadsInPool = value; } }
		/// <summary> SimType: Increment current number of active threads in the thread pool </summary>
		private Int32 IncActThreadsInPool() { return Interlocked.Increment(ref m_iActThreadsInPool); }
		/// <summary> SimType: Decrement current number of active threads in the thread pool </summary>
		private Int32 DecActThreadsInPool() { return Interlocked.Decrement(ref m_iActThreadsInPool); }
		private Int32 m_iCurWorkInPool;
		/// <summary> SimType: The current number of Work posted in the thread pool </summary>
		public Int32 GetCurWorkInPool { get { return m_iCurWorkInPool; } set { m_iCurWorkInPool = value; } }
		/// <summary> SimType: Increment current number of Work posted in the thread pool </summary>
		private Int32 IncCurWorkInPool() { return Interlocked.Increment(ref m_iCurWorkInPool); }
		/// <summary> SimType: Decrement current number of Work posted in the thread pool </summary>
		private Int32 DecCurWorkInPool() { return Interlocked.Decrement(ref m_iCurWorkInPool); }
		// Constructor, Finalize, and Dispose
		//***********************************************
		/// <summary> Constructor </summary>
		/// <param name = "iMaxConcurrency"> SimType: Max number of running threads allowed </param>
		/// <param name = "iMinThreadsInPool"> SimType: Min number of threads in the pool </param>
		/// <param name = "iMaxThreadsInPool"> SimType: Max number of threads in the pool </param>
		/// <param name = "pfnUserFunction"> DelType: Reference to a function to call to perform work </param>
		/// <exception cref = "Exception"> Unhandled Exception </exception>
		public IOCPThreadPool
					(
						Int32 iMaxConcurrency
						, Int32 iMinThreadsInPool
						, Int32 iMaxThreadsInPool
						, USER_FUNCTION pfnUserFunction
					)
		{
			try
			{
				// Set initial class state
				GetMaxConcurrency   = iMaxConcurrency;
				GetMinThreadsInPool = iMinThreadsInPool;
				GetMaxThreadsInPool = iMaxThreadsInPool;
				GetUserFunction     = pfnUserFunction;
				// Init the thread counters
				GetCurThreadsInPool = 0;
				GetActThreadsInPool = 0;
				GetCurWorkInPool    = 0;
				// Initialize the Monitor Object
				GetCriticalSection = new Object();
				// Set the disposing flag to false
				IsDisposed = false;
				unsafe
				{
					// Create an IO Completion Port for Thread Pool use
					GetHandle = CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, null, (UInt32) GetMaxConcurrency);
				}
				// Test to make sure the IO Completion Port was created
				if (GetHandle == 0)
				{
					throw new Exception("Unable To Create IO Completion Port");
				}
				// Allocate and start the Minimum number of threads specified
				Int32 iStartingCount = GetCurThreadsInPool;
				ThreadStart tsThread = new ThreadStart(IOCPFunction);
				for (Int32 iThread = 0; iThread < GetMinThreadsInPool; ++iThread)
				{
				// Create a thread and start it
				Thread thThread = new Thread(tsThread);
				thThread.Name = "IOCP " + thThread.GetHashCode();
				thThread.Start();
				// Increment the thread pool count
				IncCurThreadsInPool();
				}
			}
			catch
			{
				throw new Exception("Unhandled Exception");
			}
		}
		//***********************************************
		/// <summary> Finalize called by the GC </summary>
		~IOCPThreadPool()
		{
			if (!IsDisposed)
			{
				Dispose();
			}
		}
		//**********************************************
		/// <summary> Called when the object will be shutdown.  This
		///           function will wait for all of the work to be completed
		///           inside the queue before completing </summary>
		public void Dispose()
		{
			try
			{
				// Flag that we are disposing this object
				IsDisposed = true;
				// Get the current number of threads in the pool
				Int32 iCurThreadsInPool = GetCurThreadsInPool;
				// Shutdown all thread in the pool
				for (Int32 iThread = 0; iThread < iCurThreadsInPool; ++iThread)
				{
					unsafe
					{
						bool bret = PostQueuedCompletionStatus(GetHandle, 4, (UInt32*) SHUTDOWN_IOCPTHREAD, null);
					}
				}
				// Wait here until all the threads are gone
				while (GetCurThreadsInPool != 0)
				{
					Thread.Sleep(100);
				}
				unsafe
				{
					// Close the IOCP Handle
					CloseHandle(GetHandle);
				}
			}
			catch
			{
			}
		}
		// Private Methods
		//*******************************************
		/// <summary> IOCP Worker Function that calls the specified user function </summary>
		private void IOCPFunction()
		{
			UInt32 uiNumberOfBytes;
			Int32  iValue;
			try
			{
				while (true)
				{
					unsafe
					{
						OVERLAPPED* pOv;
						// Wait for an event
						GetQueuedCompletionStatus(GetHandle, &uiNumberOfBytes, (UInt32*) &iValue, &pOv, INIFINITE);
					}
					// Decrement the number of events in queue
					DecCurWorkInPool();
					// Was this thread told to shutdown
					if (iValue == SHUTDOWN_IOCPTHREAD)
					{
						break;
					}
					// Increment the number of active threads
					IncActThreadsInPool();
					try
					{
						// Call the user function
						GetUserFunction(iValue);
					}
					catch
					{
					}
					// Get a lock
					Monitor.Enter(GetCriticalSection);
					try
					{
						// If we have less than max threads currently in the pool
						if (GetCurThreadsInPool < GetMaxThreadsInPool)
						{
							// Should we add a new thread to the pool
							if (GetActThreadsInPool == GetCurThreadsInPool)
							{
								if (IsDisposed == false)
								{
									// Create a thread and start it
									ThreadStart tsThread = new ThreadStart(IOCPFunction);
									Thread thThread = new Thread(tsThread);
									thThread.Name = "IOCP " + thThread.GetHashCode();
									thThread.Start();
									// Increment the thread pool count
									IncCurThreadsInPool();
								}
							}
						}
					}
					catch
					{
					}
					// Relase the lock
					Monitor.Exit(GetCriticalSection);
					// Increment the number of active threads
					DecActThreadsInPool();
				}
			}
			catch
			{
			}
			// Decrement the thread pool count
			DecCurThreadsInPool();
		}
		// Public Methods
		//******************************************
		/// <summary> IOCP Worker Function that calls the specified user function </summary>
		/// <param name="iValue"> SimType: A value to be passed with the event </param>
		/// <exception cref = "Exception"> Unhandled Exception </exception>
		public void PostEvent(Int32 iValue)
		{
			try
			{
				// Only add work if we are not disposing
				if (IsDisposed == false)
				{
					unsafe
					{
						// Post an event into the IOCP Thread Pool
						PostQueuedCompletionStatus(GetHandle, 4, (UInt32*) iValue, null);
					}
					// Increment the number of item of work
					IncCurWorkInPool();
					// Get a lock
					Monitor.Enter(GetCriticalSection);
					try
					{
						// If we have less than max threads currently in the pool
						if (GetCurThreadsInPool < GetMaxThreadsInPool)
						{
							// Should we add a new thread to the pool
							if (GetActThreadsInPool == GetCurThreadsInPool)
							{
								if (IsDisposed == false)
								{
									// Create a thread and start it
									ThreadStart tsThread = new ThreadStart(IOCPFunction);
									Thread thThread = new Thread(tsThread);
									thThread.Name = "IOCP " + thThread.GetHashCode();
									thThread.Start();
									// Increment the thread pool count
									IncCurThreadsInPool();
								}
							}
						}
					}
					catch
					{
					}
					// Release the lock
					Monitor.Exit(GetCriticalSection);
				}
			}
			catch (Exception e)
			{
				throw e;
			}
///			catch
///			{
///				throw new Exception("Unhandled Exception");
///			}
		}
		//*****************************************
		/// <summary> IOCP Worker Function that calls the specified user function </summary>
		/// <exception cref = "Exception"> Unhandled Exception </exception>
		public void PostEvent()
		{
			try
			{
				// Only add work if we are not disposing
				if (IsDisposed == false)
				{
					unsafe
					{
						// Post an event into the IOCP Thread Pool
						PostQueuedCompletionStatus(GetHandle, 0, null, null);
					}
					// Increment the number of item of work
					IncCurWorkInPool();
					// Get a lock
					Monitor.Enter(GetCriticalSection);
					try
					{
						// If we have less than max threads currently in the pool
						if (GetCurThreadsInPool < GetMaxThreadsInPool)
						{
							// Should we add a new thread to the pool
							if (GetActThreadsInPool == GetCurThreadsInPool)
							{
								if (IsDisposed == false)
								{
									// Create a thread and start it
									ThreadStart tsThread = new ThreadStart(IOCPFunction);
									Thread thThread = new Thread(tsThread);
									thThread.Name = "IOCP " + thThread.GetHashCode();
									thThread.Start();
									// Increment the thread pool count
									IncCurThreadsInPool();
								}
							}
						}
					}
					catch
					{
					}
					// Release the lock
					Monitor.Exit(GetCriticalSection);
				}
			}
			catch (Exception e)
			{
				throw e;
			}
///			catch
///			{
///				throw new Exception("Unhandled Exception");
///			}
		}
	}
}
#T=IOCP Winsock Echo Server
namespace WawaSocket.Net.Iocp
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Reflection;
	using System.Runtime.ConstrainedExecution;
	using System.Runtime.InteropServices;
	using System.Threading;
	using Microsoft.Win32.SafeHandles;
	//用IOCP和winsock api实现一个echo服务器
	#region 用IOCP和winsock api实现一个echo服务器
	class IocpTest
	{
		private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1); //无效句柄
		const int PORT = 5150; //要监听的端口
		const int DATA_BUFSIZE = 8192;  //默认缓冲区
		const int ERROR_IO_PENDING = 997; //表示数据正在接受或者发送中
		const uint INIFINITE = 0xffffffff; //表示等待无限时长
		private static readonly Logger _logger = Logger.GetLogger(typeof(IocpTest));

		//单IO数据
		#region 单IO数据
		[StructLayout(LayoutKind.Sequential)]
		class PerIoOperationData
		{
			public WaOverlapped Overlapped;
			public WSABuffer DataBuf;
			public readonly byte[] Buffer = new byte[DATA_BUFSIZE];
			public uint BytesSEND;
			public uint BytesRECV;
		}
		#endregion

		//单句柄数据
		#region 单句柄数据
		[StructLayout(LayoutKind.Sequential)]
		class PerHandleData
		{
			public SafeSocketHandle Socket;
		}
		#endregion

		public static void Run()
		{
			WSAData wsaData;
			SocketError Ret;

			//初始化套接字
			#region 初始化套接字
			_logger.Log("初始化socket");
			if ((Ret = Win32Api.WSAStartup(0x0202, out wsaData)) != SocketError.Success)
			{
				_logger.Error("WSAStartup failed with error {0}\n", Ret);
				return;
			}
			#endregion

			//创建一个完成端口内核对象
			#region 创建一个完成端口内核对象
			_logger.Log("创建完成端口");
			// Setup an I/O completion port.
			SafeFileHandle CompletionPort = Win32Api.CreateIoCompletionPort(INVALID_HANDLE_VALUE, IntPtr.Zero, IntPtr.Zero, 0);
			if (CompletionPort.IsInvalid)
			{
				_logger.Error("CreateIoCompletionPort failed with error: {0}\n", Marshal.GetLastWin32Error());
				Marshal.ThrowExceptionForHR(Marshal.GetLastWin32Error());
				return;
			}
			#endregion

			//创建工作线程
			#region 创建工作线程
			int processorCount = Environment.ProcessorCount;
			_logger.Log("创建{0}个工作线程", processorCount);
			for (int i = 0; i < processorCount; i++)
			{
				// Create a server worker thread and pass the completion port to the thread.
				var thread = new Thread(ThreadProc);
				thread.Start(CompletionPort);
			}
			#endregion

			//创建监听用的套接字
			#region 创建监听用的套接字
			_logger.Log("创建监听套接字");
			// Create a listening socket
			SafeSocketHandle Listen = Win32Api.WSASocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, IntPtr.Zero, 0, SocketConstructorFlags.WSA_FLAG_OVERLAPPED);
			if (Listen.IsInvalid)
			{
				Listen.SetHandleAsInvalid();
				_logger.Error("WSASocket() failed with error {0}\n", Win32Api.WSAGetLastError());
				Marshal.ThrowExceptionForHR(Win32Api.WSAGetLastError());
				return;
			}
			#endregion

			//将套接字与本地端口绑定
			#region 将套接字与本地端口绑定
			IPEndPoint InternetAddr = new IPEndPoint(IPAddress.Any, PORT);
			SocketAddress socketAddress = InternetAddr.Serialize();
			byte[] adress_buffer;
			int adress_size;
			_logger.Log("进行套接字绑定");
			if (!DoBind(Listen, socketAddress, out adress_buffer, out adress_size))
			{
				_logger.Error("bind() failed with error {0}\n", Win32Api.WSAGetLastError());
				Marshal.ThrowExceptionForHR(Win32Api.WSAGetLastError());
				return;
			}
			#endregion

			//开始监听端口
			#region 开始监听端口
			_logger.Log("开始监听:{0}-{1}", InternetAddr.Address, InternetAddr.Port);
			// Prepare socket for listening
			if (Win32Api.listen(Listen, 5) == SocketError.SocketError)
			{
				_logger.Error("listen() failed with error {0}\n", Win32Api.WSAGetLastError());
				Marshal.ThrowExceptionForHR(Win32Api.WSAGetLastError());
				return;
			}
			#endregion

			//起一个循环来接受新连接
			#region 起一个循环来接受新连接
			// Accept connections and assign to the completion port.
			while (true)
				unsafe
				{
					//接受新连接
					#region 接受新连接
					_logger.Log("开始接受入站连接");
					SafeSocketHandle Accept = Win32Api.accept(Listen.DangerousGetHandle(), adress_buffer, ref adress_size);
					if (Accept.IsInvalid)
					{
						_logger.Error("WSAAccept() failed with error {0}\n", Win32Api.WSAGetLastError());
						Marshal.ThrowExceptionForHR(Win32Api.WSAGetLastError());
					}
					_logger.Log("有新连接进入:{0}", Accept.GetHashCode());
					#endregion

					//创建单句柄数据
					#region 创建单句柄数据
					// Create a socket information structure to associate with the socket
					PerHandleData PerHandleData = new PerHandleData();
					GCHandle gch_PerHandleData = GCHandle.Alloc(PerHandleData);
					// Associate the accepted socket with the original completion port.
					PerHandleData.Socket = Accept;
					#endregion

					//把新接受的套接字与完成端口绑定
					#region 把新接受的套接字与完成端口绑定
					SafeFileHandle iocp = Win32Api.CreateIoCompletionPort(Accept.DangerousGetHandle(),
																 CompletionPort.DangerousGetHandle(),
																GCHandle.ToIntPtr(gch_PerHandleData), 0);
					if (iocp == null)
					{
						_logger.Error("CreateIoCompletionPort failed with error {0}\n", Marshal.GetLastWin32Error());
						Marshal.ThrowExceptionForHR(Marshal.GetLastWin32Error());
						return;
					}
					#endregion

					//准备单IO数据
					#region 准备单IO数据
					// Create per I/O socket information structure to associate with the 
					// WSARecv call below.
					PerIoOperationData PerIoData = new PerIoOperationData();
					GCHandle gchPerIoData = GCHandle.Alloc(PerIoData);
					PerIoData.Overlapped = new WaOverlapped { State = ((IntPtr)gchPerIoData) };
					GCHandle gcHandle = GCHandle.Alloc(PerIoData.Overlapped, GCHandleType.Pinned);
					PerIoData.BytesSEND = 0;
					PerIoData.BytesRECV = 0;
					PerIoData.DataBuf.Length = DATA_BUFSIZE;
					PerIoData.DataBuf.Pointer = Marshal.UnsafeAddrOfPinnedArrayElement(PerIoData.Buffer, 0);
					#endregion

					//开始投递异步接受数据的请求
					#region 开始投递异步接受数据的请求
					SocketFlags Flags = SocketFlags.None;
					_logger.Log("开始异步接受数据");
					int RecvBytes;
					SocketError error = Win32Api.WSARecv(Accept, ref PerIoData.DataBuf,
						1, out RecvBytes, ref Flags, gcHandle.AddrOfPinnedObject(),
						IntPtr.Zero);
					if (error == SocketError.SocketError)
					{
						if (Win32Api.WSAGetLastError() != ERROR_IO_PENDING)
						{
							_logger.Error("WSARecv() failed with error {0}\n", Win32Api.WSAGetLastError());
							Marshal.ThrowExceptionForHR(Win32Api.WSAGetLastError());
							//其实在主线程退出之前都应该用PostQueuedCompletionStatus通知工作线程退出
							return;
						}
					}
					#endregion
				}
			#endregion
		}

		//把一个套接字绑定在一个端口上的工具方法
		#region 把一个套接字绑定在一个端口上的工具方法
		private static bool DoBind(SafeSocketHandle Listen, SocketAddress address, out byte[] buffer, out int size)
		{
			FieldInfo socketAddress_m_Buffer = typeof(SocketAddress).GetField("m_Buffer",
																			  BindingFlags.Instance | BindingFlags.NonPublic);
			FieldInfo socketAddress_m_Size = typeof(SocketAddress).GetField("m_Size",
																			BindingFlags.Instance | BindingFlags.NonPublic);
			var m_buffer = (byte[])socketAddress_m_Buffer.GetValue(address);
			var m_Size = (int)socketAddress_m_Size.GetValue(address);
			buffer = m_buffer;
			size = m_Size;

			if (Win32Api.bind(Listen, m_buffer, m_Size) != SocketError.Success)
			{
				return false;
			}
			return true;
		}
		#endregion

		//工作线程
		#region 工作线程
		static unsafe void ThreadProc(object CompletionPortID)
		{
			var CompletionPort = (SafeFileHandle) CompletionPortID; //接受通知的完成端口
			SocketFlags Flags;
			IntPtr intptr_per_io_data, intptr_per_handle_data; //单句柄数据，单实例数据的指针
			GCHandle gcHandle_per_io_data, gcHandle_per_handle_data;//单句柄数据，单实例数据的gc句柄
			uint BytesTransferred; //接受或发送的数据
			PerHandleData PerHandleData; //单据并数据
			PerIoOperationData PerIoData; //单IO数据
			int SendBytes; //发送出的字节
			int RecvBytes; //接受到的字节
			//在循环里接受和发送数据
			#region 在循环里接受和发送数据
			while (true)
			{

				//在完成端口上等消息
				#region 在完成端口上等消息
				if (!Win32Api.GetQueuedCompletionStatus(CompletionPort, out BytesTransferred, out intptr_per_handle_data, out intptr_per_io_data, INIFINITE))
				{
					_logger.Error("GetQueuedCompletionStatus failed with error {0}\n",
						Marshal.GetLastWin32Error());
					return;
				}
				#endregion

				//拿到单据并数据
				#region 拿到单据并数据
				gcHandle_per_handle_data = GCHandle.FromIntPtr(intptr_per_handle_data);
				PerHandleData = (PerHandleData)gcHandle_per_handle_data.Target;
				#endregion

				//拿到单IO数据
				#region 拿到单IO数据
				WaOverlapped o = new WaOverlapped();
				Marshal.PtrToStructure(intptr_per_io_data, o);
				gcHandle_per_io_data = GCHandle.FromIntPtr(o.State);
				PerIoData = (PerIoOperationData)gcHandle_per_io_data.Target;
				#endregion

				//判断是否为断开请求
				#region 判断是否为断开请求
				if (BytesTransferred == 0)
				{
					_logger.Log("断开连接 {0}", PerHandleData.Socket.GetHashCode());
					PerHandleData.Socket.Close();
					gcHandle_per_handle_data.Free();
					gcHandle_per_io_data.Free();
					continue;
				}
				#endregion

				//根据异步操作的类型来更新单IO数据
				#region 根据异步操作的类型来更新单IO数据
				// Check to see if the BytesRECV field equals zero. If this is so, then
				// this means a WSARecv call just completed so update the BytesRECV field
				// with the BytesTransferred value from the completed WSARecv() call.
				if (PerIoData.BytesRECV == 0)
				{
					PerIoData.BytesRECV = BytesTransferred;
					PerIoData.BytesSEND = 0;
				}
				else
				{
					PerIoData.BytesSEND += BytesTransferred;
				}
				#endregion

				try
				{
					if (PerIoData.BytesRECV > PerIoData.BytesSEND)
					{
						//如果收到消息就原封不动发给发送者
						#region 如果收到消息就原封不动发给发送者
						_logger.Log("开始异步发送数据：{0}-{1}", PerHandleData.Socket.GetHashCode(),
							PerIoData.Overlapped.GetHashCode());

						//更新单IO数据
						#region 更新单IO数据
						// Post another WSASend() request.
						// Since WSASend() is not gauranteed to send all of the bytes requested,
						// continue posting WSASend() calls until all received bytes are sent.
						GCHandle gchPerIoData = GCHandle.Alloc(PerIoData);
						PerIoData.Overlapped = new WaOverlapped { State = ((IntPtr)gchPerIoData) };
						GCHandle gchOverlapped = GCHandle.Alloc(PerIoData.Overlapped, GCHandleType.Pinned);
						PerIoData.DataBuf.Pointer = Marshal.UnsafeAddrOfPinnedArrayElement(
							PerIoData.Buffer, (int)PerIoData.BytesSEND);
						PerIoData.DataBuf.Length = PerIoData.BytesRECV - PerIoData.BytesSEND;
						#endregion

						//投递异步发送数据请求
						#region 投递异步发送数据请求
						SocketError error = Win32Api.WSASend(PerHandleData.Socket, ref PerIoData.DataBuf, 1, out SendBytes, 0, gchOverlapped.AddrOfPinnedObject(), IntPtr.Zero);
						if (error == SocketError.SocketError)
						{
							if (Win32Api.WSAGetLastError() != ERROR_IO_PENDING)
							{
								_logger.Error("WSASend() failed with error {0}", Win32Api.WSAGetLastError());
								return;
							}
						}
						#endregion
						#endregion
					}
					else
					{
						//如果没有需要发送的数据，就投递一个异步接受数据请求
						#region 如果没有需要发送的数据，就投递一个异步接受数据请求
						_logger.Log("开始异步接受数据：{0}-{1}", PerHandleData.Socket.GetHashCode(), PerIoData.Overlapped.GetHashCode());
						//更新单IO数据
						#region 更新单IO数据

						PerIoData.BytesRECV = 0;
						// Now that there are no more bytes to send post another WSARecv() request.
						Flags = SocketFlags.None;
						GCHandle gchPerIoData = GCHandle.Alloc(PerIoData);
						PerIoData.Overlapped = new WaOverlapped { State = ((IntPtr)gchPerIoData) };
						GCHandle gchOverlapped = GCHandle.Alloc(PerIoData.Overlapped, GCHandleType.Pinned);
						PerIoData.DataBuf.Length = DATA_BUFSIZE;
						PerIoData.DataBuf.Pointer = Marshal.UnsafeAddrOfPinnedArrayElement(PerIoData.Buffer, 0);
						#endregion

						//投递异步接受请求
						#region 投递异步接受请求
						SocketError error = Win32Api.WSARecv(PerHandleData.Socket, ref PerIoData.DataBuf, 1, out RecvBytes, ref Flags, gchOverlapped.AddrOfPinnedObject(), IntPtr.Zero);
						if (error == SocketError.SocketError)
						{
							if (Win32Api.WSAGetLastError() != ERROR_IO_PENDING)
							{
								_logger.Error("WSARecv() failed with error{0}", Win32Api.WSAGetLastError());
								return;
							}
						}
						#endregion
						#endregion
					}
				}
				finally
				{
					if (gcHandle_per_handle_data.IsAllocated)
						gcHandle_per_io_data.Free();
				}

			}
			#endregion
		}
		#endregion
	} 
	#endregion

	//封装原生的socket对象
	#region 封装原生的socket对象
	public class SafeSocketHandle : SafeHandleMinusOneIsInvalid
	{
		private Logger _logger = Logger.GetLogger(typeof(SafeSocketHandle));
		public SafeSocketHandle()
			: base(true)
		{
		}


		public SafeSocketHandle(bool ownsHandle)
			: base(ownsHandle)
		{
		}

		protected override bool ReleaseHandle()
		{
			if (Win32Api.closesocket(base.handle) == SocketError.SocketError)
			{
				_logger.Error("closesocket() failed with error {0}\n", Win32Api.WSAGetLastError());
			}
			return true;
		}
	} 
	#endregion

	//日志类
	#region 日志类
	class Logger
	{
		public static Logger GetLogger(Type type)
		{
			return new Logger();
		}

		public void Log(object o)
		{
			Console.WriteLine(o);
		}
		public void Log(string format, params object[] objects)
		{
			Console.WriteLine(format, objects);
		}
		public void Error(object o)
		{
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine(o);
			Console.ForegroundColor = ConsoleColor.White;
		}
		public void Error(string format, params object[] objects)
		{
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine(format, objects);
			Console.ForegroundColor = ConsoleColor.White;
		}
	} 
	#endregion

	//win32 structs
	#region win32 structs
	[StructLayout(LayoutKind.Sequential)]
	public class WaOverlapped
	{
		public IntPtr InternalLow;
		public IntPtr InternalHigh;
		public int OffsetLow;
		public int OffsetHigh;
		public IntPtr EventHandle;
		public IntPtr State;
		
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct WSABuffer
	{
		internal uint Length;
		internal IntPtr Pointer;
	}
	[StructLayout(LayoutKind.Sequential)]
	internal struct WSAData
	{
		internal short wVersion;
		internal short wHighVersion;
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 0x101)]
		internal string szDescription;
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 0x81)]
		internal string szSystemStatus;
		internal short iMaxSockets;
		internal short iMaxUdpDg;
		internal IntPtr lpVendorInfo;
	}
	[Flags]
	internal enum SocketConstructorFlags
	{
		WSA_FLAG_MULTIPOINT_C_LEAF = 4,
		WSA_FLAG_MULTIPOINT_C_ROOT = 2,
		WSA_FLAG_MULTIPOINT_D_LEAF = 0x10,
		WSA_FLAG_MULTIPOINT_D_ROOT = 8,
		WSA_FLAG_OVERLAPPED = 1
	}
	#endregion

	//封装winsock和iocp的相关API原型
	#region 封装winsock和iocp的相关API原型
	class Win32Api
	{
		[DllImport("ws2_32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
		internal static extern SocketError WSAStartup([In] short wVersionRequested, out WSAData lpWSAData);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern SafeFileHandle CreateIoCompletionPort(IntPtr FileHandle, IntPtr ExistingCompletionPort, IntPtr CompletionKey, uint NumberOfConcurrentThreads);
		[DllImport("ws2_32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern SafeSocketHandle WSASocket([In] AddressFamily addressFamily, [In] SocketType socketType, [In] ProtocolType protocolType, [In] IntPtr protocolInfo, [In] uint group, [In] SocketConstructorFlags flags);
		[DllImport("Ws2_32.dll", EntryPoint = "WSAGetLastError", SetLastError = true, CharSet = CharSet.Ansi, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
		public static extern int WSAGetLastError();
		[DllImport("ws2_32.dll", SetLastError = true)]
		internal static extern SocketError bind([In] SafeSocketHandle socketHandle, [In] byte[] socketAddress, [In] int socketAddressSize);
		[DllImport("ws2_32.dll", SetLastError = true)]
		internal static extern SocketError listen([In] SafeSocketHandle socketHandle, [In] int backlog);
		[DllImport("ws2_32.dll", SetLastError = true, ExactSpelling = true)]
		internal static extern SafeSocketHandle accept([In] IntPtr socketHandle, [Out] byte[] socketAddress, [In, Out] ref int socketAddressSize);
		[DllImport("ws2_32.dll", SetLastError = true)]
		internal static extern SocketError WSARecv([In] SafeSocketHandle socketHandle, [In, Out] ref WSABuffer buffer, [In] int bufferCount, out int bytesTransferred, [In, Out] ref SocketFlags socketFlags, [In] IntPtr overlapped, [In] IntPtr completionRoutine);
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern unsafe bool GetQueuedCompletionStatus(SafeFileHandle CompletionPort,
			out uint lpNumberOfBytes, out IntPtr lpCompletionKey,
			out IntPtr lpOverlapped, uint dwMilliseconds);
		[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success), DllImport("ws2_32.dll", SetLastError = true, ExactSpelling = true)]
		internal static extern SocketError closesocket([In] IntPtr socketHandle);
		[DllImport("ws2_32.dll", SetLastError = true)]
		internal static extern SocketError WSASend([In] SafeSocketHandle socketHandle, [In] ref WSABuffer buffer, [In] int bufferCount, out int bytesTransferred, [In] SocketFlags socketFlags, [In] IntPtr overlapped, [In] IntPtr completionRoutine);
	}
	#endregion

	public class WawaIocpTest
	{
		public static void Main(String[] args)
		{
			IocpTest.Run();
		}
	}
}

#T=IpHlpAPI IP changed notify
namespace ConsoleApplication
{
	using System;
	using Iphlpapi;

		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		CNotifyAddrChange x;
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Class1 a = new Class1();
			

			a.Run();
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		public void Run()
		{
			x = new CNotifyAddrChange();
			x.AddrChangedEvent += OnAddrChangedEvent;
		}
		public void OnAddrChangedEvent(object sender, EventArgs e)
		{
			try
			{
				Console.WriteLine("IP Address Changed", "NotifyAddrChange");
			}
			catch// (Exception e)
			{
				// Handle Error
				//MessageBox.Show(oException.ToString());
			}
		}
	}
}
namespace Iphlpapi
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Threading; 
	using System.Runtime.InteropServices; // For PInvoke
	using System.Windows.Forms; // For MessageBox

	public class CNotifyAddrChange
	{
		public event EventHandler<EventArgs> AddrChangedEvent = null;
		protected Thread TheThread { get; set; }
		protected enum EEvents
		{
			AddrChange,
			Stop,
			Count,
		}
		protected AutoResetEvent[] m_aoEvents	= new AutoResetEvent[(int)EEvents.Count]
		{
			new AutoResetEvent(false),	// AddrChangeEvent
			new AutoResetEvent(false),	// StopEvent
		};
		
		[DllImport("Iphlpapi.dll", SetLastError = true)]
		public static extern UInt32 NotifyAddrChange(ref IntPtr Handle, ref NativeOverlapped overlapped);

		public CNotifyAddrChange()
		{
			TheThread = null;
			Start();
		}

		~CNotifyAddrChange()
		{
			Stop();
		}
		
		protected AutoResetEvent AddrChangeEvent
		{
			get
			{
				return m_aoEvents[(int)EEvents.AddrChange];
			}
		}

		protected AutoResetEvent StopEvent
		{
			get
			{
				return m_aoEvents[(int)EEvents.Stop];
			}
		}
		public void Start()
		{
			Stop();
			TheThread = new Thread(new ThreadStart(ThreadProc));
			TheThread.Name	= "NotifyAddrChange";
			TheThread.Start();
		}
		
		public void Stop()
		{
			if( (TheThread != null) && TheThread.IsAlive )
			{
				StopEvent.Set();
				
				TheThread.Join();
			}
		}
		public void ThreadProc()
		{
			try
			{
				NativeOverlapped oOverlapped = new NativeOverlapped();
				IntPtr pnHandle = IntPtr.Zero;
				oOverlapped.EventHandle = AddrChangeEvent.SafeWaitHandle.DangerousGetHandle();
				while (true)
				{
					UInt32	nRetVal	= NotifyAddrChange(ref pnHandle, ref oOverlapped);
					if(nRetVal == 997) // 997 == ERROR_IO_PENDING, means that it will notify us when an IP Address changes
					{
						// Wait for any of the events to fire
						if (WaitHandle.WaitAny(m_aoEvents) == (Int32)EEvents.AddrChange)
						{
							EventHandler<EventArgs>	oHandler	= AddrChangedEvent;
							if(oHandler != null)
							{
								oHandler(this, null);
							}
						}
						else
						{
							// The abort event was triggered, so we exit
							break;
						}
					}
					else
					{
						// Handle the error
						MessageBox.Show("Failed to register for notification. " + nRetVal.ToString());		
						break;
					}
				}
			}
			catch (Exception e)
			{
				// Handle the Error
				//MessageBox.Show(oException.ToString());
			}
		}
	}
}

#T=IP纯真数据库 IPHelper
namespace QQWry.Test
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Diagnostics;

	using Microshaoft.Util;
	class Program
	{
		static void Main(string[] args)
		{

			IPHelper.LoadData("ip.txt");
			long find = IPHelper.IPToLong("59.52.113.62");
//			find = 1032063168;
			Console.WriteLine(find);
			Console.WriteLine(IPHelper.LongToIP(find));
			int r = IPHelper.FindIndex(find, IPHelper.StartIPArray);
			Console.WriteLine("r :{0}", r);
			Console.WriteLine("r :{0}", IPHelper.DataArray[r]);
			Console.WriteLine("r :{0}", IPHelper.Data1Array[r]);
			Console.WriteLine("r :{0}", IPHelper.Data2Array[r]);
			string s = "N/A";
			if (r >= 0 && find <= IPHelper.EndIPArray[r])
			{
				s = IPHelper.DataArray[r];
			}
			//List<List<string>> x = LoadData1("ip.txt");
			Console.WriteLine("end");

			try
			{
				QQWry.NET.QQWryLocator qqWry = new QQWry.NET.QQWryLocator("qqwry.dat");//初始化数据库文件，并获得IP记录数，通过Count可以获得

				QQWry.NET.IPLocation ip = qqWry.Query("120.67.217.7");  //查询一个IP地址
				Console.WriteLine("{0} {1} {2}", ip.IP, ip.Country, ip.Local); 

				Stopwatch stopwatch = new Stopwatch();
				List<string> ips = new List<string> { "218.5.3.128", "120.67.217.7", "125.78.67.175", "220.250.64.23", "218.5.3.128", "120.67.217.7", "125.78.67.175", "220.250.64.23" };
				stopwatch.Start();
				for (int i = 0; i < 100; i++)
				{
					foreach (string item in ips)
					{
						ip = qqWry.Query(item);
						// Console.WriteLine("{0} {1} {2}", ip.IP, ip.Country, ip.Local);
					}
				}

				stopwatch.Stop();
				Console.WriteLine("查询了800次IP，QQWryLocator 花了{0} ms", stopwatch.ElapsedMilliseconds);

///				stopwatch.Reset();
///				stopwatch.Start();
///				for (int i = 0; i < 100; i++)
///				{
///					foreach (string item in ips)
///					{
///						string s = IPLocation.IPLocation.IPLocate("qqwry.dat", item);
///					   // Console.WriteLine(s);
///					}
///				}
///				stopwatch.Stop();
///				Console.WriteLine("查询了800次IP，IPLocation 花了{0} ms", stopwatch.ElapsedMilliseconds);
			}
			catch (Exception e)
			{
				Console.WriteLine(e.Message);
			}
			Console.Read();
		}
	}
}


namespace QQWry.NET
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.IO;
	using System.Text.RegularExpressions;
	using System.Net;


	public class IPLocation
	{
		public string IP
		{
			get;
			set;
		}
		public string Country
		{
			get;
			set;
		}
		public string Local
		{
			get;
			set;
		}
	}
	public class QQWryLocator
	{
		private byte[] data;
		//Regex regex = new Regex(@"(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))");
		long firstStartIpOffset;
		long lastStartIpOffset;
		long ipCount;
		public long Count
		{
			get
			{
				return ipCount;
			}
		}
		public QQWryLocator(string dataPath)
		{
			using (FileStream fs = new FileStream(dataPath, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				data = new byte[fs.Length];
				fs.Read(data, 0, data.Length);
			}
			byte[] buffer = new byte[8];
			Array.Copy(data, 0, buffer, 0, 8);
			firstStartIpOffset = ((buffer[0] + (buffer[1] * 0x100)) + ((buffer[2] * 0x100) * 0x100)) + (((buffer[3] * 0x100) * 0x100) * 0x100);
			lastStartIpOffset = ((buffer[4] + (buffer[5] * 0x100)) + ((buffer[6] * 0x100) * 0x100)) + (((buffer[7] * 0x100) * 0x100) * 0x100);
			ipCount = Convert.ToInt64((double)(((double)(lastStartIpOffset - firstStartIpOffset)) / 7.0));

			if (ipCount <= 1L)
			{
				throw new ArgumentException("ip FileDataError");
			}
		}

		private static long IpToInt(string ip)
		{
///			char[] separator = new char[] { '.' };
///			if (ip.Split(separator).Length == 3)
///			{
///				ip = ip + ".0";
///			}
///			string[] strArray = ip.Split(separator);
///			long num2 = ((long.Parse(strArray[0]) * 0x100L) * 0x100L) * 0x100L;
///			long num3 = (long.Parse(strArray[1]) * 0x100L) * 0x100L;
///			long num4 = long.Parse(strArray[2]) * 0x100L;
///			long num5 = long.Parse(strArray[3]);
///			return (((num2 + num3) + num4) + num5);

			IPAddress ipa;
			if (IPAddress.TryParse(ip, out ipa))
				return (
						(
							(long) ipa.GetAddressBytes()[0] << 24)
							+ ((int) ipa.GetAddressBytes()[1] << 16)
							+ ((int) ipa.GetAddressBytes()[2] << 8)
							+ ipa.GetAddressBytes()[3]
						);
			else
			{
				return 0;
			}

		}
		private static string IntToIP(long ip_Int)
		{
///			long num = (long)((ip_Int & 0xff000000L) >> 0x18);
///			if (num < 0L)
///			{
///				num += 0x100L;
///			}
///			long num2 = (ip_Int & 0xff0000L) >> 0x10;
///			if (num2 < 0L)
///			{
///				num2 += 0x100L;
///			}
///			long num3 = (ip_Int & 0xff00L) >> 8;
///			if (num3 < 0L)
///			{
///				num3 += 0x100L;
///			}
///			long num4 = ip_Int & 0xffL;
///			if (num4 < 0L)
///			{
///				num4 += 0x100L;
///			}
///			return (num.ToString() + "." + num2.ToString() + "." + num3.ToString() + "." + num4.ToString());

			return new IPAddress(ip_Int).ToString();
		}
		public IPLocation Query(string ip)
		{
///			if (!regex.Match(ip).Success)
///			{
///				throw new ArgumentException("IP格式错误");
///			}
			IPLocation ipLocation = new IPLocation()
			{
				IP = ip
			};
			long intIP = IpToInt(ip);
			if ((intIP >= IpToInt("127.0.0.1") && (intIP <= IpToInt("127.255.255.255"))))
			{
				ipLocation.Country = "本机内部环回地址";
				ipLocation.Local = "";
			}
			else
			{
				if ((((intIP >= IpToInt("0.0.0.0")) && (intIP <= IpToInt("2.255.255.255"))) || ((intIP >= IpToInt("64.0.0.0")) && (intIP <= IpToInt("126.255.255.255")))) ||
				((intIP >= IpToInt("58.0.0.0")) && (intIP <= IpToInt("60.255.255.255"))))
				{
					ipLocation.Country = "网络保留地址";
					ipLocation.Local = "";
				}
			}
			long right = ipCount;
			long left = 0L;
			long middle = 0L;
			long startIp = 0L;
			long endIpOff = 0L;
			long endIp = 0L;
			int countryFlag = 0;
			while (left < (right - 1L))
			{
				middle = (right + left) / 2L;
				startIp = GetStartIp(middle, out endIpOff);
				if (intIP == startIp)
				{
					left = middle;
					break;
				}
				if (intIP > startIp)
				{
					left = middle;
				}
				else
				{
					right = middle;
				}
			}
			startIp = GetStartIp(left, out endIpOff);
			endIp = GetEndIp(endIpOff, out countryFlag);
			if ((startIp <= intIP) && (endIp >= intIP))
			{
				string local;
				ipLocation.Country = GetCountry(endIpOff, countryFlag, out local);
				ipLocation.Local = local;
			}
			else
			{
				ipLocation.Country = "未知";
				ipLocation.Local = "";
			}
			return ipLocation;
		}
		private long GetStartIp(long left, out long endIpOff)
		{
			long leftOffset = firstStartIpOffset + (left * 7L);
			byte[] buffer = new byte[7];
			Array.Copy(data, leftOffset, buffer, 0, 7);
			endIpOff = (Convert.ToInt64(buffer[4].ToString()) + (Convert.ToInt64(buffer[5].ToString()) * 0x100L)) + ((Convert.ToInt64(buffer[6].ToString()) * 0x100L) * 0x100L);
			return ((Convert.ToInt64(buffer[0].ToString()) + (Convert.ToInt64(buffer[1].ToString()) * 0x100L)) + ((Convert.ToInt64(buffer[2].ToString()) * 0x100L) * 0x100L)) + (((Convert.ToInt64(buffer[3].ToString()) * 0x100L) * 0x100L) * 0x100L);
		}
		private long GetEndIp(long endIpOff, out int countryFlag)
		{
			byte[] buffer = new byte[5];
			Array.Copy(data, endIpOff, buffer, 0, 5);
			countryFlag = buffer[4];
			return ((Convert.ToInt64(buffer[0].ToString()) + (Convert.ToInt64(buffer[1].ToString()) * 0x100L)) + ((Convert.ToInt64(buffer[2].ToString()) * 0x100L) * 0x100L)) + (((Convert.ToInt64(buffer[3].ToString()) * 0x100L) * 0x100L) * 0x100L);
		}
		/// <summary>
		/// Gets the country.
		/// </summary>
		/// <param name="endIpOff">The end ip off.</param>
		/// <param name="countryFlag">The country flag.</param>
		/// <param name="local">The local.</param>
		/// <returns>country</returns>
		private string GetCountry(long endIpOff, int countryFlag, out string local)
		{
			string country = "";
			long offset = endIpOff + 4L;
			switch (countryFlag)
			{
				case 1:
				case 2:
					country = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);
					offset = endIpOff + 8L;
					local = (1 == countryFlag) ? "" : GetFlagStr(ref offset, ref countryFlag, ref endIpOff);
					break;
				default:
					country = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);
					local = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);
					break;
			}
			return country;
		}
		private string GetFlagStr(ref long offset, ref int countryFlag, ref long endIpOff)
		{
			int flag = 0;
			byte[] buffer = new byte[3];

			while (true)
			{
				//用于向前累加偏移量
				long forwardOffset = offset;
				flag = data[forwardOffset++];
				//没有重定向
				if (flag != 1 && flag != 2)
				{
					break;
				}
				Array.Copy(data, forwardOffset, buffer, 0, 3);
				forwardOffset += 3;
				if (flag == 2)
				{
					countryFlag = 2;
					endIpOff = offset - 4L;
				}
				offset = (Convert.ToInt64(buffer[0].ToString()) + (Convert.ToInt64(buffer[1].ToString()) * 0x100L)) + ((Convert.ToInt64(buffer[2].ToString()) * 0x100L) * 0x100L);
			}
			if (offset < 12L)
			{
				return "";
			}
			return GetStr(ref offset);
		}
		private string GetStr(ref long offset)
		{
			byte lowByte = 0;
			byte highByte = 0;
			StringBuilder stringBuilder = new StringBuilder();
			byte[] bytes = new byte[2];
			Encoding encoding = Encoding.GetEncoding("GB2312");
			while (true)
			{
				lowByte = data[offset++];
				if (lowByte == 0)
				{
					return stringBuilder.ToString();
				}
				if (lowByte > 0x7f)
				{
					highByte = data[offset++];
					bytes[0] = lowByte;
					bytes[1] = highByte;
					if (highByte == 0)
					{
						return stringBuilder.ToString();
					}
					stringBuilder.Append(encoding.GetString(bytes));
				}
				else
				{
					stringBuilder.Append((char)lowByte);
				}
			}
		}
	}
}

namespace Microshaoft.Util
{
	using System;
	using System.IO;
	using System.Net;
	using System.Web;
	using System.Web.Caching;
	using System.Collections.Generic;

	public static class CacheHelper
	{
		private static HttpContext _context;
		public static void DependencyCache
			(
				string FileName
				, string Key
				, object Value
			)
		{
			if (_context == null)
			{
				_context = HttpContext.Current;
			}
			_context.Cache.Insert(Key, Value, new CacheDependency(FileName));
		}
		public static void DependencyCache
			(
				string FileName
				, HttpContext Context
				, string Key
				, object Value
			)
		{
			_context = Context;
			DependencyCache(FileName, Key, Value);
		}
	}

	public static class IPHelper
	{
		public static long IPToLong(string IP)
		{
			IPAddress ipa;
			if (IPAddress.TryParse(IP, out ipa))
				return (
						(
							(long) ipa.GetAddressBytes()[0] << 24)
							+ ((int) ipa.GetAddressBytes()[1] << 16)
							+ ((int) ipa.GetAddressBytes()[2] << 8)
							+ ipa.GetAddressBytes()[3]
						);
			else
			{
				return 0;
			}
		}

		public static string LongToIP(long Long)
		{
			return new IPAddress(Long).ToString();
		}

		public static int FindIndex
			(
				long x
				, long[] array
			)
		{
			if (array[0] > x)
			{
				return -1;
			}
			int lowerBound = 0; //array.GetLowerBound(0);
			int length = array.Length;
			int upperBound = length - 1;
			if (array[upperBound] < x)
			{
				return upperBound;
			}
			int i = 0;
			while (lowerBound <= upperBound)
			{
				i = (lowerBound + upperBound ) / 2;
				if (array[i] <= x && i < length - 1 && array[i+1] > x)
				{
					return i;
				}
				if (array[i] < x)
				{
					lowerBound = i + 1;
				}
				else
				{
					upperBound = i - 1;
				}
			}
			if (upperBound > 0)
			{
				return length - 1;
			}
			else
			{
				return -1;
			}
		}

		public static long[] StartIPArray;
		public static long[] EndIPArray;
		public static string[] DataArray;
		public static string[] Data1Array;
		public static string[] Data2Array;

		public static List<List<string>> LoadData1
			(
				string FileName
			)
		{
			List<long> StartIPList = new List<long>();
			List<long> EndIPList = new List<long>();
			List<List<string>> dataList = new List<List<string>>();

			using(FileStream fs = new FileStream(FileName,FileMode.Open,FileAccess.Read,FileShare.Read))
			{
				StreamReader sr = new StreamReader(fs);
				string r;
				bool b = true; //is first line
				while ((r = sr.ReadLine())!= null)
				{
					string[] s = r.Split('\t');
					StartIPList.Add(Convert.ToInt64(s[1]));
					EndIPList.Add(Convert.ToInt64(s[2]));
					int k = 0;
					for(int j = 3 ; j < s.Length;j++)
					{
						
						List<string> list;
						if (b)
						{
							list = new List<string>();
							dataList.Add(list);
						}
						else
						{
							list = dataList[k];
						}
						list.Add(s[j]);
						k++;
					}
					if (b)
					{
						b = false;
					}
				}
				sr.Close();
				sr = null;
			}
			return dataList;
		}

		public static void LoadData
			(
				string FileName
			)
		{
			List<long> StartIPList = new List<long>();
			List<long> EndIPList = new List<long>();
			List<string> DataList = new List<string>();
			List<string> Data1List = new List<string>();
			List<string> Data2List = new List<string>();
			using(FileStream fs = new FileStream(FileName,FileMode.Open,FileAccess.Read,FileShare.Read))
			{
				StreamReader sr = new StreamReader(fs);
				string r;
				while ((r = sr.ReadLine())!= null)
				{
					string[] s = r.Split('\t');
					StartIPList.Add(Convert.ToInt64(s[1]));
					EndIPList.Add(Convert.ToInt64(s[2]));

					DataList.Add(s[3]);
					Data1List.Add(s[4]);
					Data2List.Add(s[5]);
				}
				sr.Close();
				sr = null;
			}
			int k = StartIPList.Count;
			StartIPArray = new long[k];
			StartIPList.CopyTo(StartIPArray);
			EndIPArray = new long[k];
			EndIPList.CopyTo(EndIPArray);
			DataArray = new string[k];
			DataList.CopyTo(DataArray);
			Data1Array = new string[k];
			Data1List.CopyTo(Data1Array);
			Data2Array = new string[k];
			Data2List.CopyTo(Data2Array);
		}
	}
}
#T=is 多态
namespace ConsoleApplication
{
	using System;
	using Share;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			IV x = new v1(); 
			if (x is IV1)
			{
				Console.WriteLine("V2");
			}
			if (x is IV)
			{
				Console.WriteLine("V");
			}
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
	public class v1 : IV1,IV
	{
		
		string _f1;
		public string F1
		{
			
				get
				{
					return _f1;
				}
				set 
				{
						_f1 = value;
				}
		}
		public void a1()
		{
			
		}
		string _f;
		public string F
		{
			
			get
			{
				return _f;
			}
			set 
			{
				_f = value;
				}
			}
			public void a()
		{
				
		}
	};
}
namespace Share
{
	public interface IV
	{
		void a();
		string F
			{
				get;
				set;
			}
	}
	public interface IV1
	{
		void a1();
		string F1
			{
				get;
				set;
			}
	}
	public interface IV2
	{
		void a1();
		string F1
			{
				get;
				set;
			}
		void a2();
		string F2
			{
				get;
				set;
			}
	}
}

#T=JScript Eval
/*
csc noname1.cs /debug /r:C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\Microsoft.JScript.dll
*/
namespace ConsoleApplication
{
	using System;

	using Microshaoft;

	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			string s = Microshaoft.Evaluator.EvalToString("var result:int =1;result==1?\"成功\":\"失败\"");

			Console.WriteLine(s);

			int i = Microshaoft.Evaluator.EvalToInteger("4*(8+2)");

			Console.WriteLine(i);
			Console.WriteLine(Environment.Version.ToString());
		}
	}

}

namespace Microshaoft
{
	using System;
	using System.CodeDom.Compiler;
	using System.Reflection;
	using Microsoft.JScript;
	public class Evaluator
	{
		public static int EvalToInteger(string statement)
		{
			string s = EvalToString(statement);
			return int.Parse(s.ToString());
		}

		public static double EvalToDouble(string statement)
		{
			string s = EvalToString(statement);
			return double.Parse(s);
		}

		public static string EvalToString(string statement)
		{
			object o = EvalToObject(statement);
			return o.ToString();
		}

		public static object EvalToObject(string statement)
		{
			return
					_evaluatorType.InvokeMember
						(
							"Eval" ,
							BindingFlags.InvokeMethod ,
							null ,
							_evaluator ,
							new object[]
								{
									statement
								}
						);
		}

		static Evaluator()
		{
			JScriptCodeProvider compiler;
			compiler = new JScriptCodeProvider();

			CompilerParameters parameters;
			parameters = new CompilerParameters();
			parameters.GenerateInMemory = true;
			
			CompilerResults results;
			results = compiler.CompileAssemblyFromSource(parameters, _jscriptSource);

			Assembly assembly = results.CompiledAssembly;
			_evaluatorType = assembly.GetType("Microshaoft.JScript.Net.Evaluator");

			_evaluator = Activator.CreateInstance(_evaluatorType);
		}

		private static object _evaluator = null;
		private static Type _evaluatorType = null;
		private static readonly string _jscriptSource =

			@"
				package Microshaoft.JScript.Net
				{
					class Evaluator
					{
						public function Eval(statement : String) : String
						{
							return eval(statement);
						}
					}
				}
			";
	}
}

#T=json JavaScriptSerializer Deserialize<dynamic>
namespace ConsoleApplication
{
	using System;
	using System.Web.Script.Serialization;
	public class Program
	{
		static void Main(string[] args)
		{
			var javaScriptSerializer = new JavaScriptSerializer();
			var jsonObject = javaScriptSerializer.Deserialize<dynamic>
									(
										@"[
											{
												user : ""张三""
												,'age': 18
												,""sex"" : ""男""
												,'猴子':'猴子后期太刁了'
											}
											,
											{
												user : ""李四""
												,'age': 18
												,""gender"" : ""男""
												,'猴子':'猴子后期太刁了'
											}
										]");
			Console.WriteLine(jsonObject[0]["sex"]);
			Console.WriteLine(jsonObject[1]["gender"]);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}

#T=json Serialize Server Side 
// .Net 3.5
namespace Test
{
	using System;
	using System.Text;
	using System.IO;
	using System.Xml;
	using Test;
	using Microshaoft;
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			JsonObject x = new JsonObject();
			string json = JsonSerializeHelper.JavaScriptSerialize<JsonObject>(x);
			Console.WriteLine(json);
			JsonObject y = JsonSerializeHelper.DataContractJsonDeserialize<JsonObject>(json); 
			Console.WriteLine(y.F1);
			jsonObject z = y.F4;
			Console.WriteLine("{0},{1},{2}",z.f2 + 10, y.F5[0].f3[1], y.F5[0].f4[0]);
		}
	}
}
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Runtime.Serialization;

	[DataContract]
	public class JsonObject
	{
		[DataMember]
		public string F1 = "AAAAA";
		[DataMember]
		public int F2 = 100;
		[DataMember]
		private string _F3 = "BBBB";

		public void Test()
		{
		}
		[DataMember]
		public jsonObject F4 = new jsonObject();
		[DataMember]
		public jsonObject[] F5 = new jsonObject[]
										{
											new jsonObject()
											, new jsonObject()
										};
	}
	[DataContract]
	public class jsonObject
	{
		[DataMember]
		public string f1 = "测试";
		[DataMember]
		public int f2 = 10;
		[DataMember]
		public string[] f3 = new string[]{"测试1","测试"};
		[DataMember]
		public List<string> f4 = new List<string>();
		
		public jsonObject()
		{
			f4.Add("测试Tyrannosaurus");
			f4.Add("Amargasaurus");
			f4.Add("Mamenchisaurus");
			f4.Add("Deinonychus");
			f4.Add("Compsognathus");
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Runtime.Serialization.Json;
	//“System.Web.Script.Serialization.JavaScriptSerializer.JavaScriptSerializer()”已过时:
	//“The recommended alternative is System.Runtime.Serialization.DataContractJsonSerializer.”
	using System.Web.Script.Serialization;
	public static class JsonSerializeHelper
	{
		public static string DataContractJsonSerialize<T>(T jsonObject)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			MemoryStream ms = new MemoryStream();
			serializer.WriteObject(ms, jsonObject);
			string json = Encoding.UTF8.GetString(ms.GetBuffer());
			ms.Close();
			ms.Dispose();
			ms = null;
			return json;
		}
		public static T DataContractJsonDeserialize<T>(string json)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
			T jto = (T) serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return jto; 
		}
		public static string JavaScriptSerialize<T>(T jsonObject)
		{
			JavaScriptSerializer serializer = new JavaScriptSerializer();
			StringBuilder sb = new StringBuilder();
			serializer.Serialize(jsonObject, sb);
			return sb.ToString();
		}
		public static T JavaScriptDeserialize<T>(string json)
		{
			return (T) new JavaScriptSerializer().Deserialize<T>(json); 
		}
	}
}

#T=JsonHelper 2014-03-31
namespace TestConsoleApplication
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using Newtonsoft.Json;
	using System.IO;
	using System.Xml;
	//using System.Threading.Tasks;
	using Microshaoft;
	using Microshaoft.Share;
	class Program
	{
		static void Main(string[] args)
		{
			var xml = @"<a>asdsad</a>";
			var json = JsonHelper.XmlToJson(xml);
			Console.WriteLine(json);
			ProcessOnce();
			Console.WriteLine("End ...");
			Console.ReadLine();
		}
		static void ProcessOnce()
		{
			var party = new Party()
			{
				PartyID = "clientID"
				 ,
				PartyInstanceID = "userID"
			};
			var loginRequestMessage = new LoginRequest()
			{
				Header = new MessageHeader()
				{
					From = party
					,
					To = new Party[] 
					{
						party
						, new Party()
						{
							 PartyID = "1111111111"
							 ,
							 PartyInstanceID = "1111111-111111111"
						}
					}
					,
					RequireResponse = 1
					,
					SendTimeStamp = DateTime.Now
					,
					Topic = "LoginRequest"
					,
					Count = 1
					,
					ID = Guid.NewGuid().ToString("N")
					,
					LinkID = null
					,
					Result = null
				}
				,
				Body = new LoginRequestBody()
				{
					Password = "password"
				}
			};
			Console.WriteLine("Json 序列化");
			var json = JsonHelper.Serialize(loginRequestMessage);
			Console.WriteLine(json);
			Console.WriteLine("Json 反序列化");
			var path = "H";
			var messageHeader = JsonHelper.DeserializeByJTokenPath<MessageHeader>(json, path);
			Console.WriteLine("JTokenPath: {0}, MessageHeader.Topic::Value: {1}", path, messageHeader.Topic);
			path = "B";
			var loginRequestBody = JsonHelper.DeserializeByJTokenPath<LoginRequestBody>(json, path);
			Console.WriteLine("JTokenPath: {0}, LoginRequestBody.Password::Value: {1}", path, loginRequestBody.Password);
			path = "H.To[1]";
			var party1 = JsonHelper.DeserializeByJTokenPath<Party>(json, path);
			Console.WriteLine("JTokenPath: {0}, Party.PartyID::Value: {1}", path, party1.PartyID);
			path = "";
			var loginRequest = JsonHelper.DeserializeByJTokenPath<LoginRequest>(json, path);
			Console.WriteLine("JTokenPath: {0}, LoginRequest.Header.ID::Value: {1}", path, loginRequest.Header.ID);
			Console.WriteLine("JTokenPath: {0}, LoginRequest.Body.Password::Value: {1}", path, loginRequest.Body.Password);
			var xml = JsonHelper.JsonToXml(json);
			Console.WriteLine(xml);
			json = JsonHelper.XmlToJson(xml);
			Console.WriteLine(json);
			//Console.ReadLine();
		}
	}
}
namespace Microshaoft.Share
{
	using Newtonsoft.Json;
	public class LoginRequest : IMessage
	{
		[JsonProperty("H")]
		public MessageHeader Header { get; set; }
		[JsonProperty("B")]
		public LoginRequestBody Body;
	}
	public class LoginRequestBody
	{
		[JsonProperty("P")]
		public string Password;
	}
	// CommonResponse
}
namespace Microshaoft.Share
{
	using Newtonsoft.Json;
	using System;
	public interface IMessage
	{
		MessageHeader Header { get; }
	}
	public class MessageHeader
	{
		// 消息主题
		[JsonProperty(PropertyName = "T")]
		public string Topic;
		// 消息号
		[JsonProperty(PropertyName = "I")]
		public string ID;
		// 关联消息号
		[JsonProperty(PropertyName = "L")]
		public string LinkID;
		// Require Response
		[JsonProperty(PropertyName = "R")]
		public int RequireResponse;
		// 发送方
		[JsonProperty(PropertyName = "F")]
		public Party From;
		// 接收方
		public Party[] To;
		// 发送时间戳
		[JsonProperty(PropertyName = "S")]
		public DateTime? SendTimeStamp;
		// 次数
		[JsonProperty(PropertyName = "C")]
		public int Count;
		// Result
		[JsonProperty(PropertyName = "V")]
		public int? Result;
	}
	public class Party
	{
		//PartyID
		[JsonProperty(PropertyName = "P")]
		public string PartyID;
		//PartyInstanceID
		[JsonProperty(PropertyName = "I")]
		public string PartyInstanceID;
	}
}
namespace Microshaoft
{
	using Newtonsoft.Json;
	using Newtonsoft.Json.Linq;
	using System;
	using System.IO;
	using System.Xml;
	public static class JsonHelper
	{
		public static string XmlToJson(string xml, bool keyQuoteName = false)
		{
			var xmlDocument = new XmlDocument();
			xmlDocument.LoadXml(xml);
			string json = string.Empty;
			using (var stringWriter = new StringWriter())
			{
				using (var jsonTextWriter = new JsonTextWriter(stringWriter))
				{
					jsonTextWriter.QuoteName = keyQuoteName;
					JsonSerializer jsonSerializer = new JsonSerializer();
					jsonSerializer.Serialize(jsonTextWriter, xmlDocument);
					json = stringWriter.ToString();
				}
			}
			return json;
		}
		public static string JsonToXml(string json, string deserializeRootElementName = "root", bool includeRoot = true)
		{
			// var s = string.Format("{{0}}", json);
			var xmlDocument = JsonConvert.DeserializeXmlNode(json, deserializeRootElementName);
			var xml = string.Empty;
			XmlNode xmlNode = null;
			if (!includeRoot)
			{
				xmlNode = xmlDocument.SelectSingleNode(deserializeRootElementName);
			}
			else
			{
				xmlNode = xmlDocument;
			}
			xml = xmlNode.InnerXml;	 
			return xml;
		}
		public static T DeserializeByJTokenPath<T>
			(
				string json
				, string jTokenPath = null //string.Empty
			)
		{
			JObject jObject = JObject.Parse(json);
			JsonSerializer jsonSerializer = new JsonSerializer();
			JToken jToken = jObject.SelectToken(jTokenPath);
			using (var jsonReader = jToken.CreateReader())
			{
				Console.WriteLine(Environment.StackTrace);
				return jsonSerializer.Deserialize<T>(jsonReader);
			}
		}
		public static string Serialize(object target, bool keyQuoteName = false)
		{
			string json = string.Empty;
			using (StringWriter stringWriter = new StringWriter())
			{
				using (JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter))
				{
					jsonTextWriter.QuoteName = keyQuoteName;
					JsonSerializer jsonSerializer = new JsonSerializer();
					jsonSerializer.Serialize(jsonTextWriter, target);
					json = stringWriter.ToString();
				}
			}
			return json;
		}
		public static void ReadJsonPathsValuesAsStrings
							(
								string json
								, string[] jsonPaths
								, Func<string, string, bool> onReadedOncePathStringValueProcesssFunc = null
							)
		{
			using (var stringReader = new StringReader(json))
			{
				using (var jsonReader = new JsonTextReader(stringReader))
				{
					bool breakAndReturn = false;
					while
						(
							jsonReader.Read()
							&& !breakAndReturn
						)
					{
						foreach (var x in jsonPaths)
						{
							if (x == jsonReader.Path)
							{
								if (onReadedOncePathStringValueProcesssFunc != null)
								{
									var s = jsonReader.ReadAsString();
									breakAndReturn = onReadedOncePathStringValueProcesssFunc
											(
												x
												, s
											);
									if (breakAndReturn)
									{
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

#T=JsonHelper with Perf Test 2014-03-31
namespace TestConsoleApplication
{
	using System;
	using System.Diagnostics;
	using System.Threading;
	using System.Threading.Tasks;
	using Microshaoft;
	using Microshaoft.Share;
	class Program
	{
		static void Main(string[] args)
		{
			int iterations = 10000;
			int maxDegreeOfParallelism = 4; // Environment.ProcessorCount;
			var performanceCountersCategoryName = "Microshaoft EasyPerformanceCounters Category";
			var performanceCountersCategoryInstanceName
					= string.Format
							(
								"{2}{0}{3}{1}{4}"
								, ": "
								, " @ "
								, ""
								, "Json Performance Test"
								, Process.GetCurrentProcess().ProcessName
							);
			//EasyPerformanceCountersHelper 调用示例
			EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
				.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, performanceCountersCategoryInstanceName
								);
			var enableCounters = MultiPerformanceCountersTypeFlags.ProcessCounter
									| MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
									| MultiPerformanceCountersTypeFlags.ProcessedCounter
									| MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter
									| MultiPerformanceCountersTypeFlags.ProcessingCounter;
			Console.WriteLine("Press any key to Begin ...");
			Console.ReadLine();
			Parallel.For
						(
							0
							, iterations
							, new ParallelOptions()
							{
								MaxDegreeOfParallelism = maxDegreeOfParallelism
							}
							, (x) =>
							{
								EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
									.CountPerformance
										(
											enableCounters
											, performanceCountersCategoryName
											, performanceCountersCategoryInstanceName
											, null
											, () =>
											{
												ProcessOnce();
											}
											, null
											, (xx) =>
											{
												//Console.WriteLine("Exception {0}", xx.ToString());
												return false;
											}
											, null
										);
							}
						);
			Console.WriteLine("End ...");
			Console.ReadLine();
		}
		static void ProcessOnce()
		{
			var party = new Party()
			{
				PartyID = "clientID"
				 ,
				PartyInstanceID = "userID"
			};
			var loginRequestMessage = new LoginRequest()
			{
				Header = new MessageHeader()
				{
					From = party
					,
					To = new Party[] 
					{
						party
						, new Party()
						{
							 PartyID = "1111111111"
							 ,
							 PartyInstanceID = "1111111-111111111"
						}
					}
					,
					RequireResponse = 1
					,
					SendTimeStamp = DateTime.Now
					,
					Topic = "LoginRequest"
					,
					Count = 1
					,
					ID = Guid.NewGuid().ToString("N")
					,
					LinkID = null
					,
					Result = null
				}
				,
				Body = new LoginRequestBody()
				{
					Password = "password"
				}
			};
			Console.WriteLine("Json 序列化");
			var json = JsonHelper.Serialize(loginRequestMessage);
			Console.WriteLine(json);
			Console.WriteLine("Json 反序列化");
			var path = "H";
			var messageHeader = JsonHelper.DeserializeByJTokenPath<MessageHeader>(json, path);
			Console.WriteLine("JTokenPath: {0}, MessageHeader.Topic::Value: {1}", path, messageHeader.Topic);
			path = "B";
			var loginRequestBody = JsonHelper.DeserializeByJTokenPath<LoginRequestBody>(json, path);
			Console.WriteLine("JTokenPath: {0}, LoginRequestBody.Password::Value: {1}", path, loginRequestBody.Password);
			path = "H.To[1]";
			var party1 = JsonHelper.DeserializeByJTokenPath<Party>(json, path);
			Console.WriteLine("JTokenPath: {0}, Party.PartyID::Value: {1}", path, party1.PartyID);
			path = "";
			var loginRequest = JsonHelper.DeserializeByJTokenPath<LoginRequest>(json, path);
			Console.WriteLine("JTokenPath: {0}, LoginRequest.Header.ID::Value: {1}", path, loginRequest.Header.ID);
			Console.WriteLine("JTokenPath: {0}, LoginRequest.Body.Password::Value: {1}", path, loginRequest.Body.Password);
			var xml = JsonHelper.JsonToXml(json);
			Console.WriteLine(xml);
			json = JsonHelper.XmlToJson(xml);
			Console.WriteLine(json);
			//Console.ReadLine();
		}
	}
}
namespace Microshaoft.Share
{
	using Newtonsoft.Json;
	public class LoginRequest : IMessage
	{
		[JsonProperty("H")]
		public MessageHeader Header { get; set; }
		[JsonProperty("B")]
		public LoginRequestBody Body;
	}
	public class LoginRequestBody
	{
		[JsonProperty("P")]
		public string Password;
	}
	// CommonResponse
}
namespace Microshaoft.Share
{
	using Newtonsoft.Json;
	using System;
	public interface IMessage
	{
		MessageHeader Header { get; }
	}
	public class MessageHeader
	{
		// 消息主题
		[JsonProperty(PropertyName = "T")]
		public string Topic;
		// 消息号
		[JsonProperty(PropertyName = "I")]
		public string ID;
		// 关联消息号
		[JsonProperty(PropertyName = "L")]
		public string LinkID;
		// Require Response
		[JsonProperty(PropertyName = "R")]
		public int RequireResponse;
		// 发送方
		[JsonProperty(PropertyName = "F")]
		public Party From;
		// 接收方
		public Party[] To;
		// 发送时间戳
		[JsonProperty(PropertyName = "S")]
		public DateTime? SendTimeStamp;
		// 次数
		[JsonProperty(PropertyName = "C")]
		public int Count;
		// Result
		[JsonProperty(PropertyName = "V")]
		public int? Result;
	}
	public class Party
	{
		//PartyID
		[JsonProperty(PropertyName = "P")]
		public string PartyID;
		//PartyInstanceID
		[JsonProperty(PropertyName = "I")]
		public string PartyInstanceID;
	}
}
namespace Microshaoft
{
	using Newtonsoft.Json;
	using Newtonsoft.Json.Linq;
	using System;
	using System.IO;
	using System.Xml;
	public static class JsonHelper
	{
		public static string XmlToJson(string xml, bool keyQuoteName = false)
		{
			var xmlDocument = new XmlDocument();
			xmlDocument.LoadXml(xml);
			string json = string.Empty;
			using (var stringWriter = new StringWriter())
			{
				using (var jsonTextWriter = new JsonTextWriter(stringWriter))
				{
					jsonTextWriter.QuoteName = keyQuoteName;
					JsonSerializer jsonSerializer = new JsonSerializer();
					jsonSerializer.Serialize(jsonTextWriter, xmlDocument);
					json = stringWriter.ToString();
				}
			}
			return json;
		}
		public static string JsonToXml(string json, string deserializeRootElementName = "root", bool includeRoot = true)
		{
		   // var s = string.Format("{{0}}", json);
			var xmlDocument = JsonConvert.DeserializeXmlNode(json, deserializeRootElementName);
			var xml = string.Empty;
			XmlNode xmlNode = null;
			if (!includeRoot)
			{
				xmlNode = xmlDocument.SelectSingleNode(deserializeRootElementName);
			}
			else
			{
				xmlNode = xmlDocument;
			}
			xml = xmlNode.InnerXml;	 
			return xml;
		}
		public static T DeserializeByJTokenPath<T>
			(
				string json
				, string jTokenPath = null //string.Empty
			)
		{
			JObject jObject = JObject.Parse(json);
			JsonSerializer jsonSerializer = new JsonSerializer();
			JToken jToken = jObject.SelectToken(jTokenPath);
			using (var jsonReader = jToken.CreateReader())
			{
				//Console.WriteLine(Environment.StackTrace);
				return jsonSerializer.Deserialize<T>(jsonReader);
			}
		}
		public static string Serialize(object target, bool keyQuoteName = false)
		{
			string json = string.Empty;
			using (StringWriter stringWriter = new StringWriter())
			{
				using (JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter))
				{
					jsonTextWriter.QuoteName = keyQuoteName;
					JsonSerializer jsonSerializer = new JsonSerializer();
					jsonSerializer.Serialize(jsonTextWriter, target);
					json = stringWriter.ToString();
				}
			}
			return json;
		}
		public static void ReadJsonPathsValuesAsStrings
							(
								string json
								, string[] jsonPaths
								, Func<string, string, bool> onReadedOncePathStringValueProcesssFunc = null
							)
		{
			using (var stringReader = new StringReader(json))
			{
				using (var jsonReader = new JsonTextReader(stringReader))
				{
					bool breakAndReturn = false;
					while
						(
							jsonReader.Read()
							&& !breakAndReturn
						)
					{
						foreach (var x in jsonPaths)
						{
							if (x == jsonReader.Path)
							{
								if (onReadedOncePathStringValueProcesssFunc != null)
								{
									var s = jsonReader.ReadAsString();
									breakAndReturn = onReadedOncePathStringValueProcesssFunc
											(
												x
												, s
											);
									if (breakAndReturn)
									{
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
#T=JsonReader JsonCovert JavaScriptSerializer
namespace Test
{
	using Microshaoft;
	using Test.Models;
	using Newtonsoft.Json;
	using System;
	using System.Web.Script.Serialization;
	class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			string json = @"{
								""Header"" :
										{
											Topic : ""Topic001""
											, 'From' : '张三'
											, To : ['李四',""jhjhj""]
										}
								, ""Body"" :
										{
											""DisplayName"" : ""杨小军""
											, ""PictureUrl"" : null
											, ""Title"" : ""总经理""
										}
							}";
			var paths = new string[]
								{
									"Header.Topic"
									, "Body"
								};
			string topic = string.Empty;
			JsonReaderHelper.ReadJsonPathsValuesAsStrings
								(
									json
									, paths
									, (x, y) =>
									{
										//if (x == paths[0])
										{
											topic = y;
										}
										return true;
									}
								);

			if (topic == "Topic001")
			{
				var javaScriptSerializer = new JavaScriptSerializer();
				//Topic001Message message = SerializerHelper.DataContractSerializerJsonToObject<Topic001Message>(json);
				Topic001Message message = javaScriptSerializer.Deserialize<Topic001Message>(json);
				Console.WriteLine(message.Header.To[0]);
				Console.WriteLine(message.Body.DisplayName);
				//转义测试
				message.Body.DisplayName = json;
				//json = SerializerHelper.DataContractSerializerObjectToJson<Topic001Message>(message);
				//Console.WriteLine("DataContractSerializerObjectToJson:{0}{1}", "\n\t", json);
				json = javaScriptSerializer.Serialize(message);
				Console.WriteLine("javaScriptSerializer.Serialize:{0}{1}", "\n\t", json);
				message = javaScriptSerializer.Deserialize<Topic001Message>(json);
				Console.WriteLine("DisplayName:: {0}", message.Body.DisplayName);
			}
			Console.WriteLine(topic);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using Newtonsoft.Json;
	using System;
	using System.IO;
	public static class JsonReaderHelper
	{
		public static void ReadJsonPathsValuesAsStrings
							(
								string json
								, string[] jsonPaths
								, Func<string, string, bool> onReadedOncePathStringValueProcesssFunc = null
							)
		{
			using (var stringReader = new StringReader(json))
			{
				using (var jsonReader = new JsonTextReader(stringReader))
				{
					bool breakAndReturn = false;
					while
						(
							jsonReader.Read()
							&& !breakAndReturn
						)
					{
						foreach (var x in jsonPaths)
						{
							if (x == jsonReader.Path)
							{
								if (onReadedOncePathStringValueProcesssFunc != null)
								{
									var s = jsonReader.ReadAsString();
									breakAndReturn = onReadedOncePathStringValueProcesssFunc
											(
												x
												, s
											);
									if (breakAndReturn)
									{
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
namespace Test.Models
{
	public class MessageHeader
	{
		public string Topic;
		public string From;
		public string[] To;
	}
	public class Topic001Message
	{
		public MessageHeader Header;
		public Topic001Body Body;
	}
	public class Topic001Body
	{
		public string DisplayName;
		public string PictureUrl;
		public string Title;
	}
}
namespace Microshaoft
{
	using System.IO;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Formatters.Binary;
	using System.Runtime.Serialization.Formatters.Soap;
	using System.Runtime.Serialization.Json;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	public static class SerializerHelper
	{
		public static T XmlSerializerXmlToObject<T>(string xml, XmlSerializer serializer = null)
		{
			StringReader stringReader = new StringReader(xml);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			if (serializer == null)
			{
				serializer = new XmlSerializer(typeof(T));
			}
			return (T)serializer.Deserialize(xmlReader);
		}
		public static string XmlSerializerObjectToXml<T>(T target, XmlSerializer serializer = null, XmlWriterSettings settings = null)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				using (XmlWriter writer = XmlTextWriter.Create(stream, settings))
				{
					if (serializer == null)
					{
						serializer = new XmlSerializer(typeof(T));
					}
					serializer.Serialize(writer, target);
					byte[] buffer = StreamDataHelper.ReadDataToBytes(stream);
					if (settings == null)
					{
						settings = writer.Settings;
					}
					var e = settings.Encoding;
					var p = e.GetPreamble().Length;
					string s = e.GetString(buffer, p, buffer.Length - p);
					writer.Close();
					return s;
				}
			}
		}
		public static string DataContractSerializerObjectToXml<T>(T target, DataContractSerializer serializer)
		{
			using (MemoryStream ms = new MemoryStream())
			{
				serializer.WriteObject(ms, target);
				byte[] buffer = StreamDataHelper.ReadDataToBytes(ms);
				string xml = Encoding.UTF8.GetString(buffer);
				ms.Close();
				return xml;
			}
		}
		public static string DataContractSerializerObjectToXml<T>(T target)
		{
			DataContractSerializer serializer = new DataContractSerializer(typeof(T));
			string xml = DataContractSerializerObjectToXml<T>(target, serializer);
			return xml;
		}
		public static T DataContractSerializerXmlToObject<T>(string xml, DataContractSerializer serializer)
		{
			byte[] buffer = Encoding.UTF8.GetBytes(xml);
			using (MemoryStream ms = new MemoryStream(buffer))
			{
				T target = (T)serializer.ReadObject(ms);
				ms.Close();
				return target;
			}
		}
		public static T DataContractSerializerXmlToObject<T>(string xml)
		{
			DataContractSerializer serializer = new DataContractSerializer(typeof(T));
			byte[] buffer = Encoding.UTF8.GetBytes(xml);
			using (MemoryStream ms = new MemoryStream(buffer))
			{
				T target = (T)serializer.ReadObject(ms);
				ms.Close();
				return target;
			}
		}
		public static string FormatterObjectToSoap<T>(T target)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				SoapFormatter formatter = new SoapFormatter();
				formatter.Serialize(stream, target);
				string soap = Encoding.UTF8.GetString(stream.GetBuffer());
				return soap;
			}
		}
		public static T FormatterSoapToObject<T>
									(
										string soap
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				SoapFormatter formater = new SoapFormatter();
				byte[] data = Encoding.UTF8.GetBytes(soap);
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T target = (T)formater.Deserialize(stream);
				return target;
			}
		}
		public static byte[] FormatterObjectToBinary<T>
									(
										T target
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				formater.Serialize(stream, target);
				byte[] buffer = stream.ToArray();
				return buffer;
			}
		}
		public static T FormatterBinaryToObject<T>
									(
										byte[] data
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T target = (T)formater.Deserialize(stream);
				return target;
			}
		}
		public static string DataContractSerializerObjectToJson<T>(T target)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			string json = DataContractSerializerObjectToJson<T>(target);
			return json;
		}
		public static string DataContractSerializerObjectToJson<T>(T target, DataContractJsonSerializer serializer)
		{
			using (MemoryStream ms = new MemoryStream())
			{
				serializer.WriteObject(ms, target);
				string json = Encoding.UTF8.GetString(ms.GetBuffer());
				ms.Close();
				return json;
			}
		}
		public static T DataContractSerializerJsonToObject<T>(string json)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			T target = DataContractSerializerJsonToObject<T>(json, serializer);
			return target;
		}
		public static T DataContractSerializerJsonToObject<T>(string json, DataContractJsonSerializer serializer)
		{
			MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
			T target = (T)serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return target;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=KeyValueNode JObject Jtoken
namespace Test
{
	using Microshaoft;
	using Newtonsoft.Json.Linq;
	using System;
	using System.Diagnostics;
	class Program
	{
		static void Main(string[] args)
		{
			var json = @"
[
	{""B"":{""I"":1111,""M"":""你好"",""O"":""Operation"",""S"":1000},""H"":{""T"":null,""RT"":null,""SEQ"":null,""RSEQ"":null,""I"":null,""L"":null,""RR"":null,""S"":null,""R"":[{""A"":""app1"",""G"":""group1"",""U"":""user1""}],""RO"":null,""ST"":null,""ET"":""2015-01-26 17:19:30.3560275+08:00"",""SC"":null,""RV"":null}}
	,
	{""B1"":{""I"":1111,""M"":""你好"",""O"":""Operation"",""S"":1000},""H"":{""T"":null,""RT"":null,""SEQ"":null,""RSEQ"":null,""I"":null,""L"":null,""RR"":null,""S"":null,""R"":[{""A"":""app1"",""G"":""group1"",""U"":""user1""},{""A"":""app1"",""G"":""group1"",""U"":""user1""}],""RO"":null,""ST"":null,""ET"":""2015-01-26 17:19:30.3560275+08:00"",""SC"":null,""RV"":null}}
]";
			json = @"{F2: [{a:""asdsad""}],F1: ""F1f1f1f1f1"",""B"":{""I"":999,""M"":""你好"",""O"":""Operation"",""S"":1000},""H"":{""T"":null,""RT"":1111111,""SEQ"":null,""RSEQ"":null,""RR"":null,""S"":null,""R"":[{""A"":""app1"",""G"":""group1"",""U"":""user1""}],""RO"":null,""ST"":null,""ET"":""2015-01-26 17:19:30.3560275+08:00"",""SC"":null,""RV"":null}}";
			json = @"
						{
							F1 : ""F1.Value"" ,
							F2 :
									{
										F2 : ""F2.F2.Value""
									} ,
							F3 :
									[
										{
											F1 : ""F3[0].F1.Value"" ,
											F2 : ""F3[0].F2.Value""
										} ,
										{
											F4 : ""F3[0].F4.Value"" ,
											F5 : ""F3[1].F5.Value""
										}
									] ,
							F4 :
									[
										""1"" ,
										""2""
									]
						}
";
			var jToken = JToken.Parse(json);
			KeyValueNode node = KeyValueNode.Create(jToken, null);
			Console.WriteLine(node["F1"]);
			Console.WriteLine(node["F2"]["F2"].Value);
			Console.WriteLine(node["F3"][0]["F1"].Value);
			Console.WriteLine(node["F3"][1]["F5"]);
			Console.WriteLine(node["F4"][1].Value);
			node["F1"].Value += " new";
			node["F2"]["F2"].Value += " new";
			node["F3"][0]["F1"].Value += " new";
			node["F3"][1]["F5"].Value += " new";
			node["F4"][1].Value += " new";
			Console.WriteLine(node["F1"]);
			Console.WriteLine(node["F2"]["F2"].Value);
			Console.WriteLine(node["F3"][0]["F1"].Value);
			Console.WriteLine(node["F3"][1]["F5"]);
			Console.WriteLine(node["F4"][1].Value);
			//node.Instance
			Console.WriteLine("==========================");
			json = node.ToJson(false);
			Console.WriteLine(json);
			json = node.ToJson();
			Console.WriteLine(json);
			//json = JsonConvert.SerializeObject(node);
			Console.WriteLine("==========================");
			var jObject = new JObject();
			jObject.Add("Entered", DateTime.Now);
			dynamic album = jObject;
			album.AlbumName = "Dirty Deeds Done Dirt Cheap";
			album.Artist = "AC/DC";
			album.YearReleased = 1976;
			album.Songs = new JArray() as dynamic;
			dynamic song = new JObject();
			song.SongName = "Dirty Deeds Done Dirt Cheap";
			song.SongLength = "4:11";
			album.Songs.Add(song);
			song = new JObject();
			song.SongName = "Love at First Feel";
			song.SongLength = "3:10";
			album.Songs.Add(song);
			node = KeyValueNode
						.Create
							(
								(JToken)album
								, null
							);
			Console.WriteLine
				(
					node["Songs"][0]["SongName"].Value
				);
			node["Songs"][0]["SongName"].Value += " new";
			json = node.ToJson(false);
			Console.WriteLine(json);
			json = node.ToJson();
			Console.WriteLine(json);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using Newtonsoft.Json;
	using Newtonsoft.Json.Linq;
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Linq;
	public abstract class KeyValueNode
	{
		public string Key
		{
			get;
			protected set;
		}
		public KeyArrayValueNode AsKeyArrayValueNode
		{
			get;
			protected set;
		}
		public KeyObjectValueNode AsKeyObjectValueNode
		{
			get;
			protected set;
		}
		public KeyValuePairNode AsKeyValuePairNode
		{
			get;
			protected set;
		}
		public ObjectValueNode AsObjectValueNode
		{
			get;
			protected set;
		}
		public KeyValueNode Parent
		{
			get;
			protected set;
		}
		protected IEnumerable<KeyValueNode> Children
		{
			get;
			set;
		}
		protected JToken Token
		{
			get;
			set;
		}
		protected bool TryGetJValue(JToken jToken, out JValue jValue)
		{
			var r = false;
			jValue = null;
			if
				(
					Token is JProperty
				)
			{
				var jProperty = ((JProperty)Token);
				if
					(
						jProperty.Value is JValue
					)
				{
					jValue = (JValue)jProperty.Value;
					r = true;
				}
			}
			else if
				(
					Token is JValue
				)
			{
				jValue = (JValue)Token;
				r = true;
			}
			return r;
		}
		public object Value
		{
			get
			{
				JValue r = null;
				if (TryGetJValue(Token, out r))
				{
					return r;
				}
				throw
					new NotSupportedException
									(
										string
											.Format
												(
													"{1}{0}{2}"
													, ":\r\n"
													, "Get Property Value From JToken"
													, Token
												)
									);
			}
			set
			{
				if (!TrySetValue(value))
				{
					throw
						new NotSupportedException
									(
										string
											.Format
												(
													"{1}{0}{2}"
													, ":\r\n"
													,
														string
															.Format
																(
																	"Set Property Value To <{0}> In JToken"
																	, value
																)
													, Token
												)
									);
				}
			}
		}
		protected bool TrySetValue
						(
							object value
						)
		{
			var r = false;
			var jToken = Token;
			if (jToken is JProperty)
			{
				var jProperty = ((JProperty)jToken);
				if
					(
						jProperty.Value is JValue
					)
				{
					jProperty.Value = new JValue(value);
					r = true;
				}
			}
			else
			{
				//数组
				jToken = Parent.Token;
				if (jToken is JProperty)
				{
					var jProperty = ((JProperty)jToken);
					if (jProperty.Value is JArray)
					{
						if (Token is JValue)
						{
							var jArray = (JArray)jProperty.Value;
							var objectValueNode = (ObjectValueNode)this;
							JValue jValue = new JValue(value);
							jArray
								[
									objectValueNode
										.IndexInArray
								] = jValue;
							Token = jValue;
						}
						else
						{
							Token = new JValue(value);
						}
						r = true;
					}
				}
			}
			return r;
		}
		public string ToJson(bool needKeyQuote = true)
		{
			if (needKeyQuote)
			{
				return
					Token
						.ToString();
			}
			else
			{
				var json = string.Empty;
				using (var stringWriter = new StringWriter())
				{
					using (var jsonTextWriter = new JsonTextWriter(stringWriter))
					{
						jsonTextWriter.QuoteName = needKeyQuote;
						var jsonSerializer = new JsonSerializer();
						jsonSerializer.Serialize(jsonTextWriter, Token);
						json = stringWriter.ToString();
					}
				}
				return json;
			}
		}
		private Dictionary<string, KeyValueNode>
							 _stringsKeysValuesDictionary
										= new Dictionary<string, KeyValueNode>();
		protected void AddKeyedValueChild
						(
							string key
							, KeyValueNode keyValueNode
						)
		{
			_stringsKeysValuesDictionary
				.Add
					(
						key
						, keyValueNode
					);
		}
		public KeyValueNode this[string key]
		{
			get
			{
				return
					_stringsKeysValuesDictionary[key];
			}
		}
		protected KeyValueNode[] NodesArray
		{
			set;
			get;
		}
		public KeyValueNode this[int index]
		{
			get
			{
				return
					NodesArray[index];
			}
		}
		public override string ToString()
		{
			string r = string.Empty;
			JValue jValue = null;
			if
				(
					TryGetJValue(Token, out jValue)
				)
			{
				r = jValue
						.Value
						.ToString();
			}
			else
			{
				r = base.ToString();
			}
			return r;
		}
		public static KeyValueNode Create
										(
											JToken jToken
											, KeyValueNode parent
											, int IndexInArray = -1
										)
		{
			if (jToken is JValue)
			{
				return
					new ObjectValueNode
							(
								jToken
								, ((JValue)jToken).Value
								, parent
								, IndexInArray
							);
			}
			else if (jToken is JProperty)
			{
				JProperty jProperty = (JProperty)jToken;
				if (jProperty.Value is JValue)
				{
					var keyValuePairNode
							= new KeyValuePairNode
									(
										jToken
										, jProperty.Name
										,
											(
												(JValue)jProperty.Value
											).Value
										, parent
									);
					if (parent != null)
					{
						parent
							.AddKeyedValueChild
								(
									jProperty.Name
									, keyValuePairNode
								);
					}
					return keyValuePairNode;
				}
				else if (jProperty.Value is JArray)
				{
					var keyArrayNode
							= new KeyArrayValueNode
									(
										jToken
										, jProperty.Name
										, parent
									);
					if (parent != null)
					{
						parent
							.AddKeyedValueChild
								(
									jProperty.Name
									, keyArrayNode
								);
					}
					int i = 0;
					keyArrayNode
						.Children
								=
									(
										(JArray)jProperty.Value
									)
									.Children()
									.Select
										(
											(x) =>
											{
												var r = Create
															(
																x
																, keyArrayNode
																, i
															);
												i++;
												return r;
											}
										);
					keyArrayNode
						.NodesArray = keyArrayNode
											.Children
											.ToArray();
					return
						keyArrayNode;
				}
				else if (jProperty.Value is JObject)
				{
					var keyObjectNode
								= new KeyObjectValueNode
											(
												jToken
												, jProperty.Name
												, parent
											);
					if (parent != null)
					{
						parent
							.AddKeyedValueChild
								(
									jProperty.Name
									, keyObjectNode
								);
					}
					keyObjectNode
						.Children =
									(
										(JObject)jProperty.Value
									)
									.Children()
									.Select
										(
											(x) =>
											{
												var r = Create
															(
																x
																, keyObjectNode
															);
												return r;
											}
										);
					keyObjectNode
							.Children
							.ToList();
					return
						keyObjectNode;
				}
				else
				{
					throw
						new NotSupportedException
									(
										string
											.Format
												(
													"{1}{0}{2}"
													, ":\r\n"
													, "JProperty"
													, jProperty
												)
									);
				}
			}
			else if (jToken is JArray)
			{
				var keyArrayValueNode
								= new KeyArrayValueNode
												(
													jToken
													, null
													, parent
												);
				keyArrayValueNode
					.Children =
								(
									(JArray)jToken
								)
								.Children()
								.Select
									(
										(x) =>
										{
											var r = Create
														(
															x
															, keyArrayValueNode
														);
											return r;
										}
									);
				keyArrayValueNode
						.Children
						.ToList();
				return
					keyArrayValueNode;
			}
			else if (jToken is JObject)
			{
				var keyObjectValueNode
								= new KeyObjectValueNode
												(
													jToken
													, null
													, parent
												);
				keyObjectValueNode
						.Children =
									(
										(JObject)jToken
									)
									.Children()
									.Select
										(
											(x) =>
											{
												var r = Create
															(
																x
																, keyObjectValueNode
															);
												return r;
											}
										);
				keyObjectValueNode
						.Children
						.ToList();
				return keyObjectValueNode;
			}
			else
			{
				throw
					new NotSupportedException
							(
								string
									.Format
										(
											"{1}{0}{2}"
											, ":\r\n"
											, "JToken"
											, jToken
										)
							);
			}
		}
	}
	public enum ObjectValueNodeType
	{
		KeyedObjectValueNode
		, ArrayElementValueNode
	}
	public class ObjectValueNode : KeyValueNode
	{
		public ObjectValueNodeType ValueNodeType
		{
			get;
			private set;
		}
		public int IndexInArray
		{
			get;
			private set;
		}
		public ObjectValueNode
					(
						JToken jToken
						, object value
						, KeyValueNode parent
						, int indexInArray = -1
					)
		{
			AsObjectValueNode = this;
			Parent = parent;
			Token = jToken;
			IndexInArray = indexInArray;
		}
		public override string ToString()
		{
			return
				(Value != null ? Value.ToString() : "<null>");
		}
	}
	public class KeyValuePairNode : KeyValueNode
	{
		public KeyValuePairNode
					(
						JToken jToken
						, string key
						, object value
						, KeyValueNode parent
					)
		{
			AsKeyValuePairNode = this;
			Parent = parent;
			Token = jToken;
			Key = key;
			Value = value;
		}
	}
	public class KeyArrayValueNode : KeyValueNode
	{
		public KeyArrayValueNode
					(
						JToken jToken
						, string key
						, KeyValueNode parent
					)
		{
			AsKeyArrayValueNode = this;
			Parent = parent;
			Token = jToken;
			Key = key;
		}
	}
	public class KeyObjectValueNode : KeyValueNode
	{
		public KeyObjectValueNode
						(
							JToken jToken
							, string key
							, KeyValueNode parent
						)
		{
			AsKeyObjectValueNode = this;
			Parent = parent;
			Token = jToken;
			Key = key;
		}
	}
}

#T=KMP BM(BoyerMoore) 字符串匹配
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Collections;
	using System.Linq;
	using System.Text;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			TimeSpan ts1 = new TimeSpan(DateTime.Now.Ticks);
			Console.WriteLine
				(
					KmpHelper.Arithmetic_KMP
								(
									"ddddddddddddddABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAddABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkBBC ABCDAB ABCDABCDABDE"
									, "ABCDABD"
								)
				);
			TimeSpan ts2 = new TimeSpan(DateTime.Now.Ticks);
			TimeSpan ts = ts2.Subtract(ts1).Duration();
			Console.WriteLine(ts.TotalSeconds.ToString());
			Console.WriteLine("\r\n");
			TimeSpan ts3 = new TimeSpan(DateTime.Now.Ticks);
			Console.WriteLine(KmpHelper.KmpIndexOf("ddddddddddddddABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABCDAABkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkBBC ABCDAB ABCDABCDABDE", "ABCDABD"));
			TimeSpan ts4 = new TimeSpan(DateTime.Now.Ticks);
			TimeSpan ts5 = ts4.Subtract(ts3).Duration();
			Console.WriteLine(ts5.TotalSeconds.ToString());
			Console.WriteLine("\r\n");
			IList<int> result = new List<int>();
			KmpHelper.Search("BBC ABCDAB ABCDABCDABDEEFZGEABCDABDTABCDABDEABCDABDE", "ABCDABD", result);
			foreach (var item in result)
			{
				Console.WriteLine(item + "\r\n");
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Collections;
	using System.Linq;
	using System.Text;
	public static class KmpHelper
	{
		/// <summary>
		/// 尾递归查询出 字符串出现的所有开始索引
		/// </summary>
		/// <param name="str1">操作字符串</param>
		/// <param name="str2">要查找的字符串</param>
		/// <param name="indexs">位置索引 集合</param>
		public static void Search(string str1, string str2, IList<int> indexs)
		{
			int index = Arithmetic_KMP(str1, str2);
			int temp = index;
			if (indexs.Count > 0)
			{
				index += indexs[indexs.Count - 1] + str2.Length;
			}
			indexs.Add(index);
			if (temp + (str2.Length - 1) * 2 <= str1.Length)
			{
				Search(str1.Substring(temp + str2.Length), str2, indexs);
			}
		}
		/// <summary>
		/// KMP算法查找字符串
		/// </summary>
		/// <param name="operateStr">操作字符串</param>
		/// <param name="findStr">要查找的字符串</param>
		/// <returns>字符串第一次出现的位置索引</returns>
		public static int Arithmetic_KMP(string operateStr, string findStr)
		{
			int index = -1;   //正确匹配的开始索引
			int[] tableValue = GetPartialMatchTable(findStr);
			int i = 0, j = 0; //操作字符串和匹配字符串 索引迭代
			while (i < operateStr.Length && j < findStr.Length)
			{
				if (operateStr[i] == findStr[j]) //当第一个字符匹配上，接着匹配第二、、、
				{
					if (j == 0) index = i;	   //记录第一个匹配字符的索引
					j++;
					i++;
				}
				else  //当没有匹配上的时候
				{
					if (j == 0) //如果第一个字符就没匹配上
					{
						i += j + 1 - tableValue[j]; //移动位数 =已匹配的字符数 - 对应的部分匹配值
					}
					else
					{
						i = index + j - tableValue[j - 1]; //如果已匹配的字符数不为零，则重新定义i迭代
					}
					j = 0; //将已匹配迭代置为0
				}
			}
			return index;
		}
		/// <summary>
		/// 产生 部分匹配表
		/// </summary>
		/// <param name="str">要查找匹配的字符串</param>
		/// <returns></returns>
		public static int[] GetPartialMatchTable(string str)
		{
			string[] left, right; //前缀、后缀
			int[] result = new int[str.Length]; //保存 部分匹配表
			for (int i = 0; i < str.Length; i++)
			{
				left = new string[i]; //实例化前缀 容器
				right = new string[i]; //实例化后缀容器
				//前缀
				for (int j = 0; j < i; j++)
				{
					if (j == 0)
						left[j] = str[j].ToString();
					else
						left[j] = left[j - 1] + str[j].ToString();
				}
				//后缀
				for (int k = i; k > 0; k--)
				{
					if (k == i)
						right[k - 1] = str[k].ToString();
					else
						right[k - 1] = str[k].ToString() + right[k];
				}
				//找到前缀和后缀中相同的项，长度即为相等项的长度（相等项应该只有一项）
				int num = left.Length - 1;
				for (int m = 0; m < left.Length; m++)
				{
					if (right[num] == left[m])
					{
						result[i] = left[m].Length;
					}
					num--;
				}
			}
			return result;
		}

		public static int KmpIndexOf(string s, string t)
		{
			int i = 0, j = 0, v;
			int[] nextVal = GetNextVal(t);
			while (i < s.Length && j < t.Length)
			{
				if (j == -1 || s[i] == t[j])
				{
					i++;
					j++;
				}
				else
				{
					j = nextVal[j];
				}
			}
			if (j >= t.Length)
				v = i - t.Length;
			else
				v = -1;
			return v;
		}

		private static int[] GetNextVal(string t)
		{
			int j = 0, k = -1;
			int[] nextVal = new int[t.Length];
			nextVal[0] = -1;
			while (j < t.Length - 1)
			{
				if (k == -1 || t[j] == t[k])
				{
					j++;
					k++;
					if (t[j] != t[k])
					{
						nextVal[j] = k;
					}
					else
					{
						nextVal[j] = nextVal[k];
					}
				}
				else
				{
					k = nextVal[k];
				}
			}
			return nextVal;
		}
		/// <summary>
		/// BM算法
		/// </summary>
		/// <param name="source"></param>
		/// <param name="subString"></param>
		/// <returns></returns>
		static int BoyerMooreSearch(string source, string subString)
		{
			if(string.IsNullOrWhiteSpace(source) || string.IsNullOrWhiteSpace(subString))
			{
				return - 1;
			}
			int i = 0, j, sLen = subString.Length;
			while (i < sLen)
			{
				j = 0;
				while (j < sLen && source[i] == subString[j])
				{
					i++;
					j++;
				}
				if (j == sLen)
				{
					return i - sLen;
				}
				i = i - j + 1;
			}
			return -1;
		}
	}
}

#T=lambda 动态属性访问 vs 反射
namespace Microshaoft
{
	using System;
	using System.Reflection;
	using System.Linq.Expressions;
	public class DynamicPropertyAccessor
	{
		private Func<object, object> m_getter;
		public DynamicPropertyAccessor(Type type, string propertyName)
			: this(type.GetProperty(propertyName))
		{
		}

		public DynamicPropertyAccessor(PropertyInfo propertyInfo)
		{
			// target: (object)((({TargetType})instance).{Property})

			// preparing parameter, object type
			ParameterExpression instance = Expression.Parameter
															(
																typeof(object),
																"instance"
															);

			// ({TargetType})instance
			Expression instanceCast = Expression.Convert
													(
														instance, propertyInfo.ReflectedType
													);

			// (({TargetType})instance).{Property}
			Expression propertyAccess = Expression.Property
														(
															instanceCast, propertyInfo
														);

			// (object)((({TargetType})instance).{Property})
			UnaryExpression castPropertyValue = Expression.Convert
																(
																	propertyAccess,
																	typeof(object)
																);

			// Lambda expression
			Expression<Func<object, object>> lambda = Expression.Lambda<Func<object, object>>
																					(
																						castPropertyValue, instance
																					);

			this.m_getter = lambda.Compile();
		}

		public object GetValue(object o)
		{
			return this.m_getter(o);
		}
	}

}
namespace ConsoleApplication
{
	using System;
	using System.Diagnostics;
	using System.Reflection;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			var t = new { Amount = 108, Value = "Hello" };


			PropertyInfo propertyInfo = t.GetType().GetProperty("Value");
			Stopwatch watch1 = new Stopwatch();
			watch1.Start();
			for (var i = 0; i < 1000000; i ++)
			{
				var value = propertyInfo.GetValue(t, null);
			}
			watch1.Stop();
			Console.WriteLine("Reflection: " + watch1.Elapsed);

			DynamicPropertyAccessor property = new DynamicPropertyAccessor(t.GetType(), "Value");
			Stopwatch watch2 = new Stopwatch();
			watch2.Start();
			for (var i = 0; i < 1000000; i++)
			{
				var value = property.GetValue(t);
			}
			watch2.Stop();
			Console.WriteLine("Lambda: " + watch2.Elapsed);

			Stopwatch watch3 = new Stopwatch();
			watch3.Start();
			for (var i = 0; i < 1000000; i++)
			{
				var value = t.Value;
			}
			watch3.Stop();
			Console.WriteLine("Direct: " + watch3.Elapsed);
		}
	}

}
#T=lambda、匿名方法、匿名函数、委托
/*
		C# 委托的发展史: .Net 1.x 委托 =>.Net 2.x 匿名方法 => .Net 3.0/3.5 Lambda 表达式
	ms-help://MS.MSDNQTR.v90.chs/dv_csref/html/6ce3f04d-0c71-4728-9127-634c7e9a8365.htm
	在 C# 1.0 中,您通过使用在代码中其他位置定义的方法显式初始化委托来创建委托的实例。
	C# 2.0 引入了匿名方法的概念,作为一种编写可在委托调用中执行的未命名内联语句块的方式。
	C# 3.0 引入了 Lambda 表达式,这种表达式与匿名方法的概念类似,但更具表现力并且更简练。
	这两个功能统称为“匿名函数”。通常,针对 .NET Framework 版本 3.5 及更高版本的应用程序应使用 Lambda 表达式。
	下面的示例演示了从 C# 1.0 到 C# 3.0 委托创建过程的发展:
*/
namespace Microshaoft
{
	using System;
	class Test
	{
		//c# 1.0
		delegate void TestDelegate(string s);
		static void M(string s)
		{
			Console.WriteLine(s);
		}

		static void Main(string[] args)
		{
			// Original delegate syntax required 
			// initialization with a named method.
			TestDelegate testdelA = new TestDelegate(M);

			// C# 2.0: A delegate can be initialized with
			// inline code, called an "anonymous method." This
			// method takes a string as an input parameter.
			TestDelegate testDelB = delegate
										(
											string s //参数
										)
									//匿名函数
									{
										Console.WriteLine(s);
									};

			// C# 3.0. A delegate can be initialized with
			// a lambda expression. The lambda also takes a string
			// as an input parameter (x). The type of x is inferred by the compiler.
			TestDelegate testDelC =
									(x) //参数
										=>
											//匿名函数
											{
												Console.WriteLine(x);
											};

			// Invoke the delegates.
			testdelA("Hello. My name is M and I write lines.");
			testDelB("That's nothing. I'm anonymous and ");
			testDelC("I'm a famous author.");

			// Keep console window open in debug mode.
			Console.WriteLine("Press any key to exit.");
			Console.ReadKey();
		}
	}
	/* Output:
		Hello. My name is M and I write lines.
		That's nothing. I'm anonymous and
		I'm a famous author.
		Press any key to exit.
	*/
}
#T=Lambda表达式 Func委托 Linq
using System;
using System.Collections.Generic;
using System.Linq;

public class Func3Example
{
	public static void Main()
	{
		Func<string, int, bool> predicate = (str, index) => str.Length == index;

		string[] words =
						{
							"orange"
							, "apple"
							, "Article"
							, "elephant"
							, "stara"
							, "andaa"
						};
		IEnumerable<string> aWords = words.Where(predicate).Select(str => str);

		foreach (string word in aWords)
		{
			Console.WriteLine(word);
		}
	}
}
#T=Lazy<T>
using System;
class Program
{
	static void Main(string[] args)
	{
		Lazy<Large> lazyObject = new Lazy<Large>();
		Console.WriteLine(lazyObject.Value==null);
		Console.WriteLine(lazyObject.Value.GetType());
		Console.WriteLine(lazyObject.Value==null);
		Console.WriteLine(lazyObject.IsValueCreated); 
		lazyObject.Value.Test();
		Console.WriteLine(lazyObject.IsValueCreated);
	}
}
[Serializable]
class Large
{
	private string _x;
	public Large()
	{
		//_x = x;
	}
	public void Test()
	{
		Console.WriteLine(_x);
	}
}
#T=LD 算法Text 相似度Compare
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			//TextCompareLD x = new TextCompareLD();
			int i = TextCompareLD.LD("aa", "bba");
			Console.WriteLine(i);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	//文本相似度 LD算法
	public class TextCompareLD
	{
		// Fields
		private static char[] mA;
		private static char[] mB;
		// Methods
		public static int LD(string A, string B)
		{
			int num;
			mA = A.ToCharArray();
			mB = B.ToCharArray();
			int[,] numArray = new int[A.Length + 1, B.Length + 1];
			int length = A.Length;
			for (num = 1; num <= length; num++)
			{
				numArray[num, 0] = num;
			}
			int num5 = B.Length;
			int num2 = 1;
			while (num2 <= num5)
			{
				numArray[0, num2] = num2;
				num2++;
			}
			int num6 = A.Length;
			for (num = 1; num <= num6; num++)
			{
				int num7 = B.Length;
				for (num2 = 1; num2 <= num7; num2++)
				{
					if (mA[num - 1] == mB[num2 - 1])
					{
						numArray[num, num2] = numArray[num - 1, num2 - 1];
					}
					else
					{
						numArray[num, num2] = Min(numArray[num - 1, num2 - 1], numArray[num - 1, num2], numArray[num, num2 - 1]) + 1;
					}
				}
			}
			return numArray[A.Length, B.Length];
		}
		public static int Min(int A, int B, int C)
		{
			int num = A;
			if (num > B)
			{
				num = B;
			}
			if (num > C)
			{
				num = C;
			}
			return num;
		}
	}
}

#T=Linq QueryProvider
namespace Test
{
	using Microshaoft.Linq;
	using System.Linq;
	class Program
	{
		static void Main(string[] args)
		{
			Query<int> ss = new Query<int>(new QueryProvider());
			var t =
					from
						item
							in ss
					where
						item == 123
					select
						item;
			int a = t.FirstOrDefault();
		}
	}
}
namespace Microshaoft.Linq
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public class QueryProvider : IQueryProvider
	{
		public void AnalysisExpression(Expression exp)
		{
			switch (exp.NodeType)
			{
				case ExpressionType.Call:
					{
						MethodCallExpression mce = exp as MethodCallExpression;
						Console.WriteLine("The Method Is {0}", mce.Method.Name);
						for (int i = 0; i < mce.Arguments.Count; i++)
						{
							AnalysisExpression(mce.Arguments[i]);
						}
					}
					break;
				case ExpressionType.Quote:
					{
						UnaryExpression ue = exp as UnaryExpression;
						AnalysisExpression(ue.Operand);
					}
					break;
				case ExpressionType.Lambda:
					{
						LambdaExpression le = exp as LambdaExpression;
						AnalysisExpression(le.Body);
					}
					break;
				case ExpressionType.Equal:
					{
						BinaryExpression be = exp as BinaryExpression;
						Console.WriteLine("The Method Is {0}", exp.NodeType.ToString());
						AnalysisExpression(be.Left);
						AnalysisExpression(be.Right);
					}
					break;
				case ExpressionType.Constant:
					{
						ConstantExpression ce = exp as ConstantExpression;
						Console.WriteLine("The Value Type Is {0}", ce.Value.ToString());
					}
					break;
				case ExpressionType.Parameter:
					{
						ParameterExpression pe = exp as ParameterExpression;
						Console.WriteLine("The Parameter Is {0}", pe.Name);
					}
					break;
				default:
					{
						Console.Write("UnKnow");
					}
					break;
			}
		}
		IQueryable<S> IQueryProvider.CreateQuery<S>(Expression expression)
		{
			AnalysisExpression(expression);
			return new Query<S>(this, expression);
		}
		IQueryable IQueryProvider.CreateQuery(Expression expression)
		{
			Type elementType = expression.Type;
			try
			{
				return
					(IQueryable)Activator
									.CreateInstance
										(
											typeof(Query<>)
												.MakeGenericType(elementType)
											, new object[]
												{
													this, expression
												}
										);
			}
			catch (TargetInvocationException tie)
			{
				throw tie.InnerException;
			}
		}
		S IQueryProvider.Execute<S>(Expression expression)
		{
			return (S)Execute(expression);
		}
		object IQueryProvider.Execute(Expression expression)
		{
			return Execute(expression);
		}
		public object Execute(Expression expression)
		{
			return 123;
		}
	}
	public class Query<T> : IQueryable<T>
	{
		QueryProvider _queryProvider;
		Expression _expression;
		public Query(QueryProvider provider)
		{
			if (provider == null)
			{
				throw new ArgumentNullException("provider");
			}
			_queryProvider = provider;
			_expression = Expression.Constant(this);
		}
		public Query(QueryProvider provider, Expression expression)
		{
			_queryProvider = provider;
			_expression = expression;
		}
		Expression IQueryable.Expression
		{
			get { return _expression; }
		}
		Type IQueryable.ElementType
		{
			get { return typeof(T); }
		}
		IQueryProvider IQueryable.Provider
		{
			get { return _queryProvider; }
		}
		public IEnumerator<T> GetEnumerator()
		{
			return
				(
					(IEnumerable<T>) _queryProvider
										.Execute(_expression)
				).GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return
				(
					(IEnumerable) _queryProvider
									.Execute(_expression)
				).GetEnumerator();
		}
	}
}

#T=Linq Reflector
//Copyright (C) Microsoft Corporation.  All rights reserved.


// The Reflector component generates a HTML document outlining the public API
// for a given assembly. The task is achieved in two phases. First, a XML 
// document is emitted in memory (see Emit*()). The document captures the 
// relevant aspects of the assembly's metadata. In the second phase, a HTML
// document is extracted from the XML document (see Extract*()). Note that the 
// two phases handle similar information with different representations using 
// the same query constructs.

//Copyright (C) Microsoft Corporation.  All rights reserved.


// See the ReadMe.html for additional information
namespace Samples
{
	using System;
	using System.Diagnostics;
	using System.IO;
	using System.Xml;
	using System.Reflection;
	using System.Xml.Linq;

	public static class Program
	{
		const string HtmlFile = "System.Xml.Linq.html";
		
		public static void Main()
		{
			// Get Path and Name of assembly to reflect
			XDocument attr = new XDocument();
			Assembly assembly = Assembly.GetAssembly(attr.GetType());
			String AssemblyFile = assembly.CodeBase;
			AssemblyFile = @"C:\Documents and Settings\v-xiyu\桌面\Noname1.exe";
			Console.WriteLine(AssemblyFile);
			// reflect over the assembly
			Reflector reflector = new Reflector();
			reflector.Reflect(AssemblyFile);
			
			// generate the HTML document
			XmlWriterSettings settings = new XmlWriterSettings();
			settings.OmitXmlDeclaration = true;
			settings.Indent = true;
			XmlWriter writer = XmlWriter.Create(HtmlFile, settings);
			reflector.Transform(writer);
			writer.Close();
		
			// display the HTML document
			FileInfo fileInfo = new FileInfo(HtmlFile);
			if (fileInfo.Exists) Process.Start("iexplore.exe", fileInfo.FullName);
		}
	}
}

namespace Samples
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Linq;
	using System.Reflection;
	using System.Runtime.CompilerServices;
	using System.Text;
	using System.Xml;
	using System.Xml.Linq;

	public class Reflector
	{
		public XDocument document;
		
		public Reflector() 
		{
		}
		
		public void Reflect(string assemblyFile)
		{
			Assembly assembly = Assembly.LoadFrom(assemblyFile);
			document = new XDocument(EmitAssembly(assembly));
		}

		public void Transform(XmlWriter writer) 
		{
			if (document == null) return;
			XElement assembly = document.Element("assembly");
			XDocument transform = new XDocument(ExtractAssembly(assembly));
			transform.Save(writer);
		}

		XElement EmitAssembly(Assembly assembly) 
		{
			return new XElement("assembly",
						new XAttribute("name", assembly.ManifestModule.Name),
						from type in assembly.GetTypes()
						where GetVisible(type)
						group type by GetNamespace(type) into g
						orderby g.Key
						select EmitNamespace(g.Key, g));
		}
		
		XElement EmitNamespace(string ns, IEnumerable<Type> types)
		{
			return new XElement("namespace",
						new XAttribute("name", ns),
						from type in types
						orderby type.Name
						select EmitType(type));
		}
		
		XElement EmitType(Type type)
		{
			return new XElement(type.IsEnum ? "enum" : 
								type.IsValueType ? "struct" :
								type.IsInterface ? "interface" :
								"class",
						new XAttribute("name", type.Name),
						!type.IsGenericTypeDefinition ? null : 
						EmitGenericArguments(type.GetGenericArguments()),
						EmitModifiers(type),
						EmitExtends(type.BaseType),
						EmitImplements(type.GetInterfaces()),
						EmitDeclaringType(type.DeclaringType),
						EmitNestedTypes(type.GetNestedTypes()),
						EmitMethods(type.GetConstructors()),
						EmitProperties(type.GetProperties()),
						EmitMethods(type.GetMethods()));
		}

		IEnumerable<XElement> EmitGenericArguments(IEnumerable<Type> args)
		{
			return from arg in args
					select new XElement("genericArgument", EmitReference(arg));
		}
		
		static XElement EmitModifiers(Type type)
		{
			StringBuilder builder = new StringBuilder();
			if (type.IsPublic) builder.Append("public");
			else if (type.IsNestedPublic) builder.Append("public");
			else if (type.IsNestedFamily) builder.Append("protected");
			else if (type.IsNestedFamANDAssem) builder.Append("protected internal");
			if (type.IsSealed) builder.Append(" sealed");
			if (type.IsAbstract) builder.Append(" abstract");
			return new XElement("modifiers", builder.ToString());
		}
		
		XElement EmitExtends(Type baseType) 
		{
			if (baseType == null || baseType == typeof(Object) || baseType == typeof(ValueType) || baseType == typeof(Enum)) return null;
			return new XElement("extends", EmitReference(baseType));
		}
		
		IEnumerable<XElement> EmitImplements(IEnumerable<Type> ifaces)
		{
			return from iface in ifaces
					select new XElement("implements", EmitReference(iface));
		}
		
		XElement EmitDeclaringType(Type declaringType)
		{
			if (declaringType == null) return null;
			return new XElement("declaringType", EmitReference(declaringType));
		}
		
		IEnumerable<XElement> EmitNestedTypes(IEnumerable<Type> ntypes)
		{
			return from ntype in ntypes
					where GetVisible(ntype)
					select EmitType(ntype);
		}
		
		IEnumerable<XElement> EmitMethods(IEnumerable<MethodBase> metds)
		{
			return from metd in metds
					where GetVisible(metd)
					select new XElement("method",								
								new XAttribute("name", metd.Name),
								!metd.IsGenericMethodDefinition ? null :
								EmitGenericArguments(metd.GetGenericArguments()),
								EmitModifiers(metd),
								EmitReturnType(metd),
								!metd.IsDefined(typeof(ExtensionAttribute), true) ? null :
								EmitExtension(metd),
								EmitParameters(metd.GetParameters()));								
		}
		
		IEnumerable<XElement> EmitProperties(IEnumerable<PropertyInfo> props)
		{
			return from prop in props
					where GetVisible(prop.GetGetMethod()) ||
						 GetVisible(prop.GetSetMethod())
					select new XElement("property",							
								new XAttribute("name", prop.Name),
								new XElement("propertyType", EmitReference(prop.PropertyType)));
		}

		IEnumerable<object> EmitReference(Type type)
		{
			if (!type.IsGenericType) 
			{
				return new object[] { new XAttribute("name", type.Name),
									  new XAttribute("namespace", GetNamespace(type)) };			
			}
			else
			{
				return new object[] { new XAttribute("name", type.Name),
									  new XAttribute("namespace", GetNamespace(type)),
									  EmitGenericArguments(type.GetGenericArguments()) };
			}
		}

		static XElement EmitModifiers(MethodBase metd)
		{
			StringBuilder builder = new StringBuilder();			
			if (metd.IsPublic) builder.Append("public");
			else if (metd.IsFamily) builder.Append("protected");
			else if (metd.IsFamilyAndAssembly) builder.Append("protected internal");
			if (metd.IsAbstract) builder.Append(" abstract");
			if (metd.IsStatic) builder.Append(" static");
			if (metd.IsVirtual) builder.Append(" virtual");
			return new XElement("modifiers", builder.ToString());
		}

		XElement EmitReturnType(MethodBase metd)
		{  
			MethodInfo metdInfo = metd as MethodInfo;
			if (metdInfo == null) return null;
			return new XElement("returnType", EmitReference(metdInfo.ReturnType));
		}

		static XElement EmitExtension(MethodBase metd)
		{
			return new XElement("extension");
		}
		
		IEnumerable<XElement> EmitParameters(IEnumerable<ParameterInfo> parms)
		{
			return from parm in parms
					select new XElement("parameter",
								new XAttribute("name", parm.Name),
								new XElement("parameterType", EmitReference(parm.ParameterType)));
		}												
		
		static string GetNamespace(Type type)
		{
			string ns = type.Namespace;
			return ns != null ? ns : string.Empty;
		}		

		static bool GetVisible(Type type)
		{
			return type.IsPublic || type.IsNestedPublic || type.IsNestedFamily || type.IsNestedFamANDAssem;
		}
		
		static bool GetVisible(MethodBase metd)
		{
			return metd != null && (metd.IsPublic || metd.IsFamily || metd.IsFamilyAndAssembly);
		}
		
		XElement ExtractAssembly(XElement assembly)
		{
			return new XElement("html",
						new XElement("head",
							new XElement("title", ExtractName(assembly))),
						new XElement("body",
							new XElement("div", 
								new XElement("h1", "Assembly: ",ExtractName(assembly)),
								from ns in assembly.Elements("namespace") 
								select ExtractNamespace(ns))));									
		}

		XElement ExtractNamespace(XElement ns)
		{
			return new XElement("div",
						new XElement("h2", "Namespace: ", ExtractName(ns)),
						from name in new string[] { "class", "interface", "struct", "enum" }
						where ns.Elements(name).Any()
						select from type in ns.Elements(name)
								where !type.Elements("declaringType").Any()
								select ExtractType(type));
		}

		XElement ExtractType(XElement type) 
		{
			return new XElement("div",
						new XElement("h3",
							ExtractModifiers(type) + " ",
							type.Name + " ",
							ExtractReference(type),					
							ExtractInherits(type)),
						ExtractConstructors(type),
						ExtractProperties(type),
						ExtractOperators(type),
						ExtractMethods(type));
		}

		static string ExtractModifiers(XElement element)
		{
			return element.Element("modifiers").Value;
		}

		static string ExtractName(XElement element)
		{
			string name = element.Attribute("name").Value;
			int i = name.LastIndexOf("`", StringComparison.Ordinal);
			if (i > 0) name = name.Substring(0, i); // fix generic name
			return name;
		}						

		string ExtractGenericArguments(XElement element)
		{
			if (!element.Elements("genericArgument").Any()) return string.Empty;
			StringBuilder builder = new StringBuilder("<");
			foreach (XElement genericArgument in element.Elements("genericArgument"))
			{
				if (builder.Length != 1) builder.Append(", ");
				builder.Append(ExtractReference(genericArgument));
			}
			builder.Append(">");
			return builder.ToString();
		}

		string ExtractReference(XElement element)
		{
			return ExtractName(element) + ExtractGenericArguments(element);
		}
				
		string ExtractInherits(XElement type)
		{
			if (!type.Elements("extends").Concat(type.Elements("implements")).Any()) return string.Empty;
			StringBuilder builder = new StringBuilder();
			foreach (XElement inherits in type.Elements("extends").Concat(type.Elements("implements")))
			{
				if (builder.Length == 0) builder.Append(" : ");
				else builder.Append(", ");
				builder.Append(ExtractReference(inherits));
			}
			return builder.ToString();
		}

		XElement ExtractConstructors(XElement type)
		{
			var ctors = from ctor in type.Elements("method")
						where ExtractName(ctor) == ".ctor"
						select new XElement("li",
									ExtractModifiers(ctor) + " ",
									ExtractName(type),
									ExtractParameters(ctor));
			if (!ctors.Any()) return null;									
			return new XElement("div", 
						new XElement("h4", "Constructors: "),
						new XElement("ul", ctors));
		}

		XElement ExtractProperties(XElement type)
		{
			var props = from prop in type.Elements("property")
						let propName = ExtractName(prop)
						let getter = "get_" + propName
						let setter = "set_" + propName
						select new XElement("ul",
									propName,
									from metd in type.Elements("method")
									let metdName = ExtractName(metd)
									where metdName == getter ||
										  metdName == setter
									select ExtractMethod(metd));
			if (!props.Any()) return null;									
			return new XElement("div", 
						new XElement("h4", "Properties: "), 
						props);
		}

		XElement ExtractOperators(XElement type)
		{
			var ops = from op in type.Elements("method")
					  let name = ExtractName(op)
					  where name.StartsWith("op_", StringComparison.Ordinal)
					  select new XElement("ul",
									name.Substring("op_".Length),
									ExtractMethod(op));
			if (!ops.Any()) return null;									
			return new XElement("div", 
						new XElement("h4", "Operators: "),
						ops);					  
		}
				
		XElement ExtractMethods(XElement type)
		{
			var metds = from metd in type.Elements("method")
						let name = ExtractName(metd)
						where name != ".ctor" &&
							  !type.Elements("property").
								Where(prop => name == "get_" + ExtractName(prop) ||
											 name == "set_" + ExtractName(prop)).
								Any() &&
							  !name.StartsWith("op_") 
						select ExtractMethod(metd);
			if (!metds.Any()) return null;
			return new XElement("div", 
						new XElement("h4", "Methods: "), 
						new XElement("ul", metds));
		}

		XElement ExtractMethod(XElement metd)
		{
			return new XElement("li",
						ExtractModifiers(metd) + " ",
						ExtractReference(metd.Element("returnType")) + " ",
						ExtractReference(metd),
						ExtractParameters(metd));						 
		}
		
		string ExtractParameters(XElement metd)
		{
			StringBuilder builder = new StringBuilder("(");
			foreach (XElement parm in metd.Elements("parameter"))
			{
				if (builder.Length == 1)
				{
					if (metd.Element("extension") != null) builder.Append("this ");
				}
				else
				{
					builder.Append(", ");
				}
				builder.Append(ExtractReference(parm.Element("parameterType")));
				builder.Append(" ");
				builder.Append(ExtractName(parm));
			}
			builder.Append(")");
			return builder.ToString();
		}
	}
}

#T=Linq RSS HttpListener
//Copyright (C) Microsoft Corporation.  All rights reserved.

//User may need to be an Administrator to run this application
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;
using System.Linq;
using System.Xml.Linq;
using System.Net;

// See the ReadMe.html for additional information
class app {
    const string feedUrl = "http://+:8086/csharpfeeds/";

    static IEnumerable<XElement> GetItems() {
        string[] feeds = {
            "http://blogs.msdn.com/ericlippert/rss.aspx",
            "http://blogs.msdn.com/wesdyer/rss.aspx",
            "http://blogs.msdn.com/charlie/rss.aspx",            
            "http://blogs.msdn.com/cyrusn/rss.aspx",
            "http://blogs.msdn.com/mattwar/rss.aspx",
            "http://blogs.msdn.com/lucabol/rss.aspx",
            "http://www.pluralsight.com/blogs/dbox/rss.aspx",
            "http://blogs.msdn.com/jomo_fisher/rss.aspx"
        };
        foreach (var str in feeds) {
            var feed = XDocument.Load(str);
            var items = feed.Root.Element("channel").Elements("item");
            foreach (var item in items)
                yield return item;
        }
    }

    static XElement GetReplyBody() {
        return new XElement("rss",
            new XAttribute("version", "2.0"),
            new XElement("channel",
              new XElement("title", "C# Geeks"),
              new XElement("link", feedUrl),
              new XElement("description", "C# Team Members"),
              new XElement("generator", "LinqToXml-based RSS aggregator"),
              GetItems().ToArray()
              ));

    }

    //User may need to be an Administrator to run this application
    static void Main() {
        var listener = new HttpListener();

        listener.Prefixes.Add("http://+:8086/csharpfeeds/");
        listener.Start();

        // Open a browser pointing at the feeds being served.
        string uri = @"http://localhost:8086/csharpfeeds/";
        System.Diagnostics.Process browser = new System.Diagnostics.Process();
        browser.StartInfo.FileName = "iexplore.exe";
        browser.StartInfo.Arguments = uri;
        browser.Start();

        // Serve requests.
        while (true) {
            var context = listener.GetContext();
            var body = GetReplyBody();
            context.Response.ContentType = "text/xml";
            using (XmlWriter writer = new XmlTextWriter(context.Response.OutputStream, Encoding.UTF8)) 
                body.WriteTo(writer);

        }
    }
}
#T=ListView with lock Columns
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Drawing;
	using System.Data;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;
	/// <summary>
	/// A customized list view that allows the column headers
	/// to be locked to prevent resizing.  The HeaderSizeLocked
	/// property turns on and off this functionality.  This property
	/// is active on the form designer.
	/// </summary>
	public class ListViewEx : System.Windows.Forms.ListView
	{
		private HeaderControl hdrCtrl = null;
		private bool locked = false;

		/// <summary>
		/// Property to turn on and off the ability to size the column headers.
		/// </summary>
		[Category("Behavior"), Description("Prevent sizing of column headers.")]
		public bool LockColumnSize
		{
			get { return locked; }
			set
			{
				locked = value;
			}
		}

		/// <summary>
		/// Notify message header structure.
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct NMHDR
		{
			public IntPtr hwndFrom;
			public int idFrom;
			public int code;
		} //NMHDR

		/// <summary>
		/// Class used to capture window messages for the header of the list view
		/// control.  
		/// </summary>
		private class HeaderControl : NativeWindow
		{
			private ListViewEx parentListView = null;

			[DllImport("User32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			public static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);

			public HeaderControl(ListViewEx m)
			{
				parentListView = m;
				//Get the header control handle
				IntPtr header = SendMessage(m.Handle,
					(0x1000 + 31), IntPtr.Zero, IntPtr.Zero);
				this.AssignHandle(header);
			} //constructor HeaderControl()

			protected override void WndProc(ref Message message)
			{
				const int WM_LBUTTONDBLCLK = 0x0203;
				const int WM_SETCURSOR = 0x0020;
				bool callBase = true;

				switch (message.Msg)
				{
					case WM_LBUTTONDBLCLK:
					case WM_SETCURSOR:
						if (parentListView.LockColumnSize)
						{
							//Don't change cursor to sizing cursor.  Also ignore
							//double click, which sizes the column to fit the data.
							message.Result = (IntPtr)1;	//Return TRUE from message handler
							callBase = false;		//Don't call the base class.
						} //if
						break;
				} //switch

				if (callBase)
				{
					// pass messages on to the base control for processing
					base.WndProc(ref message);
				} //if
			} //WndProc()
		} //class HeaderControl


		/// <summary>
		/// When the control is created capture the messages for the header. 
		/// </summary>
		protected override void OnCreateControl()
		{
			//First actually create the control.
			base.OnCreateControl();

			//Now create the HeaderControl class to handle the customization of
			//the header messages.
			hdrCtrl = new HeaderControl(this);
		} //OnCreateControl()

		/// <summary>
		/// Capture CTRL+ to prevent resize of all columns.
		/// </summary>
		/// <param name="e"></param>
		protected override void OnKeyDown(KeyEventArgs e)
		{
			if (e.KeyValue == 107 && e.Modifiers == Keys.Control && locked)
			{
				e.Handled = true;
			}
			else
			{
				base.OnKeyDown(e);
			} //if
		} //OnKeyDown()

		/// <summary>
		/// Capture messages for the list view control.
		/// </summary>
		/// <param name="message"></param>
		protected override void WndProc(ref Message message)
		{
			const int WM_NOTIFY = 0x004E;
			const int HDN_FIRST = (0 - 300);
			const int HDN_BEGINTRACKA = (HDN_FIRST - 6);
			const int HDN_BEGINTRACKW = (HDN_FIRST - 26);
			bool callBase = true;

			switch (message.Msg)
			{
				case WM_NOTIFY:
					NMHDR nmhdr = (NMHDR)message.GetLParam(typeof(NMHDR));
					switch (nmhdr.code)
					{
						case HDN_BEGINTRACKA:  //Process both ANSI and
						case HDN_BEGINTRACKW:  //UNICODE versions of the message.
							if (locked)
							{
								//Discard the begin tracking to prevent dragging of the 
								//column headers.
								message.Result = (IntPtr)1;
								callBase = false;
							} //if
							break;
					} //switch
					break;
			} //switch

			if (callBase)
			{
				// pass messages on to the base control for processing
				base.WndProc(ref message);
			} //if
		} //WndProc()

	} //ListViewEx class
}

namespace Test
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Data;

	using Microshaoft;
	/// <summary>
	/// Main form to demonstrate the customized list view.
	/// </summary>
	public class DemoForm : System.Windows.Forms.Form
	{
		private Microshaoft.ListViewEx listViewEx1;
		private System.Windows.Forms.ColumnHeader colID;
		private System.Windows.Forms.ColumnHeader colName;
		private System.Windows.Forms.ColumnHeader colPhone;
		private System.Windows.Forms.ColumnHeader colAddress;
		private System.Windows.Forms.CheckBox checkLock;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public DemoForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Windows.Forms.ListViewItem listViewItem1 = new System.Windows.Forms.ListViewItem(new string[] {
																													 "123",
																													 "Chris",
																													 "(770) 555-1234",
																													 "929 My House Lane, Canton, Ga"}, -1);
			System.Windows.Forms.ListViewItem listViewItem2 = new System.Windows.Forms.ListViewItem(new string[] {
																													 "333",
																													 "Bob",
																													 "(404) 555-9999",
																													 "123 Street Court, Altanta, Ga"}, -1);
			System.Windows.Forms.ListViewItem listViewItem3 = new System.Windows.Forms.ListViewItem(new string[] {
																													 "444",
																													 "Fred",
																													 "(678) 555-7878",
																													 "444 Private Street, Marietta, Ga"}, -1);
			this.listViewEx1 = new Microshaoft.ListViewEx();
			this.colID = new System.Windows.Forms.ColumnHeader();
			this.colName = new System.Windows.Forms.ColumnHeader();
			this.colPhone = new System.Windows.Forms.ColumnHeader();
			this.colAddress = new System.Windows.Forms.ColumnHeader();
			this.checkLock = new System.Windows.Forms.CheckBox();
			this.SuspendLayout();
			// 
			// listViewEx1
			// 
			this.listViewEx1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
				| System.Windows.Forms.AnchorStyles.Left)
				| System.Windows.Forms.AnchorStyles.Right)));
			this.listViewEx1.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																						  this.colID,
																						  this.colName,
																						  this.colPhone,
																						  this.colAddress});
			this.listViewEx1.Items.AddRange(new System.Windows.Forms.ListViewItem[] {
																						listViewItem1,
																						listViewItem2,
																						listViewItem3});
			this.listViewEx1.Location = new System.Drawing.Point(8, 8);
			this.listViewEx1.LockColumnSize = true;
			this.listViewEx1.Name = "listViewEx1";
			this.listViewEx1.Size = new System.Drawing.Size(616, 424);
			this.listViewEx1.TabIndex = 0;
			this.listViewEx1.View = System.Windows.Forms.View.Details;
			// 
			// colID
			// 
			this.colID.Text = "Identifier";
			this.colID.Width = 103;
			// 
			// colName
			// 
			this.colName.Text = "Name";
			this.colName.Width = 82;
			// 
			// colPhone
			// 
			this.colPhone.Text = "Phone";
			this.colPhone.Width = 95;
			// 
			// colAddress
			// 
			this.colAddress.Text = "Address";
			this.colAddress.Width = 293;
			// 
			// checkLock
			// 
			this.checkLock.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.checkLock.Location = new System.Drawing.Point(16, 456);
			this.checkLock.Name = "checkLock";
			this.checkLock.Size = new System.Drawing.Size(144, 24);
			this.checkLock.TabIndex = 1;
			this.checkLock.Text = "Lock Column Size";
			this.checkLock.CheckedChanged += new System.EventHandler(this.checkLock_CheckedChanged);
			// 
			// DemoForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(632, 502);
			this.Controls.Add(this.checkLock);
			this.Controls.Add(this.listViewEx1);
			this.Name = "DemoForm";
			this.Text = "ListViewEx Demo";
			this.Load += new System.EventHandler(this.DemoForm_Load);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.Run(new DemoForm());
		} //Main()

		private void checkLock_CheckedChanged(object sender, System.EventArgs e)
		{
			listViewEx1.LockColumnSize = checkLock.CheckState == CheckState.Checked;
		} //checkLock_CheckedChanged()

		private void DemoForm_Load(object sender, System.EventArgs e)
		{
			if (listViewEx1.LockColumnSize)
			{
				checkLock.CheckState = CheckState.Checked;
			}
			else
			{
				checkLock.CheckState = CheckState.Unchecked;
			} //if
		}


	}
}

#T=LoadLibrary
/****************************** Module Header ******************************\
* Module Name:  Program.cs
* Project:	  CSLoadLibrary
* Copyright (c) Microsoft Corporation.
* 
* CSLoadLibrary in C# mimics the behavior of CppLoadLibrary to dynamically 
* load a native DLL (LoadLibrary) get the address of a function in the export  
* table (GetProcAddress, Marshal.GetDelegateForFunctionPointer), and call it. 
* The technology is called Dynamic P/Invoke. It serves as a supplement for 
* the P/Invoke technique and is useful especially when the target DLL is not 
* in the search path of P/Invoke. If you use P/Invoke, CLR will search the 
* dll in your assembly's directory first, then search the dll in directories 
* listed in PATH environment variable. If the dll is not in any of those 
* directories, you have to use the so called Dynamic PInvoke technique that 
* is demonstrated in this code sample. 
* 
* This source is subject to the Microsoft Public License.
* See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
* All other rights reserved.
* 
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
* EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
* WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
\***************************************************************************/
namespace CSLoadLibrary
{
	#region Using directives
	using System;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;
	using System.Text;
	#endregion
	class Program
	{
		#region Function Delegates
		// Function delegate of GetStringLength1 exported from the DLL module.
		// The string parameter must be marshaled as LPWStr, otherwise, the
		// string will be passed into the native as an ANSI string that the
		// Unicode API cannot resolve appropriately.
		delegate int GetStringLength1Delegate(
			[MarshalAs(UnmanagedType.LPWStr)] string str);
		// Function delegate of GetStringLength2 exported from the DLL.
		delegate int GetStringLength2Delegate(
			[MarshalAs(UnmanagedType.LPWStr)] string str);
		// Function delegate of the 'PFN_COMPARE' callback function, and the 
		// Max function that requires the callback as one of the arguments.
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		delegate int CompareCallback(int a, int b);
		delegate int MaxDelegate(int a, int b, CompareCallback cmpFunc);
		#endregion
		static void Main(string[] args)
		{
			bool isLoaded = false;
			const string moduleName = "CppDynamicLinkLibrary";
			// Check whether or not the module is loaded.
			isLoaded = IsModuleLoaded(moduleName);
			Console.WriteLine("Module \"{0}\" is {1}loaded", moduleName, 
				isLoaded ? "" : "not ");
			// Load the DLL module.
			Console.WriteLine("Load the library");
			using (UnmanagedLibrary lib = new UnmanagedLibrary(moduleName))
			{
				// Check whether or not the module is loaded.
				isLoaded = IsModuleLoaded(moduleName);
				Console.WriteLine("Module \"{0}\" is {1}loaded", moduleName, 
					isLoaded ? "" : "not ");
				//
				// Access the global data exported from the module.
				// 
				// The solution does not allow you to access the global data 
				// exported from a DLL module.
				//
				// Call the functions exported from the module.
				//
				string str = "HelloWorld";
				int length;
				// Call int /*__cdecl*/ GetStringLength1(PWSTR pszString);
				GetStringLength1Delegate GetStringLength1 = 
					lib.GetUnmanagedFunction<GetStringLength1Delegate>(
					"GetStringLength1");
				if (GetStringLength1 == null)
				{
					throw new EntryPointNotFoundException(
						"Unable to find an entry point named 'GetStringLength1'");
				}
				length = GetStringLength1(str);
				Console.WriteLine("GetStringLength1(\"{0}\") => {1}", str, length);
				// Call int __stdcall GetStringLength2(PWSTR pszString);
				GetStringLength2Delegate GetStringLength2 = 
					lib.GetUnmanagedFunction<GetStringLength2Delegate>(
					"_GetStringLength2@4");
				if (GetStringLength2 == null)
				{
					throw new EntryPointNotFoundException(
						"Unable to find an entry point named 'GetStringLength2'");
				}
				length = GetStringLength2(str);
				Console.WriteLine("GetStringLength2(\"{0}\") => {1}", str, length);
				// 
				// Call the callback functions exported from the module.
				// 
				CompareCallback cmpFunc = new CompareCallback(CompareInts);
				MaxDelegate Max = lib.GetUnmanagedFunction<MaxDelegate>("Max");
				if (Max == null)
				{
					throw new EntryPointNotFoundException(
						"Unable to find an entry point named 'Max'");
				}
				int max = Max(2, 3, cmpFunc);
				Console.WriteLine("Function: Max(2, 3) => {0}", max);
				//
				// Use the class exported from a module.
				//
				// The solution does not allow you to use the class exported 
				// from the DLL.
				// Attempt to free the library on exit.
				Console.WriteLine("Unload the dynamically-loaded DLL");
			} // The DLL module should be unloaded here.
			// Check whether or not the module is loaded.
			isLoaded = IsModuleLoaded(moduleName);
			Console.WriteLine("Module \"{0}\" is {1}loaded", moduleName,
				isLoaded ? "" : "not ");
		}
		/// <summary>
		/// This is the callback function for the method Max exported from 
		/// the DLL CppDynamicLinkLibrary.dll
		/// </summary>
		/// <param name="a">the first integer</param>
		/// <param name="b">the second integer</param>
		/// <returns>
		/// The function returns a positive number if a > b, returns 0 if a 
		/// equals b, and returns a negative number if a < b.
		/// </returns>
		static int CompareInts(int a, int b)
		{
			return (a - b);
		}
		#region IsModuleLoaded
		/// <summary>
		/// Check whether or not the specified module is loaded in the 
		/// current process.
		/// </summary>
		/// <param name="moduleName">the module name</param>
		/// <returns>
		/// The function returns true if the specified module is loaded in 
		/// the current process. If the module is not loaded, the function 
		/// returns false.
		/// </returns>
		static bool IsModuleLoaded(string moduleName)
		{
			// Get the module in the process according to the module name.
			IntPtr hMod = GetModuleHandle(moduleName);
			return (hMod != IntPtr.Zero);
		}
		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		static extern IntPtr GetModuleHandle(string moduleName);
		#endregion
	}
}
/******************************** Module Header ********************************\
* Module Name:  UnmanagedLibrary.cs
* Project:	  CSLoadLibrary
* Copyright (c) Microsoft Corporation.
* 
* The source code of UnmanagedLibrary is quoted from Mike Stall's article:
* 
* Type-safe Managed wrappers for kernel32!GetProcAddress
* http://blogs.msdn.com/jmstall/archive/2007/01/06/Typesafe-GetProcAddress.aspx
* 
* This source is subject to the Microsoft Public License.
* See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
* All other rights reserved.
* 
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
* EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
* WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
\*******************************************************************************/
namespace CSLoadLibrary
{
	#region Using directives
	using Microsoft.Win32.SafeHandles;
	using System;
	using System.Runtime.ConstrainedExecution;
	using System.Runtime.InteropServices;
	using System.Security.Permissions;
	#endregion
	/// <summary>
	/// Utility class to wrap an unmanaged DLL and be responsible for freeing it.
	/// </summary>
	/// <remarks>
	/// This is a managed wrapper over the native LoadLibrary, GetProcAddress, 
	/// and FreeLibrary calls.
	/// </example>
	/// <see cref=
	/// "http://blogs.msdn.com/jmstall/archive/2007/01/06/Typesafe-GetProcAddress.aspx"
	/// />
	public sealed class UnmanagedLibrary : IDisposable
	{
		#region Safe handles and Native imports
		/// <summary>
		/// See http://msdn.microsoft.com/msdnmag/issues/05/10/Reliability/ 
		/// for more about safe handles.
		/// </summary>
		[SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode = true)]
		sealed class SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid
		{
			/// <summary>
			/// Create safe library handle
			/// </summary>
			private SafeLibraryHandle() : base(true) { }
			/// <summary>
			/// Release handle
			/// </summary>
			protected override bool ReleaseHandle()
			{
				return NativeMethod.FreeLibrary(handle);
			}
		}
		/// <summary>
		/// Native methods
		/// </summary>
		static class NativeMethod
		{
			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			public static extern SafeLibraryHandle LoadLibrary(string fileName);
			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			[DllImport("kernel32", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			public static extern bool FreeLibrary(IntPtr hModule);
			[DllImport("kernel32", EntryPoint = "GetProcAddress")]
			public static extern IntPtr GetProcAddress(SafeLibraryHandle hModule,
				String procname);
		}
		#endregion
		/// <summary>
		/// Constructor to load a dll and be responible for freeing it.
		/// </summary>
		/// <param name="fileName">full path name of dll to load</param>
		/// <exception cref="System.IO.FileNotFoundException">
		/// If fileName can't be found
		/// </exception>
		/// <remarks>
		/// Throws exceptions on failure. Most common failure would be 
		/// file-not-found, or that the file is not a loadable image.
		/// </remarks>
		public UnmanagedLibrary(string fileName)
		{
			m_hLibrary = NativeMethod.LoadLibrary(fileName);
			if (m_hLibrary.IsInvalid)
			{
				int hr = Marshal.GetHRForLastWin32Error();
				Marshal.ThrowExceptionForHR(hr);
			}
		}
		/// <summary>
		/// Dynamically lookup a function in the dll via kernel32!GetProcAddress.
		/// </summary>
		/// <param name="functionName">
		/// raw name of the function in the export table.
		/// </param>
		/// <returns>
		/// null if function is not found. Else a delegate to the unmanaged 
		/// function.
		/// </returns>
		/// <remarks>
		/// GetProcAddress results are valid as long as the dll is not yet 
		/// unloaded. This is very very dangerous to use since you need to 
		/// ensure that the dll is not unloaded until after you're done with any 
		/// objects implemented by the dll. For example, if you get a delegate 
		/// that then gets an IUnknown implemented by this dll, you can not 
		/// dispose this library until that IUnknown is collected. Else, you may 
		/// free the library and then the CLR may call release on that IUnknown 
		/// and it will crash.
		/// </remarks>
		public TDelegate GetUnmanagedFunction<TDelegate>(string functionName)
			where TDelegate : class
		{
			IntPtr p = NativeMethod.GetProcAddress(m_hLibrary, functionName);
			// Failure is a common case, especially for adaptive code.
			if (p == IntPtr.Zero)
			{
				return null;
			}
			Delegate function = Marshal.GetDelegateForFunctionPointer(
				p, typeof(TDelegate));
			// Ideally, we'd just make the constraint on TDelegate be
			// System.Delegate, but compiler error CS0702 
			// (constrained can't be System.Delegate)
			// prevents that. So we make the constraint system.object and do the
			// cast from object-->TDelegate.
			object o = function;
			return (TDelegate)o;
		}
		#region IDisposable Members
		/// <summary>
		/// Call FreeLibrary on the unmanaged dll. All function pointers handed 
		/// out from this class become invalid after this.
		/// </summary>
		/// <remarks>
		/// This is very dangerous because it suddenly invalidate everything
		/// retrieved from this dll. This includes any functions handed out via 
		/// GetProcAddress, and potentially any objects returned from those 
		/// functions (which may have an implemention in the dll).
		/// </remarks>
		public void Dispose()
		{
			if (!m_hLibrary.IsClosed)
			{
				m_hLibrary.Close();
			}
		}
		// Unmanaged resource. CLR will ensure SafeHandles get freed, without 
		// requiring a finalizer on this class.
		SafeLibraryHandle m_hLibrary;
		#endregion
	}
}
#T=LoadLibrary Marshal GetDelegateForFunctionPointer
//GetDelegateForFunctionPointer
//GetFunctionPointerForDelegate
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	public class TestClass
	{
		public static void Main(String[] args)
		{
			IntPtr user32 = LoadLibrary("user32.dll");
			IntPtr procaddr = GetProcAddress(user32, "MessageBoxW");
			MyMessageBox mbx = (MyMessageBox) Marshal.GetDelegateForFunctionPointer(procaddr, typeof(MyMessageBox));
			mbx(IntPtr.Zero, "Hello, World", "A Test Run", 0);
		}
		internal delegate int MyMessageBox
								(
									IntPtr hwnd,
									[MarshalAs(UnmanagedType.LPWStr)]
									string text, 
									[MarshalAs(UnmanagedType.LPWStr)]
									string Caption,
									int type
								);
		[DllImport("kernel32.dll")]
		internal static extern IntPtr LoadLibrary(String dllname);
		[DllImport("kernel32.dll")]
		internal static extern IntPtr GetProcAddress(IntPtr hModule, String procname);
	}
}
#T=LogHelper
//logHelper
namespace Microsoft.Util
{
	using System;
	using System.IO;
	using System.Text;
	
	/// <summary>
	/// Utility 的摘要说明。
	/// </summary>
	public class LogHelper
	{
		public static void WriteFile
			(
				string fileName
				, string content
				, Encoding encoding
			)
		{

			string path = System.IO.Path.GetDirectoryName(fileName);

			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}
			
			using(FileStream fs = new FileStream(fileName,FileMode.OpenOrCreate,FileAccess.ReadWrite,FileShare.ReadWrite))
			{
				StreamWriter sw = new StreamWriter(fs,encoding);
				sw.BaseStream.Seek(0, SeekOrigin.End);
				sw.WriteLine("\nBegin:==============================================");
				sw.WriteLine(content);
				sw.WriteLine("\nEnd;================================================");
				sw.Flush();
				sw.Close();
			}
		}
		public static void WriteLog
			(
				string fileName
				, string content
				, string logType
			)
		{

			WriteLog(fileName,content,logType,"\r\n",Encoding.GetEncoding("gb2312"));
		}
		public static void WriteLog
			(
				string fileName
				, string content
				, string logType
				, string delimiter
				, Encoding encoding
			)
		{

			string s = string.Format
				(
					"{1}: {0}{2}{0}{3}"
					, delimiter
					, logType
					, DateTime.Now.ToString()
					, content
				);

			WriteFile(fileName,s,encoding);
		}
	}
}


#T=Lookup IGrouping Lookup
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Threading.Tasks;
	using System.Threading;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	class Program
	{
		static void Main(string[] args)
		{
			var list = new List<Employee>()
									{
										new Employee()
												{
													ID = 100
													, Name = "Bill Gates"
													, Department = "Microsoft"
												}
										, new Employee()
												{
													ID = 2
													, Name = "Steve Jobs"
													, Department = "Apple"
												}
										, new Employee()
												{
													ID = 300
													, Name = "Larry Page"
													, Department = "Google"
												}
										, new Employee()
												{
													ID = 4
													, Name = "Sergey Brin"
													, Department = "Google"
												}
										, new Employee()
												{
													ID = 300
													, Name = "Larry Page2"
													, Department = "Google"
												}
										, new Employee()
												{
													ID = 4
													, Name = "Microshaoft"
													, Department = "Microsoft"
												}
									};
			var groups = list.ToLookup<Employee,string>
											(
												x =>
												{
													return x.Department;
												}
											);
			groups.AsParallel().WithDegreeOfParallelism
										(
											groups.Count
										).ForAll
												(
													(x) =>
													{
														Console.WriteLine("{0},{1}", Thread.CurrentThread.ManagedThreadId, x.Key);
														var orderedGroup = x.OrderByDescending<Employee, int>
																			(
																				(xx) =>
																				{
																					return xx.ID;
																				}
																			);
														//orderedGroup.AsParallel().WithDegreeOfParallelism(1).ForAll
														//		(
														//			(xxx) =>
														//			{
														//				Console.WriteLine("{0},{1}", Thread.CurrentThread.ManagedThreadId, xxx.Name);
														//			}
														//		);
														orderedGroup.ToList().ForEach
																				(
																					(xxx) =>
																					{
																						Console.WriteLine("{0},{1}", Thread.CurrentThread.ManagedThreadId, xxx.Name);
																					}
																				);
													}
												);
			Console.ReadLine();
		}
		public class Employee
		{
			public int ID
			{
				get;
				set;
			}
			public string Name
			{
				get;
				set;
			}
			public string Department
			{
				get;
				set;
			}
			public string Gender
			{
				get;
				set;
			}
			public DateTime Birthday
			{
				get;
				set;
			}
		}
	}
}
#T=Mail SmtpClient Simple
//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------

namespace Microsoft.Samples.Mailer
{
	using System;
	using System.Net.Mail;

	// Mailer sends an e-mail.  
	// It will authenticate using Windows authentication if the server
	// (i.e. Exchange) requests it.
	static class Mailer
	{
		enum MailMessagePart
		{
			From,
			To,
			Subject,
			Message
		}

		static void Main(string[] args)
		{
			if (args.Length < 4)
			{	
				Console.WriteLine(
					"Expected: mailer.exe [from] [to] [subject] [message]");
				return;
			}

			// Set mailServerName to be the name of the mail server
			// you wish to use to deliver this message
			string mailServerName = "smtphost";
			string from = args[(int) MailMessagePart.From];
			string to = args[(int) MailMessagePart.To];
			string subject = args[(int) MailMessagePart.Subject];
			string body = args[(int) MailMessagePart.Message];

			try
			{
				// MailMessage is used to represent the e-mail being sent
				using (MailMessage message = 
					new MailMessage(from, to, subject, body))
				{

					// SmtpClient is used to send the e-mail
					SmtpClient mailClient = new SmtpClient(mailServerName);

					// UseDefaultCredentials tells the mail client to use the 
					// Windows credentials of the account (i.e. user account) 
					// being used to run the application
					mailClient.UseDefaultCredentials = true;

					// Send delivers the message to the mail server
					mailClient.Send(message);
				}
				Console.WriteLine("Message sent.");
			}
			catch (FormatException ex)
			{
				Console.WriteLine(ex.Message);
			}
			catch (SmtpException ex)
			{
				Console.WriteLine(ex.Message);
			}
		}
	}
}

#T=MakeGenericMethod Reflection 反射 ObjectToXml
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Reflection;
	using System.Text;
	using System.Threading.Tasks;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			Assembly asm = Assembly.GetExecutingAssembly();
			Type[] types = asm.GetTypes().Where
											(
												t
												=>
												(t.Namespace == "Entities")
												//String.Equals(t.Namespace, "LeadTone.Platform.Entities", StringComparison.OrdinalIgnoreCase)
												//true
											).ToArray();
			MethodInfo mi = typeof(SerializerHelper).GetMethods().First
																	(
																		m => m.Name.Equals("ObjectToXml") && m.IsGenericMethod && m.GetParameters().Length == 2
																	);
			Parallel.ForEach
						(
							types
							, t
							=>
							{
								Console.WriteLine
											(
												t.Name
											);
								object o = asm.CreateInstance(t.FullName);
								string s = (string) mi.MakeGenericMethod(t).Invoke("ObjectToXml", new object[] { o, Encoding.UTF8});
								Console.WriteLine(s);
							}
						);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using System.Runtime.Serialization.Formatters.Binary;
	//using System.Runtime.Serialization.Formatters.Soap;
	public static class SerializerHelper
	{
		public static T XmlToObject<T>(string Xml)
		{
			StringReader stringReader = new StringReader(Xml);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			return (T)serializer.Deserialize(xmlReader);
		}
		public static string ObjectToXml<T>
									(
										T Object
										, XmlTextWriter writer
										, XmlSerializer serializer
									)
		{
			serializer.Serialize(writer, Object);
			MemoryStream stream = writer.BaseStream as MemoryStream;
			byte[] bytes = stream.ToArray();
			Encoding e = EncodingHelper.IdentifyEncoding
											(
												bytes
												, Encoding.GetEncoding("gb2312")
				///												, new Encoding[]
				///														{
				///															Encoding.UTF8
				///															, Encoding.Unicode
				///														}
											);
			byte[] buffer = e.GetPreamble();
			int offset = buffer.Length;
			buffer = new byte[bytes.Length - offset];
			Buffer.BlockCopy(bytes, offset, buffer, 0, buffer.Length);
			string s = e.GetString(buffer);
			return s;
		}
		public static string ObjectToXml<T>(T Object, Encoding e)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			using (MemoryStream stream = new MemoryStream())
			{
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = ObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static byte[] ObjectToBinary<T>
									(
										T Object
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				formater.Serialize(stream, Object);
				byte[] buffer = stream.ToArray();
				return buffer;
			}
		}
		public static T BinaryToObject<T>
									(
										byte[] data
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T Object = (T)formater.Deserialize(stream);
				return Object;
			}
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	using System.Text;
	using System.Collections.Generic;
	public static class EncodingHelper
	{
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, identifyEncodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
									)
		{
			EncodingInfo[] encodingInfos = Encoding.GetEncodings();
			List<Encoding> list = new List<Encoding>();
			foreach (EncodingInfo info in encodingInfos)
			{
				Encoding e = info.GetEncoding();
				if (e.GetPreamble().Length > 0)
				{
					list.Add(e);
					//System.Console.WriteLine(e.EncodingName);
				}
			}
			Encoding[] encodings = new Encoding[list.Count];
			list.CopyTo(encodings);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, encodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			Encoding encoding = defaultEncoding;
			foreach (Encoding e in identifyEncodings)
			{
				byte[] buffer = e.GetPreamble();
				int l = buffer.Length;
				if (l == 0)
				{
					continue;
				}
				bool flag = false;
				for (int i = 0; i < l; i++)
				{
					if (buffer[i] != data[i])
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				else
				{
					encoding = e;
				}
			}
			return encoding;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}
namespace Entities
{
	using System;
	/// <summary>
	/// 实体类Transaction
	/// </summary>
	[Serializable]
	public partial class Transaction//: EntityObject
	{
		#region 实体公有属性
		/// <summary>
		/// 交易编号
		/// </summary>
		public string TransactionNO { set; get; }
		/// <summary>
		/// 名称
		/// </summary>
		public string Name { set; get; }
		/// <summary>
		/// 描述
		/// </summary>
		public string Description { set; get; }
		/// <summary>
		/// 交易关联的产品ID
		/// </summary>
		public int? ProductId { set; get; }
		/// <summary>
		/// 金额字段
		/// </summary>
		public string AmountField { set; get; }
		/// <summary>
		/// 修改柜员ID
		/// </summary>
		public int? ModifiedTellerId { set; get; }
		/// <summary>
		/// 修改时间
		/// </summary>
		public DateTime ModifiedTime { set; get; }
		#endregion 实体公有属性
	}
}

#T=MapReduce hadoop client
namespace WordCount
{
	using Microsoft.Hadoop.MapReduce;
	using System;
	class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine("{0}: Executing word count job", DateTime.Now);
			IHadoop hadoop = Hadoop.Connect(new Uri("http://anwhadoop:50111"), "user", "password");
			hadoop.MapReduceJob.ExecuteJob<WordCountJob>();
		}
	}
}
namespace WordCount
{
	using Microsoft.Hadoop.MapReduce;
	public class WordCountJob : HadoopJob<WordCountMapper, WordCountReducer>
	{
		public override HadoopJobConfiguration Configure(ExecutorContext context)
		{
			HadoopJobConfiguration config = new HadoopJobConfiguration()
			{
				InputPath = "test.txt",
				OutputFolder = "wordcount/output",
				DeleteOutputFolder = true,
			};
			config.AdditionalGenericArguments.Add("-D \"mapred.reduce.tasks=2\"");
			return config;
		}
	}
}
namespace WordCount
{
	using Microsoft.Hadoop.MapReduce;
	public class WordCountMapper : MapperBase
	{
		public override void Map(string inputLine, MapperContext context)
		{
			foreach (string word in inputLine.Trim().Split(' '))
			{
				context.EmitKeyValue(word.ToLower(), "1");
			}
		}
	}
}
namespace WordCount
{
	using Microsoft.Hadoop.MapReduce;
	using System.Collections.Generic;
	using System.Linq;
	public class WordCountReducer : ReducerCombinerBase
	{
		public override void Reduce(string key, IEnumerable<string> values, ReducerCombinerContext context)
		{
			string sum = values.Sum(s => long.Parse(s)).ToString();
			context.EmitKeyValue(key, sum);
		}
	}
}

#T=MapReduce PLinq
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Threading.Tasks;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	class Program
	{
		static void Main(string[] args)
		{
			var list = new List<Employee>()
									{
										new Employee()
												{
													ID = 1
													, Name = "Bill Gates"
													, Department = "Microsoft"
												}
										, new Employee()
												{
													ID = 2
													, Name = "Steve Jobs"
													, Department = "Apple"
												}
										, new Employee()
												{
													ID = 3
													, Name = "Larry Page"
													, Department = "Google"
												}
										, new Employee()
												{
													ID = 4
													, Name = "Sergey Brin"
													, Department = "Google"
												}
									};
			//按Department分组映射
			var mapper = list.AsParallel().ToLookup
											(
												x => x.Department
												, x => x
												// x => 0
											).AsParallel();
			ConcurrentDictionary<string, int> result = new ConcurrentDictionary<string, int>();
			mapper.ForAll
			//mapper.ToList().ForEach
							(
								x =>
								{
									Console.WriteLine(x.Key);
									//to do 分布式远程调用计算
									if (result.TryAdd(x.Key, x.Count())) //保存分布式结果到ConcurrentDictionary
									{
										x.AsParallel().ForAll
										//x.ToList().ForEach
														(
															xx =>
															{
																Console.WriteLine("{0},{1}", x.Key, xx.Name);
															}
														);
									}
								}
							);
			//返回所有分布式结果
			result.AsParallel().ForAll
									(
										kvp =>
										{
											Console.WriteLine("{0},{1}", kvp.Key, kvp.Value);
										}
									);
			//化简统计
			var reducer =
							from
									IGrouping<string, Employee> groupingMapper
										in mapper.AsParallel()
							select
									new
									{
										Department = groupingMapper.Key
										,
										Count = groupingMapper.Count()
									};
			reducer.ForAll
						(
							x =>
							{
								Console.WriteLine("当前 Department = {0} 的人数有: {1} 人", x.Department, x.Count);
							}
						);
			var sum = reducer.Sum
						(
							x => x.Count
						);
			Console.WriteLine("总人数有: {0} 人", sum);
			Console.ReadLine();
		}
		public class Employee
		{
			public int ID
			{
				get;
				set;
			}
			public string Name
			{
				get;
				set;
			}
			public string Department
			{
				get;
				set;
			}
			public string Gender
			{
				get;
				set;
			}
			public DateTime Birthday
			{
				get;
				set;
			}
		}
	}
}

//===========================================================

namespace Test
{
	using System;
	using System.Linq;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			var r = MapReduceHelper
						.Start<string, int, string>
							(
								(x) =>
									{
										return x.Length;
									} //Map
								, (x) =>
									{
										return x.Sum().ToString();
									} //Reduce
								, "aaaaaaaaaaaa"
								, "bbbbbbbbb"
								, "ccccccccccccc"
							).Result;
			Console.WriteLine(r);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Threading.Tasks;
	public static class MapReduceHelper
	{
		public static Task<TResult> Start<TInput, TPartialResult, TResult>
										(
											Func<TInput, TPartialResult> map
											, Func<TPartialResult[], TResult> reduce
											, params TInput[] inputs
										)
		{
			var mapTasks = CreateMapTasks(map, inputs);
			var reduceTask = CreateReduceTask(reduce, mapTasks);
			return reduceTask;
		}
		private static Task<TResult> CreateReduceTask<TPartialResult, TResult>
										(
											Func<TPartialResult[]
											, TResult> reduce
											, Task<TPartialResult>[] mapTasks
										)
		{
			return
				Task
					.Factory
						.ContinueWhenAll
							(
								mapTasks
								, (tasks) =>
									{
										return
											PerformReduce(reduce, tasks);
									}
							);
		}
		private static TResult PerformReduce<TPartialResult, TResult>
										(
											Func<TPartialResult[], TResult> reduce
											, Task<TPartialResult>[] tasks
										)
		{
			var results =
							from
								task
							in
								tasks
							select
								task.Result;
			return reduce(results.ToArray());
		}
		private static Task<TPartialResult>[] CreateMapTasks<TInput, TPartialResult>
										(
											Func<TInput, TPartialResult> map
											, TInput[] inputs
										)
		{
			var tasks = new Task<TPartialResult>[inputs.Length];
			for (int i = 0; i < inputs.Length; ++i)
			{
				var input = inputs[i];
				tasks[i] = Task
								.Factory
									.StartNew
										(
											() => map(input)
										);
			}
			return tasks;
		}
	}
}

#T=MapReduceHelper
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Threading.Tasks;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	class Program
	{
		static void Main(string[] args)
		{
			var list = new List<Employee>()
									{
										new Employee()
												{
													ID = 1
													, Name = "Bill Gates"
													, Department = "Microsoft"
												}
										, new Employee()
												{
													ID = 2
													, Name = "Steve Jobs"
													, Department = "Apple"
												}
										, new Employee()
												{
													ID = 3
													, Name = "Larry Page"
													, Department = "Google"
												}
										, new Employee()
												{
													ID = 4
													, Name = "Sergey Brin"
													, Department = "Google"
												}
									};
			//按Department分组映射
			var mapper = list.AsParallel().ToLookup
											(
												x => x.Department
												, x => x
												// x => 0
											).AsParallel();
			ConcurrentDictionary<string, int> result = new ConcurrentDictionary<string, int>();
			mapper.ForAll
			//mapper.ToList().ForEach
							(
								x =>
								{
									Console.WriteLine(x.Key);
									//to do 分布式远程调用计算
									if (result.TryAdd(x.Key, x.Count())) //保存分布式结果到ConcurrentDictionary
									{
										x.AsParallel().ForAll
										//x.ToList().ForEach
														(
															xx =>
															{
																Console.WriteLine("{0},{1}", x.Key, xx.Name);
															}
														);
									}
								}
							);
			//返回所有分布式结果
			result.AsParallel().ForAll
									(
										kvp =>
										{
											Console.WriteLine("{0},{1}", kvp.Key, kvp.Value);
										}
									);
			//化简统计
			var reducer =
							from
									IGrouping<string, Employee> groupingMapper
										in mapper.AsParallel()
							select
									new
									{
										Department = groupingMapper.Key
										,
										Count = groupingMapper.Count()
									};
			reducer.ForAll
						(
							x =>
							{
								Console.WriteLine("当前 Department = {0} 的人数有: {1} 人", x.Department, x.Count);
							}
						);
			var sum = reducer.Sum
						(
							x => x.Count
						);
			Console.WriteLine("总人数有: {0} 人", sum);
			Console.ReadLine();
		}
		public class Employee
		{
			public int ID
			{
				get;
				set;
			}
			public string Name
			{
				get;
				set;
			}
			public string Department
			{
				get;
				set;
			}
			public string Gender
			{
				get;
				set;
			}
			public DateTime Birthday
			{
				get;
				set;
			}
		}
	}
}

//===========================================================

namespace Test
{
	using System;
	using System.Linq;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			var r = MapReduceHelper
						.Start<string, int, string>
							(
								(x) =>
									{
										return x.Length;
									} //Map
								, (x) =>
									{
										return x.Sum().ToString();
									} //Reduce
								, "aaaaaaaaaaaa"
								, "bbbbbbbbb"
								, "ccccccccccccc"
							).Result;
			Console.WriteLine(r);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Threading.Tasks;
	public static class MapReduceHelper
	{
		public static Task<TResult> Start<TInput, TPartialResult, TResult>
										(
											Func<TInput, TPartialResult> map
											, Func<TPartialResult[], TResult> reduce
											, params TInput[] inputs
										)
		{
			var mapTasks = CreateMapTasks(map, inputs);
			var reduceTask = CreateReduceTask(reduce, mapTasks);
			return reduceTask;
		}
		private static Task<TResult> CreateReduceTask<TPartialResult, TResult>
										(
											Func<TPartialResult[]
											, TResult> reduce
											, Task<TPartialResult>[] mapTasks
										)
		{
			return
				Task
					.Factory
						.ContinueWhenAll
							(
								mapTasks
								, (tasks) =>
									{
										return
											PerformReduce(reduce, tasks);
									}
							);
		}
		private static TResult PerformReduce<TPartialResult, TResult>
										(
											Func<TPartialResult[], TResult> reduce
											, Task<TPartialResult>[] tasks
										)
		{
			var results =
							from
								task
							in
								tasks
							select
								task.Result;
			return reduce(results.ToArray());
		}
		private static Task<TPartialResult>[] CreateMapTasks<TInput, TPartialResult>
										(
											Func<TInput, TPartialResult> map
											, TInput[] inputs
										)
		{
			var tasks = new Task<TPartialResult>[inputs.Length];
			for (int i = 0; i < inputs.Length; ++i)
			{
				var input = inputs[i];
				tasks[i] = Task
								.Factory
									.StartNew
										(
											() => map(input)
										);
			}
			return tasks;
		}
	}
}

#T=MEF
namespace HostingMef
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.ComponentModel.Composition;
	using System.ComponentModel.Composition.Hosting;
	using System.Reflection;
	public interface IBookService
	{
		void GetBookName();
	}
	
	/// <summary>
	/// 导入
	/// </summary>
	[Export(typeof(IBookService))]
	public class ComputerBookService : IBookService
	{
		public void GetBookName()
		{
			Console.WriteLine("《Hello Silverlight》");
		}
	}

	class Program
	{
		/// <summary>
		/// 导入接口的实现部件(Part)
		/// </summary>
		[Import]
		public IBookService Service
		{ 
			get;
			set;
		}
		
		/// <summary>
		/// 宿主MEF并组合部件
		/// </summary>
		private void Compose()
		{
			var catalog = new AssemblyCatalog(Assembly.GetExecutingAssembly());
			var container = new CompositionContainer(catalog);
			//将部件（part）和宿主程序添加到组合容器
			container.ComposeParts(this, new ComputerBookService());
		}

		static void Main(string[] args)
		{
			Program p = new Program();
			p.Compose();
			p.Service.GetBookName();
		}
	}
}
#T=MEF WebApi MVC
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel.Composition;
	using System.ComponentModel.Composition.Hosting;
	using System.Linq;
	using System.Reflection;
	using System.Web.Http;
	using System.Web.Http.Dependencies;
	using System.Web.Mvc;
	using System.Web.Routing;
	using IDependencyResolver = System.Web.Http.Dependencies.IDependencyResolver;
	public static class MefConfig
	{
		public static void RegisterMef()
		{
			var container = ConfigureContainer();
			ControllerBuilder.Current.SetControllerFactory(new MefControllerFactory(container));
			var dependencyResolver = GlobalConfiguration.Configuration.DependencyResolver;
			GlobalConfiguration.Configuration.DependencyResolver = new MefDependencyResolver(container);
		}
		private static CompositionContainer ConfigureContainer()
		{
			var assemblyCatalog = new AssemblyCatalog(Assembly.GetExecutingAssembly());
			var container = new CompositionContainer(assemblyCatalog);
			return container;
		}
	}
	public class MefDependencyResolver : IDependencyResolver
	{
		private readonly CompositionContainer _container;
		
		public MefDependencyResolver(CompositionContainer container)
		{
			_container = container;
		}
		public IDependencyScope BeginScope()
		{
			return this;
		}
		public object GetService(Type serviceType)
		{
			var export = _container.GetExports(serviceType, null, null).SingleOrDefault();
			return null != export ? export.Value : null;
		}
		public IEnumerable<object> GetServices(Type serviceType)
		{
			var exports =_container.GetExports(serviceType, null, null);
			var createdObjects = new List<object>();
			if ( exports.Any())
			{
				foreach (var export in exports)
				{
					createdObjects.Add(export.Value);
				}
			}
			return createdObjects;
		}
		public void Dispose()
		{
			;
		}
	}
	public class MefControllerFactory : DefaultControllerFactory
	{
		private readonly CompositionContainer _compositionContainer;
		public MefControllerFactory(CompositionContainer compositionContainer)
		{
			_compositionContainer = compositionContainer;
		}
		protected override IController GetControllerInstance(RequestContext requestContext, Type controllerType)
		{
			var export = _compositionContainer.GetExports(controllerType, null, null).SingleOrDefault();
			IController result;
			if (null != export)
			{
				result = export.Value as IController;
			}
			else
			{
				result = base.GetControllerInstance(requestContext, controllerType);
				_compositionContainer.ComposeParts(result);
			}
			return result;
		}
	}
}
#T=MEF XmlProcessors Sample
namespace Microshaoft.MEF.Contracts
{
	using System;
	public delegate void ExceptionEventHandler<TSender>(TSender sender, Exception exception);
}
namespace Microshaoft.MEF.Contracts
{
	using System;
	public interface IMefChainedProcessorPart<TContainer, TPartKey, TResult, TParameter>
	{
		IMefChainedProcessorPart<TContainer, TPartKey, TResult, TParameter> Instance
		{
			get;
		}
		int Priority
		{
			get;
		}
		TPartKey Key
		{
			get;
		}
		void OnOnceProcessAction(params TParameter[] parameters);
		TResult OnOnceProcessFunc(params TParameter[] parameters);
		void OnChainedOnceProcessAction(out ChainedProcessNextStep next, params TParameter[] parameters);
		TResult OnChainedOnceProcessFunc(out ChainedProcessNextStep next, params TParameter[] parameters);
		void OnChainedOnceAsyncQueueProcessAction(out ChainedProcessNextStep next, params TParameter[] parameters);
		bool OnChainedOnceAsyncQueueProcessFunc(out ChainedProcessNextStep next, params TParameter[] parameters);
		event ExceptionEventHandler<IMefChainedProcessorPart<TContainer, TPartKey ,TResult, TParameter>> OnCaughtExceptionInContainer;
		string GetRuntimeTypeFullName();
		Type GetRuntimeType();
	}
	public enum ChainedProcessNextStep
	{
		Continue
		, Break
	}
}
namespace Microshaoft.MEF.Contracts
{
	using System;
	using System.Xml;
	public interface IMefPartsCompositionContainer<TPart, TPartKey, TResult, TInvokeParameter>
	{
		TPart[] Parts
		{
			get;
		}
		void ImportManyExports(string path);
		void ChainedInvokeAllPartsProcessAction(params TInvokeParameter[] parameters);
		TResult ChainedInvokeAllPartsProcessFunc(params TInvokeParameter[] parameters);
		TResult InvokeOnePartProcessFunc(TPartKey PartKey, params TInvokeParameter[] parameters);
		void InvokeOnePartProcessAction(TPartKey PartKey, params TInvokeParameter[] parameters);
	}
}
//=============================================================================================================================
namespace Microshaoft.MEF.CompositionContainers
{
	using Microshaoft;
	using Microshaoft.MEF.Contracts;
	using System;
	using System.Collections.Concurrent;
	using System.ComponentModel.Composition;
	using System.Linq;
	public class XmlMessageProcessorsCompositionContainer
					: IMefPartsCompositionContainer
							<
								IMefChainedProcessorPart
											<
												XmlMessageProcessorsCompositionContainer
												, string
												, string
												, string
											>
								, string
								, string
								, string
							>
	{
		[ImportMany(typeof(IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer,string, string, string>))]
		public IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer,string, string, string>[] Parts
		{
			get;
			private set;
		}
		ConcurrentDictionary<string, IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer,string, string, string>> _dictionary;
		public void ImportManyExports(string path)
		{
			MEFHelper.ImportManyExportsComposeParts<XmlMessageProcessorsCompositionContainer>
												(
													path
													, this
												);
			var result = Parts.OrderBy(x => x.Priority);
			if (_dictionary == null)
			{
				_dictionary = new ConcurrentDictionary<string, IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer, string, string, string>>();
			}
			result.ToList().ForEach
							(
								x
								=>
								{
									_dictionary[x.Key] = x;
								}
							);
		}
		public void ChainedInvokeAllPartsProcessAction(params string[] parameters)
		{
			throw new NotImplementedException();
		}
		public string ChainedInvokeAllPartsProcessFunc(params string[] parameters)
		{
			throw new NotImplementedException();
		}
		public string InvokeOnePartProcessFunc(string PartKey, params string[] parameters)
		{
			string r = string.Empty;
			IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer,string, string, string> part;
			if (_dictionary.TryGetValue(PartKey, out part))
			{
				r = part.OnOnceProcessFunc(parameters[0]);
			}
			return r;
		}
		public void InvokeOnePartProcessAction(string PartKey, params string[] parameters)
		{
			throw new NotImplementedException();
		}
	}
}
namespace Microshaoft.MEF.CompositionContainersManagers
{
	using Microshaoft.MEF.CompositionContainers;
	public static class CompositionContainersManager
	{
		private static XmlMessageProcessorsCompositionContainer _xmlMessageProcessorsCompositionContainer =
								new XmlMessageProcessorsCompositionContainer();
		public static XmlMessageProcessorsCompositionContainer xmlMessageProcessorsCompositionContainer
		{
			get { return CompositionContainersManager._xmlMessageProcessorsCompositionContainer; }
			set { CompositionContainersManager._xmlMessageProcessorsCompositionContainer = value; }
		}
	}
}
namespace Microshaoft
{
	using System.ComponentModel.Composition;
	using System.ComponentModel.Composition.Hosting;
	public static class MEFHelper
	{
		public static void ImportManyExportsComposeParts<T>(string path, T attributedPart)
		{
			var catalog = new AggregateCatalog();
			catalog.Catalogs.Add(new DirectoryCatalog(path));
			var container = new CompositionContainer(catalog);
			container.ComposeParts(attributedPart);
		}
	}
}
//=====================================================================================================================
//可扩展部件样例
namespace Microshaoft.MEF.Parts
{
	using Microshaoft.MEF.Contracts;
	using Microshaoft.MEF.CompositionContainers;
	using System;
	using System.ComponentModel.Composition;
	[Export(typeof(IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer, string, string, string>))]
	public class SampleXmlMessageProcessorPart : IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer, string, string, string>
	{
		public IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer, string, string, string> Instance
		{
			get { throw new NotImplementedException(); }
		}
		public int Priority
		{
			get
			{
				return 100;
			}
		}
		public string Key
		{
			get
			{
				return "SampleXmlMessageProcessorPart";
			}
		}
		public void OnOnceProcessAction(params string[] parameters)
		{
			throw new NotImplementedException();
		}
		public string OnOnceProcessFunc(params string[] parameters)
		{
			return "";
		}
		public void OnChainedOnceProcessAction(out ChainedProcessNextStep next, params string[] parameters)
		{
			throw new NotImplementedException();
		}
		public string OnChainedOnceProcessFunc(out ChainedProcessNextStep next, params string[] parameters)
		{
			throw new NotImplementedException();
		}
		public void OnChainedOnceAsyncQueueProcessAction(out ChainedProcessNextStep next, params string[] parameters)
		{
			throw new NotImplementedException();
		}
		public bool OnChainedOnceAsyncQueueProcessFunc(out ChainedProcessNextStep next, params string[] parameters)
		{
			throw new NotImplementedException();
		}
	
		public string GetRuntimeTypeFullName()
		{
			throw new NotImplementedException();
		}
		public Type GetRuntimeType()
		{
			throw new NotImplementedException();
		}
		void SampleXmlMessageProcessorPart_OnCaughtExceptionInContainer(IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer, string, string, string> sender, Exception exception)
		{
			throw new NotImplementedException();
		}
		public event ExceptionEventHandler<IMefChainedProcessorPart<XmlMessageProcessorsCompositionContainer, string, string, string>>
					OnCaughtExceptionInContainer =
													(
														(x, y) =>
														{
														}
													);
	}
}

#T=Memory High Leak
/******************************** Module Header ********************************\
Module Name:  Program.cs
Project:	  CSHighMemoryUsage
Copyright (c) Microsoft Corporation.

CSHighMemoryUsage is designed to show typical causes of high memory usage in .NET 
applications.

1. Long-lived rootless objects
2. Memory leak

This source is subject to the Microsoft Public License.
See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
All other rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES 
OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
\*******************************************************************************/
namespace CSHighMemoryUsage
{
	using System;
	using System.Collections.Specialized;
	class Program
	{
		static void Main(string[] args)
		{
			if (args.Length > 0 && (args[0].StartsWith("-") || args[0].StartsWith("/")))
			{
				string cmd = args[0].Substring(1);

				if (String.Compare(cmd, "r", true) == 0)
				{
					// High memory usage caused by long-lived rootless objects.
					HaveLongLiveRootlessObjects();
				}
				else if (string.Compare(cmd, "l", true) == 0)
				{
					// High memory usage caused by memory leaks.
					LeakMemory();
				}
				else
				{
					PrintInstructions();
				}
			}
			else
			{
				PrintInstructions();
			}

			Console.Write("Press ENTER to exit ...");
			Console.ReadLine();
		}


		static void PrintInstructions()
		{
			Console.WriteLine("CSHighMemoryUsage Instructions:");
			Console.WriteLine("-r   High memory usage caused by long-lived rootless objects");
			Console.WriteLine("-l   High memory usage caused by memory leaks");
		}


		#region HaveLongLiveRootlessObjects

		/// <summary>
		/// The function demonstrates high memory usage caused by long-lived 
		/// rootless objects.
		/// </summary>
		static void HaveLongLiveRootlessObjects()
		{
			Console.Write("Press ENTER to build memory environment ...");
			Console.ReadLine();

			HaveLongLiveRootlessObjectsImpl();

			Console.WriteLine("Please check the current memory usage");

			Console.Write("Press ENTER to trigger a Generation 0 GC ...");
			Console.ReadLine();

			// Force a generation 0 GC.
			GC.Collect(0);

			Console.Write("Press ENTER to trigger a Generation 1 GC ...");
			Console.ReadLine();

			// Force a generation 1 GC again.
			GC.Collect(1);
		}


		private static void HaveLongLiveRootlessObjectsImpl()
		{
			HybridDictionary[] caches = new HybridDictionary[100];

			// Force two GCs to promote the caches object to Gen2. It simulates 
			// that the caches object is a long-lived object.
			GC.Collect();
			GC.Collect();

			for (int i = 0; i < caches.Length; i++)
			{
				// Create a cache object and add it to the cache array.
				HybridDictionary cache = new HybridDictionary();
				caches[i] = cache;

				// Add objects to the cache.
				for (int j = 0; j < 500; j++)
				{
					cache.Add(j, new MyObject());
				}
			}

			// After the function returns, the caches object becomes rootless.
		}

		#endregion


		static void LeakMemory()
		{
		}
	}


	class MyObject
	{
		private int[] buffer = new int[500];
	}
}
#T=MemoryMappedFile CreateViewStream simple
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.IO.MemoryMappedFiles;
	using System.Text;
	//using System.Threading;
	class Program
	{
		// Process A:
		static void Main(string[] args)
		{
			using (MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile(@"D:\EditPlus\User\Microshaoft.Net.C#.CTL"))
			{
				using (MemoryMappedViewStream stream = mmf.CreateViewStream())
				{
					StreamReader sr = new StreamReader(stream, Encoding.Default);
					string s = string.Empty;
					while ((s = sr.ReadLine()) != null)
					{
						Console.WriteLine(s);
					}
					sr.Close();
					sr = null;
				}
			}
		}
	}
}

#T=MemoryMappedFiles 内存映射文件共享内存 进程间通信
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.IO.MemoryMappedFiles;
	using System.Threading;
	class ProgramA
	{
		// Process A:
		static void Main(string[] args)
		{
			using (MemoryMappedFile mmf = MemoryMappedFile.CreateNew("testmap", 10000))
			{
				bool mutexCreated;
				Mutex mutex = new Mutex(true, "testmapmutex", out mutexCreated);
				using (MemoryMappedViewStream stream = mmf.CreateViewStream())
				{
					BinaryWriter writer = new BinaryWriter(stream);
					writer.Write(1);
				}
				mutex.ReleaseMutex();
				Console.WriteLine("Start Process B and press ENTER to continue.");
				Console.ReadLine();
				Console.WriteLine("Start Process C and press ENTER to continue.");
				Console.ReadLine();
				mutex.WaitOne();
				using (MemoryMappedViewStream stream = mmf.CreateViewStream())
				{
					BinaryReader reader = new BinaryReader(stream);
					Console.WriteLine("Process A says: {0}", reader.ReadBoolean());
					Console.WriteLine("Process B says: {0}", reader.ReadBoolean());
					Console.WriteLine("Process C says: {0}", reader.ReadBoolean());
				}
				mutex.ReleaseMutex();
			}
		}
	}
}
//=============================================================================================
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.IO.MemoryMappedFiles;
	using System.Threading;
	class ProgramB
	{
		// Process B:
		static void Main(string[] args)
		{
			try
			{
				using (MemoryMappedFile mmf = MemoryMappedFile.OpenExisting("testmap"))
				{
					Mutex mutex = Mutex.OpenExisting("testmapmutex");
					mutex.WaitOne();
					using (MemoryMappedViewStream stream = mmf.CreateViewStream(1, 0))
					{
						BinaryWriter writer = new BinaryWriter(stream);
						writer.Write(0);
					}
					mutex.ReleaseMutex();
				}
			}
			catch (FileNotFoundException)
			{
				Console.WriteLine("Memory-mapped file does not exist. Run Process A first.");
			}
		}
	}
}
//=============================================================================================
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.IO.MemoryMappedFiles;
	using System.Threading;
	class ProgramC
	{
		// Process C:
		static void Main(string[] args)
		{
			try
			{
				using (MemoryMappedFile mmf = MemoryMappedFile.OpenExisting("testmap"))
				{
					Mutex mutex = Mutex.OpenExisting("testmapmutex");
					mutex.WaitOne();
					using (MemoryMappedViewStream stream = mmf.CreateViewStream(2, 0))
					{
						BinaryWriter writer = new BinaryWriter(stream);
						writer.Write(1);
					}
					mutex.ReleaseMutex();
				}
			}
			catch (FileNotFoundException)
			{
				Console.WriteLine("Memory-mapped file does not exist. Run Process A first, then B.");
			}
		}
	}
}
#T=MessageContract SOAP/WebService WCF
namespace Microsoft.WCF.Documentation
{
	using System;
	using System.Collections.Generic;
	using System.Runtime.Serialization;
	using System.ServiceModel;
	using System.ServiceModel.Channels;
	[ServiceContract(Namespace = "Microsoft.WCF.Documentation")]
	interface IMessagingHello
	{
		[
			OperationContract
				(
					Action = "http://GreetingMessage/Action",
					ReplyAction = "http://HelloResponseMessage/Action"
				)
		]
		HelloResponseMessage Hello(HelloGreetingMessage msg);
	}
	[MessageContract]
	public class HelloResponseMessage
	{
		private string localResponse = String.Empty;
		private string extra = String.Empty;
		[
			MessageBodyMember
				(
					Name = "ResponseToGreeting",
					Namespace = "http://www.examples.com"
				)
		]
		public string Response
		{
			get
			{
				return localResponse;
			}
			set
			{
				localResponse = value;
			}
		}
		[
			MessageHeader
				(
					Name = "OutOfBandData",
					Namespace = "http://www.examples.com",
					MustUnderstand = true
				)
		]
		public string ExtraValues
		{
			get
			{
				return extra;
			}
			set
			{
				this.extra = value;
			}
		}
		/*
		The following is the response message, edited for clarity.
		<s:Envelope>
		<s:Header>
		<a:Action s:mustUnderstand="1">http://HelloResponseMessage/Action</a:Action>
		<h:OutOfBandData s:mustUnderstand="1" xmlns:h="http://www.examples.com">Served by object 13804354.</h:OutOfBandData>
		</s:Header>
		<s:Body>
		<HelloResponseMessage xmlns="Microsoft.WCF.Documentation">
		<ResponseToGreeting xmlns="http://www.examples.com">Service received: Hello.</ResponseToGreeting>
		</HelloResponseMessage>
		</s:Body>	
		</s:Envelope>
		*/
	}
	[MessageContract]
	public class HelloGreetingMessage
	{
		private string localGreeting;
		[
			MessageBodyMember
				(
					Name = "Salutations", 
					Namespace = "http://www.examples.com"
				)
		]
	public string Greeting
	{
		get
		{
			return localGreeting;
		}
		set
		{
			localGreeting = value;
		}
	}
}
	/*
	The following is the request message, edited for clarity.
	<s:Envelope>
	<s:Header>
	<!-- Note: Some header content has been removed for clarity.
	<a:Action>http://GreetingMessage/Action</a:Action> 
	<a:To s:mustUnderstand="1"></a:To>
	</s:Header>
	<s:Body u:Id="_0" xmlns:u="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">
	<HelloGreetingMessage xmlns="Microsoft.WCF.Documentation">
	<Salutations xmlns="http://www.examples.com">Hello.</Salutations>
	</HelloGreetingMessage>
	</s:Body>
	</s:Envelope>
	*/
	class MessagingHello : IMessagingHello
	{
		public HelloResponseMessage Hello(HelloGreetingMessage msg)
		{
			Console.WriteLine("Caller sent: " + msg.Greeting);
			HelloResponseMessage responseMsg = new HelloResponseMessage();
			responseMsg.Response = "Service received: " + msg.Greeting;
			responseMsg.ExtraValues = String.Format("Served by object {0}.", this.GetHashCode().ToString());
			Console.WriteLine("Returned response message.");
			return responseMsg;
		}
	}
}

#T=Mosaic Effect
namespace MasicsEffect
{
	using System;
	using System.Collections.Generic;
//	using System.Text;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.Drawing.Drawing2D;
	class FallBlock
	{
		public RectangleF Range;
		public float CurrentDistance;
		public float preT;
		public float curT;
		public FallBlock(RectangleF range, float curDist, float pT, float cT)
		{
			Range = range;
			CurrentDistance = curDist;
			preT = pT;
			curT = cT;
		}
		public FallBlock(RectangleF range, float curDist)
			: this(range, curDist, 0.0f, 0.0f)
		{
		}
	}
	class MosaicSource
	{
		private Image m_fgImg; // 前景图
		private Image m_bgImg; // 背景图
		private Graphics m_gban; // 图板
		private GraphicsUnit m_GU;
		private BufferedGraphics m_bufGraphics; // 用于双缓冲
		private Graphics m_bufban;
		private List<FallBlock> m_fallRectList; // 掉落矩形列表
		private List<RectangleF> m_reservedRectList; // 剩余的矩形列表
		private RectangleF m_banBound; // 画板边界
		
		private int m_Xrate; // 分解比率
		private int m_Yrate; //
		private float m_startTime; // 起始时间
		private float m_ftime; // 掉落过程的时间长度
		private int m_fallRate;
		private bool m_isInited;
		// ***********************************************
		// 属性
		// ***********************************************
		public Image ForegoundImage
		{
			set { m_fgImg = value; }
			get { return m_fgImg; }
		}
		public Image BackgoundImage
		{
			set { m_bgImg = value; }
			get { return m_bgImg; }
		}
		public Graphics DrawBan
		{
			set { m_gban = value; }
			get { return m_gban; }
		}
		public int FallRate
		{
			set { m_fallRate = value; }
			get { return m_fallRate; }
		}
		public int XRate
		{
			set { m_Xrate = value; }
			get { return m_Xrate; }
		}
		public int YRate
		{
			set { m_Yrate = value; }
			get { return m_Yrate; }
		}
		public float FallTime
		{
			set { m_ftime = value; }
			get { return m_ftime; }
		}
		public float StartTime
		{
			set { m_startTime = value; }
			get { return m_startTime; }
		}
		public RectangleF Bound
		{
			set { m_banBound = value; }
			get { return m_banBound; }
		}
		// ***********************************************
		// 公有方法
		// ***********************************************
		public MosaicSource(Image foregoundImg, Image backgoundImg, Graphics ban,
			int Xrate, int Yrate)
		{
			ForegoundImage = foregoundImg;
			BackgoundImage = backgoundImg;
			DrawBan = ban;
			m_Xrate = Xrate;
			m_Yrate = Yrate;
			m_ftime = 0.0f;
			m_startTime = 0.0f;
			m_fallRate = 4;
			m_isInited = false;
			m_GU = GraphicsUnit.Pixel;
		}
		public MosaicSource(Image foregoundImg, Image backgoundImg, Graphics ban)
			: this(foregoundImg, backgoundImg, ban, 1, 1)
		{
		}
		public bool Initialize()
		{
			if (m_fgImg == null || m_bgImg == null || m_gban == null)
			{
				return false;
			}
			m_banBound = m_fgImg.GetBounds(ref m_GU); // 这里可以改成外部设置
			RectangleF fgRect = m_fgImg.GetBounds(ref m_GU);
			float unitWidth  = fgRect.Width / XRate;
			float unitHeight = fgRect.Height / YRate;
			BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current;
			m_bufGraphics = currentContext.Allocate(m_gban, Rectangle.Round(m_banBound));
			m_bufban = m_bufGraphics.Graphics;
			m_bufban.SmoothingMode = SmoothingMode.HighQuality;
			m_bufban.PixelOffsetMode = PixelOffsetMode.HighSpeed;
			
			m_reservedRectList = new List<RectangleF>();
			m_fallRectList  = new List<FallBlock>();
			// 分解图片
			for (int i = 0; i < YRate; i++ )
			{
				for (int j = 0; j < XRate; j++ )
				{
					RectangleF tmpRectF = new RectangleF();
					tmpRectF.X = j * unitWidth;
					tmpRectF.Y = i * unitHeight;
					tmpRectF.Width  = unitWidth;
					tmpRectF.Height = unitHeight;
					m_reservedRectList.Add(tmpRectF);
				}
			}
			return (m_isInited = true);
		}
		public void PaintOut()
		{
			if (!m_isInited)
			{
				return;
			}
			if (!GenerateFallList() && m_fallRectList.Count == 0)
			{
				return;
			}
			m_bufban.DrawImage(m_bgImg, m_banBound, m_banBound, m_GU);
			foreach (RectangleF rectF in m_reservedRectList)
			{
				m_bufban.DrawImage(m_fgImg, rectF, rectF, m_GU);
			}
			for (int i=0; i<m_fallRectList.Count; i++)
			{
				m_fallRectList[i].CurrentDistance +=
					FallingBody.CalculateDistance(m_fallRectList[i].preT,
												  m_fallRectList[i].curT);
				RectangleF tmpRectF = m_fallRectList[i].Range;
				tmpRectF.Y = m_fallRectList[i].CurrentDistance;
				m_bufban.DrawImage(m_fgImg, tmpRectF, m_fallRectList[i].Range, m_GU);
				m_fallRectList[i].preT = m_fallRectList[i].curT;
				m_fallRectList[i].curT += m_ftime;
			}
			m_bufGraphics.Render(m_gban);
			// Check bound and clear
			List<FallBlock> tmpList = new List<FallBlock>();
			foreach (FallBlock fb in m_fallRectList)
			{
				if (fb.CurrentDistance < m_banBound.Bottom)
				{
					tmpList.Add(fb);
				}
			}
			m_fallRectList.Clear();
			m_fallRectList = tmpList;
		}
		public void Dispose()
		{
			if (m_bufban != null)
			{
				m_bufban.Dispose();
			}
			if (m_bufGraphics != null)
			{
				m_bufGraphics.Dispose();
			}
		}
		// ***********************************************
		// 函数
		// ***********************************************
		private bool GenerateFallList()
		{
			if (m_reservedRectList.Count <= 0)
				return false;
			// Copy the fall list
			if (m_fallRate > m_reservedRectList.Count)
			{
				Random rd = new Random((Int32)DateTime.Now.Ticks);
				for (int i = 0; i < m_reservedRectList.Count; i++)
				{
					m_fallRectList.Add(new FallBlock(m_reservedRectList[i],
						 m_reservedRectList[i].Y, m_startTime, m_startTime + m_ftime));
				}
				m_reservedRectList.Clear();
			}
			else
			{
				Random rd = new Random((Int32)DateTime.Now.Ticks);
				int fallnumber = rd.Next(m_fallRate);
				for (int i = 0; i < fallnumber; i++)
				{
					int pos = rd.Next(m_reservedRectList.Count - 1);
					m_fallRectList.Add(new FallBlock(m_reservedRectList[pos],
							m_reservedRectList[pos].Y, m_startTime , m_startTime + m_ftime));
					m_reservedRectList.RemoveAt(pos);
				}
			}
			return true;
		}
	}
}
namespace MasicsEffect
{
	using System;
//	using System.Collections.Generic;
//	using System.Text;
	static class FallingBody
	{
		const float G = 9.8f;
		const float G_H = G / 2;
		public static float CalculateDistance(float t1, float t2)
		{
			float distance = G_H * (t2 * t2 - t1 * t1);
			return distance;
		}
	}
}
namespace MasicsEffect
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.Text;
	using System.Windows.Forms;
	public partial class mainform : Form
	{
		MosaicSource m_mosaic;
		bool m_isMosaicInited;
		public mainform()
		{
			InitializeComponent();
		}
		private void mainform_Load(object sender, EventArgs e)
		{
			Image fgImg = Image.FromFile(@"testimage.jpg");
			Image bgImg = Image.FromFile(@"bg.jpg");
			m_mosaic = new MosaicSource(fgImg, bgImg, this.CreateGraphics());
		}
		private void mainform_Paint(object sender, PaintEventArgs e)
		{
		}
		private void loopTime_Tick(object sender, EventArgs e)
		{
			if (m_isMosaicInited)
			{
				m_mosaic.PaintOut();
			}
		}
		private void btnStop_Click(object sender, EventArgs e)
		{
			loopTime.Stop();
		}
		private void btnStart_Click(object sender, EventArgs e)
		{
			m_mosaic.XRate = Convert.ToInt32(tbxXrate.Text);
			m_mosaic.YRate = Convert.ToInt32(tbxYrate.Text);
			m_mosaic.StartTime = Convert.ToSingle(tbxStartTime.Text);
			m_mosaic.FallTime = Convert.ToSingle(tbxSpeedTime.Text);
			m_mosaic.FallRate = Convert.ToInt32(tbxFallCount.Text);
			if (!(m_isMosaicInited = m_mosaic.Initialize()))
			{
				MessageBox.Show("马赛克控件初始化失败!");
			}
			loopTime.Start();
		}
	}
}
namespace MasicsEffect
{
	partial class mainform
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.loopTime = new System.Windows.Forms.Timer(this.components);
			this.btnStop = new System.Windows.Forms.Button();
			this.btnStart = new System.Windows.Forms.Button();
			this.label1 = new System.Windows.Forms.Label();
			this.tbxXrate = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.tbxYrate = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.tbxStartTime = new System.Windows.Forms.TextBox();
			this.label4 = new System.Windows.Forms.Label();
			this.tbxSpeedTime = new System.Windows.Forms.TextBox();
			this.label5 = new System.Windows.Forms.Label();
			this.tbxFallCount = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// loopTime
			// 
			this.loopTime.Interval = 40;
			this.loopTime.Tick += new System.EventHandler(this.loopTime_Tick);
			// 
			// btnStop
			// 
			this.btnStop.Location = new System.Drawing.Point(720, 487);
			this.btnStop.Name = "btnStop";
			this.btnStop.Size = new System.Drawing.Size(75, 23);
			this.btnStop.TabIndex = 0;
			this.btnStop.Text = "Stop";
			this.btnStop.UseVisualStyleBackColor = true;
			this.btnStop.Click += new System.EventHandler(this.btnStop_Click);
			// 
			// btnStart
			// 
			this.btnStart.Location = new System.Drawing.Point(720, 458);
			this.btnStart.Name = "btnStart";
			this.btnStart.Size = new System.Drawing.Size(75, 23);
			this.btnStart.TabIndex = 1;
			this.btnStart.Text = "start";
			this.btnStart.UseVisualStyleBackColor = true;
			this.btnStart.Click += new System.EventHandler(this.btnStart_Click);
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(718, 26);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(65, 12);
			this.label1.TabIndex = 2;
			this.label1.Text = "横向个数：";
			// 
			// tbxXrate
			// 
			this.tbxXrate.Location = new System.Drawing.Point(720, 52);
			this.tbxXrate.Name = "tbxXrate";
			this.tbxXrate.Size = new System.Drawing.Size(85, 21);
			this.tbxXrate.TabIndex = 3;
			this.tbxXrate.Text = "5";
			// 
			// label2
			// 
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(718, 94);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(65, 12);
			this.label2.TabIndex = 2;
			this.label2.Text = "纵向个数：";
			// 
			// tbxYrate
			// 
			this.tbxYrate.Location = new System.Drawing.Point(718, 122);
			this.tbxYrate.Name = "tbxYrate";
			this.tbxYrate.Size = new System.Drawing.Size(85, 21);
			this.tbxYrate.TabIndex = 3;
			this.tbxYrate.Text = "5";
			// 
			// label3
			// 
			this.label3.AutoSize = true;
			this.label3.Location = new System.Drawing.Point(718, 168);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(77, 12);
			this.label3.TabIndex = 2;
			this.label3.Text = "起动时间点：";
			// 
			// tbxStartTime
			// 
			this.tbxStartTime.Location = new System.Drawing.Point(718, 201);
			this.tbxStartTime.Name = "tbxStartTime";
			this.tbxStartTime.Size = new System.Drawing.Size(85, 21);
			this.tbxStartTime.TabIndex = 3;
			this.tbxStartTime.Text = "0.0";
			// 
			// label4
			// 
			this.label4.AutoSize = true;
			this.label4.Location = new System.Drawing.Point(718, 242);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(65, 12);
			this.label4.TabIndex = 2;
			this.label4.Text = "下落速度：";
			// 
			// tbxSpeedTime
			// 
			this.tbxSpeedTime.Location = new System.Drawing.Point(718, 270);
			this.tbxSpeedTime.Name = "tbxSpeedTime";
			this.tbxSpeedTime.Size = new System.Drawing.Size(85, 21);
			this.tbxSpeedTime.TabIndex = 3;
			this.tbxSpeedTime.Text = "1.0";
			// 
			// label5
			// 
			this.label5.AutoSize = true;
			this.label5.Location = new System.Drawing.Point(703, 319);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(113, 12);
			this.label5.TabIndex = 2;
			this.label5.Text = "单位时间下落个数：";
			// 
			// tbxFallCount
			// 
			this.tbxFallCount.Location = new System.Drawing.Point(720, 353);
			this.tbxFallCount.Name = "tbxFallCount";
			this.tbxFallCount.Size = new System.Drawing.Size(85, 21);
			this.tbxFallCount.TabIndex = 3;
			this.tbxFallCount.Text = "3";
			// 
			// mainform
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(817, 545);
			this.Controls.Add(this.tbxFallCount);
			this.Controls.Add(this.tbxSpeedTime);
			this.Controls.Add(this.tbxStartTime);
			this.Controls.Add(this.tbxYrate);
			this.Controls.Add(this.tbxXrate);
			this.Controls.Add(this.label5);
			this.Controls.Add(this.label4);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.btnStart);
			this.Controls.Add(this.btnStop);
			this.Name = "mainform";
			this.Text = "Demo";
			this.Paint += new System.Windows.Forms.PaintEventHandler(this.mainform_Paint);
			this.Load += new System.EventHandler(this.mainform_Load);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		#endregion
		private System.Windows.Forms.Timer loopTime;
		private System.Windows.Forms.Button btnStop;
		private System.Windows.Forms.Button btnStart;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.TextBox tbxXrate;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.TextBox tbxYrate;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.TextBox tbxStartTime;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.TextBox tbxSpeedTime;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.TextBox tbxFallCount;
	}
}
namespace MasicsEffect
{
	using System;
//	using System.Collections.Generic;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new mainform());
		}
	}
}
#T=MSN Contacts List XML
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Xml;
	using System.Net;
	class Program
	{
		static void Main(string[] args)
		{
			string username = "microshaoft@live.com";//Put a username here
			string password = "1234"; //Put password here
			string ticket = new TicketAcquirer(username, password).GetTicket();
			if (null == ticket)
			{
				System.Console.WriteLine("Unable to authenticate. Possibly invalid username / passwd");
				return;
			}
			else
				System.Console.WriteLine("Authenticated: " + username);

			List<string> lst = new LiveContacts(username, ticket).GetAllContactIds();
			foreach (string var in lst)
			{
				System.Console.WriteLine(var);
			}


			System.Console.WriteLine("Got " + lst.Count.ToString() + " contacts");			
		}
	}


	public class LiveContacts
	{
		private string _username = "";
		private string _ticket = "";
		public LiveContacts(string username, string ticket)
		{
			this._username = username;
			this._ticket = ticket;
		}

		/// <summary>
		/// Returns the URI Path for the address book
		/// </summary>
		/// <param name="username"></param>
		/// <returns></returns>
		private String getURIPath()
		{
			// Define account information.
			string uri = "https://cumulus.services.live.com/" + _username + "/LiveContacts/";
			return uri;
		}

		/// <summary>
		/// Creates a web request object with the appropriate properties set to talk to the live server
		/// </summary>
		/// <param name="uriPath">Path of the URI for the web request</param>
		/// <param name="ticket">Ticket acquired for this session</param>
		/// <returns>Web request object</returns>
		private HttpWebRequest getHttpWebRequest(String uriPath)
		{
			HttpWebRequest request = (HttpWebRequest)WebRequest.Create(uriPath);
			request.Headers.Add("Authorization", "WLID1.0 t=\"" + _ticket + "\"");  // Add the authentication header
			request.AllowAutoRedirect = false;
			request.UserAgent = "Sample Live App";
			request.ContentType = "text/xml";
			request.Pipelined = false;
			request.ProtocolVersion = HttpVersion.Version10;
			request.CookieContainer = new CookieContainer();
			return request;
		}

		public List<String> GetAllContactIds()
		{
			List<String> contactids = new List<string>();
			HttpWebRequest request = getHttpWebRequest(getURIPath());
			request.Method = "GET";

			HttpWebResponse response;

			response = (HttpWebResponse)request.GetResponse();

			if (response.StatusCode != HttpStatusCode.OK || response.ContentLength == 0)
			{
				throw new ApplicationException("Get ALL faield");
			}

			XmlDocument xmldoc = new XmlDocument();
			xmldoc.Load(response.GetResponseStream());

			Console.WriteLine(xmldoc.InnerXml);

			XmlNode contactsNode = xmldoc.SelectSingleNode("LiveContacts/Contacts");
			
			if (null == contactsNode)
				return new List<String>();

			XmlNodeList contacts = contactsNode.ChildNodes;
			foreach (XmlNode contact in contacts)
			{
				contactids.Add(contact.SelectSingleNode("ID").InnerText);
			}


			return contactids;
		}
	};

	public class TicketAcquirer
	{
		private const string applicationId = "10"; // An arbitrary value that will be defined in the next non-alpha release
		private string soapEnvelope = null;

		public TicketAcquirer(String userName, String password)
		{
			soapEnvelope = @"<s:Envelope
				xmlns:s = ""http://www.w3.org/2003/05/soap-envelope""
				xmlns:wsse = ""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd""
				xmlns:saml = ""urn:oasis:names:tc:SAML:1.0:assertion""
				xmlns:wsp = ""http://schemas.xmlsoap.org/ws/2004/09/policy""
				xmlns:wsu = ""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd""
				xmlns:wsa = ""http://www.w3.org/2005/08/addressing""
				xmlns:wssc = ""http://schemas.xmlsoap.org/ws/2005/02/sc""
				xmlns:wst = ""http://schemas.xmlsoap.org/ws/2005/02/trust"">
				<s:Header>
				<wlid:ClientInfo xmlns:wlid = ""http://schemas.microsoft.com/wlid"">
				<wlid:ApplicationID>" + applicationId + @"</wlid:ApplicationID>
				</wlid:ClientInfo>
				<wsa:Action s:mustUnderstand = ""1"">http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue</wsa:Action>
				<wsa:To s:mustUnderstand = ""1"">https://dev.login.live.com/wstlogin.srf</wsa:To>
				<wsse:Security>
				<wsse:UsernameToken wsu:Id = ""user"">
				<wsse:Username>" + userName + @"</wsse:Username>
				<wsse:Password>" + password + @"</wsse:Password>
				</wsse:UsernameToken>
				</wsse:Security>
				</s:Header>
				<s:Body>
				<wst:RequestSecurityToken Id = ""RST0"">
				<wst:RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</wst:RequestType>
				<wsp:AppliesTo>
				<wsa:EndpointReference>
				<wsa:Address>http://live.com</wsa:Address>
				</wsa:EndpointReference>
				</wsp:AppliesTo>
				<wsp:PolicyReference URI = ""MBI""></wsp:PolicyReference>
				</wst:RequestSecurityToken>
				</s:Body>
				</s:Envelope>
				";
		}

		/* methods */
		public string GetTicket()
		{
			const string url = @"https://dev.login.live.com/wstlogin.srf";
			WebRequest request = WebRequest.Create(url);
			request.Method = "POST";
			request.ContentType = "application/soap+xml; charset=UTF-8";
			request.Timeout = 10 * 1000; // Wait for at most 10 seconds
			byte[] bytes = System.Text.Encoding.UTF8.GetBytes(soapEnvelope);
			request.GetRequestStream().Write(bytes, 0, bytes.Length);
			request.GetRequestStream().Close();
			WebResponse response;
			response = request.GetResponse();
			string xml;
			using (System.IO.StreamReader reader = new System.IO.StreamReader(response.GetResponseStream()))

			xml = reader.ReadToEnd();
			response.Close();

			Console.WriteLine(xml);
			XmlDocument document = new XmlDocument();
			document.LoadXml(xml);
			XmlNamespaceManager nsManager = new XmlNamespaceManager(document.NameTable);
			nsManager.AddNamespace("wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
			XmlNode node = document.SelectSingleNode(@"//wsse:BinarySecurityToken/text()", nsManager);
			if (node == null)
				return null; // The wsse:BinarySecurityToken element is missing. Examine the xml for error information
			else
				return node.Value;
		}
	}

}
#T=MSN GUI MSAA On Property Change
/*
C:\WINDOWS\Microsoft.NET\Framework\v3.5\csc.exe /r:"C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\UIAutomationTypes.dll";"C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\UIAutomationClient.dll";"C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\WindowsBase.dll"
*/
namespace Microshaoft
{

	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Windows.Automation;
	using System.Collections;
	using System.Runtime.InteropServices;

	class FocusElementPropertyChangedTracker
	{

		public FocusElementPropertyChangedTracker(string WindowTitle)
		{
			_WindowTitle = WindowTitle;
			Startup();
		}

		/// <summary>
		/// Entry point.
		/// </summary>
		/// <param name="args">Command-line arguments; not used.</param>
		private int msnProccessID = 0;
		public static void Main(string[] args)
		{
			Console.Title = "Focus UI Automation Element Property Changed Tracker Sample";
			Console.WriteLine("Please wait while UI Automation initializes...");
			FocusElementPropertyChangedTracker tracker = new FocusElementPropertyChangedTracker(args[0]);
			Console.WriteLine(args[0]);
			Console.WriteLine("Tracking Focus UI Automation Element Property Changed, Press Enter to quit.");
			Console.ReadLine();
			Automation.RemoveAllEventHandlers();
		}

		void Startup()
		{
			Automation.AddAutomationFocusChangedEventHandler(OnFocusChanged);
			propChangeHandler = new AutomationPropertyChangedEventHandler(OnPropertyChange);
		}

		private AutomationPropertyChangedEventHandler propChangeHandler;

		private void OnFocusChanged(object src, AutomationFocusChangedEventArgs e)
		{
			try
			{
				AutomationElement elementFocused = src as AutomationElement;
				if (IsMsnElement(elementFocused))
				{
					//Console.WriteLine("Focused element: ");
					//Console.WriteLine("  Type: " + elementFocused.Current.LocalizedControlType);
					//Console.WriteLine("  Name: " + elementFocused.Current.Name);
					//Console.WriteLine();

					if (IsTreeItem(elementFocused))
					{
						if (propChangeHandler != null)
						{
							Automation.RemoveAutomationPropertyChangedEventHandler(elementFocused, propChangeHandler);
						}
						Automation.AddAutomationPropertyChangedEventHandler
										(
											elementFocused
											, TreeScope.Element
											, propChangeHandler
											, AutomationElement.NameProperty
										);
					}
				}
			}
			catch (ElementNotAvailableException)
			{
				return;
			}

		}
		private void OnPropertyChange(object src, AutomationPropertyChangedEventArgs e)
		{
			AutomationElement sourceElement = src as AutomationElement;
			Console.WriteLine("Change to: {0}", sourceElement.Current.Name);
		}
		private string _WindowTitle = "Windows Live Messenger 试用版";
		private bool IsMsnElement(AutomationElement element)
		{
			if (msnProccessID == 0)
			{

				IntPtr msnHandle = FindWindow(null, _WindowTitle);
				Console.WriteLine(msnHandle);
				AutomationElement msnElement = AutomationElement.FromHandle(msnHandle);
				msnProccessID = msnElement.Current.ProcessId;
			}
			return element.Current.ProcessId == msnProccessID;
		}

		private bool IsTreeItem(AutomationElement element)
		{
			return element.Current.ControlType == ControlType.TreeItem;
		}

		//p/Invoke
		[DllImport("user32.dll", CharSet = CharSet.Auto)]
		internal static extern IntPtr FindWindow(string className, string windowName);
	}
}

#T=MSN GUI MSAA UIAutomation FocusTracker
/*


/r:"C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\UIAutomationTypes.dll";"C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\UIAutomationClient.dll";"C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\WindowsBase.dll"
*/
/*******************************************************************************
 *
 * File: FocusTracker.cs
 *
 * Description: This is a simple console application that might be used as a 
 * starting-point for an application that uses UI Automation to track events on 
 * the desktop, such as a screen reader.
 * 
 * The program announces when the input focus changes. If the focus moves to a 
 * different application window, the name (usually the caption) of the window is 
 * announced. If the focus moves within an application window, the type and name
 * of the control being read are announced.
 * 
 * To know when the focus switches from one application to another, a TreeWalker 
 * is used to find the parent window, and that window is compared with the last 
 * window that had focus.
 * 
 * 
 *  This file is part of the Microsoft Windows SDK Code Samples.
 * 
 *  Copyright (C) Microsoft Corporation.  All rights reserved.
 * 
 * This source code is intended only as a supplement to Microsoft
 * Development Tools and/or on-line documentation.  See these other
 * materials for detailed information regarding Microsoft code samples.
 * 
 * THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 * PARTICULAR PURPOSE.
 * 
 ******************************************************************************/

namespace FocusTracker
{

	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Windows.Automation;
	using System.Collections;
	using System.Runtime.InteropServices;

	class Tracker
	{
		//AutomationElement lastTopLevelWindow;

		/// <summary>
		/// Constructor.
		/// </summary>
		public Tracker()
		{
			Startup();
		}

		/// <summary>
		/// Entry point.
		/// </summary>
		/// <param name="args">Command-line arguments; not used.</param>


		public int msnProccessID=0;
		public static void Main(string[] args)
		{
			Console.Title = "UI Automation Focus-tracking Sample";
			Console.WriteLine("Please wait while UI Automation initializes...");
			Tracker reader = new Tracker();
			Console.WriteLine("Tracking focus. Press Enter to quit.");
			Console.ReadLine();
			Automation.RemoveAllEventHandlers();
		}

		/// <summary>
		/// Initialization.
		/// </summary>
		void Startup()
		{
			Automation.AddAutomationFocusChangedEventHandler(OnFocusChanged);
		}


		/// <summary>
		/// Retrieves the top-level window that contains the specified 
		/// UI Automation element.
		/// </summary>
		/// <param name="element">The contained element.</param>
		/// <returns>The  top-level window element.</returns>
		private AutomationElement GetTopLevelWindow(AutomationElement element)
		{
			TreeWalker walker = TreeWalker.ControlViewWalker;
			AutomationElement elementParent;
			AutomationElement node = element;
			try  // In case the element disappears suddenly, as menu items are 
				 // likely to do.
			{
				if (node == AutomationElement.RootElement)
				{
					return node;
				}
				// Walk up the tree to the child of the root.
				while (true)
				{
					elementParent = walker.GetParent(node);
					if (elementParent == null)
					{
						return null;
					}
					if (elementParent == AutomationElement.RootElement)
					{
						break;
					}
					node = elementParent;
				}
			}
			catch (ElementNotAvailableException)
			{
				node = null;
			}
			catch (ArgumentNullException)
			{
				node = null;
			}
			return node;
		}


		/// <summary>
		/// Handles focus-changed events. If the element that received focus is 
		/// in a different top-level window, announces that. If not, just
		///  announces which element received focus.
		/// </summary>
		/// <param name="src">Object that raised the event.</param>
		/// <param name="e">Event arguments.</param>
		private void OnFocusChanged(object src, AutomationFocusChangedEventArgs e)
		{
			try
			{
				AutomationElement elementFocused = src as AutomationElement;

				if (IsMsnElement(elementFocused))
				{
				
					Console.WriteLine("Focused element: ");
					Console.WriteLine("  Type: " + elementFocused.Current.LocalizedControlType);
					Console.WriteLine("  Name: " + elementFocused.Current.Name);
					Console.WriteLine();
				}
			}
			catch (ElementNotAvailableException)
			{
				return;
			}
		}

		private bool IsMsnElement(AutomationElement element)
		{
			if (msnProccessID == 0)
			{
				IntPtr msnHandle = FindWindow(null, "Windows Live Messenger");
				AutomationElement msnElement = AutomationElement.FromHandle(msnHandle);
				msnProccessID = msnElement.Current.ProcessId;
			}
			return element.Current.ProcessId == msnProccessID;
		}
		[DllImport("user32.dll", CharSet = CharSet.Auto)]
		internal static extern IntPtr FindWindow(string className, string windowName);
	}
}

#T=MSN Hack InsertMenu
namespace ConsoleApplication
{
	using System;

	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			int hwnd = Win32.FindWindow("MSBLWindowClass","Windows Live Messenger");
			Console.WriteLine(hwnd);
			int menu = Win32.GetMenu(hwnd);
			Console.WriteLine(menu);
			//InsertMenu(menu, 10, "Reset Systemmenu");
			//InsertMenu(0, ItemFlags.mfByPosition | ItemFlags.mfString, ID, "于溪h");
			Win32.InsertMenu(menu,6, (int) (Win32.ItemFlags.mfByPosition | Win32.ItemFlags.mfString), 0, "于溪h");
			//InsertMenu(m_SysMenu, Pos, (Int32)Flags, ID, Item)
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}

}
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	using System.Drawing;
	/// <summary>
	/// Summary description for Win32.
	/// </summary>
	public class Win32
	{
		// The WM_COMMAND message is sent when the user selects a command item from a menu, 
		// when a control sends a notification message to its parent window, or when an 
		// accelerator keystroke is translated.
		public const int WM_COMMAND = 0x111;


		[DllImport("user32.dll")]
		public static extern int CreateMenu();

		[DllImport("user32.dll")]
		public static extern int GetMenu(int hWnd);


		[DllImport("user32.dll")]
		public static extern bool InsertMenuItem(
			int hMenu, int itemindex, bool fByPosition, ref APIsStructs.MENUITMEINFO infos);

[DllImport("user32", SetLastError = true, CharSet = CharSet.Auto)]
public static extern bool InsertMenu(int hmenu, uint position, uint flags,
       uint item_id, [MarshalAs(UnmanagedType.LPTStr)]string item_text);

public enum ItemFlags
{ // The item ...
   mfUnchecked    = 0x00000000,    // ... is not checked
   mfString       = 0x00000000,    // ... contains a string as label
   mfDisabled     = 0x00000002,    // ... is disabled
   mfGrayed       = 0x00000001,    // ... is grayed
   mfChecked      = 0x00000008,    // ... is checked
   mfPopup        = 0x00000010,    // ... Is a popup menu. Pass the
                                   //     menu handle of the popup
                                   //     menu into the ID parameter.
   mfBarBreak     = 0x00000020,    // ... is a bar break
   mfBreak        = 0x00000040,    // ... is a break
   mfByPosition   = 0x00000400,    // ... is identified by the position
   mfByCommand    = 0x00000000,    // ... is identified by its ID
   mfSeparator    = 0x00000800     // ... is a seperator (String and
                                   //     ID parameters are ignored).
}


[StructLayoutAttribute(LayoutKind.Sequential)]
			public struct MENUITMEINFO
		{
			public int cbSize;
			public APIsEnums.MenuItemMasks fMask;
			public APIsEnums.MenuItemTypes fType;
			public APIsEnums.MenuItemStates fState;
			public int wID;
			public IntPtr hSubMenu;
			public IntPtr hbmpChecked;
			public IntPtr hbmpUnchecked;
			public int dwItemData;
			public IntPtr dwTypeData;
			public int cch;
			public IntPtr hbmpItem;
		}



        public const int GW_HWNDNEXT = 2; public const int GW_HWNDPREV = 3; public const int GW_CHILD = 5; public const int MF_BYPOSITION = 0x400;
        [DllImport("User32.dll")]
        public static extern int GetDesktopWindow();
        [DllImport("User32.dll")]
        public static extern int GetTopWindow(int hwndParent);
        [DllImport("User32.dll")]
        public static extern int GetWindow(int hwndSibling, int wFlag);
        [DllImport("User32.dll")]
        public static extern int GetWindowText(int hWnd, System.Text.StringBuilder text, int count);
        [DllImport("User32.dll")]
        public static extern UInt32 RealGetWindowClass(int hWnd, System.Text.StringBuilder text, UInt32 count);
        [DllImport("User32.dll")]
        public static extern int SetParent(int hWndChild, int hWndNewParent);

        [DllImport("User32.dll")]
        public static extern int GetSubMenu(int hMenu, int nPos);
        [DllImport("User32.dll")]
        public static extern uint GetMenuItemID(int hMenu, int nPos);
        [DllImport("User32.dll")]
        public static extern int GetMenuItemCount(int hMenu);
        [DllImport("User32.dll")]
        public static extern int GetMenuString(int hMenu, uint uIDItem, System.Text.StringBuilder lpString, int nMaxCount, uint uFlag);	

		// The FindWindow function retrieves a handle to the top-level window whose class name
		// and window name match the specified strings. This function does not search child windows.
		// This function does not perform a case-sensitive search.
		[DllImport("User32.dll")]
		public static extern int FindWindow(string strClassName, string strWindowName);

		// The FindWindowEx function retrieves a handle to a window whose class name 
		// and window name match the specified strings. The function searches child windows, beginning
		// with the one following the specified child window. This function does not perform a case-sensitive search.
		[DllImport("User32.dll")]
		public static extern int FindWindowEx(int hwndParent, int hwndChildAfter, string strClassName, string strWindowName);


		// The SendMessage function sends the specified message to a 
		// window or windows. It calls the window procedure for the specified 
		// window and does not return until the window procedure has processed the message. 
		[DllImport("User32.dll")]
		public static extern Int32 SendMessage(
			int hWnd,               // handle to destination window
			int Msg,                // message
			int wParam,             // first message parameter
			[MarshalAs(UnmanagedType.LPStr)] string lParam); // second message parameter

		[DllImport("User32.dll")]
		public static extern Int32 SendMessage(
			int hWnd,               // handle to destination window
			int Msg,                // message
			int wParam,             // first message parameter
			int lParam);			// second message parameter

		public Win32()
		{
			
		}

		~Win32()
		{
		}

	}

	public class APIsStructs
	{
		#region DLLVERSIONINFO
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct DLLVERSIONINFO
		{
			public int cbSize;
			public int dwMajorVersion;
			public int dwMinorVersion;
			public int dwBuildNumber;
			public int dwPlatformID;
		}
		#endregion
		#region DLLVERSIONINFO2
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct DLLVERSIONINFO2
		{
			public DLLVERSIONINFO info1;
			public int dwFlags;
			ulong ullVersion;
		}
		#endregion
		#region WIN32_FIND_DATA
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
			public struct WIN32_FIND_DATA
		{
			public uint fileAttributes;
			public System.Runtime.InteropServices.ComTypes.FILETIME creationTime;
			public System.Runtime.InteropServices.ComTypes.FILETIME lastAccessTime;
			public System.Runtime.InteropServices.ComTypes.FILETIME lastWriteTime;
			public uint fileSizeHigh;
			public uint fileSizeLow;
			public uint reserved0;
			public uint reserved1;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst=260)]
			public string fileName;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst=14)]
			public string alternateFileName;
		}
		#endregion

		#region SHITEMIDLIST
		[StructLayout(LayoutKind.Sequential)]
			public struct SHITEMIDLIST
		{
			public SHITEMID[] mkid;
		}
		#endregion
		#region SHITEMID
		[StructLayout(LayoutKind.Sequential)]
			public struct SHITEMID
		{
			public ushort cb;
			public byte abID;
		}
		#endregion
		#region SHFILEOPSTRUCT
		/// <summary>
		/// Contains information that the SHFileOperation function uses to perform file operations.
		/// </summary>
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
		public struct SHFILEOPSTRUCT
		{
			/// <summary>
			/// Window handle to the dialog box to display information about the status of the file operation.
			/// </summary>
			public IntPtr hwnd;
			/// <summary>
			/// Value that indicates which operation to perform.
			/// </summary>
			public UInt32 wFunc;
			/// <summary>
			/// Address of a buffer to specify one or more source file names.
			/// </summary>
			public IntPtr pFrom;
			/// <summary>
			/// Address of a buffer to contain the name of the destination file or directory.
			/// </summary>
			public IntPtr pTo;
			/// <summary>
			/// Flags that control the file operation (should use APISEnums.FOF).
			/// </summary>
			public UInt16 fFlags;
			/// <summary>
			/// Value that receives TRUE if the user aborted any file operations before they were completed, or FALSE otherwise.
			/// </summary>
			public Int32 fAnyOperationsAborted;
			/// <summary>
			/// A handle to a name mapping object containing the old and new names of the renamed files.
			/// </summary>
			public IntPtr hNameMappings;
			/// <summary>
			/// Address of a string to use as the title of a progress dialog box.
			/// </summary>
			[MarshalAs(UnmanagedType.LPWStr)] public string lpszProgressTitle;
		}
		#endregion
		#region SHELLEXECUTEINFO
		[StructLayoutAttribute(LayoutKind.Sequential)]
			public struct SHELLEXECUTEINFO
		{
			public int cbSize;
			public APIsEnums.ShellExecuteFlags fMask;
			public IntPtr hWnd;
			public string lpVerb;
			public string lpFile;
			public string lpParameters;
			public string lpDirectory;
			public APIsEnums.ShowWindowStyles nShow;
			public IntPtr hInstApp;
			public IntPtr lpIDList;
			public int lpClass;
			public int hkeyClass;
			public int dwHotKey;
			public IntPtr hIcon;
			public IntPtr hProcess;
		}
		#endregion
		#region SHFILEINFO
		[StructLayout(LayoutKind.Sequential)]
		public struct SHFILEINFO
		{
			public SHFILEINFO(bool b)
			{
				hIcon=IntPtr.Zero;iIcon=0;dwAttributes=0;szDisplayName="";szTypeName="";
			}
			public IntPtr hIcon;
			public int iIcon;
			public uint dwAttributes;
			[MarshalAs(UnmanagedType.LPStr, SizeConst=260)]
			public string szDisplayName;
			[MarshalAs(UnmanagedType.LPStr, SizeConst=80)]
			public string szTypeName;
		};
		#endregion

		#region STRRET
		[StructLayout(LayoutKind.Sequential)]
			public struct STRRET
		{
			public int uType;
			//		IntPtr pOleStr;
			//		uint uOffset;
			[MarshalAs(UnmanagedType.ByValArray, SizeConst=260)] public byte[] cStr;
		}
		#endregion
		#region MENUITMEINFO
		[StructLayoutAttribute(LayoutKind.Sequential)]
			public struct MENUITMEINFO
		{
			public int cbSize;
			public APIsEnums.MenuItemMasks fMask;
			public APIsEnums.MenuItemTypes fType;
			public APIsEnums.MenuItemStates fState;
			public int wID;
			public IntPtr hSubMenu;
			public IntPtr hbmpChecked;
			public IntPtr hbmpUnchecked;
			public int dwItemData;
			public IntPtr dwTypeData;
			public int cch;
			public IntPtr hbmpItem;
		}
		#endregion
		#region StartupInfo
		[StructLayout(LayoutKind.Sequential)]
			public class StartupInfo
		{
			public int cb;
			public String lpReserved;
			public String lpDesktop;
			public String lpTitle;
			public int dwX;
			public int dwY;
			public int dwXSize;
			public int dwYSize;
			public int dwXCountChars;
			public int dwYCountChars;
			public int dwFillAttribute;
			public int dwFlags;
			public UInt16 wShowWindow;
			public UInt16 cbReserved2;
			public Byte  lpReserved2;
			public int hStdInput;
			public int hStdOutput;
			public int hStdError;
		}
		#endregion
		#region ProcessInformation
		[StructLayout(LayoutKind.Sequential)]
			public class ProcessInformation
		{
			public int hProcess;
			public int hThread;
			public int dwProcessId;
			public int dwThreadId;
		}
		#endregion
		#region MENUITEMINFO
		[StructLayout(LayoutKind.Sequential)]
			public struct MENUITEMINFO
		{
			public uint cbSize;
			public uint fMask;
			public uint fType;
			public uint fState;
			public int	wID;
			public int	/*HMENU*/	  hSubMenu;
			public int	/*HBITMAP*/   hbmpChecked;
			public int	/*HBITMAP*/	  hbmpUnchecked;
			public int	/*ULONG_PTR*/ dwItemData;
			public String dwTypeData;
			public uint cch;
			public int /*HBITMAP*/ hbmpItem;
		}
		#endregion
		#region FORMATETC
		[StructLayout(LayoutKind.Sequential)]
		public struct FORMATETC
		{
			public APIsEnums.ClipboardFormats	cfFormat;
			public uint ptd;
			public APIsEnums.TargetDevices		dwAspect;
			public int			lindex;
			public APIsEnums.StorageMediumTypes		tymed;
		}
		#endregion
		#region STGMEDIUM
		[StructLayout(LayoutKind.Sequential)]
			public struct STGMEDIUM
		{
			public uint tymed;
			public uint hGlobal;
			public uint pUnkForRelease;
		}
		#endregion
		#region CMINVOKECOMMANDINFO
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
			public struct CMINVOKECOMMANDINFO
		{
			public int cbSize;				// sizeof(CMINVOKECOMMANDINFO)
			public int fMask;				// any combination of CMIC_MASK_*
			public IntPtr hwnd;				// might be NULL (indicating no owner window)
			public IntPtr lpVerb;			// either a string or MAKEINTRESOURCE(idOffset)
			public IntPtr lpParameters;		// might be NULL (indicating no parameter)
			public IntPtr lpDirectory;		// might be NULL (indicating no specific directory)
			public int nShow;				// one of SW_ values for ShowWindow() API
			public int dwHotKey;
			public IntPtr hIcon;
		}
		#endregion

		#region LV_ITEM
		[StructLayoutAttribute(LayoutKind.Sequential)]
		public struct LV_ITEM
		{
			public APIsEnums.ListViewItemFlags mask;
			public Int32 iItem;
			public Int32 iSubItem;
			public APIsEnums.ListViewItemStates state;
			public APIsEnums.ListViewItemStates stateMask;
			public String pszText;
			public Int32 cchTextMax;
			public Int32 iImage;
			public IntPtr lParam;
			public Int32 iIndent;
		}
		#endregion
		#region LVCOLUMN
		[StructLayoutAttribute(LayoutKind.Sequential)]
			public struct LVCOLUMN
		{
			public Int32 mask;
			public Int32 fmt;
			public Int32 cx;
			public string pszText;
			public Int32 cchTextMax;
			public Int32 iSubItem;
			public Int32 iImage;
			public Int32 iOrder;
		}
		#endregion
		#region LVHITTESTINFO
		[StructLayoutAttribute(LayoutKind.Sequential)]
		public struct LVHITTESTINFO
		{
			public POINTAPI pt;
			public int flags;
			public Int32 iItem;
			public Int32 iSubItem;
		}
		#endregion
		#region NMLVDISPINFO
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct NMLVDISPINFO
		{
			public NMHDR hdr;
			public LV_ITEM lvitem;
		}
		#endregion
		#region NMLISTVIEW
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct NMLISTVIEW
		{
			public NMHDR nmhdr;
			public int iItem;
			public int iSubItem;
			public uint uNewState;
			public uint uOldState;
			public uint uChanged;
			public POINTAPI ptAction;
			public IntPtr lParam;
			public bool NewSelected
			{
				get
				{
					return ((APIsEnums.ListViewItemStates)uNewState & APIsEnums.ListViewItemStates.SELECTED) == APIsEnums.ListViewItemStates.SELECTED;
				}
			}
			public bool OldSelected
			{
				get
				{
					return ((APIsEnums.ListViewItemStates)uOldState & APIsEnums.ListViewItemStates.SELECTED) == APIsEnums.ListViewItemStates.SELECTED;
				}
			}
			public bool NewCheck
			{
				get
				{
					try
					{
						return uNewState >= 0x1000 ? ((uNewState & (uint)APIsEnums.ListViewItemStates.STATEIMAGEMASK) >> 12) - 1 > 0 : false;
					}
					catch
					{
						return false;
					}
				}
			}
			public bool OldCheck
			{
				get
				{
					try
					{
						return uOldState >= 0x1000 ? ((uOldState & (uint)APIsEnums.ListViewItemStates.STATEIMAGEMASK) >> 12) - 1 > 0 : false;
					}
					catch
					{
						return false;
					}
				}
			}
			public bool NewFocused
			{
				get
				{
					return ((APIsEnums.ListViewItemStates)uNewState & APIsEnums.ListViewItemStates.FOCUSED) == APIsEnums.ListViewItemStates.FOCUSED;
				}
			}
			public bool OldFocused
			{
				get
				{
					return ((APIsEnums.ListViewItemStates)uOldState & APIsEnums.ListViewItemStates.FOCUSED) == APIsEnums.ListViewItemStates.FOCUSED;
				}
			}
			public bool Select
			{
				get
				{
					return !OldSelected && NewSelected;
				}
			}
			public bool UnSelect
			{
				get
				{
					return OldSelected && !NewSelected;
				}
			}
			public bool Focus
			{
				get
				{
					return !OldFocused && NewFocused;
				}
			}
			public bool UnFocus
			{
				get
				{
					return OldFocused && !NewFocused;
				}
			}
			public bool Check
			{
				get
				{
					return !OldCheck && NewCheck;
				}
			}
			public bool UnCheck
			{
				get
				{
					return OldCheck && !NewCheck;
				}
			}
		}
		#endregion
		#region HDITEM
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct HDITEM
		{
			public	APIsEnums.HeaderItemFlags mask;
			public	int     cxy;
			public	IntPtr  pszText;
			public	IntPtr  hbm;
			public	int     cchTextMax;
			public	int     fmt;
			public	int     lParam;
			public	int     iImage;
			public	int     iOrder;
		}
		#endregion
		#region HD_HITTESTINFO
		[StructLayout(LayoutKind.Sequential)]
			public struct HD_HITTESTINFO
		{
			public POINTAPI pt;
			public APIsEnums.HeaderControlHitTestFlags flags;
			public int iItem;
		}
		#endregion

		#region POINTAPI
		[StructLayoutAttribute(LayoutKind.Sequential)]
		public struct POINTAPI
		{
			public POINTAPI(System.Drawing.Point p) {x = p.X; y = p.Y;}
			public POINTAPI(Int32 X, Int32 Y) {x = X; y = Y;}
			public Int32 x;
			public Int32 y;
		}
		#endregion
		#region RECT
		[StructLayout(LayoutKind.Sequential)]
		public struct RECT
		{
			public RECT(System.Drawing.Rectangle rectangle)
			{	left = rectangle.Left; top = rectangle.Top;
				right = rectangle.Right; bottom = rectangle.Bottom;}
			public int left;
			public int top;
			public int right;
			public int bottom;
		}
		#endregion
		#region SIZE
		[StructLayout(LayoutKind.Sequential)]
		public struct SIZE
		{
			public int cx;
			public int cy;
		}
		#endregion

		#region NMHDR
//		[StructLayout(LayoutKind.Sequential)]
			public struct NMHDR
		{
			public IntPtr hwndFrom;
			public int idFrom;
			public int code;
		}
		#endregion
		#region NMCUSTOMDRAW
		[StructLayout(LayoutKind.Sequential)]
		public struct NMCUSTOMDRAW
		{
			public NMHDR hdr;
			public int dwDrawStage;
			public IntPtr hdc;
			public RECT rc;
			public uint dwItemSpec;
			public uint uItemState;
			public IntPtr lItemlParam;
		}
		#endregion
		#region NMLVCUSTOMDRAW
		[StructLayout(LayoutKind.Sequential)]
		public struct NMLVCUSTOMDRAW
		{
			public NMCUSTOMDRAW nmcd;
			public int clrText;
			public int clrTextBk;
			public int iSubItem;
			public int dwItemType;
			public int clrFace;
			public int iIconEffect;
			public int iIconPhase;
			public int iPartId;
			public int iStateId;
			public RECT rcText;
			public uint uAlign;
		}
		#endregion
		#region NMTVCUSTOMDRAW
		[StructLayout(LayoutKind.Sequential)]
		public struct NMTVCUSTOMDRAW
		{
			public NMCUSTOMDRAW nmcd;
			public uint clrText;
			public uint clrTextBk;
			public int iLevel;
		}
		#endregion

		#region BITMAPINFO_FLAT
		[StructLayout(LayoutKind.Sequential)]
			public struct BITMAPINFO_FLAT
		{
			public int      bmiHeader_biSize;
			public int      bmiHeader_biWidth;
			public int      bmiHeader_biHeight;
			public short    bmiHeader_biPlanes;
			public short    bmiHeader_biBitCount;
			public int      bmiHeader_biCompression;
			public int      bmiHeader_biSizeImage;
			public int      bmiHeader_biXPelsPerMeter;
			public int      bmiHeader_biYPelsPerMeter;
			public int      bmiHeader_biClrUsed;
			public int      bmiHeader_biClrImportant;
			[MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValArray, SizeConst=1024)]
			public byte[] bmiColors;
		}
		#endregion
		#region BITMAPINFOHEADER
		[StructLayout(LayoutKind.Sequential)]
			public class BITMAPINFOHEADER
		{
			public int      biSize = Marshal.SizeOf(typeof(BITMAPINFOHEADER));
			public int      biWidth;
			public int      biHeight;
			public short    biPlanes;
			public short    biBitCount;
			public int      biCompression;
			public int      biSizeImage;
			public int      biXPelsPerMeter;
			public int      biYPelsPerMeter;
			public int      biClrUsed;
			public int      biClrImportant;
		}
		#endregion

		#region MSG
		[StructLayout(LayoutKind.Sequential)]
		public struct MSG
		{
			public IntPtr hwnd;
			public int message;
			public IntPtr wParam;
			public IntPtr lParam;
			public int time;
			public int pt_x;
			public int pt_y;
		}
		#endregion
		#region PAINTSTRUCT
		[StructLayout(LayoutKind.Sequential)]
		public struct PAINTSTRUCT
		{
			public IntPtr hdc;
			public int fErase;
			public System.Drawing.Rectangle rcPaint;
			public int fRestore;
			public int fIncUpdate;
			public int Reserved1;
			public int Reserved2;
			public int Reserved3;
			public int Reserved4;
			public int Reserved5;
			public int Reserved6;
			public int Reserved7;
			public int Reserved8;
		}
		#endregion
		#region TRACKMOUSEEVENTS
		[StructLayout(LayoutKind.Sequential)]
			public struct TRACKMOUSEEVENTS
		{
			public uint cbSize;
			public APIsEnums.TrackerEventFlags dwFlags;
			public IntPtr hWnd;
			public uint dwHoverTime;
		}
		#endregion
		#region WINDOWPLACEMENT
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct WINDOWPLACEMENT
		{
			public uint length;
			public uint flags;
			public uint showCmd;
			public APIsStructs.POINTAPI ptMinPosition;
			public APIsStructs.POINTAPI ptMaxPosition;
			public APIsStructs.RECT  rcNormalPosition;
		}
		#endregion

		#region SCROLLINFO
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct SCROLLINFO
		{
			public 	uint   cbSize;
			public 	uint   fMask;
			public 	int    nMin;
			public 	int    nMax;
			public 	uint   nPage;
			public 	int    nPos;
			public 	int    nTrackPos;
		}
		#endregion
		#region SCROLLBARINFO
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct SCROLLBARINFO
		{
			public uint  cbSize;
			public APIsStructs.RECT  rcScrollBar;
			public int   dxyLineButton;
			public int   xyThumbTop;
			public int   xyThumbBottom;
			public int   reserved;
			[MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValArray, SizeConst=6)]
			public uint[] rgstate;
		}
		#endregion

		#region PCOMBOBOXINFO
		[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
		public struct PCOMBOBOXINFO
		{
			public uint  cbSize;
			public APIsStructs.RECT  rcItem;
			public APIsStructs.RECT  rcButton;
			public int   stateButton;
			public IntPtr hwndCombo;
			public IntPtr hwndItem;
			public IntPtr hwndList;
		}
		#endregion

		#region BLENDFUNCTION
		[StructLayout(LayoutKind.Sequential, Pack=1)]
		public struct BLENDFUNCTION
		{
			public byte BlendOp;
			public byte BlendFlags;
			public byte SourceConstantAlpha;
			public byte AlphaFormat;
		}
		#endregion

		#region NMHEADER
		[StructLayout(LayoutKind.Sequential, Pack=1)]
		public struct NMHEADER
		{
			public NMHDR nmhdr;
			public int iItem;
			public int iButton;
			public HDITEM pItem;
		}
		#endregion

		[StructLayout(LayoutKind.Sequential, Pack=1)]
		public struct INPUT
		{
			public uint type;
			public int dx;
			public int dy;
			public uint mouseData;
			public uint dwFlags;
			public uint time;
			public uint dwExtra;
		}
	}
	public class APIsEnums
	{
		#region Window messages / WM
		/// <summary>
		/// Window messages / WM
		/// </summary>
		public enum WindowMessages
		{
			APP = 32768,
			ACTIVATE = 6,
			ACTIVATEAPP = 28,
			AFXFIRST = 864,
			AFXLAST = 895,
			ASKCBFORMATNAME = 780,
			CANCELJOURNAL = 75,
			CANCELMODE = 31,
			CAPTURECHANGED = 533,
			CHANGECBCHAIN = 781,
			CHAR = 258,
			CHARTOITEM = 47,
			CHILDACTIVATE = 34,
			CLEAR = 771,
			CLOSE = 16,
			COMMAND = 273,
			COMMNOTIFY = 68,
			COMPACTING = 65,
			COMPAREITEM = 57,
			CONTEXTMENU = 123,
			COPY = 769,
			COPYDATA = 74,
			CREATE = 1,
			CTLCOLOR = 0x0019,
			CTLCOLORBTN = 309,
			CTLCOLORDLG = 310,
			CTLCOLOREDIT = 307,
			CTLCOLORLISTBOX = 308,
			CTLCOLORMSGBOX = 306,
			CTLCOLORSCROLLBAR = 311,
			CTLCOLORSTATIC = 312,
			CUT = 768,
			DEADCHAR = 259,
			DELETEITEM = 45,
			DESTROY = 2,
			DESTROYCLIPBOARD = 775,
			DEVICECHANGE = 537,
			DEVMODECHANGE = 27,
			DISPLAYCHANGE = 126,
			DRAWCLIPBOARD = 776,
			DRAWITEM = 43,
			DROPFILES = 563,
			ENABLE = 10,
			ENDSESSION = 22,
			ENTERIDLE = 289,
			ENTERMENULOOP = 529,
			ENTERSIZEMOVE = 561,
			ERASEBKGND = 20,
			EXITMENULOOP = 530,
			EXITSIZEMOVE = 562,
			FONTCHANGE = 29,
			GETDLGCODE = 135,
			GETFONT = 49,
			GETHOTKEY = 51,
			GETICON = 127,
			GETMINMAXINFO = 36,
			GETTEXT = 13,
			GETTEXTLENGTH = 14,
			HANDHELDFIRST = 856,
			HANDHELDLAST = 863,
			HELP = 83,
			HOTKEY = 786,
			HSCROLL = 276,
			HSCROLLCLIPBOARD = 782,
			ICONERASEBKGND = 39,
			INITDIALOG = 272,
			INITMENU = 278,
			INITMENUPOPUP = 279,
			UNINITMENUPOPUP = 293,
			INPUTLANGCHANGE = 81,
			INPUTLANGCHANGEREQUEST = 80,
			KEYDOWN = 256,
			KEYUP = 257,
			KILLFOCUS = 8,
			MDIACTIVATE = 546,
			MDICASCADE = 551,
			MDICREATE = 544,
			MDIDESTROY = 545,
			MDIGETACTIVE = 553,
			MDIICONARRANGE = 552,
			MDIMAXIMIZE = 549,
			MDINEXT = 548,
			MDIREFRESHMENU = 564,
			MDIRESTORE = 547,
			MDISETMENU = 560,
			MDITILE = 550,
			MEASUREITEM = 44,
			MENUCHAR = 288,
			MENUSELECT = 287,
			MENUCOMMAND = 294,
			NEXTMENU = 531,
			MOVE = 3,
			MOVING = 534,
			NCACTIVATE = 134,
			NCCALCSIZE = 131,
			NCCREATE = 129,
			NCDESTROY = 130,
			NCHITTEST = 132,
			NCLBUTTONDBLCLK = 163,
			NCLBUTTONDOWN = 161,
			NCLBUTTONUP = 162,
			NCMBUTTONDBLCLK = 169,
			NCMBUTTONDOWN = 167,
			NCMBUTTONUP = 168,
			NCMOUSEMOVE = 160,
			NCPAINT = 133,
			NCRBUTTONDBLCLK = 166,
			NCRBUTTONDOWN = 164,
			NCRBUTTONUP = 165,
			NEXTDLGCTL = 40,
			NOTIFY = 78,
			NOTIFYFORMAT = 85,
			NULL = 0,
			PAINT = 15,
			PAINTCLIPBOARD = 777,
			PAINTICON = 38,
			PALETTECHANGED = 785,
			PALETTEISCHANGING = 784,
			PARENTNOTIFY = 528,
			PASTE = 770,
			PENWINFIRST = 896,
			PENWINLAST = 911,
			POWER = 72,
			POWERBROADCAST = 536,
			PRINT = 791,
			PRINTCLIENT = 792,
			QUERYDRAGICON = 55,
			QUERYENDSESSION = 17,
			QUERYNEWPALETTE = 783,
			QUERYOPEN = 19,
			QUEUESYNC = 35,
			QUIT = 18,
			RENDERALLFORMATS = 774,
			RENDERFORMAT = 773,
			SETCURSOR = 32,
			SETFOCUS = 7,
			SETFONT = 48,
			SETHOTKEY = 50,
			SETICON = 128,
			SETREDRAW = 11,
			SETTEXT = 12,
			SETTINGCHANGE = 26,
			SHOWWINDOW = 24,
			SIZE = 5,
			SIZECLIPBOARD = 779,
			SIZING = 532,
			SPOOLERSTATUS = 42,
			STYLECHANGED = 125,
			STYLECHANGING = 124,
			SYSCHAR = 262,
			SYSCOLORCHANGE = 21,
			SYSCOMMAND = 274,
			SYSDEADCHAR = 263,
			SYSKEYDOWN = 260,
			SYSKEYUP = 261,
			TCARD = 82,
			TIMECHANGE = 30,
			TIMER = 275,
			UNDO = 772,
			USER = 1024,
			USERCHANGED = 84,
			VKEYTOITEM = 46,
			VSCROLL = 277,
			VSCROLLCLIPBOARD = 778,
			WINDOWPOSCHANGED = 71,
			WINDOWPOSCHANGING = 70,
			WININICHANGE = 26,
			KEYFIRST = 256,
			KEYLAST = 264,
			SYNCPAINT = 136,
			MOUSEACTIVATE = 33,
			MOUSEMOVE = 512,
			LBUTTONDOWN = 513,
			LBUTTONUP = 514,
			LBUTTONDBLCLK = 515,
			RBUTTONDOWN = 516,
			RBUTTONUP = 517,
			RBUTTONDBLCLK = 518,
			MBUTTONDOWN = 519,
			MBUTTONUP = 520,
			MBUTTONDBLCLK = 521,
			MOUSEWHEEL = 522,
			MOUSEFIRST = 512,
			MOUSELAST = 522,
			MOUSEHOVER = 0x2A1,
			MOUSELEAVE = 0x2A3,
			SHNOTIFY = 0x0401,
			UNICHAR = 0x0109,
			THEMECHANGED = 0x031A,
		}
		#endregion

		#region Key State Masks / MK
		/// <summary>
		/// Key State Masks / MK
		/// </summary>
		public enum KeyStatesMasks
		{
			LBUTTON          = 0x0001,
			RBUTTON          = 0x0002,
			SHIFT            = 0x0004,
			CONTROL          = 0x0008,
			MBUTTON          = 0x0010,
			XBUTTON1         = 0x0020,
			XBUTTON2         = 0x0040,
		}
		#endregion

		#region Edit Control Notification Codes / EN
		/// <summary>
		/// Edit Control Notification Codes / EN
		/// </summary>
		public enum EditControlNotificationCodes
		{
			SETFOCUS         = 0x0100,
			KILLFOCUS        = 0x0200,
			CHANGE           = 0x0300,
			UPDATE           = 0x0400,
			ERRSPACE         = 0x0500,
			MAXTEXT          = 0x0501,
			HSCROLL          = 0x0601,
			VSCROLL          = 0x0602,
			ALIGN_LTR_EC     = 0x0700,
			ALIGN_RTL_EC     = 0x0701,
		}
		#endregion

		#region Combo Box Notification Codes / CBN
		/// <summary>
		/// Combo Box Notification Codes / CBN
		/// </summary>
		public enum ComboBoxNotificationCodes
		{
			ERRSPACE        = (-1),
			SELCHANGE       = 1,
			DBLCLK          = 2,
			SETFOCUS        = 3,
			KILLFOCUS       = 4,
			EDITCHANGE      = 5,
			EDITUPDATE      = 6,
			DROPDOWN        = 7,
			CLOSEUP         = 8,
			SELENDOK        = 9,
			SELENDCANCEL    = 10,
		}
		#endregion
		#region Combo Box Messages / CB
		/// <summary>
		/// Combo Box Messages / CB
		/// </summary>
		public enum ComboBoxMessages
		{
			GETEDITSEL               = 0x0140,
			LIMITTEXT                = 0x0141,
			SETEDITSEL               = 0x0142,
			ADDSTRING                =
#T=MSN 批量登录验证
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Xml;
	using System.Net;
	using System.Drawing;
	class Program
	{
		static void Main(string[] args)
		{
			for (int i = 2;  i < 140; i ++)
			{
				string UserName = string.Format("ehomechina{0:0000}@hotmail.com", i);
				string Password = "qwer1234"; //Put password here
				string ticket = new TicketAcquirer(UserName, Password).GetTicket();
				if (null == ticket)
				{
					ConsoleColor c = Console.ForegroundColor;
					Console.ForegroundColor = ConsoleColor.Red;
					Console.WriteLine(UserName);
					Console.ForegroundColor = c;
				}
				else
				{
					Console.WriteLine("Authenticated: " + UserName);
				}
			}
		}
	}
	public class LiveContacts
	{
		private string _username = "";
		private string _ticket = "";
		public LiveContacts(string username, string ticket)
		{
			this._username = username;
			this._ticket = ticket;
		}

		/// <summary>
		/// Returns the URI Path for the address book
		/// </summary>
		/// <param name="username"></param>
		/// <returns></returns>
		private String getURIPath()
		{
			// Define account information.
			string uri = "https://cumulus.services.live.com/" + _username + "/LiveContacts/";
			return uri;
		}

		/// <summary>
		/// Creates a web request object with the appropriate properties set to talk to the live server
		/// </summary>
		/// <param name="uriPath">Path of the URI for the web request</param>
		/// <param name="ticket">Ticket acquired for this session</param>
		/// <returns>Web request object</returns>
		private HttpWebRequest getHttpWebRequest(String uriPath)
		{
			HttpWebRequest request = (HttpWebRequest)WebRequest.Create(uriPath);
			request.Headers.Add("Authorization", "WLID1.0 t=\"" + _ticket + "\"");  // Add the authentication header
			request.AllowAutoRedirect = false;
			request.UserAgent = "Sample Live App";
			request.ContentType = "text/xml";
			request.Pipelined = false;
			request.ProtocolVersion = HttpVersion.Version10;
			request.CookieContainer = new CookieContainer();
			return request;
		}

		public List<String> GetAllContactIds()
		{
			List<String> contactids = new List<string>();
			HttpWebRequest request = getHttpWebRequest(getURIPath());
			request.Method = "GET";

			HttpWebResponse response;

			response = (HttpWebResponse)request.GetResponse();

			if (response.StatusCode != HttpStatusCode.OK || response.ContentLength == 0)
			{
				throw new ApplicationException("Get ALL faield");
			}

			XmlDocument xmldoc = new XmlDocument();
			xmldoc.Load(response.GetResponseStream());

			//Console.WriteLine(xmldoc.InnerXml);

			XmlNode contactsNode = xmldoc.SelectSingleNode("LiveContacts/Contacts");
			
			if (null == contactsNode)
				return new List<String>();

			XmlNodeList contacts = contactsNode.ChildNodes;
			foreach (XmlNode contact in contacts)
			{
				contactids.Add(contact.SelectSingleNode("ID").InnerText);
			}


			return contactids;
		}
	};

	public class TicketAcquirer
	{
		private const string applicationId = "10"; // An arbitrary value that will be defined in the next non-alpha release
		private string soapEnvelope = null;

		public TicketAcquirer(String userName, String password)
		{
			soapEnvelope = @"<s:Envelope
				xmlns:s = ""http://www.w3.org/2003/05/soap-envelope""
				xmlns:wsse = ""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd""
				xmlns:saml = ""urn:oasis:names:tc:SAML:1.0:assertion""
				xmlns:wsp = ""http://schemas.xmlsoap.org/ws/2004/09/policy""
				xmlns:wsu = ""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd""
				xmlns:wsa = ""http://www.w3.org/2005/08/addressing""
				xmlns:wssc = ""http://schemas.xmlsoap.org/ws/2005/02/sc""
				xmlns:wst = ""http://schemas.xmlsoap.org/ws/2005/02/trust"">
				<s:Header>
				<wlid:ClientInfo xmlns:wlid = ""http://schemas.microsoft.com/wlid"">
				<wlid:ApplicationID>" + applicationId + @"</wlid:ApplicationID>
				</wlid:ClientInfo>
				<wsa:Action s:mustUnderstand = ""1"">http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue</wsa:Action>
				<wsa:To s:mustUnderstand = ""1"">https://dev.login.live.com/wstlogin.srf</wsa:To>
				<wsse:Security>
				<wsse:UsernameToken wsu:Id = ""user"">
				<wsse:Username>" + userName + @"</wsse:Username>
				<wsse:Password>" + password + @"</wsse:Password>
				</wsse:UsernameToken>
				</wsse:Security>
				</s:Header>
				<s:Body>
				<wst:RequestSecurityToken Id = ""RST0"">
				<wst:RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</wst:RequestType>
				<wsp:AppliesTo>
				<wsa:EndpointReference>
				<wsa:Address>http://live.com</wsa:Address>
				</wsa:EndpointReference>
				</wsp:AppliesTo>
				<wsp:PolicyReference URI = ""MBI""></wsp:PolicyReference>
				</wst:RequestSecurityToken>
				</s:Body>
				</s:Envelope>
				";
		}

		/* methods */
		public string GetTicket()
		{
			const string url = @"https://dev.login.live.com/wstlogin.srf";
			WebRequest request = WebRequest.Create(url);
			request.Method = "POST";
			request.ContentType = "application/soap+xml; charset=UTF-8";
			request.Timeout = 10 * 1000; // Wait for at most 10 seconds
			byte[] bytes = System.Text.Encoding.UTF8.GetBytes(soapEnvelope);
			request.GetRequestStream().Write(bytes, 0, bytes.Length);
			request.GetRequestStream().Close();
			WebResponse response;
			response = request.GetResponse();
			string xml;
			using (System.IO.StreamReader reader = new System.IO.StreamReader(response.GetResponseStream()))

			xml = reader.ReadToEnd();
			response.Close();

			//Console.WriteLine(xml);
			XmlDocument document = new XmlDocument();
			document.LoadXml(xml);
			XmlNamespaceManager nsManager = new XmlNamespaceManager(document.NameTable);
			nsManager.AddNamespace("wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
			XmlNode node = document.SelectSingleNode(@"//wsse:BinarySecurityToken/text()", nsManager);
			if (node == null)
				return null; // The wsse:BinarySecurityToken element is missing. Examine the xml for error information
			else
				return node.Value;
		}
	}

}
#T=MVC UrlRoute
namespace Microshaoft
{
	using System;
	using System.Web;
	using System.Web.Routing;
	public class Global : HttpApplication
	{
		protected void Application_Start(object sender, EventArgs e)
		{
			var defaults = new RouteValueDictionary{{"name","*"},{"id","*"}};
			RouteTable.Routes.MapPageRoute("", "employees/{name}/{id}", "~/Default.aspx", true,defaults);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Web.UI;
	public partial class Default : Page
	{
			private EmployeeRepository repository;
			public EmployeeRepository Repository
			{
				get { return null == repository ? repository = new EmployeeRepository() : repository; }
			}
			protected void Page_Load(object sender, EventArgs e)
			{
				if (this.IsPostBack)
				{
					return;
				}
				string employeeId = this.RouteData.Values["id"] as string;
				if (employeeId == "*" || string.IsNullOrEmpty(employeeId))
				{
					this.GridViewEmployees.DataSource = this.Repository.GetEmployees();
					this.GridViewEmployees.DataBind();
					this.DetailsViewEmployee.Visible = false;
				}
				else
				{
					var employees = this.Repository.GetEmployees(employeeId);
					this.DetailsViewEmployee.DataSource = employees;
					this.DetailsViewEmployee.DataBind();
					this.GridViewEmployees.Visible = false;
				}
			}
		}
}
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. 
// </auto-generated>
//------------------------------------------------------------------------------
namespace Microshaoft
{
	public partial class Default
	{
		/// <summary>
		/// form1 control.
		/// </summary>
		/// <remarks>
		/// Auto-generated field.
		/// To modify move field declaration from designer file to code-behind file.
		/// </remarks>
		protected global::System.Web.UI.HtmlControls.HtmlForm form1;
		/// <summary>
		/// GridViewEmployees control.
		/// </summary>
		/// <remarks>
		/// Auto-generated field.
		/// To modify move field declaration from designer file to code-behind file.
		/// </remarks>
		protected global::System.Web.UI.WebControls.GridView GridViewEmployees;
		/// <summary>
		/// DetailsViewEmployee control.
		/// </summary>
		/// <remarks>
		/// Auto-generated field.
		/// To modify move field declaration from designer file to code-behind file.
		/// </remarks>
		protected global::System.Web.UI.WebControls.DetailsView DetailsViewEmployee;
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	public class EmployeeRepository
	{
		private static IList<Employee> employees;
		static EmployeeRepository()
		{
			employees = new List<Employee>();
			employees.Add(new Employee(Guid.NewGuid().ToString(), "张三", "男", new DateTime(1981, 8, 24), "销售部"));
			employees.Add(new Employee(Guid.NewGuid().ToString(), "李四", "女", new DateTime(1982, 7, 10), "人事部"));
			employees.Add(new Employee(Guid.NewGuid().ToString(), "王五", "男", new DateTime(1981, 9, 21), "人事部"));
		}
		public IEnumerable<Employee> GetEmployees(string id = "")
		{
			return employees.Where(e => e.Id == id || string.IsNullOrEmpty(id) || id=="*");
		}
	}
}
namespace Microshaoft
{
	using System;
	public class Employee
	{
		public string Id { get; private set; }
		public string Name { get; private set; }
		public string Gender { get; private set; }
		public DateTime BirthDate { get; private set; }
		public string Department { get; private set; }
		public Employee(string id, string name, string gender, DateTime birthDate, string department)
		{
			this.Id = id;
			this.Name = name;
			this.Gender = gender;
			this.BirthDate = birthDate;
			this.Department = department;
		}
	}
}
//global.asax=============================================================================================================
/*
<%@ Application Inherits="Microshaoft.Global" Language="C#" %>
*/
//========================================================================================================================
//default.aspx============================================================================================================
/*
<%@ Page Language="C#" AutoEventWireup="true" Inherits="Microshaoft.Default" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
<title>员工管理系统</title>
<script language="javascript" type="text/javascript" src="/jquery-1.4.1.min.js"></script>
<style type="text/css">
	#page
	{
		width: 600px;
		margin: 10px auto;
	}
	body
	{
		font-size: 12px;
		text-align: center;
	}
	table
	{
		border: 1px solid #000000;
		margin: 10px auto;
		background-color: #eee;
	}
	tr
	{
		line-height: 23px;
	}
	th
	{
		background-color: #ccc;
		color: #fff;
	}
	.oddRow
	{
		background-color: #fff;
	}
</style>
<script type="text/javascript">
	$(
		function ()
		{
			$("#DetailsViewEmployee tr td:even")
				.css("width", "100px")
				.css("background-color", "#fff")
				.css("text-align", "right")
				.css("padding-right", "2px");
			$("#DetailsViewEmployee tr td:odd")
				.css("text-align", "left")
				.css("padding-left", "2px");
			$("#GridViewEmployees tr:odd").addClass("oddRow");
		}
	);
</script>
</head>
<body>
<form id="form1" runat="server">
	<div id="page">
		<asp:GridView ID="GridViewEmployees" runat="server" AutoGenerateColumns="false" Width="100%">
			<Columns>
				<asp:HyperLinkField HeaderText="姓名" DataTextField="Name" DataNavigateUrlFields="Name,Id" DataNavigateUrlFormatString="~/employees/{0}/{1}" />
				<asp:BoundField DataField="Gender" HeaderText="性别" />
				<asp:BoundField DataField="BirthDate" HeaderText="出生日期" DataFormatString="{0:dd/MM/yyyy}" />
				<asp:BoundField DataField="Department" HeaderText="部门" />
			</Columns>
		</asp:GridView>
		<asp:DetailsView ID="DetailsViewEmployee" runat="server" AutoGenerateRows="false"  Width="100%">
			<Fields>
				<asp:BoundField DataField="ID" HeaderText= "ID"  />
				<asp:BoundField DataField="Name" HeaderText= "姓名"  />
				<asp:BoundField DataField="Gender" HeaderText="性别" />
				<asp:BoundField DataField="BirthDate" HeaderText="出生日期" DataFormatString="{0:dd/MM/yyyy}" />
				<asp:BoundField DataField="Department" HeaderText="部门" />
			</Fields>
		</asp:DetailsView>
	</div>
</form>
</body>
</html>
*/
//============================================================================================================

#T=NativeWindow Listener not OK
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Linq;
	using System.Text;
	using System.Windows.Forms;

	using System.Runtime.InteropServices;

	class NativeWindowListener : NativeWindow
	{
		Form parent;

		public event NativeWindowListenerEventHandler ListenedMouseMove;
		public event NativeWindowListenerEventHandler ListenedMouseDown;
		public event NativeWindowListenerEventHandler ListenedMouseDrag;

		public event NativeWindowListenerEventHandler ListenedMouseActive;

		public delegate void NativeWindowListenerEventHandler
			(
				NativeWindowListener sender
				, MouseEventArgs e
			);

		public NativeWindowListener(Form parent)
		{
			this.parent = parent;
			this.parent.HandleCreated += new EventHandler(parent_HandleCreated);
			//this.parent.HandleDestroyed += new EventHandler(parent_HandleDestroyed);
		}

		void parent_HandleCreated(object sender, EventArgs e)
		{
			AssignHandle(((Form)sender).Handle);
		}

		void parent_HandleDestroyed(object sender, EventArgs e)
		{
			ReleaseHandle();
		}
		private Point lastMousePosition;
		private bool IsDrag = false;

		//Declare the wrapper managed POINT class.
		[StructLayout(LayoutKind.Sequential)]
		public struct PointStruct
		{
			public int x;
			public int y;
		}


		[StructLayout(LayoutKind.Sequential)]
		public struct MouseHookStruct
		{
			public PointStruct pt;
			public int hwnd;
			public int wHitTestCode;
			public int dwExtraInfo;
		}
		protected override void WndProc(ref Message m)
		{
			Console.WriteLine(m.ToString());


			int wparam = (int)m.WParam;

			

			int x;
			int y;

			MouseHookStruct mouseHookStruct;
			if (wparam == WM_LBUTTONDOWN)
			{
				Console.WriteLine("WM_LBUTTONDOWN");

				mouseHookStruct = (MouseHookStruct)Marshal.PtrToStructure
										  (
											  m.LParam
											  , typeof(MouseHookStruct)
										  );
				x = mouseHookStruct.pt.x;
				y = mouseHookStruct.pt.y;//; - this.Top;
				if (this.IsDrag == false)
				{
					this.IsDrag = true;

					if (this.lastMousePosition == null)
					{
						this.lastMousePosition = new Point();
					}

					this.lastMousePosition.X = x;
					this.lastMousePosition.Y = y;
					if (this.ListenedMouseDown != null)
					{
						MouseEventArgs e = new MouseEventArgs(MouseButtons.Left, 1, x, y, 0);
						this.ListenedMouseDown(this, e);
					}
				}
			}
			if (wparam == WM_MOUSEMOVE)
			{
					Console.WriteLine("WM_MOUSEMOVE");
				mouseHookStruct = (MouseHookStruct)Marshal.PtrToStructure
										  (
											  m.LParam
											  , typeof(MouseHookStruct)
										  );
				x = mouseHookStruct.pt.x;
				y = mouseHookStruct.pt.y;//; - this.Top;
				MouseButtons mb = MouseButtons.None;
				if (IsDrag == true)
				{
					mb = MouseButtons.Left;
					if (this.ListenedMouseDrag != null)
					{
						MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
						this.ListenedMouseDrag(this, e);
					}
				}

				if (this.ListenedMouseMove != null)
				{
					x = mouseHookStruct.pt.x;
					y = mouseHookStruct.pt.y;//; - this.Top;
					mouseHookStruct = (MouseHookStruct)Marshal.PtrToStructure
										 (
											 m.LParam
											 , typeof(MouseHookStruct)
										 );
					MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
					this.ListenedMouseMove(this, e);
				}
				//IsDrag = false;
			}

			if (wparam == WM_LBUTTONUP)
			{
				Console.WriteLine("WM_LBUTTONUP");
				IsDrag = false;
			}
			if (wparam == WM_RBUTTONDOWN)
			{
				Console.WriteLine("WM_RBUTTONDOWN");
				IsDrag = false;
			}


			base.WndProc(ref m);
		}
		private const int WM_SYSCOMMAND = 0x0112;
		private const int SC_MOVE = 0xF010;
		private const int HTCAPTION = 0x0002;

		private const int WM_MOUSEMOVE = 0x200;
		private const int WM_LBUTTONDOWN = 0x201;
		private const int WM_RBUTTONDOWN = 0x204;
		private const int WM_MBUTTONDOWN = 0x207;
		private const int WM_LBUTTONUP = 0x202;
		private const int WM_RBUTTONUP = 0x205;
		private const int WM_MBUTTONUP = 0x208;
		private const int WM_LBUTTONDBLCLK = 0x203;
		private const int WM_RBUTTONDBLCLK = 0x206;
		private const int WM_MBUTTONDBLCLK = 0x209;

		private const int WH_MOUSE = 7;
		private const int WH_MOUSE_LL = 14;
	}
}

namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}

namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Linq;
	using System.Text;
	using System.Windows.Forms;
	using Microshaoft;

	public partial class Form1 : Form
	{
		NativeWindowListener _listener;

		public Form1()
		{
			InitializeComponent();
			_listener = new NativeWindowListener(this);
			_listener.ListenedMouseDrag += new NativeWindowListener.NativeWindowListenerEventHandler(_listener_ListenedMouseDrag);

		}
		private Point lastMousePosition;
		private bool IsDrag = false;


		private Point lastLocation;
		void _listener_ListenedMouseDown(NativeWindowListener sender, MouseEventArgs e)
		{
			if (e.Button == MouseButtons.Left)
			{
				if (lastLocation == null)
				{
					lastLocation = new Point();
				}
				lastLocation.X = e.X - this.Left;
				lastLocation.Y = e.Y - this.Top;
			}
		}

		bool lastIsMouseIn = false;
		void _listener_ListenedMouseActive(NativeWindowListener sender, MouseEventArgs e)
		{

			bool IsMouseIn = false;
			if ((e.X < this.Left)
				|| (e.Y < this.Top)
				|| (e.X > this.Left + this.Width)
				|| (e.Y > this.Top + this.Height)
				)
			{
				//Console.WriteLine("leave");
				IsMouseIn = false;
			}
			else//(IsMouseIn)
			{
				//Console.WriteLine("enter");
				IsMouseIn = true;
			}
			if (IsMouseIn != lastIsMouseIn)
			{
				//this.Visible = false;
				if (IsMouseIn)
				{

					this.Opacity = 1;
				}
				else
				{
					this.Opacity = .5;
				}
				this.Invalidate();
				lastIsMouseIn = IsMouseIn;
				Console.WriteLine(lastIsMouseIn);
			}



		}


		void _listener_ListenedMouseDrag(NativeWindowListener sender, MouseEventArgs e)
		{
			//throw new NotImplementedException();
			this.Text = e.X.ToString();
			this.Location = new Point(e.X - lastLocation.X, e.Y - lastLocation.Y);
			//this.Location = new Point(this.Left + (e.X - hooker.LastMousePosition.X),this.Top + (e.Y - hooker.LastMousePosition.Y));
		}
	}
}
namespace Test
{
	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.webBrowser1 = new System.Windows.Forms.WebBrowser();
			this.SuspendLayout();
			// 
			// webBrowser1
			// 
			this.webBrowser1.Dock = System.Windows.Forms.DockStyle.Fill;
			this.webBrowser1.Location = new System.Drawing.Point(0, 0);
			this.webBrowser1.MinimumSize = new System.Drawing.Size(20, 20);
			this.webBrowser1.Name = "webBrowser1";
			this.webBrowser1.Size = new System.Drawing.Size(292, 273);
			this.webBrowser1.TabIndex = 0;
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(292, 273);
			this.Controls.Add(this.webBrowser1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.WebBrowser webBrowser1;

	}
}
#T=Net Port Scan 网络 端口扫描
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Net.Sockets;

	using Microshaoft;
	class Program
	{
		private static  TimeSpan ts;
		private static DateTime start;
		private static void Usage()
		{
			Console.WriteLine("[remote ip] [start port][end port][Thread Count]");
			Console.WriteLine("example 10.186.16.4 1 65535 100");
		}
		static void Main(string[] args)
		{
			if (args.Length != 4)
			{
				Usage();
				return;
			}
			string ip = args[0];
			int sport = Convert.ToInt32(args[1]);
			int eport = Convert.ToInt32(args[2]);
			int threadCount = Convert.ToInt32(args[3]);
			ScanPort s = new ScanPort();
			s.OnPortConnect += new ScanHandler(s_OnPortConnect);
			s.OnScanFinish += new EventHandler(s_OnScanFinish);
			start = DateTime.Now;
			s.Scan(ip, sport, eport,threadCount);
		}

		static void s_OnScanFinish(object sender, EventArgs e)
		{
			ts = DateTime.Now - start;
			Console.WriteLine("total cost:{0:f}", ts.TotalSeconds);
		}

		static void s_OnPortConnect(object o, ScanEventArg e)
		{
			Console.WriteLine(e.Port.ToString());
		}
	}
}
namespace Microshaoft//.PortsScan
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Net.Sockets;
	using System.Runtime.InteropServices;
	using System.Threading;
	using System.Net;
	public delegate void ScanHandler(object o,ScanEventArg e);
	public class ScanEventArg:EventArgs
	{
		public int port;
		public ScanEventArg(int p)
		{
			port= p;
		}
		public int Port
		{
			get
			{
				return port;
			}
		}
	}
	internal class ScanSocket : Socket
	{
		private int port;
		public ScanSocket(SocketInformation s): base(s)
		{
 
		}
		public ScanSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)
			: base(addressFamily, socketType, protocolType)
		{
 
		}
		public int Port
		{
			get
			{
				return port;
			}
			set
			{
				port = value;
			}
		}
	}
	public class ScanPort
	{

		private  const int DEFAULT_THREAD_COUNT = 1000;
		private  int maxThreadCount;
		private  IPAddress  scanIP;

		private int realThreadCount;
		private int sport, eport;
		private string ip;

		public  event EventHandler OnPortError;
		public event EventHandler OnScanFinish;
		public  event ScanHandler OnPortConnect;
		public event EventHandler OnPortThreadFinish;

	  
		public int RealThreadCount
		{
			set
			{
				lock (this)
				{
					realThreadCount = value;
				}
			}
		}
		/// <summary>
		/// 扫描指定端口段
		/// </summary>
		/// <param name="ip"></param>
		/// <param name="sport"></param>
		/// <param name="eport"></param>
		public  void Scan(string ip, int sport, int eport)
		{
			Scan(ip,sport,eport,DEFAULT_THREAD_COUNT);
		}
		public void Scan(string ip, int sport, int eport, int threadCount)
		{
			this.ip = ip;
			this.sport = sport;
			this.eport = eport;
			this.maxThreadCount = threadCount;

			Thread mainThread = new Thread(new ThreadStart(MainScan));
			mainThread.Start();
		}
		/// <summary>
		/// 扫描指定端口段
		/// </summary>
		/// <param name="ip"></param>
		/// <param name="sport"></param>
		/// <param name="eport"></param>
		/// <param name="threadCount"></param>
		private  void MainScan()
		{
			if (!AdjustPortAndIP(ip,ref sport, ref eport))
			{
				if (OnPortError != null)
					OnPortError(null, null);
				return;
			}
			if (maxThreadCount > DEFAULT_THREAD_COUNT)
			{
				maxThreadCount = DEFAULT_THREAD_COUNT;
			}
			realThreadCount = 0;
		   
			ScanThread st = new ScanThread();
			st.ScanIP = this.scanIP;
			st.OnPortConnect += new ScanHandler(st_OnPortConnect);
			st.OnPortThreadFinish += new EventHandler(st_OnPortThreadFinish);
			for (int i = sport; i <= eport; i++,realThreadCount++)
			{
				while (realThreadCount-st.FinishThreads > maxThreadCount)
				{
					Thread.Sleep(10);
				}
				Thread.Sleep(10);
				ParameterizedThreadStart ps = new ParameterizedThreadStart(st.ThreadFunc);
				Thread start = new Thread(ps);
				start.Start(i);
			}
			while (st.FinishThreads != realThreadCount) Thread.Sleep(1000);//等到所有线程全退出为止
			//Thread.Sleep(10000);
			if (OnScanFinish != null)									   //通知客户端扫描已经完成
				OnScanFinish(null, null);
		}
		/// <summary>
		/// 扫描所有端口
		/// </summary>
		/// <param name="ip"></param>
		public void Scan(string ip)
		{
			Scan(ip, 0, 65535, DEFAULT_THREAD_COUNT);
		}


		void st_OnPortThreadFinish(object sender, EventArgs e)
		{
			if (OnPortThreadFinish != null)
				OnPortThreadFinish(null, null);
		}
	  
		/// <summary>
		/// 端口可以连接，通知客户端
		/// </summary>
		/// <param name="o"></param>
		/// <param name="e"></param>
		void st_OnPortConnect(object o, ScanEventArg e)
		{
			if (OnPortConnect != null)
				OnPortConnect(null, e);
		}
		/// <summary>
		/// 调整端口范围
		/// </summary>
		/// <param name="sport"></param>
		/// <param name="eport"></param>
		private  bool AdjustPortAndIP(string ip, ref int sport, ref int eport)
		{
			bool retval = true;
			if (!IPAddress.TryParse(ip, out scanIP))
			{
				retval = false;
			}
			else
			{
				if (sport < 0 || eport > 65535)
				{
					retval = false;
				}
				sport = Math.Min(sport, eport);
				eport = Math.Max(sport, eport);
			}
			return retval;
		}
	   
	   
	}
	/// <summary>
	/// 扫描端口类
	/// </summary>
	internal class ScanThread
	{
		public event ScanHandler OnPortConnect;	  //该端口可以连接
		public event EventHandler OnPortThreadFinish;   //该端口已经扫描完毕

		private int finishThreads = 0;			  //已经完成的线程数 
		private IPAddress scanIP;				   //要扫描的ip地址
	  
		public ScanThread()
		{
			finishThreads = 0;
		}
		public IPAddress ScanIP
		{
			set
			{
				scanIP = value;
			}
		}
		public int FinishThreads
		{
			get
			{
				return finishThreads;
			}
		}
		/// <summary>
		/// 线程函数
		/// </summary>
		/// <param name="o"></param>
		public void ThreadFunc(object o)
		{
			int port = (int)o;
			ScanSocket s = new ScanSocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			s.Port = port;
			IPEndPoint ipport = new IPEndPoint(scanIP, port);

			try
			{
				// s.BeginConnect(ipport, new AsyncCallback(EndConnect), s);
				s.Connect(ipport);
				if (s.Connected == true)
				{
					OnPortConnect(null, new ScanEventArg(s.Port));
				}
			}
			catch (Exception e)
			{
 
			}
			finally
			{
				lock (this)
				{
					finishThreads++;
				}
				if (OnPortThreadFinish != null)
					OnPortThreadFinish(null, null);
			}
		}
	}
}

#T=NetStatTool
//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------

namespace Microsoft.Samples.NetStatTool
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Net.NetworkInformation;
	using System.Globalization;
	[Flags]
	public enum ProtocolTypes
	{
		None = 0x0000,
		Tcp = 0x0001,
		Udp = 0x0002,
		TcpV6 = 0x0004,
		UdpV6 = 0x0008,
		IP = 0x0010,
		IPv6 = 0x0020,
		Icmp = 0x0040,
		IcmpV6 = 0x0080
	}

	static class NetStatTool
	{
		private static bool showNumeric;
		private static bool showListening;
		private static bool showProtocolStatistics;
		private static bool showInterfaceStatistics;
		private static int interval = -1;
		private static ProtocolTypes selectedProtocols = ProtocolTypes.None;
		private const string connectionFormatString =
			"\t{0,-12}{1, -16}{2, -28}{3}";
		private const string equalsFormatString =
			"\t{0, -32} = {1}";
		private const string sendReceiveFormatString =
			"\t{0, -32}{1, -16}{2}";
		private const string errorFormatString =
			"\tStatistics not available for {0}: {1}";

		static void Main(string[] args)
		{
			if (ParseArguments(args))
			{
				while (true)
				{
					if (showInterfaceStatistics)
						DisplayInterfaceStatistics();
					if (showProtocolStatistics)
						DisplayProtocolStatistics();
					if (!showInterfaceStatistics && !showProtocolStatistics)
						DisplayConnections();
					if (interval <= 0)
						break;
					else
						System.Threading.Thread.Sleep(interval * 1000);
				}
			}
			else
			{
				Usage();
				System.Environment.Exit(0);
			}
		}

		// Helper function display the all possible command line options and 
		// their purpose for this tool.
		private static void Usage()
		{
			Console.WriteLine();
			Console.WriteLine("NETSTATTOOL [-?] [-a] [-e] [-n] [-s] [-p protocol] [interval]");
			Console.WriteLine();
			Console.WriteLine("(default)	 Displays open connection information.");
			Console.WriteLine("-?			Displays this help message.");
			Console.WriteLine("-e			Displays NIC statistics. May be combined with -s.");
			Console.WriteLine("-s			Displays per-protocol statistics.  By default, statistics are");
			Console.WriteLine("				  shown for TCP.  The -p and -a options may be used to specify");
			Console.WriteLine("				  other protocols to display.");
			Console.WriteLine("-p protocol   Display information for the protocol specified.");
			Console.WriteLine("				  May be any of: IP, IPv6, ICMP, ICMPv6, TCP, TCPv6, UDP,");
			Console.WriteLine("				  or UDPv6TCP.  Connections can only be shown for TCP,");
			Console.WriteLine("				  UDP, TCPv6, or UDPv6.");
			Console.WriteLine("-a			Display information for all protocals.");
			Console.WriteLine("-n			Displays addresses and port numbers in numerical form.");
			Console.WriteLine("interval	  Redisplays selected statistics, pausing interval seconds");
			Console.WriteLine("				  between each display.  Press CTRL+C to stop.");
		}

		// Parse the command line arguments and set appropriate properties as 
		// per requested user options.
		private static bool ParseArguments(string[] args)
		{
			for (int i = 0; i < args.Length; i++)
			{
				string arg = args[i].ToLower(CultureInfo.CurrentCulture);
				if (arg.Length < 2 || (arg[0] != '/' && arg[0] != '-'))
				{
					try
					{
						interval =
							Convert.ToInt32(arg, NumberFormatInfo.CurrentInfo);
					}
					catch (FormatException)
					{
						return false;
					}
					catch (OverflowException)
					{
						return false;
					}
				}
				else
				{
					switch (arg[1])
					{
						// Just display the help message
						case '?': 
							return false;
						case 'n':
							showNumeric = true;
							break;
						case 'e':
							showInterfaceStatistics = true;
							break;
						case 'a':
							selectedProtocols =
								ProtocolTypes.Tcp | ProtocolTypes.Udp |
								ProtocolTypes.IP | ProtocolTypes.Icmp |
								ProtocolTypes.TcpV6 | ProtocolTypes.UdpV6 |
								ProtocolTypes.IPv6 | ProtocolTypes.IcmpV6;
							showListening = true;
							break;
						case 's':
							showProtocolStatistics = true;
							break;
						case 'p':
							if (args.Length < i + 1)
							{
								return false; // invalid parameters
							}
							else
							{
								i++;
								AddSelectedProtocol(
									args[i].ToLower(
									CultureInfo.CurrentCulture));
							}
							break;
						default:
							return false;
					}
				}
			}
			if (selectedProtocols == ProtocolTypes.None)
			{
				// User wants Tcp as default.
				selectedProtocols = selectedProtocols | ProtocolTypes.Tcp;
			}
			return true;
		}

		// Get the display string for localIPEndPoint, either numric or full
		// name format.
		private static String GetLocalAddressAsString(IPEndPoint ipe)
		{
			string displayString = ipe.ToString();
			if (!showNumeric)
			{
				displayString =
					Dns.GetHostName() + ":" + GetPortNameMapping(ipe.Port);
			}
			return displayString;
		}

		// Get the display string for Remote IPEndPoint, either numric or full 
		// name format.
		private static String GetRemoteAddressAsString(IPEndPoint ipe)
		{
			string displayString = ipe.ToString();
			if (!showNumeric)
			{
				try
				{
					displayString =
						Dns.GetHostEntry(ipe.Address).HostName + ":" +
						GetPortNameMapping(ipe.Port);
				}
				catch (SocketException)
				{
				}
			}
			return displayString;
		}

		private static void AddSelectedProtocol(string protocol)
		{
			switch (protocol)
			{
				case "tcp":
					selectedProtocols = selectedProtocols | ProtocolTypes.Tcp;
					break;
				case "udp":
					selectedProtocols = selectedProtocols | ProtocolTypes.Udp;
					break;
				case "ip":
					selectedProtocols = selectedProtocols | ProtocolTypes.IP;
					break;
				case "icmp":
					selectedProtocols = selectedProtocols | ProtocolTypes.Icmp;
					break;
				case "tcpv6":
					selectedProtocols =
						selectedProtocols | ProtocolTypes.TcpV6;
					break;
				case "udpv6":
					selectedProtocols =
						selectedProtocols | ProtocolTypes.UdpV6;
					break;
				case "ipv6":
					selectedProtocols = selectedProtocols | ProtocolTypes.IPv6;
					break;
				case "icmpv6":
					selectedProtocols =
						selectedProtocols | ProtocolTypes.IcmpV6;
					break;
			}
		}

		// Return the displaystring for known protocol ports
		private static string GetPortNameMapping(int Port)
		{
			string Portname = Port.ToString(NumberFormatInfo.CurrentInfo);
			switch (Port)
			{
				case 21:
					Portname = "ftp";
					break;
				case 25:
					Portname = "smtp";
					break;
				case 80:
					Portname = "http";
					break;
				case 135:
					Portname = "epmap";
					break;
				case 137:
					Portname = "netbios-ns";
					break;
				case 138:
					Portname = "netbios-dgm";
					break;
				case 139:
					Portname = "netbios-ssn";
					break;
				case 443:
					Portname = "ssl";
					break;
				case 445:
					Portname = "microsoft-ds";
					break;
				case 500:
					Portname = "isakmp";
					break;

			}
			return Portname;
		}

		private static string GetProtocolString(ProtocolTypes type)
		{
			switch (type)
			{
				case ProtocolTypes.Icmp: return "ICMP";
				case ProtocolTypes.IcmpV6: return "ICMP V6";
				case ProtocolTypes.IP: return "IP";
				case ProtocolTypes.IPv6: return "IP V6";
				case ProtocolTypes.Tcp: return "TCP";
				case ProtocolTypes.TcpV6: return "TCP V6";
				case ProtocolTypes.Udp: return "UDP";
				case ProtocolTypes.UdpV6: return "UDP V6";
				default: return "Unknown";
			}
		}

		// Display the list of connections on console.
		private static void DisplayConnections()
		{
			IPGlobalProperties ipGlobal =
				IPGlobalProperties.GetIPGlobalProperties();
			Console.WriteLine();
			Console.WriteLine("Connections");
			Console.WriteLine(
				connectionFormatString, "Protocol", "State", "Local", "Remote");
			if ((selectedProtocols & ProtocolTypes.Tcp) == ProtocolTypes.Tcp)
			{
				TcpConnectionInformation[] tcpInfoList =
					ipGlobal.GetActiveTcpConnections();
				foreach (TcpConnectionInformation tcpInfo in tcpInfoList)
				{
					if (tcpInfo.State == TcpState.Listen && !showListening)
					{
						// Skip listening port unless user requested all.
						continue;
					}
					else
					{
						Console.WriteLine(
							connectionFormatString,
							"TCP",
							tcpInfo.State,
							GetLocalAddressAsString(tcpInfo.LocalEndPoint),
							GetRemoteAddressAsString(tcpInfo.RemoteEndPoint));
					}
				}
			}
			if ((selectedProtocols & ProtocolTypes.Udp) == ProtocolTypes.Udp)
			{
				IPEndPoint[] udpInfoList = ipGlobal.GetActiveUdpListeners();
				foreach (IPEndPoint udpInfo in udpInfoList)
				{
					Console.WriteLine(
						connectionFormatString,
						"UDP",
						"(None)",
						GetLocalAddressAsString(udpInfo),
						"*:*");
				}
			}
		}

		// Display the interface statisitics of all interfaces on console.
		private static void DisplayInterfaceStatistics()
		{
			NetworkInterface[] networkInterfaceList =
				NetworkInterface.GetAllNetworkInterfaces();
			Console.WriteLine();
			Console.WriteLine("Interface Statistics");

			foreach (NetworkInterface nic in networkInterfaceList)
			{
				IPv4InterfaceStatistics interfaceStatistics =
					nic.GetIPv4Statistics();
				Console.WriteLine(
					sendReceiveFormatString, nic.Name, "Received", "Sent");
				Console.WriteLine(
					sendReceiveFormatString,
					"Bytes",
					interfaceStatistics.BytesReceived,
					interfaceStatistics.BytesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Unicast packets",
					interfaceStatistics.UnicastPacketsReceived,
					interfaceStatistics.UnicastPacketsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Non-unicast packets",
					interfaceStatistics.NonUnicastPacketsReceived,
					interfaceStatistics.NonUnicastPacketsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Discards",
					interfaceStatistics.IncomingPacketsDiscarded,
					interfaceStatistics.OutgoingPacketsDiscarded);
				Console.WriteLine(
					sendReceiveFormatString,
					"Errors",
					interfaceStatistics.IncomingPacketsWithErrors,
					interfaceStatistics.OutgoingPacketsWithErrors);
				Console.WriteLine(
					sendReceiveFormatString,
					"Unknown protocols",
					interfaceStatistics.IncomingUnknownProtocolPackets,
					"");
				Console.WriteLine();
			}
		}

		// Display the protocol statisitics of requested protocols.
		private static void DisplayProtocolStatistics()
		{
			IPGlobalProperties ipGlobal =
				IPGlobalProperties.GetIPGlobalProperties();

			if ((selectedProtocols & ProtocolTypes.IP) ==
				ProtocolTypes.IP)
				DisplayIPv4Statistics(ipGlobal);
			if ((selectedProtocols & ProtocolTypes.Tcp) ==
				ProtocolTypes.Tcp)
				DisplayTcpV4Statistics(ipGlobal);
			if ((selectedProtocols & ProtocolTypes.Udp) ==
				ProtocolTypes.Udp)
				DisplayUdpV4Statistics(ipGlobal);
			if ((selectedProtocols & ProtocolTypes.Icmp) ==
				ProtocolTypes.Icmp)
				DisplayIcmpV4Statistics(ipGlobal);
			if ((selectedProtocols & ProtocolTypes.UdpV6) ==
				ProtocolTypes.UdpV6)
				DisplayUdpV6Statistics(ipGlobal);
			if ((selectedProtocols & ProtocolTypes.TcpV6) ==
				ProtocolTypes.TcpV6)
				DisplayTcpV6Statistics(ipGlobal);
			if ((selectedProtocols & ProtocolTypes.IPv6) ==
				ProtocolTypes.IPv6)
				DisplayIPv6Statistics(ipGlobal);
			if ((selectedProtocols & ProtocolTypes.IcmpV6) ==
				ProtocolTypes.IcmpV6)
				DisplayIcmpV6Statistics(ipGlobal);
		}


		// Display the data for given IcmpV4Statistics object.
		private static void DisplayIcmpV4Statistics(
			IPGlobalProperties ipGlobal)
		{
			string protocol = GetProtocolString(ProtocolTypes.Icmp);
			Console.WriteLine();
			Console.WriteLine("{0} Statistics", protocol);

			try
			{
				IcmpV4Statistics icmpStat = ipGlobal.GetIcmpV4Statistics();
				Console.WriteLine(sendReceiveFormatString, "", "Received", "Sent");
				Console.WriteLine(
					sendReceiveFormatString,
					"Messages",
					icmpStat.MessagesReceived,
					icmpStat.MessagesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Errors",
					icmpStat.ErrorsReceived,
					icmpStat.ErrorsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Destination Unreachable",
					icmpStat.DestinationUnreachableMessagesReceived,
					icmpStat.DestinationUnreachableMessagesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Time Exceeded",
					icmpStat.TimeExceededMessagesReceived,
					icmpStat.TimeExceededMessagesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Parameter Problems",
					icmpStat.ParameterProblemsReceived,
					icmpStat.ParameterProblemsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Source Quenches",
					icmpStat.SourceQuenchesReceived,
					icmpStat.SourceQuenchesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Redirects",
					icmpStat.RedirectsReceived,
					icmpStat.RedirectsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Echos",
					icmpStat.EchoRequestsReceived,
					icmpStat.EchoRequestsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Echo Replies",
					icmpStat.EchoRepliesReceived,
					icmpStat.EchoRepliesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Timestamps",
					icmpStat.TimestampRequestsReceived,
					icmpStat.TimestampRequestsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Timestamp Replies",
					icmpStat.TimestampRepliesReceived,
					icmpStat.TimestampRepliesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Address Masks",
					icmpStat.AddressMaskRequestsReceived,
					icmpStat.AddressMaskRequestsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Address Mask Replies",
					icmpStat.AddressMaskRepliesReceived,
					icmpStat.AddressMaskRepliesSent);
			}
			catch (NetworkInformationException ex)
			{
				Console.WriteLine(errorFormatString, protocol, ex.Message);
			}
		}

		// Display the data for given IcmpV6Statistics object.
		private static void DisplayIcmpV6Statistics(
			IPGlobalProperties ipGlobal)
		{
			string protocol = GetProtocolString(ProtocolTypes.IcmpV6);
			Console.WriteLine();
			Console.WriteLine("{0} Statistics", protocol);
			try
			{
				IcmpV6Statistics icmpStat = ipGlobal.GetIcmpV6Statistics();
				Console.WriteLine(sendReceiveFormatString, "", "Received", "Sent");
				Console.WriteLine(
					sendReceiveFormatString,
					"Messages",
					icmpStat.MessagesReceived,
					icmpStat.MessagesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Errors",
					icmpStat.ErrorsReceived,
					icmpStat.ErrorsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Destination Unreachable",
					icmpStat.DestinationUnreachableMessagesReceived,
					icmpStat.DestinationUnreachableMessagesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Time Exceeded",
					icmpStat.TimeExceededMessagesReceived,
					icmpStat.TimeExceededMessagesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Parameter Problems",
					icmpStat.ParameterProblemsReceived,
					icmpStat.ParameterProblemsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Redirects",
					icmpStat.RedirectsReceived,
					icmpStat.RedirectsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Echos",
					icmpStat.EchoRepliesReceived,
					icmpStat.EchoRepliesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Echo Replies",
					icmpStat.EchoRepliesReceived,
					icmpStat.EchoRepliesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Membership Queries",
					icmpStat.MembershipQueriesReceived,
					icmpStat.MembershipQueriesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Membership Reductios",
					icmpStat.MembershipReductionsReceived,
					icmpStat.MembershipReductionsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Membership Reports",
					icmpStat.MembershipReportsReceived,
					icmpStat.MembershipReportsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Neighbour Advertisements",
					icmpStat.NeighborAdvertisementsReceived,
					icmpStat.NeighborAdvertisementsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Neighbour Solicit",
					icmpStat.NeighborSolicitsReceived,
					icmpStat.NeighborSolicitsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Packets Too Large",
					icmpStat.PacketTooBigMessagesReceived,
					icmpStat.PacketTooBigMessagesSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Redirects",
					icmpStat.RedirectsReceived,
					icmpStat.RedirectsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Router Advertisements",
					icmpStat.RouterAdvertisementsReceived,
					icmpStat.RouterAdvertisementsSent);
				Console.WriteLine(
					sendReceiveFormatString,
					"Router Solicits",
					icmpStat.RouterSolicitsReceived,
					icmpStat.RouterSolicitsSent);
			}
			catch (NetworkInformationException ex)
			{
				Console.WriteLine(errorFormatString, protocol, ex.Message);
			}
		}

		private static void DisplayUdpV4Statistics(IPGlobalProperties ipGlobal)
		{
			string protocol = GetProtocolString(ProtocolTypes.Udp);
			Console.WriteLine();
			Console.WriteLine("{0} Statistics", protocol);
			try
			{
				DisplayUdpStatistics(ipGlobal.GetUdpIPv4Statistics());
			}
			catch (NetworkInformationException ex)
			{
				Console.WriteLine(errorFormatString, protocol, ex.Message);
			}
		}

		private static void DisplayUdpV6Statistics(IPGlobalProperties ipGlobal)
		{
			string protocol = GetProtocolString(ProtocolTypes.UdpV6);
			Console.WriteLine();
			Console.WriteLine("{0} Statistics", protocol);
			try
			{
				DisplayUdpStatistics(ipGlobal.GetUdpIPv6Statistics());
			}
			catch (NetworkInformationException ex)
			{
				Console.WriteLine(errorFormatString, protocol, ex.Message);
			}
		}

		// Display the data for given UdpStatistics object.
		private static void DisplayUdpStatistics(UdpStatistics udpStat)
		{
			Console.WriteLine(
				equalsFormatString,
				"Datagrams Received",
				udpStat.DatagramsReceived);
			Console.WriteLine(
				equalsFormatString,
				"No Ports",
				udpStat.IncomingDatagramsDiscarded);
			Console.WriteLine(
				equalsFormatString,
				"Receive Errors",
				udpStat.IncomingDatagramsWithErrors);
			Console.WriteLine(
				equalsFormatString, "Datagrams Sent", udpStat.DatagramsSent);
		}

		private static void DisplayTcpV4Statistics(IPGlobalProperties ipGlobal)
		{
			string protocol = GetProtocolString(ProtocolTypes.Tcp);
			Console.WriteLine();
			Console.WriteLine("{0} Statistics", protocol);
			try
			{
				DisplayTcpStatistics(ipGlobal.GetTcpIPv4Statistics());
			}
			catch (NetworkInformationException ex)
			{
				Console.WriteLine(errorFormatString, protocol, ex.Message);
			}
		}

		private static void DisplayTcpV6Statistics(IPGlobalProperties ipGlobal)
		{
			string protocol = GetProtocolString(ProtocolTypes.TcpV6);
			Console.WriteLine();
			Console.WriteLine("{0} Statistics", protocol);
			try
			{
				DisplayTcpStatistics(ipGlobal.GetTcpIPv6Statistics());
			}
			catch (NetworkInformationException ex)
			{
				Console.WriteLine(errorFormatString, protocol, ex.Message);
			}
		}

		// Display the data for given TcpStatistics object.
		private static void DisplayTcpStatistics(TcpStatistics tcpStat)
		{
			Console.WriteLine(
				equalsFormatString,
				"Active Opens",
				tcpStat.ConnectionsInitiated);
			Console.WriteLine(
				equalsFormatString,
				"Passive Opens",
				tcpStat.ConnectionsAccepted);
			Console.WriteLine(
				equalsFormatString,
				"Failed Connection Attempts",
				tcpStat.FailedConnectionAttempts);
			Console.WriteLine(
				equalsFormatString,
				"Reset Connections",
				tcpStat.ResetConnections);
			Console.WriteLine(
				equalsFormatString,
				"Current Connections",
				tcpStat.CurrentConnections);
			Console.WriteLine(
				equalsFormatString,
				"Segments Received",
				tcpStat.SegmentsReceived);
			Console.WriteLine(
				equalsFormatString,
				"Segments Sent",
				tcpStat.SegmentsSent);
			Console.WriteLine(
				equalsFormatString,
				"Segments Retransmitted",
				tcpStat.SegmentsResent);
		}

		private static void DisplayIPv4Statistics(IPGlobalProperties ipGlobal)
		{
			string protocol = GetProtocolString(ProtocolTypes.IP);
			Console.WriteLine();
			Console.WriteLine("{0} Statistics", protocol);
			try
			{
				DisplayIPStatistics(ipGlobal.GetIPv4GlobalStatistics());
			}
			catch (NetworkInformationException ex)
			{
				Console.WriteLine(errorFormatString, protocol, ex.Message);
			}
		}

		private static void DisplayIPv6Statistics(IPGlobalProperties ipGlobal)
		{
			string protocol = GetProtocolString(ProtocolTypes.IPv6);
			Console.WriteLine();
			Console.WriteLine("{0} Statistics", protocol);
			try
			{
				DisplayIPStatistics(ipGlobal.GetIPv6GlobalStatistics());
			}
			catch (NetworkInformationException ex)
			{
				Console.WriteLine(errorFormatString, protocol, ex.Message);
			}
		}

		// Display the global IP statisitcs for given IPGlobalStatistics 
		// object.
		private static void DisplayIPStatistics(IPGlobalStatistics ipStat)
		{
			Console.WriteLine(
				equalsFormatString,
				"Packets Received",
				ipStat.ReceivedPackets);
			Console.WriteLine(
				equalsFormatString,
				"Received Header Errors",
				ipStat.ReceivedPacketsWithHeadersErrors);
			Console.WriteLine(
				equalsFormatString,
				"Received Address Errors",
				ipStat.ReceivedPacketsWithAddressErrors);
			Console.WriteLine(
				equalsFormatString,
				"Datagrams Forwarded",
				ipStat.ReceivedPacketsForwarded);
			Console.WriteLine(
				equalsFormatString,
				"Unknown Protocols Received",
				ipStat.ReceivedPacketsWithUnknownProtocol);
			Console.WriteLine(
				equalsFormatString,
				"Received Packets Discarded",
				ipStat.ReceivedPacketsDiscarded);
			Console.WriteLine(
				equalsFormatString,
				"Received Packets Delivered",
				ipStat.ReceivedPacketsDelivered);
			Console.WriteLine(
				equalsFormatString,
				"Output Requests",
				ipStat.OutputPacketRequests);
			Console.WriteLine(
				equalsFormatString,
				"Routing Discards",
				ipStat.OutputPacketRoutingDiscards);
			Console.WriteLine(
				equalsFormatString,
				"Discarded Output Packets",
				ipStat.OutputPacketsDiscarded);
			Console.WriteLine(
				equalsFormatString,
				"Output Packet No Route",
				ipStat.OutputPacketsWithNoRoute);
			Console.WriteLine(
				equalsFormatString,
				"Reassembly Required",
				ipStat.PacketReassembliesRequired);
			Console.WriteLine(
				equalsFormatString,
				"Reassembly Successful",
				ipStat.PacketsReassembled);
			Console.WriteLine(
				equalsFormatString,
				"Reassembly Failures",
				ipStat.PacketReassemblyFailures);
			Console.WriteLine(
				equalsFormatString,
				"Datagrams Successfuly Fragmented",
				ipStat.PacketsFragmented);
			Console.WriteLine(
				equalsFormatString,
				"Datagrams Failing Fragmentation",
				ipStat.PacketFragmentFailures);
			Console.WriteLine(
				equalsFormatString,
				"Fragments Created",
				ipStat.PacketsFragmented);
		}
	}
}

#T=Network Information Change
//---------------------------------------------------------------------
//	This file is part of the Microsoft .NET	Framework SDK Code Samples.
// 
//	Copyright (C) Microsoft	Corporation.  All rights reserved.
// 
//This source code is intended only	as a supplement	to Microsoft
//Development Tools	and/or on-line documentation.  See these other
//materials	for	detailed information regarding Microsoft code samples.
// 
//THIS CODE	AND	INFORMATION	ARE	PROVIDED AS	IS WITHOUT WARRANTY	OF ANY
//KIND,	EITHER EXPRESSED OR	IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF	MERCHANTABILITY	AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
namespace Microsoft.Samples.NetworkInformation
{
	using System;
	using System.Windows.Forms;
	static class EntryPoint
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.Run(new NetworkInformation());
		}
	}
}
//---------------------------------------------------------------------
//	This file is part of the Microsoft .NET	Framework SDK Code Samples.
// 
//	Copyright (C) Microsoft	Corporation.  All rights reserved.
// 
//This source code is intended only	as a supplement	to Microsoft
//Development Tools	and/or on-line documentation.  See these other
//materials	for	detailed information regarding Microsoft code samples.
// 
//THIS CODE	AND	INFORMATION	ARE	PROVIDED AS	IS WITHOUT WARRANTY	OF ANY
//KIND,	EITHER EXPRESSED OR	IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF	MERCHANTABILITY	AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
namespace Microsoft.Samples.NetworkInformation
{
	using System;
	using System.Net;
	using System.Drawing;
	using System.Collections;
	using System.Globalization;
	using System.Windows.Forms;
	using System.ComponentModel;
	using System.Net.NetworkInformation;
	///	<summary>
	///	This form provides information pertaining to the network elements
	///	on the current machine such	as network interfaces, IP addresses,
	///	and	transmission statistics
	///	</summary>
	public partial class NetworkInformation : System.Windows.Forms.Form
	{
		///	<summary>
		///	Required designer variable.
		///	</summary>
		private System.ComponentModel.IContainer components = null;
		private NetworkInterface[] networkInterfaces = null;
		private NetworkInterface currentInterface = null;
		public NetworkInformation()
		{
			InitializeComponent();
		}
		private void NetworkInformation_Load(object sender, System.EventArgs e)
		{
			// Wire	up the NetworkAddressChanged events so we can get notified
			// when	an address change occurs on any of the network interfaces.
			// These changes occur when the interface changes operational
			// status (up/down) or a new interface is added. 
			NetworkChange.NetworkAddressChanged +=
				new NetworkAddressChangedEventHandler(
				NetworkChange_NetworkAddressChanged);
			NetworkChange.NetworkAvailabilityChanged +=
				new NetworkAvailabilityChangedEventHandler(
				NetworkChange_NetworkAvailabilityChanged);
			// Populate	the	global interfaces container	with the list of all
			// network interfaces.
			networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
			// Determine if	the	network	is available at	startup.
			UpdateNetworkAvailability(NetworkInterface.GetIsNetworkAvailable());
			// Update the information for the network interfaces.
			UpdateNetworkInformation();
		}
		// This	timer call updates information associated with the currently
		// selected	interface that is often	changing such as operational 
		// status, transfer	statistics,	and	speed.
		private void tmrUpdateInfo_Tick(object sender, System.EventArgs e)
		{
			UpdateNicStats();
		}
		private void UpdateNicStats()
		{
			// Get the IPv4	statistics for the currently selected interface.
			IPv4InterfaceStatistics ipStats =
				currentInterface.GetIPv4Statistics();
			NumberFormatInfo numberFormat = NumberFormatInfo.CurrentInfo;
			long bytesReceivedInKB = ipStats.BytesReceived / 1024;
			long bytesSentInKB = ipStats.BytesSent / 1024;
			this.speedTextLabel.Text = GetSpeedString(currentInterface.Speed);
			this.bytesReceivedTextLabel.Text = 
				bytesReceivedInKB.ToString("N0", numberFormat) + " KB";
			this.bytesSentTextLabel.Text =
				bytesSentInKB.ToString("N0", numberFormat) + " KB";
			this.operationalStatusTextLabel.Text =
				currentInterface.OperationalStatus.ToString();
			this.supportsMulticastTextLabel.Text =
				currentInterface.SupportsMulticast.ToString();
		}
		// Provide better formatting for some common speeds.
		static private string GetSpeedString(long speed)
		{
			switch (speed)
			{
				case 10000000:
					return "10 MB";
				case 11000000:
					return "11 MB";
				case 54000000:
					return "54 MB";
				case 100000000:
					return "100 MB";
				case 1000000000:
					return "1 GB";
				default:
					return speed.ToString(NumberFormatInfo.CurrentInfo);
			}
		}
		// Display the interface information that doesn't update so	often that
		// it should be	on the timer that fires	every 100 ms.  
		private void UpdateCurrentNicInformation()
		{
			// Set the DNS suffix if any exists
			IPInterfaceProperties ipProperties =
				currentInterface.GetIPProperties();
			this.dnsSuffixTextLabel.Text =
				ipProperties.DnsSuffix.ToString();
			// Display the IP address information associated with this
			// interface including anycast,	unicast, multicast,	DNS	servers,
			// WINS	servers, DHCP servers, and the gateway.
			this.addressListView.Items.Clear();
			IPAddressInformationCollection anycastInfo =
				ipProperties.AnycastAddresses;
			foreach (IPAddressInformation info in anycastInfo)
				InsertAddress(info.Address, "Anycast");
			UnicastIPAddressInformationCollection unicastInfo =
				ipProperties.UnicastAddresses;
			foreach (UnicastIPAddressInformation info in unicastInfo)
				InsertAddress(info.Address, "Unicast");
			MulticastIPAddressInformationCollection multicastInfo =
				ipProperties.MulticastAddresses;
			foreach (MulticastIPAddressInformation info in multicastInfo)
				InsertAddress(info.Address, "Multicast");
			GatewayIPAddressInformationCollection gatewayInfo =
				ipProperties.GatewayAddresses;
			foreach (GatewayIPAddressInformation info in gatewayInfo)
				InsertAddress(info.Address, "Gateway");
			IPAddressCollection ipAddresses = 
				ipProperties.WinsServersAddresses;
			InsertAddresses(ipAddresses, "WINS Server");
			ipAddresses = ipProperties.DhcpServerAddresses;
			InsertAddresses(ipAddresses, "DHCP Server");
			ipAddresses = ipProperties.DnsAddresses;
			InsertAddresses(ipAddresses, "DNS Server");
		}
		// Used	for	inserting the IPAddress	information	into the listbox.
		private void InsertAddresses(
			IPAddressCollection ipAddresses, string addressType)
		{
			foreach (IPAddress ipAddress in ipAddresses)
				InsertAddress(ipAddress, addressType);
		}
		private void InsertAddress(IPAddress ipAddress, string addressType)
		{
			string[] listViewInformation = new string[2];
			listViewInformation[0] = ipAddress.ToString();
			listViewInformation[1] = addressType;
			ListViewItem item = new ListViewItem(listViewInformation);
			addressListView.Items.Add(item);
		}
		// Called on startup and whenever there	is a network change	event, this
		// method reloads the list of interfaces and sets the selection	to the
		// first one in	the	list.  The list	is reloaded	because	this event 
		// could have been fired as	a result of	an interface being removed from
		// the machine.
		private void UpdateNetworkInformation()
		{
			networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
			this.networkInterfacesComboBox.Items.Clear();
			foreach (NetworkInterface networkInterface in networkInterfaces)
			{
				networkInterfacesComboBox.Items.Add(
					networkInterface.Description);
			}
			if (networkInterfaces.Length == 0)
			{
				this.networkInterfacesComboBox.Items.Add(
					"No	NICs found on the machine");
			}
			else
			{
				currentInterface = networkInterfaces[0];
				UpdateCurrentNicInformation();
			}
			this.networkInterfacesComboBox.SelectedIndex = 0;
		}
		private void UpdateNetworkAvailability(bool isNetworkAvailable)
		{
			if (isNetworkAvailable)
			{
				this.networkAvailabilityTextLabel.Text =
					"At least one network interface is up.";
			}
			else
			{
				this.networkAvailabilityTextLabel.Text =
					"The network is not currently available.";
			}
		}
		private delegate void NetworkAddressChangedCallback();
		private delegate void NetworkAvailabilityCallback(
			bool isNetworkAvailable);
		// Update network interface	information	whenever an	address	changes.
		private void NetworkChange_NetworkAddressChanged(
			object sender, EventArgs e)
		{
			this.Invoke(
				new NetworkAddressChangedCallback(UpdateNetworkInformation));
		}
		// Update network availability.
		private void NetworkChange_NetworkAvailabilityChanged(
			object sender, NetworkAvailabilityEventArgs e)
		{
			this.Invoke(
				new NetworkAvailabilityCallback(UpdateNetworkAvailability),
				new object[1] { e.IsAvailable });
		}
		// Update current interface	information	whenever selection changes.
		private void OnSelectionChanged(object sender, System.EventArgs e)
		{
			currentInterface =
				networkInterfaces[networkInterfacesComboBox.SelectedIndex];
			UpdateCurrentNicInformation();
		}
	}
}
//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
namespace Microsoft.Samples.NetworkInformation
{
	public partial class NetworkInformation : System.Windows.Forms.Form
	{
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.networkInterfacesComboBox = new System.Windows.Forms.ComboBox();
			this.interfacesLabel = new System.Windows.Forms.Label();
			this.updateInfoTimer = new System.Windows.Forms.Timer(this.components);
			this.addressListView = new System.Windows.Forms.ListView();
			this.clmnAddress = new System.Windows.Forms.ColumnHeader("");
			this.clmnAddressType = new System.Windows.Forms.ColumnHeader("");
			this.networkAvailabilityLabel = new System.Windows.Forms.Label();
			this.networkAvailabilityTextLabel = new System.Windows.Forms.Label();
			this.operationalStatusLabel = new System.Windows.Forms.Label();
			this.operationalStatusTextLabel = new System.Windows.Forms.Label();
			this.supportsMulticastLabel = new System.Windows.Forms.Label();
			this.supportsMulticastTextLabel = new System.Windows.Forms.Label();
			this.bytesSentLabel = new System.Windows.Forms.Label();
			this.bytesSentTextLabel = new System.Windows.Forms.Label();
			this.bytesReceivedLabel = new System.Windows.Forms.Label();
			this.bytesReceivedTextLabel = new System.Windows.Forms.Label();
			this.speedLabel = new System.Windows.Forms.Label();
			this.speedTextLabel = new System.Windows.Forms.Label();
			this.dnsSuffixLabel = new System.Windows.Forms.Label();
			this.dnsSuffixTextLabel = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// networkInterfacesComboBox
			// 
			this.networkInterfacesComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.networkInterfacesComboBox.FormattingEnabled = true;
			this.networkInterfacesComboBox.Location = new System.Drawing.Point(85, 36);
			this.networkInterfacesComboBox.Margin = new System.Windows.Forms.Padding(1, 3, 3, 3);
			this.networkInterfacesComboBox.Name = "networkInterfacesComboBox";
			this.networkInterfacesComboBox.Size = new System.Drawing.Size(431, 21);
			this.networkInterfacesComboBox.TabIndex = 0;
			this.networkInterfacesComboBox.SelectedIndexChanged += new System.EventHandler(this.OnSelectionChanged);
			// 
			// interfacesLabel
			// 
			this.interfacesLabel.Location = new System.Drawing.Point(11, 37);
			this.interfacesLabel.Margin = new System.Windows.Forms.Padding(3, 3, 0, 3);
			this.interfacesLabel.Name = "interfacesLabel";
			this.interfacesLabel.Size = new System.Drawing.Size(72, 20);
			this.interfacesLabel.TabIndex = 1;
			this.interfacesLabel.Text = "Interfaces:";
			// 
			// updateInfoTimer
			// 
			this.updateInfoTimer.Enabled = true;
			this.updateInfoTimer.Tick += new System.EventHandler(this.tmrUpdateInfo_Tick);
			// 
			// addressListView
			// 
			this.addressListView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
			this.clmnAddress,
			this.clmnAddressType});
			this.addressListView.FullRowSelect = true;
			this.addressListView.GridLines = true;
			this.addressListView.BackgroundImageTiled = false;
			this.addressListView.Location = new System.Drawing.Point(24, 147);
			this.addressListView.Name = "addressListView";
			this.addressListView.Size = new System.Drawing.Size(492, 272);
			this.addressListView.TabIndex = 2;
			this.addressListView.View = System.Windows.Forms.View.Details;
			// 
			// clmnAddress
			// 
			this.clmnAddress.Text = "Address";
			this.clmnAddress.Width = 236;
			// 
			// clmnAddressType
			// 
			this.clmnAddressType.Text = "Type";
			this.clmnAddressType.Width = 248;
			// 
			// networkAvailabilityLabel
			// 
			this.networkAvailabilityLabel.Location = new System.Drawing.Point(11, 12);
			this.networkAvailabilityLabel.Margin = new System.Windows.Forms.Padding(3, 3, 3, 1);
			this.networkAvailabilityLabel.Name = "networkAvailabilityLabel";
			this.networkAvailabilityLabel.Size = new System.Drawing.Size(106, 19);
			this.networkAvailabilityLabel.TabIndex = 3;
			this.networkAvailabilityLabel.Text = "Network Availability:";
			// 
			// networkAvailabilityTextLabel
			// 
			this.networkAvailabilityTextLabel.Location = new System.Drawing.Point(122, 12);
			this.networkAvailabilityTextLabel.Name = "networkAvailabilityTextLabel";
			this.networkAvailabilityTextLabel.Size = new System.Drawing.Size(380, 20);
			this.networkAvailabilityTextLabel.TabIndex = 4;
			this.networkAvailabilityTextLabel.Text = "At least one network interface is up";
			// 
			// operationalStatusLabel
			// 
			this.operationalStatusLabel.Location = new System.Drawing.Point(286, 88);
			this.operationalStatusLabel.Margin = new System.Windows.Forms.Padding(3, 0, 3, 3);
			this.operationalStatusLabel.Name = "operationalStatusLabel";
			this.operationalStatusLabel.Size = new System.Drawing.Size(104, 15);
			this.operationalStatusLabel.TabIndex = 5;
			this.operationalStatusLabel.Text = "Operational Status:";
			// 
			// operationalStatusTextLabel
			// 
			this.operationalStatusTextLabel.Location = new System.Drawing.Point(418, 86);
			this.operationalStatusTextLabel.Margin = new System.Windows.Forms.Padding(3, 2, 3, 3);
			this.operationalStatusTextLabel.Name = "operationalStatusTextLabel";
			this.operationalStatusTextLabel.Size = new System.Drawing.Size(113, 16);
			this.operationalStatusTextLabel.TabIndex = 6;
			this.operationalStatusTextLabel.Text = "Up";
			// 
			// supportsMulticastLabel
			// 
			this.supportsMulticastLabel.Location = new System.Drawing.Point(286, 63);
			this.supportsMulticastLabel.Name = "supportsMulticastLabel";
			this.supportsMulticastLabel.Size = new System.Drawing.Size(104, 21);
			this.supportsMulticastLabel.TabIndex = 7;
			this.supportsMulticastLabel.Text = "Supports Multicast:";
			// 
			// supportsMulticastTextLabel
			// 
			this.supportsMulticastTextLabel.Location = new System.Drawing.Point(418, 63);
			this.supportsMulticastTextLabel.Margin = new System.Windows.Forms.Padding(3, 3, 3, 1);
			this.supportsMulticastTextLabel.Name = "supportsMulticastTextLabel";
			this.supportsMulticastTextLabel.Size = new System.Drawing.Size(73, 20);
			this.supportsMulticastTextLabel.TabIndex = 8;
			this.supportsMulticastTextLabel.Text = "Yes";
			// 
			// bytesSentLabel
			// 
			this.bytesSentLabel.Location = new System.Drawing.Point(11, 90);
			this.bytesSentLabel.Name = "bytesSentLabel";
			this.bytesSentLabel.Size = new System.Drawing.Size(89, 18);
			this.bytesSentLabel.TabIndex = 9;
			this.bytesSentLabel.Text = "Bytes Sent:";
			// 
			// bytesSentTextLabel
			// 
			this.bytesSentTextLabel.Location = new System.Drawing.Point(122, 91);
			this.bytesSentTextLabel.Name = "bytesSentTextLabel";
			this.bytesSentTextLabel.Size = new System.Drawing.Size(144, 17);
			this.bytesSentTextLabel.TabIndex = 10;
			this.bytesSentTextLabel.Text = "0";
			// 
			// bytesReceivedLabel
			// 
			this.bytesReceivedLabel.Location = new System.Drawing.Point(11, 115);
			this.bytesReceivedLabel.Name = "bytesReceivedLabel";
			this.bytesReceivedLabel.Size = new System.Drawing.Size(88, 17);
			this.bytesReceivedLabel.TabIndex = 11;
			this.bytesReceivedLabel.Text = "Bytes Received:";
			// 
			// bytesReceivedTextLabel
			// 
			this.bytesReceivedTextLabel.Location = new System.Drawing.Point(122, 116);
			this.bytesReceivedTextLabel.Name = "bytesReceivedTextLabel";
			this.bytesReceivedTextLabel.Size = new System.Drawing.Size(158, 16);
			this.bytesReceivedTextLabel.TabIndex = 12;
			this.bytesReceivedTextLabel.Text = "0";
			// 
			// speedLabel
			// 
			this.speedLabel.Location = new System.Drawing.Point(286, 113);
			this.speedLabel.Name = "speedLabel";
			this.speedLabel.Size = new System.Drawing.Size(88, 18);
			this.speedLabel.TabIndex = 13;
			this.speedLabel.Text = "Speed:";
			// 
			// speedTextLabel
			// 
			this.speedTextLabel.Location = new System.Drawing.Point(418, 114);
			this.speedTextLabel.Margin = new System.Windows.Forms.Padding(3, 1, 3, 3);
			this.speedTextLabel.Name = "speedTextLabel";
			this.speedTextLabel.Size = new System.Drawing.Size(119, 22);
			this.speedTextLabel.TabIndex = 14;
			this.speedTextLabel.Text = "100";
			// 
			// dnsSuffixLabel
			// 
			this.dnsSuffixLabel.Location = new System.Drawing.Point(11, 63);
			this.dnsSuffixLabel.Name = "dnsSuffixLabel";
			this.dnsSuffixLabel.Size = new System.Drawing.Size(68, 18);
			this.dnsSuffixLabel.TabIndex = 15;
			this.dnsSuffixLabel.Text = "DNS Suffix:";
			// 
			// dnsSuffixTextLabel
			// 
			this.dnsSuffixTextLabel.Location = new System.Drawing.Point(121, 63);
			this.dnsSuffixTextLabel.Margin = new System.Windows.Forms.Padding(3, 3, 3, 1);
			this.dnsSuffixTextLabel.Name = "dnsSuffixTextLabel";
			this.dnsSuffixTextLabel.Size = new System.Drawing.Size(159, 23);
			this.dnsSuffixTextLabel.TabIndex = 16;
			this.dnsSuffixTextLabel.Text = "n/a";
			// 
			// NetworkInformation
			// 
			this.AutoSize = true;
			this.ClientSize = new System.Drawing.Size(558, 440);
			this.Controls.Add(this.dnsSuffixTextLabel);
			this.Controls.Add(this.dnsSuffixLabel);
			this.Controls.Add(this.speedTextLabel);
			this.Controls.Add(this.speedLabel);
			this.Controls.Add(this.bytesReceivedTextLabel);
			this.Controls.Add(this.bytesReceivedLabel);
			this.Controls.Add(this.bytesSentTextLabel);
			this.Controls.Add(this.bytesSentLabel);
			this.Controls.Add(this.supportsMulticastTextLabel);
			this.Controls.Add(this.supportsMulticastLabel);
			this.Controls.Add(this.operationalStatusTextLabel);
			this.Controls.Add(this.operationalStatusLabel);
			this.Controls.Add(this.networkAvailabilityTextLabel);
			this.Controls.Add(this.networkAvailabilityLabel);
			this.Controls.Add(this.addressListView);
			this.Controls.Add(this.interfacesLabel);
			this.Controls.Add(this.networkInterfacesComboBox);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.Fixed3D;
			this.MaximizeBox = false;
			this.Name = "NetworkInformation";
			this.Padding = new System.Windows.Forms.Padding(9);
			this.Text = "Network Information";
			this.Load += new System.EventHandler(this.NetworkInformation_Load);
			this.ResumeLayout(false);
		}
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		private System.Windows.Forms.ComboBox networkInterfacesComboBox;
		private System.Windows.Forms.Label interfacesLabel;
		private System.Windows.Forms.Timer updateInfoTimer;
		private System.Windows.Forms.ColumnHeader clmnAddress;
		private System.Windows.Forms.ColumnHeader clmnAddressType;
		private System.Windows.Forms.ListView addressListView;
		private System.Windows.Forms.Label networkAvailabilityLabel;
		private System.Windows.Forms.Label networkAvailabilityTextLabel;
		private System.Windows.Forms.Label operationalStatusLabel;
		private System.Windows.Forms.Label operationalStatusTextLabel;
		private System.Windows.Forms.Label supportsMulticastLabel;
		private System.Windows.Forms.Label supportsMulticastTextLabel;
		private System.Windows.Forms.Label bytesSentTextLabel;
		private System.Windows.Forms.Label bytesSentLabel;
		private System.Windows.Forms.Label bytesReceivedLabel;
		private System.Windows.Forms.Label bytesReceivedTextLabel;
		private System.Windows.Forms.Label speedTextLabel;
		private System.Windows.Forms.Label speedLabel;
		private System.Windows.Forms.Label dnsSuffixLabel;		
		private System.Windows.Forms.Label dnsSuffixTextLabel;
	}
}

#T=NetworkAvailabilityChanged  NetworkAddressChanged
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.NetworkInformation;
	public class NetworkChangeMointor
	{
		public static void Main()
		{
			NetworkChange.NetworkAddressChanged += new NetworkAddressChangedEventHandler(NetworkChangedCallback);
			NetworkChange.NetworkAvailabilityChanged += new NetworkAvailabilityChangedEventHandler(NetworkChangedCallback);
			Console.WriteLine("Listening for address changes. Press any key to exit.");
			Console.ReadLine();
		}
		static void NetworkChangedCallback(object sender, EventArgs e)
		{
			if (e is NetworkAvailabilityEventArgs)
			{
				Console.WriteLine("NetworkAvailabilityChanged: {0}", (e as NetworkAvailabilityEventArgs).IsAvailable);
			}
			else
			{
				Console.WriteLine("NetworkAddressChanged!");
			}
			
			NetworkInterface[] adapters = NetworkInterface.GetAllNetworkInterfaces();
			foreach(NetworkInterface n in adapters)
			{
				Console.WriteLine("   {0} is {1}", n.Name, n.OperationalStatus);
			}
		}
	}
}
#T=ObjectsTypesBytesHelper 2012-04-17
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Reflection;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	using System.Linq.Expressions;
	public static class ObjectsTypesBytesHelper
	{
		public static byte[] ObjectToBytes<T>
								 (
									T Object
									, Func
										<
											int
											, int
											, MemberInfo
											, Type									//Member Data Type
											, MemberSequenceBytesLengthAttribute
											, DynamicPropertyOrFieldAccessor
											, byte[]								// return
										> processObjectMemberBytesBlockFunc
								 )
		{
			Type type = typeof(T);
			Tuple
				<
					Type
					, ClassOrStructBytesLengthAttribute
					, List
						<
							Tuple
								<
									Type
									, ClassOrStructBytesLengthAttribute
									, MemberInfo
									, Type
									, MemberSequenceBytesLengthAttribute
									, DynamicPropertyOrFieldAccessor
								>
						>
				> entry = ObjectsTypesCache.GetOrAdd(type);
			int p = 0;
			List<byte[]> buffersList = new List<byte[]>();
			int i = 1;
			entry.Item3.ForEach
							(
								(x) =>
								{
									byte[] buffer = processObjectMemberBytesBlockFunc
														(
															i
															, p					//累计长度
															, x.Item3
															, x.Item4
															, x.Item5
															, x.Item6
														);
									p += buffer.Length;
									buffersList.Add(buffer);
								}
							);
			ClassOrStructBytesLengthAttribute attribute = entry.Item2;
			int offset = attribute.BytesLength;
			byte[] buff = new byte[offset];
			byte[] buf = BitConverter.GetBytes(p);
			int count = (buf.Length < buff.Length ? buf.Length : buff.Length);
			Buffer.BlockCopy
						(
							buf
							, 0
							, buff
							, 0
							, count
						);
			Array.Reverse(buff);
			byte[] bytes = new byte[p + offset];
			p = 0;
			Buffer.BlockCopy
						(
							buff
							, 0
							, bytes
							, 0
							, buff.Length
						);
			p += buff.Length;
			buffersList.ForEach
							(
								(x) =>
								{
									Buffer.BlockCopy
												(
													x
													, 0
													, bytes
													, p
													, x.Length
												);
									p += x.Length;
								}
							);
			return bytes;
		}
	
	
	}



	public static class ObjectsTypesCache
	{
		public static ConcurrentDictionary
									<
										Type
										, Tuple
											<
												Type			//类的类型
												, ClassOrStructBytesLengthAttribute
												, List
													<
														Tuple
															<
																Type									//类的类型
																, ClassOrStructBytesLengthAttribute
																, MemberInfo
																, Type									//Member Data Type
																, MemberSequenceBytesLengthAttribute
																, DynamicPropertyOrFieldAccessor
															>
													>
											>
									> TypesMembersInfosAccessorsDictionaryCache
		{
			get;
			private set;
		}
		static ObjectsTypesCache()
		{
			TypesMembersInfosAccessorsDictionaryCache = new ConcurrentDictionary
																		<
																			Type
																			, Tuple
																				<
																					Type
																					, ClassOrStructBytesLengthAttribute
																					, List
																						<
																							Tuple
																								<
																									Type
																									, ClassOrStructBytesLengthAttribute
																									, MemberInfo
																									, Type
																									, MemberSequenceBytesLengthAttribute
																									, DynamicPropertyOrFieldAccessor
																								>
																						>
																				>
																		>();
		}
		public static Tuple
						<
							Type
							, ClassOrStructBytesLengthAttribute
							, List
								<
									Tuple
										<
											Type
											, ClassOrStructBytesLengthAttribute
											, MemberInfo
											, Type
											, MemberSequenceBytesLengthAttribute
											, DynamicPropertyOrFieldAccessor
										>
								>
						> GetOrAdd(Type type)
		{
			return TypesMembersInfosAccessorsDictionaryCache.GetOrAdd
																(
																	type
																	, (t) =>
																	{
																		ClassOrStructBytesLengthAttribute typeAttribute =
																									(
																										(ClassOrStructBytesLengthAttribute[])
																										t.GetCustomAttributes
																												(
																													typeof(ClassOrStructBytesLengthAttribute)
																													, false
																												)
																									).OrderBy
																										(
																											(x) =>
																											{
																												return x.AttributeSequence;
																											}
																										).ToList().First();
																		Tuple
																			<
																				Type			//类的类型
																				, ClassOrStructBytesLengthAttribute
																				, List
																					<
																						Tuple
																							<
																								Type										//类的类型
																								, ClassOrStructBytesLengthAttribute
																								, MemberInfo
																								, Type										//Member Data Type
																								, MemberSequenceBytesLengthAttribute
																								, DynamicPropertyOrFieldAccessor
																							>
																					>
																			> entry =
																					new Tuple
																							<
																								Type
																								, ClassOrStructBytesLengthAttribute
																								, List
																									<
																										Tuple
																											<
																												Type
																												, ClassOrStructBytesLengthAttribute
																												, MemberInfo
																												, Type
																												, MemberSequenceBytesLengthAttribute
																												, DynamicPropertyOrFieldAccessor
																											>
																									>
																							>
																							(
																								type
																								, typeAttribute
																								, GetTypeAllMembersInfosList(type, typeAttribute)
																							);
																		return entry;
																	}
																);
		}
		private static List
						<
							Tuple
								<
									Type										//类的类型
									, ClassOrStructBytesLengthAttribute
									, MemberInfo
									, Type										//Member Data Type
									, MemberSequenceBytesLengthAttribute
									, DynamicPropertyOrFieldAccessor
								>
						> GetTypeAllMembersInfosList(Type t, ClassOrStructBytesLengthAttribute typeAttribute)
		{
			List
				<
					Tuple
						<
							Type												//类的类型
							, ClassOrStructBytesLengthAttribute
							, MemberInfo
							, Type												//Member Data Type
							, MemberSequenceBytesLengthAttribute
							, DynamicPropertyOrFieldAccessor
						>
				> list = null;
			t.GetMembers().ToList().Where
											(
												(mi) =>
												{
													var r = false;
													if (mi.MemberType == MemberTypes.Field || mi.MemberType == MemberTypes.Property)
													{
														var attributes =
																		(
																			(MemberSequenceBytesLengthAttribute[])mi.GetCustomAttributes
																									(
																										typeof(MemberSequenceBytesLengthAttribute)
																										, false
																									)
																		).OrderBy
																										(
																											(x) =>
																											{
																												return x.AttributeSequence;
																											}
																										).ToList();
														if (attributes.Count > 0)
														{
															var attribute = attributes.First();
															if (list == null)
															{
																list = new List
																				<
																					Tuple
																						<
																							Type									//类的类型
																							, ClassOrStructBytesLengthAttribute
																							, MemberInfo
																							, Type									//Member Data Type
																							, MemberSequenceBytesLengthAttribute
																							, DynamicPropertyOrFieldAccessor
																						>
																				>();
															}
															Type type = null;
															if (mi.MemberType == MemberTypes.Field)
															{
																type = ((FieldInfo)mi).FieldType;
															}
															else if (mi.MemberType == MemberTypes.Property)
															{
																type = ((PropertyInfo)mi).PropertyType;
															}
															Tuple
																<
																	Type
																	, ClassOrStructBytesLengthAttribute
																	, MemberInfo
																	, Type													//Member Data Type
																	, MemberSequenceBytesLengthAttribute
																	, DynamicPropertyOrFieldAccessor
																 > entry = new Tuple
																				<
																					Type									//类的类型
																					, ClassOrStructBytesLengthAttribute
																					, MemberInfo
																					, Type									//Member Data Type
																					, MemberSequenceBytesLengthAttribute
																					, DynamicPropertyOrFieldAccessor
																				>
																				(
																					t
																					, typeAttribute
																					, mi
																					, type
																					, attribute
																					, new DynamicPropertyOrFieldAccessor(mi)
																				);
															list.Add(entry);
															r = true;
														}
													}
													return r;
												}
											).ToList();
			var result = list.OrderBy
								(
									(entry) =>
									{
										return entry.Item5.AttributeSequence;
									}
								).ToList();
			return result;
		}
	}
	public class DynamicPropertyOrFieldAccessor
	{
		private Func<object, object> m_getter;
		//public DynamicPropertyAccessor(Type type, string propertyName)
		//	: this(type.GetProperty(propertyName))
		//{
		//}
		public DynamicPropertyOrFieldAccessor(MemberInfo memberInfo)
		{
			// target: (object)((({TargetType})instance).{Property})
			// preparing parameter, object type
			ParameterExpression instance = Expression.Parameter
															(
																typeof(object),
																"instance"
															);
			// ({TargetType})instance
			Expression instanceCast = Expression.Convert
													(
														instance
														, memberInfo.ReflectedType
													);
			// (({TargetType})instance).{Property}
			Expression memberAccess = Expression.PropertyOrField
														(
															instanceCast
															, memberInfo.Name
														);
			// (object)((({TargetType})instance).{Property})
			UnaryExpression castPropertyValue = Expression.Convert
																(
																	memberAccess
																	, typeof(object)
																);
			// Lambda expression
			Expression<Func<object, object>> lambda = Expression.Lambda<Func<object, object>>
																					(
																						castPropertyValue, instance
																					);
			this.m_getter = lambda.Compile();
		}
		public object GetValue(object o)
		{
			return this.m_getter(o);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Reflection;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	[AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true)]
	public class ClassOrStructBytesLengthAttribute : Attribute
	{
		public int BytesLength
		{
			get;
			set;
		}
		public int AttributeSequence
		{
			get;
			set;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)]
	public class MemberSequenceBytesLengthAttribute : Attribute
	{
		public int MemberSequence
		{
			get;
			set;
		}
		public int AttributeSequence
		{
			get;
			set;
		}
		public int BytesLength
		{
			get;
			set;
		}
	}
}
#T=OfficeCommunicator 2007 Daemon
// /r:Interop.CommunicatorAPI.dll;Interop.CommunicatorPrivate.dll;C:\Windows\assembly\GAC\Microsoft.mshtml\7.0.3300.0__b03f5f7f11d50a3a\Microsoft.mshtml.dll
namespace Microshaoft
{
	using System;
	using CommunicatorAPI;
	using CommunicatorPrivate;
	using mshtml;
	using WindowsAPI;
	class OcDaemon
	{
		private Messenger _messenger;
		static void Main(string[] args)
		{
			OcDaemon x = new OcDaemon();
			x.Run();
		}
		public void Run()
		{
			_messenger = new Messenger();
			_messenger.OnSignin += new DMessengerEvents_OnSigninEventHandler(_messenger_OnSignin);
			_messenger.OnIMWindowCreated += new DMessengerEvents_OnIMWindowCreatedEventHandler(_messenger_OnIMWindowCreated);
			_messenger.OnIMWindowContactAdded += new DMessengerEvents_OnIMWindowContactAddedEventHandler(_messenger_OnIMWindowContactAdded);
			_messenger.OnIMWindowContactRemoved += new DMessengerEvents_OnIMWindowContactRemovedEventHandler(_messenger_OnIMWindowContactRemoved);
			_messenger.OnIMWindowDestroyed += new DMessengerEvents_OnIMWindowDestroyedEventHandler(_messenger_OnIMWindowDestroyed);
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine()))
			{
				if (string.IsNullOrEmpty(input))
				{
					input = "test@facebook.com";
				}
				object[] sipUris = { input , input };
				long hWnd;
				IMessengerAdvanced ma = _messenger as IMessengerAdvanced;
				if (ma != null)
				{
					object conversationWindow = ma.StartConversation
							(
								CONVERSATION_TYPE.CONVERSATION_TYPE_IM,
								sipUris,
								null,
								"Testing",
								"1",
								null
							);
					hWnd = long.Parse(conversationWindow.ToString());
					Console.WriteLine(hWnd);
					IntPtr hDirectUIHWND = IntPtr.Zero;
					IntPtr hHistory = IntPtr.Zero;
					IntPtr hInput = IntPtr.Zero;
					hDirectUIHWND = NativeMethods.FindWindowEx(new IntPtr(hWnd), IntPtr.Zero, "DirectUIHWND", IntPtr.Zero);
					Console.WriteLine(hDirectUIHWND);
					hHistory = NativeMethods.FindWindowEx(hDirectUIHWND, IntPtr.Zero, "Internet Explorer_Server", IntPtr.Zero);
					Console.WriteLine(hHistory);
///					hInput = NativeMethods.FindWindowEx(hDirectUIHWND, hHistory, "Internet Explorer_Server", IntPtr.Zero);
///					Console.WriteLine(hInput);
					//mshtml.IHTMLWindow2 ihtmlwin;
					IHTMLDocument2 doc;
					IHTMLWindow2 win;
					IEHelper.GetIEDocumentFromWindowHandle(hHistory, out doc, out win);
					if (doc != null)
					{
						if (doc.body != null)
						{
							string senderName = sipUris[0].ToString();
							string html =
@"
<DIV>
	<DIV style=""POSITION: relative; PADDING-BOTTOM: 0px; PADDING-LEFT: 3px; WIDTH: 100%; PADDING-RIGHT: 3px; FONT-FAMILY: MS Shell Dlg 2; CLEAR: both; FONT-SIZE: 10pt; PADDING-TOP: 0px"" id=Normalheader class=immessageheader xmlns:convItem=""http://schemas.microsoft.com/2008/10/sip/convItems"" xmlns=""http://schemas.microsoft.com/2008/10/sip/convItems"" xmlns:rtc=""urn:microsoft-rtc-xslt-functions"" xmlns:msxsl=""urn:schemas-microsoft-com:xslt"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"">
		<SPAN style=""WHITE-SPACE: nowrap; FLOAT: right; COLOR: #666666; FONT-SIZE: 8pt; PADDING-TOP: 2px"" id=imsendtimestamp>
			{1}
		</SPAN>
		<SPAN style=""FLOAT: left; COLOR: #666666"" id=imsendname>
			{2}
		</SPAN>
		<SPAN style=""CLEAR: both"">
		</SPAN>
</DIV>
<DIV style=""POSITION: relative; PADDING-BOTTOM: 0px; PADDING-LEFT: 3px; WIDTH: 100%; PADDING-RIGHT: 3px; CLEAR: both; PADDING-TOP: 0px"" id=Normalcontent xmlns:convItem=""http://schemas.microsoft.com/2008/10/sip/convItems"" xmlns=""http://schemas.microsoft.com/2008/10/sip/convItems"" xmlns:rtc=""urn:microsoft-rtc-xslt-functions"" xmlns:msxsl=""urn:schemas-microsoft-com:xslt"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"">
	<DIV style=""FLOAT: left; HEIGHT: 100%; MARGIN-LEFT: 5px"" id=imwidget>
		<OBJECT tabIndex=-1 classid=clsid:b3913e54-389f-45ea-9a3c-56b74cd62307>
			<PARAM NAME=""_cx"" VALUE=""158"">
			<PARAM NAME=""_cy"" VALUE=""317"">
			<PARAM NAME=""EmoticonID"" VALUE=""114"">
			</OBJECT>
		</DIV>
		<DIV style=""MARGIN-LEFT: 12px"" id=imcontent>
			<SPAN>
				<DIV style=""FONT-FAMILY: MS Shell Dlg 2; DIRECTION: ltr; COLOR: #000000; FONT-SIZE: 9pt"">
					{3}
				</DIV>
			</SPAN>
		</DIV>
	</DIV>
</DIV>
";
							html = string.Format
												(
													html
													, ""
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")
													, senderName
													,
@"
请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款
请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款请汇款
" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")
												);
							doc.body.innerHTML += html;
						}
					}
					win.scrollTo(0, short.MaxValue);
				}
			}
		}
		void _messenger_OnIMWindowDestroyed(object pIMWindow)
		{
			Console.WriteLine("{0} OnIMWindowDestroyed.", "");
		}
		void _messenger_OnIMWindowContactRemoved(object pContact, object pIMWindow)
		{
			//Console.WriteLine("{0} OnIMWindowContactRemoved.", "");
			IMessengerConversationWndAdvanced imWindow = pIMWindow as IMessengerConversationWndAdvanced;
			IMessengerContact contact = pContact as IMessengerContact;
			IMessengerContacts contacts = imWindow.Contacts as IMessengerContacts;
			//if (contacts.Count == 0)
			{
				Console.WriteLine("contact:{0}{1}history:{0}{2}", "\r\n" , contact.SigninName ,imWindow.History);
			}
		}
		void _messenger_OnIMWindowContactAdded(object pContact, object pIMWindow)
		{
			IMessengerConversationWndAdvanced imWindow = pIMWindow as IMessengerConversationWndAdvanced;
			IMessengerContact contact = pContact as IMessengerContact;
			if (!contact.IsSelf)
			{
				Console.WriteLine("{0} OnIMWindowContactAdded {1}.", contact.SigninName, contact.Status);
			}
		}
		void _messenger_OnIMWindowCreated(object pIMWindow)
		{
			Console.WriteLine("{0} OnIMWindowCreated.", "");
		}
		void _messenger_OnSignin(int hr)
		{
			Console.WriteLine("{0} OnSignin.", _messenger.MySigninName);
		}
	}
}
namespace WindowsAPI
{
	using System;
	using System.Runtime.InteropServices;
	using mshtml;
	public static class IEHelper
	{
		[ComImport]
		[Guid("6d5140c1-7436-11ce-8034-00aa006009fa")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		interface IServiceProvider
		{
			void QueryService(ref Guid guidService, ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object ppvObject);
		}
		public static void GetIEDocumentFromWindowHandle
								(
									IntPtr hWnd
									, out IHTMLDocument2 document
									, out IHTMLWindow2 window
								)
		{
			document = null;
			window = null;
			Guid IID_IHTMLDocument2 = typeof(IHTMLDocument2).GUID;
			Guid IID_IHTMLWindow2 = typeof(IHTMLWindow2).GUID;
			//IHTMLDocument2 htmlDocument = null;
			if (hWnd != IntPtr.Zero)
			{
				uint lMsg = NativeMethods.RegisterWindowMessage("WM_HTML_GETOBJECT");
				UIntPtr lResult;
				NativeMethods.SendMessageTimeout
								(
									hWnd
									, lMsg
									, UIntPtr.Zero
									, IntPtr.Zero
									, SendMessageTimeoutFlags.SMTO_ABORTIFHUNG
									, 1000
									, out lResult
								 );
				if (lResult != UIntPtr.Zero)
				{
					document = NativeMethods.ObjectFromLresult(lResult, IID_IHTMLDocument2, IntPtr.Zero) as IHTMLDocument2;
					IServiceProvider provider = document as IServiceProvider;
					object htmlWindow;
					provider.QueryService(ref IID_IHTMLWindow2, ref IID_IHTMLWindow2, out htmlWindow);
					window = htmlWindow as IHTMLWindow2;
				}
			}
		}
	}
}
namespace WindowsAPI
{
	using System;
	using System.Runtime.InteropServices;
	[Flags]
	public enum SendMessageTimeoutFlags : uint
	{
		SMTO_NORMAL = 0x0,
		SMTO_BLOCK = 0x1,
		SMTO_ABORTIFHUNG = 0x2,
		SMTO_NOTIMEOUTIFNOTHUNG = 0x8
	}
	public static class NativeMethods
	{
		[DllImport("user32.dll", EntryPoint = "FindWindow", SetLastError = true)]
		public static extern IntPtr FindWindowByCaption(IntPtr ZeroOnly, string lpWindowName);
		[DllImport("user32.dll", SetLastError = true)]
		public static extern IntPtr FindWindowEx(IntPtr parentHandle, IntPtr childAfter, string className, IntPtr windowTitle);
		[DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
		public static extern uint RegisterWindowMessage(string lpString);
		[DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
		public static extern IntPtr SendMessageTimeout
										(
											IntPtr hWnd,
											uint Msg,
											UIntPtr wParam,
											IntPtr lParam,
											SendMessageTimeoutFlags fuFlags,
											uint uTimeout,
											out UIntPtr lpdwResult
										);
		[DllImport("oleacc.dll", PreserveSig = false)]
		[return: MarshalAs(UnmanagedType.Interface)]
		public static extern object ObjectFromLresult(UIntPtr lResult, [MarshalAs(UnmanagedType.LPStruct)] Guid refiid, IntPtr wParam);
	}
}

#T=OleDbDataAdapter dataset
// Assumes that customerConnection is a valid SqlConnection object.
// Assumes that orderConnection is a valid OleDbConnection object.
SqlDataAdapter custAdapter = new SqlDataAdapter(
  "SELECT * FROM dbo.Customers", customerConnection);
OleDbDataAdapter ordAdapter = new OleDbDataAdapter(
  "SELECT * FROM Orders", orderConnection);

DataSet customerOrders = new DataSet();

custAdapter.Fill(customerOrders, "Customers");
ordAdapter.Fill(customerOrders, "Orders");

DataRelation relation = customerOrders.Relations.Add("CustOrders",
  customerOrders.Tables["Customers"].Columns["CustomerID"],
  customerOrders.Tables["Orders"].Columns["CustomerID"]);

foreach (DataRow pRow in customerOrders.Tables["Customers"].Rows)
{
  Console.WriteLine(pRow["CustomerID"]);
   foreach (DataRow cRow in pRow.GetChildRows(relation))
    Console.WriteLine("\t" + cRow["OrderID"]);
}

#T=OO SOLID 5 大原则
namespace SingleResponsibilityPrinciple
{
	///[S] Single Responsibility Principle （单一职责原则）
	///认为一个对象应该仅只有一个单一的职责
	using System;
	class DataAccess
	{
		void InsertData()
		{
			Console.WriteLine("数据插入成功");
		}
		// 错误的设计，不符合 单一职责原则
		//void WriteLog()
		//{
		//	Console.WriteLine("日志插入成功");
		//}
	}
	// 应该把不同的职责交给不同的对象处理
	class Logger
	{
		void WriteLog()
		{
			Console.WriteLine("日志插入成功");
		}
	}
}
namespace OpenClosePrinciple
{
	///[o] Open Close Principle （开闭原则）
	///认为软件应该是对扩展开放的，而对修改是关闭的
	using System;
	abstract class DataProvider
	{
		public abstract void OpenConnection();
		public abstract void CloseConnection();
		public abstract void ExecuteCommand();
	}
	// MS SQL
	class SqlDataProvider:DataProvider
	{
		public override void OpenConnection()
		{
			Console.WriteLine("打开Sql数据连接");
		}
		public override void CloseConnection()
		{
			Console.WriteLine("关闭Sql数据连接");
		}
		public override void ExecuteCommand()
		{
			Console.WriteLine("执行Sql数据命令");
		}
	}
	// ORACLE
	class OracleDataProvider:DataProvider
	{
		public override void OpenConnection()
		{
			Console.WriteLine("打开Oracle数据连接");
		}
		public override void CloseConnection()
		{
			Console.WriteLine("关闭Oracle数据连接");
		}
		public override void ExecuteCommand()
		{
			Console.WriteLine("执行Oracle数据命令");
		}
	}
	class Start
	{
		void Invoke()
		{
			DataProvider dataProvider = new SqlDataProvider();
			dataProvider.OpenConnection();
			dataProvider.ExecuteCommand();
			dataProvider.CloseConnection();
			dataProvider = new OracleDataProvider();
			dataProvider.OpenConnection();
			dataProvider.ExecuteCommand();
			dataProvider.CloseConnection();
		}
	}
}
namespace LiskovSubstitutionPrinciple
{
	///[L] Liskov Substitution Principle（里氏替换原则）
	///认为程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的
	class Rectangle
	{
		protected int width = 0;
		protected int height = 0;
		public virtual void SetWidth(int width)
		{
			this.width = width;
		}
		public virtual void SetHeight(int height)
		{
			this.height = height;
		}
		public virtual int GetArea()
		{
			return this.width * this.height;
		}
	}
	class Square : Rectangle
	{
		public override void SetHeight(int height)
		{
			this.height = height;
			this.width = height;
		}
		public override void SetWidth(int width)
		{
			this.height = width;
			this.width = width;
		}
	}
	class Start
	{
		public static Rectangle CreateInstance(int condition = 1)
		{
			if (condition == 1)
			{
				return new Rectangle();
			}
			else
			{
				return new Square();
			}
		}
		public static void Invoke()
		{
			Rectangle rectangleObject = CreateInstance();
			rectangleObject.SetHeight(10);
			rectangleObject.SetWidth(20);
			rectangleObject.GetArea();
		}
	}
}
namespace InterfaceSegregationPrinciple
{
	///[I] Interface Segregation Principle（接口分离原则）
	///认为多个特定客户端接口要好于一个宽泛用途的接口，也有单一职责的意思
	using System;
	interface IDataProvider
	{
		void OpenConnection();
		void CloseConnection();
	}
	interface ISqlDataProvider : IDataProvider
	{
		void ExecuteSqlCommand();
	}
	interface IOracleDataProvider : IDataProvider
	{
		void ExecuteOracleCommand();
	}
	class SqlDataProvider : ISqlDataProvider
	{
		public void ExecuteSqlCommand()
		{
			Console.WriteLine("执行Sql数据命令");
		}
		public void OpenConnection()
		{
			Console.WriteLine("打开Sql数据连接");
		}
		public void CloseConnection()
		{
			Console.WriteLine("关闭Sql数据连接");
		}
	}
	class OracleDataProvider : IOracleDataProvider
	{
		public void ExecuteOracleCommand()
		{
			Console.WriteLine("执行Oracle数据命令");
		}
		public void OpenConnection()
		{
			Console.WriteLine("打开Oracle数据连接");
		}
		public void CloseConnection()
		{
			Console.WriteLine("关闭Oracle数据连接");
		}
	}
	class Start
	{
		public void Invoke()
		{
			ISqlDataProvider sqlDataProvider = new SqlDataProvider();
			sqlDataProvider.OpenConnection();
			sqlDataProvider.ExecuteSqlCommand();
			sqlDataProvider.CloseConnection();
			IOracleDataProvider oracleDataprovider = new OracleDataProvider();
			oracleDataprovider.OpenConnection();
			oracleDataprovider.ExecuteOracleCommand();
			oracleDataprovider.CloseConnection();
		}
	}
}
namespace DependencyInversionPrinciple
{
	///[D] Dependency Inversion Principle（依赖反转原则）
	///认为一个方法应该遵从依赖于抽象而不是一个实例，控制反转，依赖注入是该原则的一种实现
	using System;
	interface IBankAccount
	{
		long BankNumber { get; set; } // 卡号
		decimal Balance { get; set; } // 余额
	}
	// 转账人
	interface ITransferSource : IBankAccount
	{
		void CutPayment(decimal value);
	}
	// 收款人
	interface ITransferDestination : IBankAccount
	{
		void AddMoney(decimal value);
	}
	class BankAccout : IBankAccount, ITransferSource, ITransferDestination
	{
		public long BankNumber { get; set; }
		public decimal Balance { get; set; }
		public void CutPayment(decimal value)
		{
			Balance -= value;
		}
		public void AddMoney(decimal value)
		{
			Balance += value;
		}
	}
	class TransferAmount
	{
		public decimal Amount { get; set; }
		public void Transfer(ITransferSource source, ITransferDestination dest)
		{
			source.CutPayment(Amount);
			dest.AddMoney(Amount);
		}
	}
	class Start
	{
		void Invoke()
		{
			ITransferSource source = new BankAccout { Balance = 10000, BankNumber = 111 };
			ITransferDestination dest = new BankAccout { Balance = 1, BankNumber = 222 };
			TransferAmount transfer = new TransferAmount();
			transfer.Amount = 9999; // 转多少钱
			transfer.Transfer(source, dest); // 开始转账
			// 这是用依赖反转的思维做一个银行转账的功能，使银行账户可以依赖ITransferSource，ITransferDestination
			// 而不是以前直接 BankAccout account = new BankAccout();大大增加了账户这个核心对象的灵活性
			// 这个例子基本上有SOLID原则的所有身影
		}
	}
	// 附上一个普通版的 做下对比，用中文名做变量，通俗易懂吧
	class 银行账户
	{
		public int 卡号 { get; set; }
		public decimal 余额 { get; set; }
		public void 存入(decimal value)
		{
			余额 += value;
		}
		public void 支出(decimal value)
		{
			余额 -= value;
		}
	}
	class 银行转账操作 //ATM
	{
		public 银行账户 转账人 { get; set; }
		public 银行账户 收款人 { get; set; }
		public decimal 金额 { get; set; }
		public void 转账()
		{
			转账人.支出(金额);
			收款人.存入(金额);
		}
	}
	class Start1
	{
		public static void Main()
		{
			银行账户 张三 = new 银行账户 { 卡号 = 111, 余额 = 10000 };
			银行账户 李四 = new 银行账户 { 卡号 = 222, 余额 = 5 };
			银行转账操作 转账 = new 银行转账操作();
			转账.金额 = 1000;
			转账.转账人 = 张三;
			转账.收款人 = 李四;
			转账.转账();
		}
	}
}
#T=Open XML Excel
// /r:D:\OpenXML\FormatSDK\lib\DocumentFormat.OpenXml.dll
namespace ConsoleApplication
{
	using System;
	using System.Xml;
	using System.IO;
	using System.Linq;
	using System.Collections.Generic;

	using DocumentFormat.OpenXml;
	using DocumentFormat.OpenXml.Packaging;
	using DocumentFormat.OpenXml.Spreadsheet;

	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());

			using (SpreadsheetDocument doc = SpreadsheetDocument.Open(@"Book2.xlsx", true))
			{
				IEnumerable<ExternalWorkbookPart> parts = doc.WorkbookPart.ExternalWorkbookParts;
				foreach (ExternalWorkbookPart i in parts)
				{
					IEnumerable<ExternalRelationship> ships = i.ExternalRelationships;
					foreach (ExternalRelationship j in ships)
					{
						Console.WriteLine("External: {0},{1}", i.Uri.OriginalString, j.Uri.OriginalString);
					}
				}

				Worksheet sheet = GetWorksheet(doc, "Sheet1");
				Cell x = GetSpreadsheetCell(sheet, "A", 1);
				string s = x.CellFormula.Text;
				Console.WriteLine(s);
				//				x.CellFormula.Text = "[Book1.xlsx]Sheet1!A1+[Book1.xlsx]Sheet1!B1*10";
				//				x.CellFormula.CalculateCell = true;
				///				sheet.Save();
				///				Console.WriteLine(s);
			}

			///			List<string> list = XLGetSheetsInfo(@"Book1.xlsx");
			///			foreach (string var in list)
			///			{
			///				Console.WriteLine(var);
			///			}

			Console.ReadLine();
		}
		private static Cell GetSpreadsheetCell
								(
									Worksheet worksheet
									, string columnName
									, uint rowIndex
								)
		{
			IEnumerable<Row> rows = worksheet.GetFirstChild<SheetData>().Elements<Row>().Where(r => r.RowIndex == rowIndex);
			if (rows.Count() == 0)
			{
				// A cell does not exist at the specified row.
				return null;
			}
			IEnumerable<Cell> cells = rows.First().Elements<Cell>().Where(c => string.Compare(c.CellReference.Value, columnName + rowIndex, true) == 0);
			if (cells.Count() == 0)
			{
				// A cell does not exist at the specified column, in the specified row.
				return null;
			}
			return cells.First();
		}

		// Given a SpreadsheetDocument and a worksheet name, gets the specified worksheet.
		private static Worksheet GetWorksheet
									(
										SpreadsheetDocument document
										, string worksheetName
									)
		{
			IEnumerable<Sheet> sheets = document.WorkbookPart.Workbook.Descendants<Sheet>().Where(s => s.Name == worksheetName);
			if (sheets.Count() == 0)
			{
				// The specified worksheet does not exist.
				return null;
			}
			WorksheetPart worksheetPart = (WorksheetPart)document.WorkbookPart.GetPartById(sheets.First().Id);
			return worksheetPart.Worksheet;
		}

		public static List<string> XLGetSheetsInfo(string fileName)
		{
			//  Fill this collection with a list of all the sheets.
			List<string> sheets = new List<string>();
			using (SpreadsheetDocument xlPackage = SpreadsheetDocument.Open(fileName, false))
			{
				WorkbookPart workbook = xlPackage.WorkbookPart;
				Stream workbookstr = workbook.GetStream();
				XmlDocument doc = new XmlDocument();
				doc.Load(workbookstr);
				XmlNamespaceManager nsManager = new XmlNamespaceManager(doc.NameTable);
				nsManager.AddNamespace("default", doc.DocumentElement.NamespaceURI);
				XmlNodeList nodelist = doc.SelectNodes("//default:sheets/default:sheet", nsManager);
				foreach (XmlNode node in nodelist)
				{
					string sheetName = string.Empty;
					sheetName = node.Attributes["name"].Value;
					sheets.Add(sheetName);
				}
			}
			return sheets;
		}
	}
}
#T=OutputCache.asmx
<%@ WebService Language="c#" Codebehind="Service1.asmx.cs" Class="Microshaoft.Service1Class" %>

namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Web;
	using System.Web.Services;
	using System.Web.Caching;
	[WebService(Namespace="http://www.microshaoft.com/")]
	public class Service1Class : System.Web.Services.WebService
	{
		[WebMethod(CacheDuration=10)]
		public string HelloWorld()
		{
			var response = Context.Response;
			if (Context.Cache["page1"] == null)
			{
				Context.Cache.Insert
						(
							"page1"
							, DateTime.Now
							, null
							, DateTime.MaxValue
							, TimeSpan.Zero
							, CacheItemPriority.NotRemovable
							, null
						);
				response.AddCacheItemDependency("page1");
			}
			return "Hello World " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
		}
	}
}
#T=OutputCache.aspx
<%@
	Page
	language="c#"
	AutoEventWireup="true"
%>
<%@
	OutputCache
	Duration="10"
	VaryByParam="none"
%>
<%@ Import Namespace="System.Data" %>
<%@ Import Namespace="System.Security.Principal" %>
<%@ Import Namespace="System.Threading" %>
<script language="C#" runat="server">
	protected void Page_Load(object sender, EventArgs ea) 
	{
		if (Cache["page1"] == null)
		{
			Cache.Insert
					(
						"page1"
						, DateTime.Now
						, null
						, DateTime.MaxValue
						, TimeSpan.Zero
						, CacheItemPriority.NotRemovable
						, null
					);
					Response.AddCacheItemDependency("page1");
		}
		Response.Write("<br>" + DateTime.Now );
		WindowsPrincipal wp = new WindowsPrincipal(WindowsIdentity.GetCurrent());
		IIdentity identity = WindowsIdentity.GetCurrent();
		string username = identity.Name;
		Response.Write("<br>WindowsIdentity.GetCurrent(): " + username );
		identity = Thread.CurrentPrincipal.Identity;
		username = identity.Name;
		Response.Write("<br>Thread.CurrentPrincipal.Identity: " + username );
		identity = Context.User.Identity;
		Response.Write("<br>HttpContext.User.Identity: " + username );
		Response.Write("<br>.Net Framework version: " + Environment.Version.ToString()+ "<br>" );
		Response.Write("IP:<br>");
		Response.Write(string.Format("Your current IP is {0}<br>", Request.UserHostAddress));
		Response.Write("Request.ContentEncoding:<br>");
		Encoding e = Request.ContentEncoding;
		Response.Write(string.Format("&nbsp;&nbsp;&nbsp;&nbsp;{0},{1}<br>", e.EncodingName, e.HeaderName));
	}
</script>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" >
<HTML>
	<HEAD>
		<title>WebForm1</title>
		<meta name="GENERATOR" Content="Microsoft Visual Studio .NET 7.1">
		<meta name="CODE_LANGUAGE" Content="C#">
		<meta name="vs_defaultClientScript" content="JavaScript">
		<meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5">
	</HEAD>
	<body MS_POSITIONING="GridLayout">
		<form id="Form1" method="post" runat="server">
		</form>
	</body>
</HTML>
#T=p3p header
<meta http-equiv="P3P" content='CP="IDC DSP COR CURa ADMa  
OUR IND PHY ONL COM STA"'>

<meta http-equiv="P3P" href="/your_2nd_policy/p3p.xml"  
content='CP="your compact policy"'>

Response.AddHeader("P3P","policyref="http://www.xxxx.com/xxx/w3c/p3p.xml CP=\"NON DSP COR CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa CONa HISa TELa OTPa OUR UNRa IND UNI COM NAV INT DEM CNT PRE LOC\""); 
#T=Parallel TaskScheduler TaskFactory
namespace System.Threading.Tasks.Schedulers
{

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Threading;

	class Program
	{
		static void Main()
		{
			LimitedConcurrencyLevelTaskScheduler lcts = new LimitedConcurrencyLevelTaskScheduler(1);
			TaskFactory factory = new TaskFactory(lcts);

			factory.StartNew(()=> 
				{
					for (int i = 0; i < 500; i++)
					{
						Console.Write("{0} on thread {1}", i, Thread.CurrentThread.ManagedThreadId);
					}
				}
			);

			Console.ReadKey();
		}
	}

	/// <summary>
	/// Provides a task scheduler that ensures a maximum concurrency level while
	/// running on top of the ThreadPool.
	/// </summary>
	public class LimitedConcurrencyLevelTaskScheduler : TaskScheduler
	{
		/// <summary>Whether the current thread is processing work items.</summary>
		[ThreadStatic]
		private static bool _currentThreadIsProcessingItems;
		/// <summary>The list of tasks to be executed.</summary>
		private readonly LinkedList<Task> _tasks = new LinkedList<Task>(); // protected by lock(_tasks)
		/// <summary>The maximum concurrency level allowed by this scheduler.</summary>
		private readonly int _maxDegreeOfParallelism;
		/// <summary>Whether the scheduler is currently processing work items.</summary>
		private int _delegatesQueuedOrRunning = 0; // protected by lock(_tasks)

		/// <summary>
		/// Initializes an instance of the LimitedConcurrencyLevelTaskScheduler class with the
		/// specified degree of parallelism.
		/// </summary>
		/// <param name="maxDegreeOfParallelism">The maximum degree of parallelism provided by this scheduler.</param>
		public LimitedConcurrencyLevelTaskScheduler(int maxDegreeOfParallelism)
		{
			if (maxDegreeOfParallelism < 1) throw new ArgumentOutOfRangeException("maxDegreeOfParallelism");
			_maxDegreeOfParallelism = maxDegreeOfParallelism;
		}

		/// <summary>Queues a task to the scheduler.</summary>
		/// <param name="task">The task to be queued.</param>
		protected sealed override void QueueTask(Task task)
		{
			// Add the task to the list of tasks to be processed.  If there aren't enough
			// delegates currently queued or running to process tasks, schedule another.
			lock (_tasks)
			{
				_tasks.AddLast(task);
				if (_delegatesQueuedOrRunning < _maxDegreeOfParallelism)
				{
					++_delegatesQueuedOrRunning;
					NotifyThreadPoolOfPendingWork();
				}
			}
		}

		/// <summary>
		/// Informs the ThreadPool that there's work to be executed for this scheduler.
		/// </summary>
		private void NotifyThreadPoolOfPendingWork()
		{
			ThreadPool.UnsafeQueueUserWorkItem(_ =>
			{
				// Note that the current thread is now processing work items.
				// This is necessary to enable inlining of tasks into this thread.
				_currentThreadIsProcessingItems = true;
				try
				{
					// Process all available items in the queue.
					while (true)
					{
						Task item;
						lock (_tasks)
						{
							// When there are no more items to be processed,
							// note that we're done processing, and get out.
							if (_tasks.Count == 0)
							{
								--_delegatesQueuedOrRunning;
								break;
							}

							// Get the next item from the queue
							item = _tasks.First.Value;
							_tasks.RemoveFirst();
						}

						// Execute the task we pulled out of the queue
						base.TryExecuteTask(item);
					}
				}
				// We're done processing items on the current thread
				finally { _currentThreadIsProcessingItems = false; }
			}, null);
		}

		/// <summary>Attempts to execute the specified task on the current thread.</summary>
		/// <param name="task">The task to be executed.</param>
		/// <param name="taskWasPreviouslyQueued"></param>
		/// <returns>Whether the task could be executed on the current thread.</returns>
		protected sealed override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
		{
			// If this thread isn't already processing a task, we don't support inlining
			if (!_currentThreadIsProcessingItems) return false;

			// If the task was previously queued, remove it from the queue
			if (taskWasPreviouslyQueued) TryDequeue(task);

			// Try to run the task.
			return base.TryExecuteTask(task);
		}

		/// <summary>Attempts to remove a previously scheduled task from the scheduler.</summary>
		/// <param name="task">The task to be removed.</param>
		/// <returns>Whether the task could be found and removed.</returns>
		protected sealed override bool TryDequeue(Task task)
		{
			lock (_tasks) return _tasks.Remove(task);
		}

		/// <summary>Gets the maximum concurrency level supported by this scheduler.</summary>
		public sealed override int MaximumConcurrencyLevel { get { return _maxDegreeOfParallelism; } }

		/// <summary>Gets an enumerable of the tasks currently scheduled on this scheduler.</summary>
		/// <returns>An enumerable of the tasks currently scheduled.</returns>
		protected sealed override IEnumerable<Task> GetScheduledTasks()
		{
			bool lockTaken = false;
			try
			{
				Monitor.TryEnter(_tasks, ref lockTaken);
				if (lockTaken) return _tasks.ToArray();
				else throw new NotSupportedException();
			}
			finally
			{
				if (lockTaken) Monitor.Exit(_tasks);
			}
		}
	}
}

#T=Parallel.For
namespace MultiplyMatrices
{
	using System;
	using System.Collections.Generic;
	using System.Collections.Concurrent;
	using System.Diagnostics;
	using System.Linq;
	using System.Threading;
	using System.Threading.Tasks;
	class Program
	{
		#region Sequential_Loop
		static void MultiplyMatricesSequential(double[,] matA, double[,] matB,
												double[,] result)
		{
			int matACols = matA.GetLength(1);
			int matBCols = matB.GetLength(1);
			int matARows = matA.GetLength(0);
			for (int i = 0; i < matARows; i++)
			{
				for (int j = 0; j < matBCols; j++)
				{
					for (int k = 0; k < matACols; k++)
					{
						result[i, j] += matA[i, k] * matB[k, j];
					}
				}
			}
		}
		#endregion
		#region Parallel_Loop
		static void MultiplyMatricesParallel(double[,] matA, double[,] matB, double[,] result)
		{
			int matACols = matA.GetLength(1);
			int matBCols = matB.GetLength(1);
			int matARows = matA.GetLength(0);
			// A basic matrix multiplication.
			// Parallelize the outer loop to partition the source array by rows.
			Parallel.For(0, matARows, i =>
			{
				for (int j = 0; j < matBCols; j++)
				{
					// Use a temporary to improve parallel performance.
					double temp = 0;
					for (int k = 0; k < matACols; k++)
					{
						temp += matA[i, k] * matB[k, j];
					}
					result[i, j] = temp;
				}
			}); // Parallel.For
		}
		#endregion
		#region Main
		static void Main(string[] args)
		{
			// Set up matrices. Use small values to better view 
			// result matrix. Increase the counts to see greater 
			// speedup in the parallel loop vs. the sequential loop.
			int colCount = 180;
			int rowCount = 2000;
			int colCount2 = 270;
			double[,] m1 = InitializeMatrix(rowCount, colCount);
			double[,] m2 = InitializeMatrix(colCount, colCount2);
			double[,] result = new double[rowCount, colCount2];
			// First do the sequential version.
			Console.WriteLine("Executing sequential loop...");
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			MultiplyMatricesSequential(m1, m2, result);
			stopwatch.Stop();
			Console.WriteLine("Sequential loop time in milliseconds: {0}", stopwatch.ElapsedMilliseconds);
			// For the skeptics.
			OfferToPrint(rowCount, colCount2, result);
			// Reset timer and results matrix. 
			stopwatch.Reset();
			result = new double[rowCount, colCount2];
			// Do the parallel loop.
			Console.WriteLine("Executing parallel loop...");
			stopwatch.Start();
			MultiplyMatricesParallel(m1, m2, result);
			stopwatch.Stop();
			Console.WriteLine("Parallel loop time in milliseconds: {0}", stopwatch.ElapsedMilliseconds);
			OfferToPrint(rowCount, colCount2, result);
			// Keep the console window open in debug mode.
			Console.WriteLine("Press any key to exit.");
			Console.ReadKey();
		}
		#endregion
		#region Helper_Methods
		static double[,] InitializeMatrix(int rows, int cols)
		{
			double[,] matrix = new double[rows, cols];
			Random r = new Random();
			for (int i = 0; i < rows; i++)
			{
				for (int j = 0; j < cols; j++)
				{
					matrix[i, j] = r.Next(100);
				}
			}
			return matrix;
		}
		private static void OfferToPrint(int rowCount, int colCount, double[,] matrix)
		{
			Console.WriteLine("Computation complete. Print results? y/n");
			char c = Console.ReadKey().KeyChar;
			if (c == 'y' || c == 'Y')
			{
				Console.WindowWidth = 180;
				Console.WriteLine();
				for (int x = 0; x < rowCount; x++)
				{
					Console.WriteLine("ROW {0}: ", x);
					for (int y = 0; y < colCount; y++)
					{
						Console.Write("{0:#.##} ", matrix[x, y]);
					}
					Console.WriteLine();
				}
			}
		}
		#endregion
	}
}

#T=PathFileHelper
^#define NET45
namespace Test
{
	using Microshaoft;
	using System;
	using System.Diagnostics;
	using System.IO;
	public class Program
	{
		public static void Main()
		{
^#if NET45
			var files = Directory.EnumerateFiles(@"d:\", "*.gz*", SearchOption.TopDirectoryOnly);
			foreach (var file in files)
			{
				var r = false;
				string path = string.Empty;
				try
				{
					if
						(
							GZipFileHelper
								.Decompress
									(
										file
										, @"d:\temp"
										, (x) =>
										{
											var s = ".Gz";
											int p = x.ToLower().LastIndexOf(s.ToLower());
											if (p > 0)
											{
												x = x.Remove(p, s.Length);
											}
											return x;
										}
										, out path
									)
						)
					{
						r = PathFileHelper
								.MoveFileTo
									(
										path
										, @"d:\Temp"
										, @"d:\Temp2"
										, true
									);
					}
				}
				catch (Exception e)
				{
					string log = string
									.Format
										(
											"Process file: [{1}] caught exception:{0}{2}"
											, "\r\n"
											, file
											, e.ToString()
										);
					Console.Error.WriteLine(log);
					EventLogHelper
						.WriteEventLogEntry
							(
								""
								, log
								, EventLogEntryType.Error
								, 1001
							);
					r = false;
				}
				if (r)
				{
					PathFileHelper
							.MoveFileTo
								(
									file
									, @"d:\"
									, @"d:\Temp3"
									, true
								);
					Console.WriteLine("ok: {0}", file);
				}
				else
				{
					PathFileHelper
								.MoveFileTo
									(
										file
										, @"d:\Temp"
										, @"d:\Temp4"
										, true
									);
				}
			}
			Console.ReadLine();
^#endif
		}
	}
}
^#if NET45
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.IO.Compression;
	public static class GZipFileHelper
	{
		public static bool Decompress
							(
								string originalFileFullPath
								, string targetDirectoryPath
								, Func<string, string> onNamingDecompressedFileProcessFunc
								, out string decompressedFileFullPath
							)
		{
			var r = false;
			using (FileStream originalFileStream = File.OpenRead(originalFileFullPath))
			{
				var originalFileExtensionName = Path.GetExtension(originalFileFullPath);
				var originalDirectoryPath = Path.GetDirectoryName(originalFileFullPath);
				decompressedFileFullPath = PathFileHelper.GetNewPath(originalDirectoryPath, targetDirectoryPath, originalFileFullPath);
				string fileName = Path.GetFileName(decompressedFileFullPath);
				string directory = Path.GetDirectoryName(decompressedFileFullPath);
				if (onNamingDecompressedFileProcessFunc != null)
				{
					fileName = onNamingDecompressedFileProcessFunc(fileName);
				}
				decompressedFileFullPath = Path.Combine(directory, fileName);
				using (FileStream decompressedFileStream = File.Create(decompressedFileFullPath))
				{
					using (GZipStream decompressionStream = new GZipStream(originalFileStream, CompressionMode.Decompress))
					{
						decompressionStream.CopyTo(decompressedFileStream);
						r = true;
					}
				}
			}
			return r;
		}
	}
}
^#endif
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Linq;
	public static class PathFileHelper
	{
		public static bool MoveFileTo
							(
								string sourceFullPathFileName
								, string sourceDirectoryPath
								, string destDirectorytPath
								, bool deleteExistsDestFile = false
							)
		{
			var r = false;
			var destFullPathFileName = GetNewPath(sourceDirectoryPath, destDirectorytPath, sourceFullPathFileName);
			var directory = Path.GetDirectoryName(destFullPathFileName);
			if (File.Exists(directory))
			{
				File.Delete(directory);
			}
			if (!Directory.Exists(directory))
			{
				Directory.CreateDirectory(directory);
			}
			if (deleteExistsDestFile)
			{
				if (File.Exists(destFullPathFileName))
				{
					File.Delete(destFullPathFileName);
				}
			}
			File.Move(sourceFullPathFileName, destFullPathFileName);
			r = true;
			return r;
		}
		public static string GetValidPathOrFileName(string path, string replacement)
		{
			string s = string.Empty;
			var chars = Path.GetInvalidPathChars();
			chars = chars.Union(Path.GetInvalidFileNameChars()).ToArray();
			Array
				.ForEach
					(
						chars
						, (x) =>
						{
							s = s.Replace(x.ToString(), replacement);
						}
					);
			return s;
		}
		public static string GetNewPath(string oldDirectoryPath, string newDirectoryPath, string originalFileFullPath)
		{
			string newPath = newDirectoryPath;
			originalFileFullPath = Path.GetFullPath(originalFileFullPath);
			var directorySeparator = Path.DirectorySeparatorChar.ToString();
			oldDirectoryPath = Path.GetFullPath(oldDirectoryPath);
			newDirectoryPath = Path.GetFullPath(newDirectoryPath);
			if (!oldDirectoryPath.EndsWith(directorySeparator))
			{
				oldDirectoryPath += directorySeparator;
			}
			if (!newDirectoryPath.EndsWith(directorySeparator))
			{
				newDirectoryPath += directorySeparator;
			}
			string relativeDirectoryPath = string.Empty;
			int p = originalFileFullPath
						.ToLower()
						.IndexOf(oldDirectoryPath.ToLower());
			if (p >= 0)
			{
				p += oldDirectoryPath.Length;
				relativeDirectoryPath = originalFileFullPath.Substring(p);
				newPath = Path.Combine(newPath, relativeDirectoryPath);
			}
			newPath = Path.GetFullPath(newPath);
			return newPath;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Diagnostics;
	public static class EventLogHelper
	{
		private static string _processNameID = new Func<string>
												(
													() =>
													{
														var process = Process.GetCurrentProcess();
														return
															string.Format
																	(
																		"{1}{0}({2})"
																		, ""
																		, process.ProcessName
																		, process.Id
																	);
													}
												)();
		public static EventLog[] GetEventLogs()
		{
			var r = EventLog.GetEventLogs();
			return r;
		}
		public static void WriteEventLogEntry
										(
											//string logName,
											string sourceName,
											string logMessage,
											EventLogEntryType logEntryType
											, int eventID
										)
		{
			EventLog eventLog = new EventLog();
			eventLog.Source = sourceName;
			//eventLog.Log = logName;
			logMessage = string.Format
							(
								"{1}{0}Process [{3}] @ {4}{0}{5}{0}{2}"
								, "\r\n"
								, "begin ==========================================="
								, "end ============================================="
								, _processNameID
								, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
								, logMessage
							);
			eventLog.WriteEntry
				(
					logMessage
					, logEntryType
					, eventID
				);
		}
		public static bool TryCreateEventSourceLog
										(
											string logName,
											string sourceName,
											bool allowRecreate = false
										)
		{
			bool r = false;
			if (EventLog.SourceExists(sourceName))
			{
				if (allowRecreate)
				{
					try
					{
						var s = EventLog.LogNameFromSourceName(sourceName, ".");
						if (string.Compare(s, logName, true) != 0)
						{
							EventLog.DeleteEventSource(sourceName);
							EventLog.Delete(logName);
							EventLog.CreateEventSource(sourceName, logName);
							r = true;
						}
					}
					catch// (Exception e)
					{
						r = false;
					}
				}
				else
				{
					r = true;
				}
				
			}
			else
			{
				EventLog.CreateEventSource(sourceName, logName);
				r = true;
			}
			return r;
		}
	}
}

#T=PDF Filter Library (1)
namespace FilterLibrary
{
	///
	/// Sample library for using IFilter to read text from any registered filter type.
	/// 
	///  Helpful links:
	///	 http://msdn.microsoft.com/en-us/library/ms691105(VS.85).aspx
	///	 http://ifilter.codeplex.com/
	///	 http://www.pinvoke.net/default.aspx/query/LoadIFilter.html
	///	 
	///  Code here is taken from a combination of the project located at http://ifilter.codeplex.com/
	///  as well as definitions taken from p-invoke.net.  License is MS-PL so enjoy.
	/// 
	///  Modify by eaglet at 2013-01-09, add convert to file method
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.IO;
	using System.Runtime.InteropServices;
	public partial class FilterCode
	{
		int DefaultBufferSize = 4096;
		/// <summary>
		/// Utilizes IFilter interface in Windows to parse the contents of files.
		/// </summary>
		/// <param name="path">Path - Location of file to parse</param>
		/// <param name="Path">Buffer - Return text artifacts</param>
		/// <returns>Raw set of strings from the document in plain text format.</returns>
		public void ConvertToFile(string path, string outuptFilePath, Encoding encoding)
		{
			IFilter filter = null;
			int hresult;
			IFilterReturnCodes rtn;
			// Try to load the filter for the path given.
			hresult = LoadIFilter(path, new IntPtr(0), ref filter);
			if (hresult == 0)
			{
				using (StreamWriter outFile = new StreamWriter(outuptFilePath, false, encoding))
				{
					IFILTER_FLAGS uflags;
					// Init the filter provider.
					rtn = filter.Init(
							IFILTER_INIT.IFILTER_INIT_CANON_PARAGRAPHS |
							IFILTER_INIT.IFILTER_INIT_CANON_HYPHENS |
							IFILTER_INIT.IFILTER_INIT_CANON_SPACES |
							IFILTER_INIT.IFILTER_INIT_APPLY_INDEX_ATTRIBUTES |
							IFILTER_INIT.IFILTER_INIT_INDEXING_ONLY,
							0, new IntPtr(0), out uflags);
					if (rtn == IFilterReturnCodes.S_OK)
					{
						STAT_CHUNK statChunk;
						// Outer loop will read chunks from the document at a time.  For those
						// chunks that have text, the contents will be pulled and put into the
						// return buffer.
						bool bMoreChunks = true;
						while (bMoreChunks)
						{
							rtn = filter.GetChunk(out statChunk);
							if (rtn == IFilterReturnCodes.S_OK)
							{
								// Ignore all non-text chunks.
								if (statChunk.flags != CHUNKSTATE.CHUNK_TEXT)
									continue;
								// Check for white space items and add the appropriate breaks.
								switch (statChunk.breakType)
								{
									case CHUNK_BREAKTYPE.CHUNK_NO_BREAK:
										break;
									case CHUNK_BREAKTYPE.CHUNK_EOW:
										outFile.Write(' ');
										break;
									case CHUNK_BREAKTYPE.CHUNK_EOC:
									case CHUNK_BREAKTYPE.CHUNK_EOP:
									case CHUNK_BREAKTYPE.CHUNK_EOS:
										outFile.WriteLine();
										break;
								}
								// At this point we have a text chunk.  The following code will pull out
								// all of it and add it to the buffer.
								bool bMoreText = true;
								while (bMoreText)
								{
									// Create a temporary string buffer we can use for the parsing algorithm.
									int cBuffer = DefaultBufferSize;
									StringBuilder sbBuffer = new StringBuilder(DefaultBufferSize);
									// Read the next piece of data up to the size of our local buffer.
									rtn = filter.GetText(ref cBuffer, sbBuffer);
									if (rtn == IFilterReturnCodes.S_OK || rtn == IFilterReturnCodes.FILTER_S_LAST_TEXT)
									{
										// If any data was returned, scrub it and then add it to the buffer.
										CleanUpCharacters(cBuffer, sbBuffer);
										outFile.Write(sbBuffer.ToString());
										// If we got back some text but there is no more, terminate the loop.
										if (rtn == IFilterReturnCodes.FILTER_S_LAST_TEXT)
										{
											bMoreText = false;
											break;
										}
									}
									// Once all data is exhausted, we are done so terminate.
									else if (rtn == IFilterReturnCodes.FILTER_E_NO_MORE_TEXT)
									{
										bMoreText = false;
										break;
									}
									// Check for any fatal errors.  It is a bug if you land here.
									else if (rtn == IFilterReturnCodes.FILTER_E_NO_TEXT)
									{
										System.Diagnostics.Debug.Assert(false, "Should not get here");
										throw new InvalidOperationException();
									}
								}
							}
							// Once all chunks have been read, we are done with the file.
							else if (rtn == IFilterReturnCodes.FILTER_E_END_OF_CHUNKS)
							{
								bMoreChunks = false;
								break;
							}
							else if (rtn == IFilterReturnCodes.FILTER_E_EMBEDDING_UNAVAILABLE ||
								rtn == IFilterReturnCodes.FILTER_E_LINK_UNAVAILABLE)
							{
								continue;
							}
							else
							{
								throw new COMException("IFilter COM error: " + rtn.ToString());
							}
						}
					}
				}
			}
			else
			{
				// If you get here there is no filter for the file type you asked for.  Throw an
				// exception for the caller.
				throw new InvalidOperationException("Failed to find IFilter for file " + path);
			}
		}
		/// <summary>
		/// Utilizes IFilter interface in Windows to parse the contents of files.
		/// </summary>
		/// <param name="path">Path - Location of file to parse</param>
		/// <param name="buffer">Buffer - Return text artifacts</param>
		/// <returns>Raw set of strings from the document in plain text format.</returns>
		public void GetTextFromDocument(string path, ref StringBuilder buffer)
		{
			IFilter filter = null;
			int hresult;
			IFilterReturnCodes rtn;
			// Initialize the return buffer to 64K.
			buffer = new StringBuilder(64 * 1024);
			// Try to load the filter for the path given.
			hresult = LoadIFilter(path, new IntPtr(0), ref filter);
			if (hresult == 0)
			{
				IFILTER_FLAGS uflags;
				// Init the filter provider.
				rtn = filter.Init(
						IFILTER_INIT.IFILTER_INIT_CANON_PARAGRAPHS |
						IFILTER_INIT.IFILTER_INIT_CANON_HYPHENS |
						IFILTER_INIT.IFILTER_INIT_CANON_SPACES |
						IFILTER_INIT.IFILTER_INIT_APPLY_INDEX_ATTRIBUTES |
						IFILTER_INIT.IFILTER_INIT_INDEXING_ONLY,
						0, new IntPtr(0), out uflags);
				if (rtn == IFilterReturnCodes.S_OK)
				{
					STAT_CHUNK statChunk;
					// Outer loop will read chunks from the document at a time.  For those
					// chunks that have text, the contents will be pulled and put into the
					// return buffer.
					bool bMoreChunks = true;
					while (bMoreChunks)
					{
						rtn = filter.GetChunk(out statChunk);
						if (rtn == IFilterReturnCodes.S_OK)
						{
							// Ignore all non-text chunks.
							if (statChunk.flags != CHUNKSTATE.CHUNK_TEXT)
								continue;
							// Check for white space items and add the appropriate breaks.
							switch (statChunk.breakType)
							{
								case CHUNK_BREAKTYPE.CHUNK_NO_BREAK:
									break;
								case CHUNK_BREAKTYPE.CHUNK_EOW:
									buffer.Append(' ');
									break;
								case CHUNK_BREAKTYPE.CHUNK_EOC:
								case CHUNK_BREAKTYPE.CHUNK_EOP:
								case CHUNK_BREAKTYPE.CHUNK_EOS:
									buffer.AppendLine();
									break;
							}
							// At this point we have a text chunk.  The following code will pull out
							// all of it and add it to the buffer.
							bool bMoreText = true;
							while (bMoreText)
							{
								// Create a temporary string buffer we can use for the parsing algorithm.
								int cBuffer = DefaultBufferSize;
								StringBuilder sbBuffer = new StringBuilder(DefaultBufferSize);
								// Read the next piece of data up to the size of our local buffer.
								rtn = filter.GetText(ref cBuffer, sbBuffer);
								if (rtn == IFilterReturnCodes.S_OK || rtn == IFilterReturnCodes.FILTER_S_LAST_TEXT)
								{
									// If any data was returned, scrub it and then add it to the buffer.
									CleanUpCharacters(cBuffer, sbBuffer);
									buffer.Append(sbBuffer.ToString());
									// If we got back some text but there is no more, terminate the loop.
									if (rtn == IFilterReturnCodes.FILTER_S_LAST_TEXT)
									{
										bMoreText = false;
										break;
									}
								}
								// Once all data is exhausted, we are done so terminate.
								else if (rtn == IFilterReturnCodes.FILTER_E_NO_MORE_TEXT)
								{
									bMoreText = false;
									break;
								}
								// Check for any fatal errors.  It is a bug if you land here.
								else if (rtn == IFilterReturnCodes.FILTER_E_NO_TEXT)
								{
									System.Diagnostics.Debug.Assert(false, "Should not get here");
									throw new InvalidOperationException();
								}
							}
						}
						// Once all chunks have been read, we are done with the file.
						else if (rtn == IFilterReturnCodes.FILTER_E_END_OF_CHUNKS)
						{
							bMoreChunks = false;
							break;
						}
						else if (rtn == IFilterReturnCodes.FILTER_E_EMBEDDING_UNAVAILABLE ||
							rtn == IFilterReturnCodes.FILTER_E_LINK_UNAVAILABLE)
						{
							continue;
						}
						else
						{
							throw new COMException("IFilter COM error: " + rtn.ToString());
						}
					}
				}
			}
			else
			{
				// If you get here there is no filter for the file type you asked for.  Throw an
				// exception for the caller.
				throw new InvalidOperationException("Failed to find IFilter for file " + path);
			}
		}
	}
}

#T=PDF Filter Library (2)
namespace FilterLibrary
{
	///
	/// Sample library for using IFilter to read text from any registered filter type.
	/// 
	///  Helpful links:
	///	 http://msdn.microsoft.com/en-us/library/ms691105(VS.85).aspx
	///	 http://ifilter.codeplex.com/
	///	 http://www.pinvoke.net/default.aspx/query/LoadIFilter.html
	///	 
	///  Code here is taken from a combination of the project located at http://ifilter.codeplex.com/
	///  as well as definitions taken from p-invoke.net.  License is MS-PL so enjoy.
	/// 
	///  Modify by eaglet at 2013-01-09, add convert to file method
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.IO;
	using System.Runtime.InteropServices;
	public partial class FilterCode
	{
		[DllImport("query.dll", SetLastError = true, CharSet = CharSet.Unicode)]
		static extern int LoadIFilter(string pwcsPath,
				  [MarshalAs(UnmanagedType.IUnknown)] object pUnkOuter,
				  ref IFilter ppIUnk);
		[ComImport, Guid("89BCB740-6119-101A-BCB7-00DD010655AF")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		public interface IFilter
		{
			/// <summary>
			/// The IFilter::Init method initializes a filtering session.
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes Init(
				//[in] Flag settings from the IFILTER_INIT enumeration for
				// controlling text standardization, property output, embedding
				// scope, and IFilter access patterns. 
			  IFILTER_INIT grfFlags,
			  // [in] The size of the attributes array. When nonzero, cAttributes
				//  takes 
				// precedence over attributes specified in grfFlags. If no
				// attribute flags 
				// are specified and cAttributes is zero, the default is given by
				// the 
				// PSGUID_STORAGE storage property set, which contains the date and
				//  time 
				// of the last write to the file, size, and so on; and by the
				//  PID_STG_CONTENTS 
				// 'contents' property, which maps to the main contents of the
				// file. 
				// For more information about properties and property sets, see
				// Property Sets. 
			  int cAttributes,
			  //[in] Array of pointers to FULLPROPSPEC structures for the
				// requested properties. 
				// When cAttributes is nonzero, only the properties in aAttributes
				// are returned. 
			  IntPtr aAttributes,
			  // [out] Information about additional properties available to the
				//  caller; from the IFILTER_FLAGS enumeration. 
			  out IFILTER_FLAGS pdwFlags);
			/// <summary>
			/// The IFilter::GetChunk method positions the filter at the beginning
			/// of the next chunk, 
			/// or at the first chunk if this is the first call to the GetChunk
			/// method, and returns a description of the current chunk. 
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes GetChunk(out STAT_CHUNK pStat);
			/// <summary>
			/// The IFilter::GetText method retrieves text (text-type properties)
			/// from the current chunk, 
			/// which must have a CHUNKSTATE enumeration value of CHUNK_TEXT.
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes GetText(
				// [in/out] On entry, the size of awcBuffer array in wide/Unicode
				// characters. On exit, the number of Unicode characters written to
				// awcBuffer. 
				// Note that this value is not the number of bytes in the buffer. 
				ref int pcwcBuffer,
				// Text retrieved from the current chunk. Do not terminate the
				// buffer with a character.  
				[Out(), MarshalAs(UnmanagedType.LPWStr)] 
	   StringBuilder awcBuffer);
			/// <summary>
			/// The IFilter::GetValue method retrieves a value (public
			/// value-type property) from a chunk, 
			/// which must have a CHUNKSTATE enumeration value of CHUNK_VALUE.
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes GetValue(
				// Allocate the PROPVARIANT structure with CoTaskMemAlloc. Some
				// PROPVARIANT 
				// structures contain pointers, which can be freed by calling the
				// PropVariantClear function. 
				// It is up to the caller of the GetValue method to call the
				//   PropVariantClear method.			
				// ref IntPtr ppPropValue
				// [MarshalAs(UnmanagedType.Struct)]
				ref IntPtr PropVal);
			/// <summary>
			/// The IFilter::BindRegion method retrieves an interface representing
			/// the specified portion of the object. 
			/// Currently reserved for future use.
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes BindRegion(ref FILTERREGION origPos,
			  ref Guid riid, ref object ppunk);
		}
		public struct FILTERREGION
		{
			public int idChunk;
			public int cwcStart;
			public int cwcExtent;
		}
		public enum IFilterReturnCodes : uint
		{
			/// <summary>
			/// Success
			/// </summary>
			S_OK = 0,
			/// <summary>
			/// The function was denied access to the filter file. 
			/// </summary>
			E_ACCESSDENIED = 0x80070005,
			/// <summary>
			/// The function encountered an invalid handle,
			/// probably due to a low-memory situation. 
			/// </summary>
			E_HANDLE = 0x80070006,
			/// <summary>
			/// The function received an invalid parameter.
			/// </summary>
			E_INVALIDARG = 0x80070057,
			/// <summary>
			/// Out of memory
			/// </summary>
			E_OUTOFMEMORY = 0x8007000E,
			/// <summary>
			/// Not implemented
			/// </summary>
			E_NOTIMPL = 0x80004001,
			/// <summary>
			/// Unknown error
			/// </summary>
			E_FAIL = 0x80000008,
			/// <summary>
			/// File not filtered due to password protection
			/// </summary>
			FILTER_E_PASSWORD = 0x8004170B,
			/// <summary>
			/// The document format is not recognised by the filter
			/// </summary>
			FILTER_E_UNKNOWNFORMAT = 0x8004170C,
			/// <summary>
			/// No text in current chunk
			/// </summary>
			FILTER_E_NO_TEXT = 0x80041705,
			/// <summary>
			/// No values in current chunk
			/// </summary>
			FILTER_E_NO_VALUES = 0x80041706,
			/// <summary>
			/// No more chunks of text available in object
			/// </summary>
			FILTER_E_END_OF_CHUNKS = 0x80041700,
			/// <summary>
			/// No more text available in chunk
			/// </summary>
			FILTER_E_NO_MORE_TEXT = 0x80041701,
			/// <summary>
			/// No more property values available in chunk
			/// </summary>
			FILTER_E_NO_MORE_VALUES = 0x80041702,
			/// <summary>
			/// Unable to access object
			/// </summary>
			FILTER_E_ACCESS = 0x80041703,
			/// <summary>
			/// Moniker doesn't cover entire region
			/// </summary>
			FILTER_W_MONIKER_CLIPPED = 0x00041704,
			/// <summary>
			/// Unable to bind IFilter for embedded object
			/// </summary>
			FILTER_E_EMBEDDING_UNAVAILABLE = 0x80041707,
			/// <summary>
			/// Unable to bind IFilter for linked object
			/// </summary>
			FILTER_E_LINK_UNAVAILABLE = 0x80041708,
			/// <summary>
			///  This is the last text in the current chunk
			/// </summary>
			FILTER_S_LAST_TEXT = 0x00041709,
			/// <summary>
			/// This is the last value in the current chunk
			/// </summary>
			FILTER_S_LAST_VALUES = 0x0004170A
		}
		/// <summary>
		/// Flags controlling the operation of the FileFilter
		/// instance.
		/// </summary>
		[Flags]
		public enum IFILTER_INIT
		{
			/// <summary>
			/// Paragraph breaks should be marked with the Unicode PARAGRAPH
			/// SEPARATOR (0x2029)
			/// </summary>
			IFILTER_INIT_CANON_PARAGRAPHS = 1,
			/// <summary>
			/// Soft returns, such as the newline character in Microsoft Word, should
			/// be replaced by hard returnsLINE SEPARATOR (0x2028). Existing hard
			/// returns can be doubled. A carriage return (0x000D), line feed (0x000A),
			/// or the carriage return and line feed in combination should be considered
			/// a hard return. The intent is to enable pattern-expression matches that
			/// match against observed line breaks. 
			/// </summary>
			IFILTER_INIT_HARD_LINE_BREAKS = 2,
			/// <summary>
			/// Various word-processing programs have forms of hyphens that are not
			/// represented in the host character set, such as optional hyphens
			/// (appearing only at the end of a line) and nonbreaking hyphens. This flag
			/// indicates that optional hyphens are to be converted to nulls, and
			/// non-breaking hyphens are to be converted to normal hyphens (0x2010), or
			/// HYPHEN-MINUSES (0x002D). 
			/// </summary>
			IFILTER_INIT_CANON_HYPHENS = 4,
			/// <summary>
			/// Just as the IFILTER_INIT_CANON_HYPHENS flag standardizes hyphens,
			/// this one standardizes spaces. All special space characters, such as
			/// nonbreaking spaces, are converted to the standard space character
			/// (0x0020). 
			/// </summary>
			IFILTER_INIT_CANON_SPACES = 8,
			/// <summary>
			/// Indicates that the client wants text split into chunks representing
			/// public value-type properties. 
			/// </summary>
			IFILTER_INIT_APPLY_INDEX_ATTRIBUTES = 16,
			/// <summary>
			/// Indicates that the client wants text split into chunks representing
			/// properties determined during the indexing process. 
			/// </summary>
			IFILTER_INIT_APPLY_CRAWL_ATTRIBUTES = 256,
			/// <summary>
			/// Any properties not covered by the IFILTER_INIT_APPLY_INDEX_ATTRIBUTES
			/// and IFILTER_INIT_APPLY_CRAWL_ATTRIBUTES flags should be emitted. 
			/// </summary>
			IFILTER_INIT_APPLY_OTHER_ATTRIBUTES = 32,
			/// <summary>
			/// Optimizes IFilter for indexing because the client calls the
			/// IFilter::Init method only once and does not call IFilter::BindRegion.
			/// This eliminates the possibility of accessing a chunk both before and
			/// after accessing another chunk. 
			/// </summary>
			IFILTER_INIT_INDEXING_ONLY = 64,
			/// <summary>
			/// The text extraction process must recursively search all linked
			/// objects within the document. If a link is unavailable, the
			/// IFilter::GetChunk call that would have obtained the first chunk of the
			/// link should return FILTER_E_LINK_UNAVAILABLE. 
			/// </summary>
			IFILTER_INIT_SEARCH_LINKS = 128,
			/// <summary>
			/// The content indexing process can return property values set by the  filter. 
			/// </summary>
			IFILTER_INIT_FILTER_OWNED_VALUE_OK = 512
		}
		[Flags]
		public enum IFILTER_FLAGS
		{
			/// <summary>
			/// The caller should use the IPropertySetStorage and IPropertyStorage
			/// interfaces to locate additional properties. 
			/// When this flag is set, properties available through COM
			/// enumerators should not be returned from IFilter. 
			/// </summary>
			IFILTER_FLAGS_OLE_PROPERTIES = 1
		}
		public struct STAT_CHUNK
		{
			/// <summary>
			/// The chunk identifier. Chunk identifiers must be unique for the
			/// current instance of the IFilter interface. 
			/// Chunk identifiers must be in ascending order. The order in which
			/// chunks are numbered should correspond to the order in which they appear
			/// in the source document. Some search engines can take advantage of the
			/// proximity of chunks of various properties. If so, the order in which
			/// chunks with different properties are emitted will be important to the
			/// search engine. 
			/// </summary>
			public int idChunk;
			/// <summary>
			/// The type of break that separates the previous chunk from the current
			///  chunk. Values are from the CHUNK_BREAKTYPE enumeration. 
			/// </summary>
			[MarshalAs(UnmanagedType.U4)]
			public CHUNK_BREAKTYPE breakType;
			/// <summary>
			/// Flags indicate whether this chunk contains a text-type or a
			/// value-type property. 
			/// Flag values are taken from the CHUNKSTATE enumeration. If the CHUNK_TEXT flag is set, 
			/// IFilter::GetText should be used to retrieve the contents of the chunk
			/// as a series of words. 
			/// If the CHUNK_VALUE flag is set, IFilter::GetValue should be used to retrieve 
			/// the value and treat it as a single property value. If the filter dictates that the same 
			/// content be treated as both text and as a value, the chunk should be emitted twice in two	   
			/// different chunks, each with one flag set. 
			/// </summary>
			[MarshalAs(UnmanagedType.U4)]
			public CHUNKSTATE flags;
			/// <summary>
			/// The language and sublanguage associated with a chunk of text. Chunk locale is used 
			/// by document indexers to perform proper word breaking of text. If the chunk is 
			/// neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, 
			/// this field is ignored. 
			/// </summary>
			public int locale;
			/// <summary>
			/// The property to be applied to the chunk. If a filter requires that	   the same text 
			/// have more than one property, it needs to emit the text once for each	   property 
			/// in separate chunks. 
			/// </summary>
			public FULLPROPSPEC attribute;
			/// <summary>
			/// The ID of the source of a chunk. The value of the idChunkSource	 member depends on the nature of the chunk: 
			/// If the chunk is a text-type property, the value of the idChunkSource	   member must be the same as the value of the idChunk member. 
			/// If the chunk is an public value-type property derived from textual	   content, the value of the idChunkSource member is the chunk ID for the
			/// text-type chunk from which it is derived. 
			/// If the filter attributes specify to return only public value-type
			/// properties, there is no content chunk from which to derive the current
			/// public value-type property. In this case, the value of the
			/// idChunkSource member must be set to zero, which is an invalid chunk. 
			/// </summary>
			public int idChunkSource;
			/// <summary>
			/// The offset from which the source text for a derived chunk starts in
			/// the source chunk. 
			/// </summary>
			public int cwcStartSource;
			/// <summary>
			/// The length in characters of the source text from which the current
			/// chunk was derived. 
			/// A zero value signifies character-by-character correspondence between
			/// the source text and 
			/// the derived text. A nonzero value means that no such direct
			/// correspondence exists
			/// </summary>
			public int cwcLenSource;
		}
		public enum CHUNKSTATE
		{
			/// <summary>
			/// The current chunk is a text-type property.
			/// </summary>
			CHUNK_TEXT = 0x1,
			/// <summary>
			/// The current chunk is a value-type property. 
			/// </summary>
			CHUNK_VALUE = 0x2,
			/// <summary>
			/// Reserved
			/// </summary>
			CHUNK_FILTER_OWNED_VALUE = 0x4
		}
		[StructLayout(LayoutKind.Explicit)]
		public struct PROPSPEC
		{
			[FieldOffset(0)]
			public int ulKind;	 // 0 - string used; 1 - PROPID
			[FieldOffset(4)]
			public int propid;
			[FieldOffset(4)]
			public IntPtr lpwstr;
		}
		public struct FULLPROPSPEC
		{
			public Guid guidPropSet;
			public PROPSPEC psProperty;
		}
		/// <summary>
		/// Enumerates the different breaking types that occur between 
		/// chunks of text read out by the FileFilter.
		/// </summary>
		public enum CHUNK_BREAKTYPE
		{
			/// <summary>
			/// No break is placed between the current chunk and the previous chunk.
			/// The chunks are glued together. 
			/// </summary>
			CHUNK_NO_BREAK = 0,
			/// <summary>
			/// A word break is placed between this chunk and the previous chunk that
			/// had the same attribute. 
			/// Use of CHUNK_EOW should be minimized because the choice of word
			/// breaks is language-dependent, 
			/// so determining word breaks is best left to the search engine. 
			/// </summary>
			CHUNK_EOW = 1,
			/// <summary>
			/// A sentence break is placed between this chunk and the previous chunk
			/// that had the same attribute. 
			/// </summary>
			CHUNK_EOS = 2,
			/// <summary>
			/// A paragraph break is placed between this chunk and the previous chunk
			/// that had the same attribute.
			/// </summary>	 
			CHUNK_EOP = 3,
			/// <summary>
			/// A chapter break is placed between this chunk and the previous chunk
			/// that had the same attribute. 
			/// </summary>
			CHUNK_EOC = 4
		}
		static void CleanUpCharacters(int chBuf, StringBuilder buf)
		{
			// The game here is to fold any "cute" versions of characters to thier 
			// simplified form to make parsing easier.
			// Truncate any extra chars that may have been writting to the buffer.
			buf.Remove(chBuf, buf.Length - chBuf);
			for (int i = 0; i < chBuf; i++)
			{
				char ch = buf[i];
				int chi = ch;
				switch (chi)
				{
					case 0:		// embedded null
					case 0x2000:   // en quad
					case 0x2001:   // em quad
					case 0x2002:   // en space
					case 0x2003:   // em space
					case 0x2004:   // three-per-em space
					case 0x2005:   // four-per-em space
					case 0x2006:   // six-per-em space
					case 0x2007:   // figure space
					case 0x2008:   // puctuation space
					case 0x2009:   // thin space
					case 0x200A:   // hair space
					case 0x200B:   // zero-width space
					case 0x200C:   // zero-width non-joiner
					case 0x200D:   // zero-width joiner
					case 0x202f:   // no-break space
					case 0x3000:   // ideographic space
						buf[i] = ' ';
						break;
					case 0x00B6:   // pilcro
					case 0x2028:   // line seperator
					case 0x2029:   // paragraph seperator
						buf[i] = '\n';
						break;
					case 0x00AD:   // soft-hyphen
					case 0x00B7:   // middle dot
					case 0x2010:   // hyphen
					case 0x2011:   // non-breaking hyphen
					case 0x2012:   // figure dash
					case 0x2013:   // en dash
					case 0x2014:   // em dash
					case 0x2015:   // quote dash
					case 0x2027:   // hyphenation point
					case 0x2043:   // hyphen bullet
					case 0x208B:   // subscript minus
					case 0xFE31:   // vertical em dash
					case 0xFE32:   // vertical en dash
					case 0xFE58:   // small em dash
					case 0xFE63:   // small hyphen minus
						buf[i] = '-';
						break;
					case 0x00B0:   // degree
					case 0x2018:   // left single quote
					case 0x2019:   // right single quote
					case 0x201A:   // low right single quote
					case 0x201B:   // high left single quote
					case 0x2032:   // prime
					case 0x2035:   // reversed prime
					case 0x2039:   // left-pointing angle quotation mark
					case 0x203A:   // right-pointing angle quotation mark
						buf[i] = '\'';
						break;
					case 0x201C:   // left double quote
					case 0x201D:   // right double quote
					case 0x201E:   // low right double quote
					case 0x201F:   // high left double quote
					case 0x2033:   // double prime
					case 0x2034:   // triple prime
					case 0x2036:   // reversed double prime
					case 0x2037:   // reversed triple prime
					case 0x00AB:   // left-pointing double angle quotation mark
					case 0x00BB:   // right-pointing double angle quotation mark
					case 0x3003:   // ditto mark
					case 0x301D:   // reversed double prime quotation mark
					case 0x301E:   // double prime quotation mark
					case 0x301F:   // low double prime quotation mark
						buf[i] = '\"';
						break;
					case 0x00A7:   // section-sign
					case 0x2020:   // dagger
					case 0x2021:   // double-dagger
					case 0x2022:   // bullet
					case 0x2023:   // triangle bullet
					case 0x203B:   // reference mark
					case 0xFE55:   // small colon
						buf[i] = ':';
						break;
					case 0x2024:   // one dot leader
					case 0x2025:   // two dot leader
					case 0x2026:   // elipsis
					case 0x3002:   // ideographic full stop
					case 0xFE30:   // two dot vertical leader
					case 0xFE52:   // small full stop
						buf[i] = '.';
						break;
					case 0x3001:   // ideographic comma
					case 0xFE50:   // small comma
					case 0xFE51:   // small ideographic comma
						buf[i] = ',';
						break;
					case 0xFE54:   // small semicolon
						buf[i] = ';';
						break;
					case 0x00A6:   // broken-bar
					case 0x2016:   // double vertical line
						buf[i] = '|';
						break;
					case 0x2017:   // double low line
					case 0x203E:   // overline
					case 0x203F:   // undertie
					case 0x2040:   // character tie
					case 0xFE33:   // vertical low line
					case 0xFE49:   // dashed overline
					case 0xFE4A:   // centerline overline
					case 0xFE4D:   // dashed low line
					case 0xFE4E:   // centerline low line
						buf[i] = '_';
						break;
					case 0x301C:   // wave dash
					case 0x3030:   // wavy dash
					case 0xFE34:   // vertical wavy low line
					case 0xFE4B:   // wavy overline
					case 0xFE4C:   // double wavy overline
					case 0xFE4F:   // wavy low line
						buf[i] = '~';
						break;
					case 0x2038:   // caret
					case 0x2041:   // caret insertion point
						buf[i] = '^';
						break;
					case 0x2030:   // per-mille
					case 0x2031:   // per-ten thousand
					case 0xFE6A:   // small per-cent
						buf[i] = '%';
						break;
					case 0xFE6B:   // small commercial at
						buf[i] = '@';
						break;
					case 0x00A9:   // copyright
						buf[i] = 'c';
						break;
					case 0x00B5:   // micro
						buf[i] = 'u';
						break;
					case 0x00AE:   // registered
						buf[i] = 'r';
						break;
					case 0x207A:   // superscript plus
					case 0x208A:   // subscript plus
					case 0xFE62:   // small plus
						buf[i] = '+';
						break;
					case 0x2044:   // fraction slash
						buf[i] = '/';
						break;
					case 0x2042:   // asterism
					case 0xFE61:   // small asterisk
						buf[i] = '*';
						break;
					case 0x208C:   // subscript equal
					case 0xFE66:   // small equal
						buf[i] = '=';
						break;
					case 0xFE68:   // small reverse solidus
						buf[i] = '\\';
						break;
					case 0xFE5F:   // small number sign
						buf[i] = '#';
						break;
					case 0xFE60:   // small ampersand
						buf[i] = '&';
						break;
					case 0xFE69:   // small dollar sign
						buf[i] = '$';
						break;
					case 0x2045:   // left square bracket with quill
					case 0x3010:   // left black lenticular bracket
					case 0x3016:   // left white lenticular bracket
					case 0x301A:   // left white square bracket
					case 0xFE3B:   // vertical left lenticular bracket
					case 0xFF41:   // vertical left corner bracket
					case 0xFF43:   // vertical white left corner bracket
						buf[i] = '[';
						break;
					case 0x2046:   // right square bracket with quill
					case 0x3011:   // right black lenticular bracket
					case 0x3017:   // right white lenticular bracket
					case 0x301B:   // right white square bracket
					case 0xFE3C:   // vertical right lenticular bracket
					case 0xFF42:   // vertical right corner bracket
					case 0xFF44:   // vertical white right corner bracket
						buf[i] = ']';
						break;
					case 0x208D:   // subscript left parenthesis
					case 0x3014:   // left tortise-shell bracket
					case 0x3018:   // left white tortise-shell bracket
					case 0xFE35:   // vertical left parenthesis
					case 0xFE39:   // vertical left tortise-shell bracket
					case 0xFE59:   // small left parenthesis
					case 0xFE5D:   // small left tortise-shell bracket
						buf[i] = '(';
						break;
					case 0x208E:   // subscript right parenthesis
					case 0x3015:   // right tortise-shell bracket
					case 0x3019:   // right white tortise-shell bracket
					case 0xFE36:   // vertical right parenthesis
					case 0xFE3A:   // vertical right tortise-shell bracket
					case 0xFE5A:   // small right parenthesis
					case 0xFE5E:   // small right tortise-shell bracket
						buf[i] = ')';
						break;
					case 0x3008:   // left angle bracket
					case 0x300A:   // left double angle bracket
					case 0xFF3D:   // vertical left double angle bracket
					case 0xFF3F:   // vertical left angle bracket
					case 0xFF64:   // small less-than
						buf[i] = '<';
						break;
					case 0x3009:   // right angle bracket
					case 0x300B:   // right double angle bracket
					case 0xFF3E:   // vertical right double angle bracket
					case 0xFF40:   // vertical right angle bracket
					case 0xFF65:   // small greater-than
						buf[i] = '>';
						break;
					case 0xFE37:   // vertical left curly bracket
					case 0xFE5B:   // small left curly bracket
						buf[i] = '{';
						break;
					case 0xFE38:   // vertical right curly bracket
					case 0xFE5C:   // small right curly bracket
						buf[i] = '}';
						break;
					case 0x00A1:   // inverted exclamation mark
					case 0x00AC:   // not
					case 0x203C:   // double exclamation mark
					case 0x203D:   // interrobang
					case 0xFE57:   // small exclamation mark
						buf[i] = '!';
						break;
					case 0x00BF:   // inverted question mark
					case 0xFE56:   // small question mark
						buf[i] = '?';
						break;
					case 0x00B9:   // superscript one
						buf[i] = '1';
						break;
					case 0x00B2:   // superscript two
						buf[i] = '2';
						break;
					case 0x00B3:   // superscript three
						buf[i] = '3';
						break;
					case 0x2070:   // superscript zero
					case 0x2074:   // superscript four
					case 0x2075:   // superscript five
					case 0x2076:   // superscript six
					case 0x2077:   // superscript seven
					case 0x2078:   // superscript eight
					case 0x2079:   // superscript nine
					case 0x2080:   // subscript zero
					case 0x2081:   // subscript one
					case 0x2082:   // subscript two
					case 0x2083:   // subscript three
					case 0x2084:   // subscript four
					case 0x2085:   // subscript five
					case 0x2086:   // subscript six
					case 0x2087:   // subscript seven
					case 0x2088:   // subscript eight
					case 0x2089:   // subscript nine
					case 0x3021:   // Hangzhou numeral one
					case 0x3022:   // Hangzhou numeral two
					case 0x3023:   // Hangzhou numeral three
					case 0x3024:   // Hangzhou numeral four
					case 0x3025:   // Hangzhou numeral five
					case 0x3026:   // Hangzhou numeral six
					case 0x3027:   // Hangzhou numeral seven
					case 0x3028:   // Hangzhou numeral eight
					case 0x3029:   // Hangzhou numeral nine
						chi = chi & 0x000F;
						buf[i] = System.Convert.ToChar(chi);
						break;
					// ONE is at ZERO location... careful
					case 0x3220:   // parenthesized ideograph one
					case 0x3221:   // parenthesized ideograph two
					case 0x3222:   // parenthesized ideograph three
					case 0x3223:   // parenthesized ideograph four
					case 0x3224:   // parenthesized ideograph five
					case 0x3225:   // parenthesized ideograph six
					case 0x3226:   // parenthesized ideograph seven
					case 0x3227:   // parenthesized ideograph eight
					case 0x3228:   // parenthesized ideograph nine
					case 0x3280:   // circled ideograph one
					case 0x3281:   // circled ideograph two
					case 0x3282:   // circled ideograph three
					case 0x3283:   // circled ideograph four
					case 0x3284:   // circled ideograph five
					case 0x3285:   // circled ideograph six
					case 0x3286:   // circled ideograph seven
					case 0x3287:   // circled ideograph eight
					case 0x3288:   // circled ideograph nine
						chi = (chi & 0x000F) + 1;
						buf[i] = System.Convert.ToChar(chi);
						break;
					case 0x3007:   // ideographic number zero
					case 0x24EA:   // circled number zero
						buf[i] = '0';
						break;
					default:
						if (0xFF01 <= ch		   // fullwidth exclamation mark 
							&& ch <= 0xFF5E)	   // fullwidth tilde
						{
							// the fullwidths line up with ASCII low subset
							buf[i] = System.Convert.ToChar(chi & 0xFF00 + '!' - 1);
							//ch = ch & 0xFF00 + '!' - 1;			   
						}
						else if (0x2460 <= ch	  // circled one
								 && ch <= 0x2468)  // circled nine
						{
							buf[i] = System.Convert.ToChar(chi - 0x2460 + '1');
							//ch = ch - 0x2460 + '1';
						}
						else if (0x2474 <= ch	  // parenthesized one
								 && ch <= 0x247C)  // parenthesized nine
						{
							buf[i] = System.Convert.ToChar(chi - 0x2474 + '1');
							// ch = ch - 0x2474 + '1';
						}
						else if (0x2488 <= ch	  // one full stop
								 && ch <= 0x2490)  // nine full stop
						{
							buf[i] = System.Convert.ToChar(chi - 0x2488 + '1');
							//ch = ch - 0x2488 + '1';
						}
						else if (0x249C <= ch	  // parenthesized small a
								 && ch <= 0x24B5)  // parenthesized small z
						{
							buf[i] = System.Convert.ToChar(chi - 0x249C + 'a');
							//ch = ch - 0x249C + 'a';
						}
						else if (0x24B6 <= ch	  // circled capital A
								 && ch <= 0x24CF)  // circled capital Z
						{
							buf[i] = System.Convert.ToChar(chi - 0x24B6 + 'A');
							//ch = ch - 0x24B6 + 'A';
						}
						else if (0x24D0 <= ch	  // circled small a
								 && ch <= 0x24E9)  // circled small z
						{
							buf[i] = System.Convert.ToChar(chi - 0x24D0 + 'a');
							//ch = ch - 0x24D0 + 'a';
						}
						else if (0x2500 <= ch	  // box drawing (begin)
								 && ch <= 0x257F)  // box drawing (end)
						{
							buf[i] = '|';
						}
						else if (0x2580 <= ch	  // block elements (begin)
								 && ch <= 0x259F)  // block elements (end)
						{
							buf[i] = '#';
						}
						else if (0x25A0 <= ch	  // geometric shapes (begin)
								 && ch <= 0x25FF)  // geometric shapes (end)
						{
							buf[i] = '*';
						}
						else if (0x2600 <= ch	  // dingbats (begin)
								 && ch <= 0x267F)  // dingbats (end)
						{
							buf[i] = '.';
						}
						//else
						//   ValidUnicode(ch);   // validate that it's legit Unicode
						break;
				}
			}
		}
	}
}

#T=PDF Filter Library (3)
namespace Hubble.Tools
{
	/*
	 * Licensed to the Apache Software Foundation (ASF) under one or more
	 * contributor license agreements.  See the NOTICE file distributed with
	 * this work for additional information regarding copyright ownership.
	 * The ASF licenses this file to You under the Apache License, Version 2.0
	 * (the "License"); you may not use this file except in compliance with
	 * the License.  You may obtain a copy of the License at
	 * 
	 * http://www.apache.org/licenses/LICENSE-2.0
	 * 
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/* If you want to convert pdf to text, you have to install Adobe PDF iFilter 9 or later  
	 * 64bit download url  http://www.adobe.com/support/downloads/thankyou.jsp?ftpID=4025&fileID=3941
	 * 
	*/
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.IO;
	/// <summary>
	/// This class is used to Convert file to text.
	/// Support all of the office file type such as *.doc, *.docx, *.ppt, *.xls etc. and pdf file.
	/// </summary>
	public class TextParse
	{
		string _FilePath;
		/// <summary>
		/// Constractor
		/// </summary>
		/// <param name="filePath">file path of document file</param>
		public TextParse(string filePath)
		{
			_FilePath = filePath;
			if (!File.Exists(_FilePath))
			{
				throw new IOException(string.Format("{0} does not exist", _FilePath));
			}
		}
		/// <summary>
		/// Convert document file to string
		/// </summary>
		/// <returns></returns>
		public string ConvertToString()
		{
			FilterLibrary.FilterCode filter = new FilterLibrary.FilterCode();
			StringBuilder sb = new StringBuilder();
			filter.GetTextFromDocument(_FilePath, ref sb);
			return sb.ToString();
		}
		/// <summary>
		/// Convert to a text file
		/// </summary>
		/// <param name="filePath">specified output text file path</param>
		public void ConvertToFile(string filePath)
		{
			ConvertToFile(filePath, Encoding.UTF8);
		}
		/// <summary>
		/// Convert to a text file
		/// </summary>
		/// <param name="filePath">specified output text file path</param>
		/// <param name="encoding">specified encoding</param>
		public void ConvertToFile(string filePath, Encoding encoding)
		{
			FilterLibrary.FilterCode filter = new FilterLibrary.FilterCode();
			StringBuilder sb = new StringBuilder();
			filter.ConvertToFile(_FilePath, filePath, encoding);
		}
	}
}

#T=PDF IFilter library
namespace Microshaoft
{
	using System;
	using System.Text;
	using Microshaoft;
	public class Class1
	{
		static void Main()
		{
			string s = IFilterHelper.GetTextFromDocument
								(
									@"D:\Download\移动开发者解决方案研究报告第一期.pdf"
								);
			Console.WriteLine(s);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	///
	/// Sample library for using IFilter to read text from any registered filter type.
	/// 
	///  Helpful links:
	///	 http://msdn.microsoft.com/en-us/library/ms691105(VS.85).aspx
	///	 http://ifilter.codeplex.com/
	///	 http://www.pinvoke.net/default.aspx/query/LoadIFilter.html
	///	 
	///  Code here is taken from a combination of the project located at http://ifilter.codeplex.com/
	///  as well as definitions taken from p-invoke.net.  License is MS-PL so enjoy.
	/// 
	///  Modify by eaglet at 2013-01-09, add convert to file method
	using System;
	using System.Diagnostics;
	using System.Text;
	using System.Runtime.InteropServices;
	using Microshaoft;
	public static class IFilterHelper
	{
		
		
		/// <summary>
		/// Utilizes IFilter interface in Windows to parse the contents of files.
		/// </summary>
		/// <param name="path">Path - Location of file to parse</param>
		/// <param name="buffer">Buffer - Return text artifacts</param>
		/// <returns>Raw set of strings from the document in plain text format.</returns>
		public static string GetTextFromDocument(string path)
		{
			int DefaultBufferSize = 4096;
			StringBuilder sb = new StringBuilder();
			IFilterAPI.IFilter filter = null;
			int hresult;
			IFilterAPI.IFilterReturnCodes rc;
			// Initialize the return buffer to 64K.
			sb = new StringBuilder(64 * 1024);
			// Try to load the filter for the path given.
			hresult = IFilterAPI.LoadIFilter(path, new IntPtr(0), ref filter);
			if (hresult == 0)
			{
				IFilterAPI.IFILTER_FLAGS uflags;
				// Init the filter provider.
				rc = filter.Init
								(
									IFilterAPI.IFILTER_INIT.IFILTER_INIT_CANON_PARAGRAPHS |
									IFilterAPI.IFILTER_INIT.IFILTER_INIT_CANON_HYPHENS |
									IFilterAPI.IFILTER_INIT.IFILTER_INIT_CANON_SPACES |
									IFilterAPI.IFILTER_INIT.IFILTER_INIT_APPLY_INDEX_ATTRIBUTES |
									IFilterAPI.IFILTER_INIT.IFILTER_INIT_INDEXING_ONLY
									, 0
									, new IntPtr(0)
									, out uflags
							   );
				if (rc == IFilterAPI.IFilterReturnCodes.S_OK)
				{
					IFilterAPI.STAT_CHUNK statChunk;
					// Outer loop will read chunks from the document at a time.  For those
					// chunks that have text, the contents will be pulled and put into the
					// return buffer.
					bool bMoreChunks = true;
					while (bMoreChunks)
					{
						rc = filter.GetChunk(out statChunk);
						if (rc == IFilterAPI.IFilterReturnCodes.S_OK)
						{
							// Ignore all non-text chunks.
							if (statChunk.flags != IFilterAPI.CHUNKSTATE.CHUNK_TEXT)
								continue;
							// Check for white space items and add the appropriate breaks.
							switch (statChunk.breakType)
							{
								case IFilterAPI.CHUNK_BREAKTYPE.CHUNK_NO_BREAK:
									break;
								case IFilterAPI.CHUNK_BREAKTYPE.CHUNK_EOW:
									sb.Append(' ');
									break;
								case IFilterAPI.CHUNK_BREAKTYPE.CHUNK_EOC:
								case IFilterAPI.CHUNK_BREAKTYPE.CHUNK_EOP:
								case IFilterAPI.CHUNK_BREAKTYPE.CHUNK_EOS:
									sb.AppendLine();
									break;
							}
							// At this point we have a text chunk.  The following code will pull out
							// all of it and add it to the buffer.
							bool bMoreText = true;
							while (bMoreText)
							{
								// Create a temporary string buffer we can use for the parsing algorithm.
								int cBuffer = DefaultBufferSize;
								StringBuilder sbBuffer = new StringBuilder(DefaultBufferSize);
								// Read the next piece of data up to the size of our local buffer.
								rc = filter.GetText(ref cBuffer, sbBuffer);
								if (rc == IFilterAPI.IFilterReturnCodes.S_OK || rc == IFilterAPI.IFilterReturnCodes.FILTER_S_LAST_TEXT)
								{
									// If any data was returned, scrub it and then add it to the buffer.
									CleanUpCharacters(cBuffer, sbBuffer);
									sb.Append(sbBuffer.ToString());
									// If we got back some text but there is no more, terminate the loop.
									if (rc == IFilterAPI.IFilterReturnCodes.FILTER_S_LAST_TEXT)
									{
										bMoreText = false;
										break;
									}
								}
								// Once all data is exhausted, we are done so terminate.
								else if (rc == IFilterAPI.IFilterReturnCodes.FILTER_E_NO_MORE_TEXT)
								{
									bMoreText = false;
									break;
								}
								// Check for any fatal errors.  It is a bug if you land here.
								else if (rc == IFilterAPI.IFilterReturnCodes.FILTER_E_NO_TEXT)
								{
									Debug.Assert(false, "Should not get here");
									throw new InvalidOperationException();
								}
							}
						}
						// Once all chunks have been read, we are done with the file.
						else if (rc == IFilterAPI.IFilterReturnCodes.FILTER_E_END_OF_CHUNKS)
						{
							bMoreChunks = false;
							break;
						}
						else if (rc == IFilterAPI.IFilterReturnCodes.FILTER_E_EMBEDDING_UNAVAILABLE ||
							rc == IFilterAPI.IFilterReturnCodes.FILTER_E_LINK_UNAVAILABLE)
						{
							continue;
						}
						else
						{
							throw new COMException("IFilter COM error: " + rc.ToString());
						}
					}
				}
			}
			else
			{
				// If you get here there is no filter for the file type you asked for.  Throw an
				// exception for the caller.
				throw new InvalidOperationException("Failed to find IFilter for file " + path);
			}
			return sb.ToString();
		}
		public static void CleanUpCharacters(int chBuf, StringBuilder buf)
		{
			// The game here is to fold any "cute" versions of characters to thier 
			// simplified form to make parsing easier.
			// Truncate any extra chars that may have been writting to the buffer.
			buf.Remove(chBuf, buf.Length - chBuf);
			for (int i = 0; i < chBuf; i++)
			{
				char ch = buf[i];
				int chi = ch;
				switch (chi)
				{
					case 0:		// embedded null
					case 0x2000:   // en quad
					case 0x2001:   // em quad
					case 0x2002:   // en space
					case 0x2003:   // em space
					case 0x2004:   // three-per-em space
					case 0x2005:   // four-per-em space
					case 0x2006:   // six-per-em space
					case 0x2007:   // figure space
					case 0x2008:   // puctuation space
					case 0x2009:   // thin space
					case 0x200A:   // hair space
					case 0x200B:   // zero-width space
					case 0x200C:   // zero-width non-joiner
					case 0x200D:   // zero-width joiner
					case 0x202f:   // no-break space
					case 0x3000:   // ideographic space
						buf[i] = ' ';
						break;
					case 0x00B6:   // pilcro
					case 0x2028:   // line seperator
					case 0x2029:   // paragraph seperator
						buf[i] = '\n';
						break;
					case 0x00AD:   // soft-hyphen
					case 0x00B7:   // middle dot
					case 0x2010:   // hyphen
					case 0x2011:   // non-breaking hyphen
					case 0x2012:   // figure dash
					case 0x2013:   // en dash
					case 0x2014:   // em dash
					case 0x2015:   // quote dash
					case 0x2027:   // hyphenation point
					case 0x2043:   // hyphen bullet
					case 0x208B:   // subscript minus
					case 0xFE31:   // vertical em dash
					case 0xFE32:   // vertical en dash
					case 0xFE58:   // small em dash
					case 0xFE63:   // small hyphen minus
						buf[i] = '-';
						break;
					case 0x00B0:   // degree
					case 0x2018:   // left single quote
					case 0x2019:   // right single quote
					case 0x201A:   // low right single quote
					case 0x201B:   // high left single quote
					case 0x2032:   // prime
					case 0x2035:   // reversed prime
					case 0x2039:   // left-pointing angle quotation mark
					case 0x203A:   // right-pointing angle quotation mark
						buf[i] = '\'';
						break;
					case 0x201C:   // left double quote
					case 0x201D:   // right double quote
					case 0x201E:   // low right double quote
					case 0x201F:   // high left double quote
					case 0x2033:   // double prime
					case 0x2034:   // triple prime
					case 0x2036:   // reversed double prime
					case 0x2037:   // reversed triple prime
					case 0x00AB:   // left-pointing double angle quotation mark
					case 0x00BB:   // right-pointing double angle quotation mark
					case 0x3003:   // ditto mark
					case 0x301D:   // reversed double prime quotation mark
					case 0x301E:   // double prime quotation mark
					case 0x301F:   // low double prime quotation mark
						buf[i] = '\"';
						break;
					case 0x00A7:   // section-sign
					case 0x2020:   // dagger
					case 0x2021:   // double-dagger
					case 0x2022:   // bullet
					case 0x2023:   // triangle bullet
					case 0x203B:   // reference mark
					case 0xFE55:   // small colon
						buf[i] = ':';
						break;
					case 0x2024:   // one dot leader
					case 0x2025:   // two dot leader
					case 0x2026:   // elipsis
					case 0x3002:   // ideographic full stop
					case 0xFE30:   // two dot vertical leader
					case 0xFE52:   // small full stop
						buf[i] = '.';
						break;
					case 0x3001:   // ideographic comma
					case 0xFE50:   // small comma
					case 0xFE51:   // small ideographic comma
						buf[i] = ',';
						break;
					case 0xFE54:   // small semicolon
						buf[i] = ';';
						break;
					case 0x00A6:   // broken-bar
					case 0x2016:   // double vertical line
						buf[i] = '|';
						break;
					case 0x2017:   // double low line
					case 0x203E:   // overline
					case 0x203F:   // undertie
					case 0x2040:   // character tie
					case 0xFE33:   // vertical low line
					case 0xFE49:   // dashed overline
					case 0xFE4A:   // centerline overline
					case 0xFE4D:   // dashed low line
					case 0xFE4E:   // centerline low line
						buf[i] = '_';
						break;
					case 0x301C:   // wave dash
					case 0x3030:   // wavy dash
					case 0xFE34:   // vertical wavy low line
					case 0xFE4B:   // wavy overline
					case 0xFE4C:   // double wavy overline
					case 0xFE4F:   // wavy low line
						buf[i] = '~';
						break;
					case 0x2038:   // caret
					case 0x2041:   // caret insertion point
						buf[i] =  '^';
						break;
					case 0x2030:   // per-mille
					case 0x2031:   // per-ten thousand
					case 0xFE6A:   // small per-cent
						buf[i] = '%';
						break;
					case 0xFE6B:   // small commercial at
						buf[i] = '@';
						break;
					case 0x00A9:   // copyright
						buf[i] = 'c';
						break;
					case 0x00B5:   // micro
						buf[i] = 'u';
						break;
					case 0x00AE:   // registered
						buf[i] = 'r';
						break;
					case 0x207A:   // superscript plus
					case 0x208A:   // subscript plus
					case 0xFE62:   // small plus
						buf[i] = '+';
						break;
					case 0x2044:   // fraction slash
						buf[i] = '/';
						break;
					case 0x2042:   // asterism
					case 0xFE61:   // small asterisk
						buf[i] = '*';
						break;
					case 0x208C:   // subscript equal
					case 0xFE66:   // small equal
						buf[i] = '=';
						break;
					case 0xFE68:   // small reverse solidus
						buf[i] = '\\';
						break;
					case 0xFE5F:   // small number sign
						buf[i] = '#';
						break;
					case 0xFE60:   // small ampersand
						buf[i] = '&';
						break;
					case 0xFE69:   // small dollar sign
						buf[i] = '$';
						break;
					case 0x2045:   // left square bracket with quill
					case 0x3010:   // left black lenticular bracket
					case 0x3016:   // left white lenticular bracket
					case 0x301A:   // left white square bracket
					case 0xFE3B:   // vertical left lenticular bracket
					case 0xFF41:   // vertical left corner bracket
					case 0xFF43:   // vertical white left corner bracket
						buf[i] = '[';
						break;
					case 0x2046:   // right square bracket with quill
					case 0x3011:   // right black lenticular bracket
					case 0x3017:   // right white lenticular bracket
					case 0x301B:   // right white square bracket
					case 0xFE3C:   // vertical right lenticular bracket
					case 0xFF42:   // vertical right corner bracket
					case 0xFF44:   // vertical white right corner bracket
						buf[i] = ']';
						break;
					case 0x208D:   // subscript left parenthesis
					case 0x3014:   // left tortise-shell bracket
					case 0x3018:   // left white tortise-shell bracket
					case 0xFE35:   // vertical left parenthesis
					case 0xFE39:   // vertical left tortise-shell bracket
					case 0xFE59:   // small left parenthesis
					case 0xFE5D:   // small left tortise-shell bracket
						buf[i] = '(';
						break;
					case 0x208E:   // subscript right parenthesis
					case 0x3015:   // right tortise-shell bracket
					case 0x3019:   // right white tortise-shell bracket
					case 0xFE36:   // vertical right parenthesis
					case 0xFE3A:   // vertical right tortise-shell bracket
					case 0xFE5A:   // small right parenthesis
					case 0xFE5E:   // small right tortise-shell bracket
						buf[i] = ')';
						break;
					case 0x3008:   // left angle bracket
					case 0x300A:   // left double angle bracket
					case 0xFF3D:   // vertical left double angle bracket
					case 0xFF3F:   // vertical left angle bracket
					case 0xFF64:   // small less-than
						buf[i] = '<';
						break;
					case 0x3009:   // right angle bracket
					case 0x300B:   // right double angle bracket
					case 0xFF3E:   // vertical right double angle bracket
					case 0xFF40:   // vertical right angle bracket
					case 0xFF65:   // small greater-than
						buf[i] = '>';
						break;
					case 0xFE37:   // vertical left curly bracket
					case 0xFE5B:   // small left curly bracket
						buf[i] = '{';
						break;
					case 0xFE38:   // vertical right curly bracket
					case 0xFE5C:   // small right curly bracket
						buf[i] = '}';
						break;
					case 0x00A1:   // inverted exclamation mark
					case 0x00AC:   // not
					case 0x203C:   // double exclamation mark
					case 0x203D:   // interrobang
					case 0xFE57:   // small exclamation mark
						buf[i] = '!';
						break;
					case 0x00BF:   // inverted question mark
					case 0xFE56:   // small question mark
						buf[i] = '?';
						break;
					case 0x00B9:   // superscript one
						buf[i] = '1';
						break;
					case 0x00B2:   // superscript two
						buf[i] = '2';
						break;
					case 0x00B3:   // superscript three
						buf[i] = '3';
						break;
					case 0x2070:   // superscript zero
					case 0x2074:   // superscript four
					case 0x2075:   // superscript five
					case 0x2076:   // superscript six
					case 0x2077:   // superscript seven
					case 0x2078:   // superscript eight
					case 0x2079:   // superscript nine
					case 0x2080:   // subscript zero
					case 0x2081:   // subscript one
					case 0x2082:   // subscript two
					case 0x2083:   // subscript three
					case 0x2084:   // subscript four
					case 0x2085:   // subscript five
					case 0x2086:   // subscript six
					case 0x2087:   // subscript seven
					case 0x2088:   // subscript eight
					case 0x2089:   // subscript nine
					case 0x3021:   // Hangzhou numeral one
					case 0x3022:   // Hangzhou numeral two
					case 0x3023:   // Hangzhou numeral three
					case 0x3024:   // Hangzhou numeral four
					case 0x3025:   // Hangzhou numeral five
					case 0x3026:   // Hangzhou numeral six
					case 0x3027:   // Hangzhou numeral seven
					case 0x3028:   // Hangzhou numeral eight
					case 0x3029:   // Hangzhou numeral nine
						chi = chi & 0x000F;
						buf[i] = System.Convert.ToChar(chi);
						break;
					// ONE is at ZERO location... careful
					case 0x3220:   // parenthesized ideograph one
					case 0x3221:   // parenthesized ideograph two
					case 0x3222:   // parenthesized ideograph three
					case 0x3223:   // parenthesized ideograph four
					case 0x3224:   // parenthesized ideograph five
					case 0x3225:   // parenthesized ideograph six
					case 0x3226:   // parenthesized ideograph seven
					case 0x3227:   // parenthesized ideograph eight
					case 0x3228:   // parenthesized ideograph nine
					case 0x3280:   // circled ideograph one
					case 0x3281:   // circled ideograph two
					case 0x3282:   // circled ideograph three
					case 0x3283:   // circled ideograph four
					case 0x3284:   // circled ideograph five
					case 0x3285:   // circled ideograph six
					case 0x3286:   // circled ideograph seven
					case 0x3287:   // circled ideograph eight
					case 0x3288:   // circled ideograph nine
						chi = (chi & 0x000F) + 1;
						buf[i] = System.Convert.ToChar(chi);
						break;
					case 0x3007:   // ideographic number zero
					case 0x24EA:   // circled number zero
						buf[i] = '0';
						break;
					default:
						if (0xFF01 <= ch		   // fullwidth exclamation mark 
							&& ch <= 0xFF5E)	   // fullwidth tilde
						{
							// the fullwidths line up with ASCII low subset
							buf[i] = System.Convert.ToChar(chi & 0xFF00 + '!' - 1);
							//ch = ch & 0xFF00 + '!' - 1;			   
						}
						else if (0x2460 <= ch	  // circled one
								 && ch <= 0x2468)  // circled nine
						{
							buf[i] = System.Convert.ToChar(chi - 0x2460 + '1');
							//ch = ch - 0x2460 + '1';
						}
						else if (0x2474 <= ch	  // parenthesized one
								 && ch <= 0x247C)  // parenthesized nine
						{
							buf[i] = Convert.ToChar(chi - 0x2474 + '1');
							// ch = ch - 0x2474 + '1';
						}
						else if (0x2488 <= ch	  // one full stop
								 && ch <= 0x2490)  // nine full stop
						{
							buf[i] = Convert.ToChar(chi - 0x2488 + '1');
							//ch = ch - 0x2488 + '1';
						}
						else if (0x249C <= ch	  // parenthesized small a
								 && ch <= 0x24B5)  // parenthesized small z
						{
							buf[i] = Convert.ToChar(chi - 0x249C + 'a');
							//ch = ch - 0x249C + 'a';
						}
						else if (0x24B6 <= ch	  // circled capital A
								 && ch <= 0x24CF)  // circled capital Z
						{
							buf[i] = Convert.ToChar(chi - 0x24B6 + 'A');
							//ch = ch - 0x24B6 + 'A';
						}
						else if (0x24D0 <= ch	  // circled small a
								 && ch <= 0x24E9)  // circled small z
						{
							buf[i] = Convert.ToChar(chi - 0x24D0 + 'a');
							//ch = ch - 0x24D0 + 'a';
						}
						else if (0x2500 <= ch	  // box drawing (begin)
								 && ch <= 0x257F)  // box drawing (end)
						{
							buf[i] = '|';
						}
						else if (0x2580 <= ch	  // block elements (begin)
								 && ch <= 0x259F)  // block elements (end)
						{
							buf[i] = '#';
						}
						else if (0x25A0 <= ch	  // geometric shapes (begin)
								 && ch <= 0x25FF)  // geometric shapes (end)
						{
							buf[i] = '*';
						}
						else if (0x2600 <= ch	  // dingbats (begin)
								 && ch <= 0x267F)  // dingbats (end)
						{
							buf[i] = '.';
						}
						//else
						//   ValidUnicode(ch);   // validate that it's legit Unicode
						break;
				}
			}
		}
	}
}
namespace Microshaoft
{
	///
	/// Sample library for using IFilter to read text from any registered filter type.
	/// 
	///  Helpful links:
	///	 http://msdn.microsoft.com/en-us/library/ms691105(VS.85).aspx
	///	 http://ifilter.codeplex.com/
	///	 http://www.pinvoke.net/default.aspx/query/LoadIFilter.html
	///	 
	///  Code here is taken from a combination of the project located at http://ifilter.codeplex.com/
	///  as well as definitions taken from p-invoke.net.  License is MS-PL so enjoy.
	/// 
	///  Modify by eaglet at 2013-01-09, add convert to file method
	using System;
	using System.Text;
	using System.Runtime.InteropServices;
	public static class IFilterAPI
	{
		[DllImport("query.dll", SetLastError = true, CharSet = CharSet.Unicode)]
		public static extern int LoadIFilter
									(
										string pwcsPath
										, [MarshalAs(UnmanagedType.IUnknown)] object pUnkOuter
										, ref IFilter ppIUnk
									);
		[ComImport, Guid("89BCB740-6119-101A-BCB7-00DD010655AF")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		public interface IFilter
		{
			/// <summary>
			/// The IFilter::Init method initializes a filtering session.
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes Init
								(
										//[in] Flag settings from the IFILTER_INIT enumeration for
										// controlling text standardization, property output, embedding
										// scope, and IFilter access patterns. 
									  IFILTER_INIT grfFlags,
										// [in] The size of the attributes array. When nonzero, cAttributes
										//  takes 
										// precedence over attributes specified in grfFlags. If no
										// attribute flags 
										// are specified and cAttributes is zero, the default is given by
										// the 
										// PSGUID_STORAGE storage property set, which contains the date and
										//  time 
										// of the last write to the file, size, and so on; and by the
										//  PID_STG_CONTENTS 
										// 'contents' property, which maps to the main contents of the
										// file. 
										// For more information about properties and property sets, see
										// Property Sets. 
									  int cAttributes,
										//[in] Array of pointers to FULLPROPSPEC structures for the
										// requested properties. 
										// When cAttributes is nonzero, only the properties in aAttributes
										// are returned. 
									  IntPtr aAttributes,
										// [out] Information about additional properties available to the
										//  caller; from the IFILTER_FLAGS enumeration. 
									  out IFILTER_FLAGS pdwFlags
								);
			/// <summary>
			/// The IFilter::GetChunk method positions the filter at the beginning
			/// of the next chunk, 
			/// or at the first chunk if this is the first call to the GetChunk
			/// method, and returns a description of the current chunk. 
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes GetChunk(out STAT_CHUNK pStat);
			/// <summary>
			/// The IFilter::GetText method retrieves text (text-type properties)
			/// from the current chunk, 
			/// which must have a CHUNKSTATE enumeration value of CHUNK_TEXT.
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes GetText
									(
										// [in/out] On entry, the size of awcBuffer array in wide/Unicode
										// characters. On exit, the number of Unicode characters written to
										// awcBuffer. 
										// Note that this value is not the number of bytes in the buffer. 
										ref int pcwcBuffer,
										// Text retrieved from the current chunk. Do not terminate the
										// buffer with a character.  
										[Out(), MarshalAs(UnmanagedType.LPWStr)] 
										StringBuilder awcBuffer
									);
			/// <summary>
			/// The IFilter::GetValue method retrieves a value (public
			/// value-type property) from a chunk, 
			/// which must have a CHUNKSTATE enumeration value of CHUNK_VALUE.
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes GetValue
								(
									// Allocate the PROPVARIANT structure with CoTaskMemAlloc. Some
									// PROPVARIANT 
									// structures contain pointers, which can be freed by calling the
									// PropVariantClear function. 
									// It is up to the caller of the GetValue method to call the
									//   PropVariantClear method.			
									// ref IntPtr ppPropValue
									// [MarshalAs(UnmanagedType.Struct)]
									ref IntPtr PropVal
								);
			/// <summary>
			/// The IFilter::BindRegion method retrieves an interface representing
			/// the specified portion of the object. 
			/// Currently reserved for future use.
			/// </summary>
			[PreserveSig]
			IFilterReturnCodes BindRegion
									(
										ref FILTERREGION origPos
										, ref Guid riid
										, ref object ppunk
									);
		}
		public struct FILTERREGION
		{
			public int idChunk;
			public int cwcStart;
			public int cwcExtent;
		}
		public enum IFilterReturnCodes : uint
		{
			/// <summary>
			/// Success
			/// </summary>
			S_OK = 0,
			/// <summary>
			/// The function was denied access to the filter file. 
			/// </summary>
			E_ACCESSDENIED = 0x80070005,
			/// <summary>
			/// The function encountered an invalid handle,
			/// probably due to a low-memory situation. 
			/// </summary>
			E_HANDLE = 0x80070006,
			/// <summary>
			/// The function received an invalid parameter.
			/// </summary>
			E_INVALIDARG = 0x80070057,
			/// <summary>
			/// Out of memory
			/// </summary>
			E_OUTOFMEMORY = 0x8007000E,
			/// <summary>
			/// Not implemented
			/// </summary>
			E_NOTIMPL = 0x80004001,
			/// <summary>
			/// Unknown error
			/// </summary>
			E_FAIL = 0x80000008,
			/// <summary>
			/// File not filtered due to password protection
			/// </summary>
			FILTER_E_PASSWORD = 0x8004170B,
			/// <summary>
			/// The document format is not recognised by the filter
			/// </summary>
			FILTER_E_UNKNOWNFORMAT = 0x8004170C,
			/// <summary>
			/// No text in current chunk
			/// </summary>
			FILTER_E_NO_TEXT = 0x80041705,
			/// <summary>
			/// No values in current chunk
			/// </summary>
			FILTER_E_NO_VALUES = 0x80041706,
			/// <summary>
			/// No more chunks of text available in object
			/// </summary>
			FILTER_E_END_OF_CHUNKS = 0x80041700,
			/// <summary>
			/// No more text available in chunk
			/// </summary>
			FILTER_E_NO_MORE_TEXT = 0x80041701,
			/// <summary>
			/// No more property values available in chunk
			/// </summary>
			FILTER_E_NO_MORE_VALUES = 0x80041702,
			/// <summary>
			/// Unable to access object
			/// </summary>
			FILTER_E_ACCESS = 0x80041703,
			/// <summary>
			/// Moniker doesn't cover entire region
			/// </summary>
			FILTER_W_MONIKER_CLIPPED = 0x00041704,
			/// <summary>
			/// Unable to bind IFilter for embedded object
			/// </summary>
			FILTER_E_EMBEDDING_UNAVAILABLE = 0x80041707,
			/// <summary>
			/// Unable to bind IFilter for linked object
			/// </summary>
			FILTER_E_LINK_UNAVAILABLE = 0x80041708,
			/// <summary>
			///  This is the last text in the current chunk
			/// </summary>
			FILTER_S_LAST_TEXT = 0x00041709,
			/// <summary>
			/// This is the last value in the current chunk
			/// </summary>
			FILTER_S_LAST_VALUES = 0x0004170A
		}
		/// <summary>
		/// Flags controlling the operation of the FileFilter
		/// instance.
		/// </summary>
		[Flags]
		public enum IFILTER_INIT
		{
			IFILTER_INIT_CANON_PARAGRAPHS = 1,
			IFILTER_INIT_HARD_LINE_BREAKS = 2,
			IFILTER_INIT_CANON_HYPHENS = 4,
			IFILTER_INIT_CANON_SPACES = 8,
			IFILTER_INIT_APPLY_INDEX_ATTRIBUTES = 16,
			IFILTER_INIT_APPLY_CRAWL_ATTRIBUTES = 256,
			IFILTER_INIT_APPLY_OTHER_ATTRIBUTES = 32,
			IFILTER_INIT_INDEXING_ONLY = 64,
			IFILTER_INIT_SEARCH_LINKS = 128,
			IFILTER_INIT_FILTER_OWNED_VALUE_OK = 512
		}
		[Flags]
		public enum IFILTER_FLAGS
		{
			IFILTER_FLAGS_OLE_PROPERTIES = 1
		}
		public struct STAT_CHUNK
		{
			public int idChunk;
			[MarshalAs(UnmanagedType.U4)]
			public CHUNK_BREAKTYPE breakType;
			[MarshalAs(UnmanagedType.U4)]
			public CHUNKSTATE flags;
			public int locale;
			public FULLPROPSPEC attribute;
			public int idChunkSource;
			public int cwcStartSource;
			public int cwcLenSource;
		}
		public enum CHUNKSTATE
		{
			CHUNK_TEXT = 0x1,
			CHUNK_VALUE = 0x2,
			CHUNK_FILTER_OWNED_VALUE = 0x4
		}
		[StructLayout(LayoutKind.Explicit)]
		public struct PROPSPEC
		{
			[FieldOffset(0)]
			public int ulKind;	 // 0 - string used; 1 - PROPID
			[FieldOffset(4)]
			public int propid;
			[FieldOffset(4)]
			public IntPtr lpwstr;
		}
		public struct FULLPROPSPEC
		{
			public Guid guidPropSet;
			public PROPSPEC psProperty;
		}
		public enum CHUNK_BREAKTYPE
		{
			CHUNK_NO_BREAK = 0,
			CHUNK_EOW = 1,
			CHUNK_EOS = 2,
			CHUNK_EOP = 3,
			CHUNK_EOC = 4
		}
	}
}

#T=PDF/XPS from Word/Excel
// /r:"C:\Program Files (x86)\Microsoft Visual Studio 10.0\Visual Studio Tools for Office\PIA\Office14\Microsoft.Office.Interop.Word.dll"
namespace ConsoleApplication
{
	using System;
	using Word = Microsoft.Office.Interop.Word;
	//using System.Runtime.InteropServices;
	//using Microsoft.Office.Interop.Word;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Convert(@"D:\a.doc", @"d:\aaa7.pdf", Word.WdExportFormat.wdExportFormatPDF);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		private static bool Convert
								(
									string sourcePath
									, string targetPath
									, Word.WdExportFormat exportFormat
								)
		{
			bool result = false;
			Word._Application wordApplication = new Word.Application();
			Word._Document wordDocument = null;
			object paramSourceDocPath = sourcePath;
			string paramExportFilePath = targetPath;
			Word.WdExportFormat paramExportFormat = exportFormat;
			//bool paramOpenAfterExport = false;
			//Word.WdExportOptimizeFor paramExportOptimizeFor =
			//Word.WdExportOptimizeFor.wdExportOptimizeForPrint;
			//Word.WdExportRange paramExportRange = Word.WdExportRange.wdExportAllDocument;
			//int paramStartPage = 0;
			//int paramEndPage = 0;
			//Word.WdExportItem paramExportItem = Word.WdExportItem.wdExportDocumentContent;
			//bool paramIncludeDocProps = true;
			//bool paramKeepIRM = true;
			//Word.WdExportCreateBookmarks paramCreateBookmarks =
			//	Word.WdExportCreateBookmarks.wdExportCreateWordBookmarks;
			//bool paramDocStructureTags = true;
			//bool paramBitmapMissingFonts = true;
			//bool paramUseISO19005_1 = false;
			wordDocument = wordApplication.Documents.Open
														(
															ref paramSourceDocPath
															//, 
															//Type.Missing, Type.Missing,
															//Type.Missing, Type.Missing, Type.Missing,
															//Type.Missing, Type.Missing, Type.Missing,
															//Type.Missing, Type.Missing, Type.Missing,
															//Type.Missing, Type.Missing, Type.Missing,
															//Type.Missing
														);

			if (wordDocument != null)
			{
				wordDocument.ExportAsFixedFormat
										(
											paramExportFilePath
											, paramExportFormat
											, false
											//,
											//paramExportOptimizeFor, paramExportRange, paramStartPage,
											//paramEndPage, paramExportItem, paramIncludeDocProps,
											//paramKeepIRM, paramCreateBookmarks, paramDocStructureTags,
											//paramBitmapMissingFonts, paramUseISO19005_1,
											//Type.Missing
										);
				wordDocument.Close
							 (
								//Type.Missing, Type.Missing, Type.Missing
							 );
				wordDocument = null;
			}
			if (wordApplication != null)
			{
				wordApplication.Quit
									(
										//Type.Missing, Type.Missing, Type.Missing
									);
				wordApplication = null;
			}
			return result;
		}
	}
}

#T=PerfMon Remoting
//Server.cs
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Configuration.Install;
	using System.Security.Principal;
	using Microshaoft.RemotingObjects.ServiceContracts.Share;
	
	using Microshaoft.Win32;
	using Microshaoft;
	public class ServiceHost : ServiceBase
	{
		///// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		public static readonly string serviceName = "eHome Remoting PerfMon Service";
		static void Main(string[] args)
		{
			//Microshaoft
			//Microshaoft TODO: 在此处添加代码以启动应用程序
			//Microshaoft 
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
				}
				Console.Title = "Server"; //不能以服务运行
				Console.WriteLine("Console");
				service.OnStart(null);
				Console.ReadLine();
				return;
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			RemotingHelper.StartRemoting<RemotingPerformanceMonitor>
								(
									"perfmonurl"
									, 8082
								);
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}
namespace Microshaoft.RemotingObjects
{
	using System;
	using System.IO;
	using System.Net;
	using System.Web;
	using System.Text;
	using System.Threading;
	using System.Configuration;
	using System.Collections.Generic;
	using System.Diagnostics;
	using System.Globalization;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Server;
	using Microshaoft.RemotingObjects.ServiceContracts.Share;
	public class RemotingPerformanceMonitor : MarshalByRefObject, IRemotingPerformanceMonitor
	{
		public string[] ReadAllInstancePerformanceCounterNextValue(string categoryName, string[] instanceNamesFilter, string[] countersName)
		{
			try
			{
				PerformanceCounterCategory pcc = new PerformanceCounterCategory(categoryName);
				string[] instances = pcc.GetInstanceNames();
				List<string> list = new List<string>();
				foreach (string instanceNameFilter in instanceNamesFilter)
				{
					
					//f = instanceNameFilter.ToLower();
					foreach (string s in instances)
					{
						string instance = "";
						if (string.IsNullOrEmpty(instanceNameFilter))
						{
							instance = s;
						}
						else
						{
							
							if (s.ToLower().IndexOf(instanceNameFilter.ToLower()) >= 0)
							{
								instance = s;
								Console.WriteLine(instance);
							}
						}
						
						if (!string.IsNullOrEmpty(instance))
						{
							foreach (string counterName in countersName)
							{
								string[] l = ReadInstancePerformanceCounterNextValue(categoryName, instance, counterName);
								if (l.Length > 0)
								{
									list.AddRange(l);
								}
							}
							
						}
					}
				}
				return list.ToArray();
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
				return null;
			}
		}
		public string[] ReadAllInstanceAllPerformanceCounterNextValue(string categoryName, string instanceNameFilter)
		{
			try
			{
				PerformanceCounterCategory pcc = new PerformanceCounterCategory(categoryName);
				string[] instances = pcc.GetInstanceNames();
				List<string> list = new List<string>();
				instanceNameFilter = instanceNameFilter.ToLower();
				foreach (string s in instances)
				{
					string instance = "";
					if (string.IsNullOrEmpty(instanceNameFilter))
					{
						instance = s;
					}
					else
					{
						Console.WriteLine(s);
						if (s.ToLower().IndexOf(instanceNameFilter) >= 0)
						{
							instance = s;
						}
					}
					if (!string.IsNullOrEmpty(instance))
					{
						string[] l = ReadInstanceAllPerformanceCounterNextValue(categoryName, instance);
						if (l.Length > 0)
						{
							list.AddRange(l);
						}
						
					}
				}
				return list.ToArray();
			}
			catch //(Exception e)
			{
				return null;
			}
			
		}
		public string[] ReadInstanceAllPerformanceCounterNextValue(string categoryName, string instanceName)
		{
			PerformanceCounterCategory pcc = new PerformanceCounterCategory(categoryName);
			PerformanceCounter[] counters = pcc.GetCounters(instanceName);
			List<string> list = new List<string>();
			foreach (PerformanceCounter counter in counters)
			{
				list.Add
						(
							string.Format
										(
											"Machine[{0}] - Category[{1}] - Instance[{2}] - Counter[{3}]: {4:dddd.dddd}"
											, counter.MachineName
											, categoryName
											, counter.InstanceName
											, counter.CounterName
											, counter.NextValue()
										)
						);
			}
			return list.ToArray();
		}
		public string[] ReadInstancePerformanceCounterNextValue(string categoryName, string instanceName, string counterName)
		{
			PerformanceCounterCategory pcc = new PerformanceCounterCategory(categoryName);
			PerformanceCounter counter = new PerformanceCounter(categoryName,  counterName, instanceName);
			List<string> list = new List<string>();
///			foreach (PerformanceCounter counter in counters)
///			{
				//NumberFormatInfo nfi = new NumberFormatInfo();
				//nfi.NumberGroupSizes = new int[] {3,3,3,3,3,3};
				//nfi.NumberGroupSeparator = ",";
				//string nextValueString = counter.NextValue();
				list.Add
						(
							string.Format
										(
											"Machine[{1}] {0} DateTime[{2}] {0} Category[{3}] {0} Instance[{4}] {0} Counter[{5}]: {6:N}"
											, "-"
											, counter.MachineName
											, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											, categoryName
											, counter.InstanceName
											, counter.CounterName
											, counter.NextValue()
										)
						);
///			}
			return list.ToArray();
		}
	}
}
//Share.cs ============================================
//Microshaoft =========================================
//Microshaoft Remoting Object Client Local Proxy
namespace Microshaoft.RemotingObjects.ServiceContracts.Share
{
	//using System;
	//using System.Collections.Generic;
	public interface IRemotingPerformanceMonitor
	{
		string[] ReadAllInstanceAllPerformanceCounterNextValue(string categoryName, string instanceNameFilter);
		string[] ReadAllInstancePerformanceCounterNextValue(string categoryName, string[] instanceNamesFilter, string[] countersName);
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Text;
	public static class RemotingHelper
	{
		public static void StartRemoting
			(
				Type RemotingType
				, string Url
				, int Port
			)
		{
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
			IDictionary ht = new Hashtable();
			ht["port"] = Port;
			TcpChannel tc = new TcpChannel(ht, null, provider);
			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, WellKnownObjectMode.Singleton);
			Console.WriteLine("Remoting Object Started ...");
		}
		public static void StartRemoting<T>
			(
				string Url
				, int Port
			)
		{
			StartRemoting(typeof(T), Url, Port);
		}
		public static T GetRemotingLocalClientProxyObject<T>
			(
				string Url
			)
		{
			return (T) Activator.GetObject
									(
										typeof(T)
										, Url
										//, "tcp://127.0.0.1:8080/queueUrl"
									);
		}
	}
}
//Client.cs ============================================================================================
namespace Microshaoft.RemotingObjects.Client
{
	using System;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Threading;
	using System.Collections.Generic;
	using Microshaoft;
	using Microshaoft.RemotingObjects.ServiceContracts.Share;
	public class Class1
	{
		public static void Main()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
		}
		public void Run()
		{
				IRemotingPerformanceMonitor monitor = RemotingHelper.GetRemotingLocalClientProxyObject<IRemotingPerformanceMonitor>("tcp://127.0.0.1:8082/perfmonurl");
				string[] ss = monitor.ReadAllInstancePerformanceCounterNextValue
											(
												"Process"
												, new string[]
													{
														"devenv"
													}
												, new string[]
													{
														"Working Set"
													}
												);
			foreach (string s in ss)
			{
				Console.WriteLine(s);
			}
		}
	}
}

#T=PerformanceCounter RateOfCountsPerSecond
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Timers;
	using System.Threading;
	public sealed class PCDemo
	{
		static PerformanceCounter theCounter;
		const string _categoryName	= "ACounterDemo";
		const string _counterName	= "CountPerSecond";
		const string _instanceName	= "_Total";
		private PCDemo()
		{
		}
		public static void Main(string[] args)
		{
			// Get the category/counters installed...
			if ( (args.Length > 0) ) 
			{
				if ((args[0].StartsWith("/install")))
				{
					if (InstallCounters())
					{
						return;
					}
					else
						Console.WriteLine("Continuing with sample...\r\n");
				}
				else if ((args[0].StartsWith("/uninstall")))
				{
					DeleteCounters();
					return;
				}
				else 
				{
					ShowUsage();
					return;
				}
			}
			{
				theCounter = new PerformanceCounter(_categoryName, _counterName, _instanceName, false);
				theCounter.RawValue = 0;
			}
			System.Timers.Timer aTimer = new System.Timers.Timer();
			aTimer.Elapsed += new ElapsedEventHandler(OnTimer);
			aTimer.Interval  = 100;
			aTimer.Enabled   = true;
			aTimer.AutoReset = false;
			System.Timers.Timer bTimer = new System.Timers.Timer();
			bTimer.Elapsed += new ElapsedEventHandler(OnTimer2);
			bTimer.Interval  = 50;
			bTimer.Enabled   = true;
			bTimer.AutoReset = true;
			Console.WriteLine("Press \'+\' to increase the interval");
			Console.WriteLine("Press \'-\' to decrease the interval");
			Console.WriteLine("Press \'q\' to quit the sample");
			Console.WriteLine("Started");
			int command;
			do 
			{
				command = Console.Read();
				if (command == '+')
				{
					aTimer.Interval = Math.Max(1, aTimer.Interval / 2);
				}
				if (command == '-')
				{
					aTimer.Interval *= 2;
				}
				Thread.Sleep(500);
			}
			while (command != 'q');
		}
		private static void OnTimer2(Object source, ElapsedEventArgs e) 
		{
			Console.WriteLine(theCounter.NextValue());
		}
		private static void OnTimer(Object source, ElapsedEventArgs e) 
		{
			theCounter.IncrementBy(1);
			System.Timers.Timer theTimer = (System.Timers.Timer)source;
			theTimer.Enabled = true;
		}
		// Returns true if we install the counters...
		private static bool InstallCounters()
		{
			if (!PerformanceCounterCategory.Exists(_categoryName))
			{
				Console.WriteLine("Installing category - " + _categoryName);
				CounterCreationData ccd = new CounterCreationData();
				ccd.CounterName = _counterName;
				ccd.CounterType = PerformanceCounterType.RateOfCountsPerSecond64;
				CounterCreationDataCollection ccds = new CounterCreationDataCollection();
				ccds.Add(ccd);
				PerformanceCounterCategory.Create(_categoryName, "Sample Object", PerformanceCounterCategoryType.Unknown, ccds);
				Console.Write("Category has been successfully installed.");
				return (true);
			}
			else
			{
				Console.Write("Category already installed!  ");
				return (false);
			}
		}
		private static void DeleteCounters()
		{
			if(PerformanceCounterCategory.Exists(_categoryName)) 
			{
				PerformanceCounterCategory.Delete(_categoryName);
				Console.Write("Category has been successfully deleted!  ");
			}
			else
			{
				Console.Write("Category not installed!  ");
			}
		}
		private static void ShowUsage()
		{
			Console.WriteLine("Usage");
			Console.WriteLine("-----");
			Console.WriteLine("To install perf counter AcounterDemo: pcdemo /inst");
			Console.WriteLine("To apply changes to perf counter AcounterDemo: pcdemo");
			Console.WriteLine("To delete perf counter AcounterDemo: pcdemo /del");
		}
	}
}
#T=PerformanceCounter Sample 2012-09-12
namespace TestConsoleApplication
{
	using System;
	using System.Diagnostics;
	using System.Text;
	using System.Threading;
	using Microshaoft;
	//using FNS.FrontEnd.Workflow.Server.BOCChannelInterfaceConnection;
	class Program
	{
		static void Main(string[] args)
		{
			if (args == null || args.Length <= 0)
			{
				Console.WriteLine("args[1]: {0}", "主机IP");
				Console.WriteLine("args[2]: {0}", "主机端口");
				Console.WriteLine("args[3]: {0}", "并发线程数");
				Console.WriteLine("args[4]: {0}", "独立线程迭代次数");
				Console.WriteLine("args[5]: {0}", "思考时间");
				Console.WriteLine("Sample:");
				Console.WriteLine("TestConsoleApplication.exe 22.188.155.131 10003 20 200 200");
				Console.ReadLine();
				return;
			}
			var host = args[0];
			var port = Convert.ToString(args[1]);
			var threads = int.Parse(args[2]);
			var iterations = int.Parse(args[3]);
			var sleep = int.Parse(args[4]);
			var hexStringData = "2030313330202020202020202020202020202020202020202A2A20202020202020202020202020202020202020203030333130303031303438303031303030314535343030313035303030303030303030202020202020202020202030203030303030303020203030303034313233313233202020202020202020202037363830302020202020"; 
			var buffer = BytesHelper.HexStringToBytesArray(hexStringData);
			var length = buffer.Length;
			var e = Encoding.GetEncoding("gb18030");
			var pcc = new PerformanceCountersContainer();
			pcc.AttachPerformanceCountersToProperties
											(
												Process.GetCurrentProcess().ProcessName
												, "Microshaoft ComPlus SendMessage Performance Counters Category"
											);
			//var ccic = new CChannelInterfaceConnection();//???????????????????
			for (int i = 0; i < threads; i++)
			{
				new Thread
						(
							new ThreadStart
									(
										() =>
										{
											for (int j = 0; j < iterations; j++)
											{
												
												pcc.SendRequestsPerformanceCounter.Increment();
												pcc.SendingRequestsPerformanceCounter.Increment();
												pcc.SendedRequestProcessedAverageTimerPerformanceCounter.ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
														(
															true
															, pcc.SendedRequestAverageBasePerformanceCounter
															, () =>
															{
///																var r = ccic.sendMessage
///																			(
///																				host
///																				, port
///																				, 10
///																				, buffer
///																				, length
///																				, "tellno"
///																				, false
///																				, "gb18030"
///																			);
///																var a = r.ToArray();
///																Console.WriteLine(a.Length);
///																var bytes = a.GetValue(0) as byte[];
///																if (bytes != null)
///																{
///																	var s = e.GetString(bytes);
///																	Console.WriteLine(s.Trim());
///																}
																//Array.ForEach
																//		(
																//			 a
																//			 , (x) =>
																//				 {
																//					 Console.WriteLine(x);
																//				 }
																//		);
																Thread.Sleep(sleep);
															}
														   // , null
														   // , null
														);
												pcc.SendingRequestsPerformanceCounter.Decrement();
												pcc.SendedRequestsRateOfCountsPerSecondPerformanceCounter.Increment();
												pcc.SendedRequestsPerformanceCounter.Increment();
											}
											
										}
									)
						).Start();
			}
			Console.WriteLine("Running ...");
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			return new CounterCreationData()
			{
				CounterName = counterName
				,
				CounterHelp = string.Format("{0} Help", counterName)
				,
				CounterType = performanceCounterType
			};
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	//using System.Collections.Concurrent;
	public class PerformanceCountersContainer
	{
		#region PerformanceCounters
		private PerformanceCounter _sendRequestsPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter SendRequestsPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _sendRequestsPerformanceCounter, value, 2);
			}
			get
			{
				return _sendRequestsPerformanceCounter;
			}
		}
		private PerformanceCounter _sendedRequestsPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter SendedRequestsPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _sendedRequestsPerformanceCounter, value, 2);
			}
			get
			{
				return _sendedRequestsPerformanceCounter;
			}
		}
		private PerformanceCounter _sendingRequestsPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter SendingRequestsPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _sendingRequestsPerformanceCounter, value, 2);
			}
			get
			{
				return _sendingRequestsPerformanceCounter;
			}
		}
		private PerformanceCounter _sendedRequestsRateOfCountsPerSecondPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.RateOfCountsPerSecond64)]
		public PerformanceCounter SendedRequestsRateOfCountsPerSecondPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _sendedRequestsRateOfCountsPerSecondPerformanceCounter, value, 2);
			}
			get
			{
				return _sendedRequestsRateOfCountsPerSecondPerformanceCounter;
			}
		}
		private PerformanceCounter _sendedRequestProcessedAverageTimerPerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter SendedRequestProcessedAverageTimerPerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _sendedRequestProcessedAverageTimerPerformanceCounter, value, 2);
			}
			get
			{
				return _sendedRequestProcessedAverageTimerPerformanceCounter;
			}
		}
		private PerformanceCounter _sendedRequestProcessedAverageBasePerformanceCounter;
		[PerformanceCounterTypeAttribute(CounterType = PerformanceCounterType.AverageBase)]
		public PerformanceCounter SendedRequestAverageBasePerformanceCounter
		{
			private set
			{
				ReaderWriterLockSlimHelper.TryEnterWriterLockSlimWrite<PerformanceCounter>(ref _sendedRequestProcessedAverageBasePerformanceCounter, value, 2);
			}
			get
			{
				return _sendedRequestProcessedAverageBasePerformanceCounter;
			}
		}
		#endregion
		// indexer declaration
		public PerformanceCounter this[string name]
		{
			get
			{
				throw new NotImplementedException();
				//return null;
			}
		}
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCountersToProperties
							(
								string instanceName
								, string categoryName
							)
		{
			if (!_isAttachedPerformanceCounters)
			{
				var type = this.GetType();
				PerformanceCountersHelper.AttachPerformanceCountersToProperties<PerformanceCountersContainer>(instanceName, categoryName, this);
			}
			_isAttachedPerformanceCounters = true;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
	public class PerformanceCounterTypeAttribute : Attribute
	{
		public PerformanceCounterType CounterType;
	}
}
namespace Microshaoft
{
	using System.Diagnostics;
	using System.Linq;
	public static class PerformanceCountersHelper
	{
		public static void AttachPerformanceCountersToProperties<T>
									(
										string performanceCounterInstanceName
										, string category
										, T target = default(T)
									)
		{
			var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList.Where
												(
													(pi) =>
													{
														var parameters = pi.GetIndexParameters();
														return
															(
																pi.PropertyType == typeof(PerformanceCounter)
																&& (parameters == null ? 0 : parameters.Length) <= 0
															);
													}
												).ToList();
			if (PerformanceCounterCategory.Exists(category))
			{
				propertiesList.ForEach
									(
										(pi) =>
										{
											if (PerformanceCounterCategory.CounterExists(pi.Name, category))
											{
												if (PerformanceCounterCategory.InstanceExists(performanceCounterInstanceName, category))
												{
													//var pc = new PerformanceCounter(category, pi.Name, instanceName, false);
													//pc.InstanceName = instanceName;
													//pc.RemoveInstance();
												}
											}
										}
									);
				//PerformanceCounterCategory.Delete(category);
			}
			if (!PerformanceCounterCategory.Exists(category))
			{
				var ccdc = new CounterCreationDataCollection();
				propertiesList.ForEach
								(
									(pi) =>
									{
										var propertyName = pi.Name;
										PerformanceCounterTypeAttribute attribute = pi.GetCustomAttributes(false).FirstOrDefault
																					(
																						(x) =>
																						{
																							return x as PerformanceCounterTypeAttribute != null;
																						}
																					) as PerformanceCounterTypeAttribute;
										PerformanceCounterType performanceCounterType = (attribute == null ? PerformanceCounterType.NumberOfItems64 : attribute.CounterType);
										var ccd = PerformanceCounterHelper.GetCounterCreationData
										(
											propertyName
											, performanceCounterType
										);
										ccdc.Add(ccd);
									}
								);
				PerformanceCounterCategory.Create
								(
									category,
									string.Format("{0} Category Help.", category),
									PerformanceCounterCategoryType.MultiInstance,
									ccdc
								);
			}
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var pc = new PerformanceCounter()
									{
										CategoryName = category
										,
										CounterName = propertyName
										,
										InstanceLifetime = PerformanceCounterInstanceLifetime.Process
										,
										InstanceName = performanceCounterInstanceName
										,
										ReadOnly = false
										,
										RawValue = 0
									};
									if (pi.GetGetMethod().IsStatic)
									{
										var setter = DynamicPropertyAccessor.CreateSetStaticPropertyValueAction<PerformanceCounter>(type, propertyName);
										setter(pc);
									}
									else
									{
										if (target != null)
										{
											var setter = DynamicPropertyAccessor.CreateSetPropertyValueAction<PerformanceCounter>(type, propertyName);
											setter(target, pc);
										}
									}
								}
							);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterExtensionMethodsManager
	{
		public static T ChangeCounterValueWithTryCatchExceptionFinally<T>
								(
									this PerformanceCounter performanceCounter
									, bool enabled
									, Func<PerformanceCounter, T> OnCounterChangeProcessFunc = null
									, Action<PerformanceCounter> OnCounterChangedProcessAction = null
									, Func<PerformanceCounter, Exception, bool> OnCaughtExceptionProcessFunc = null
									, Action<PerformanceCounter> OnCaughtExceptionFinallyProcessAction = null
								)
		{
			T r = default(T);
			if (enabled)
			{
				if (OnCounterChangeProcessFunc != null)
				{
					var catchedException = false;
					try
					{
						r = OnCounterChangeProcessFunc(performanceCounter);
					}
					catch (Exception e)
					{
						catchedException = true;
						if (OnCaughtExceptionProcessFunc != null)
						{
							var b = OnCaughtExceptionProcessFunc(performanceCounter, e);
							if (b)
							{
								throw new Exception("OnCounterChangeProcessFunc InnerExcepion", e);
							}
						}
					}
					finally
					{
						if (catchedException)
						{
							if (OnCaughtExceptionFinallyProcessAction != null)
							{
								OnCaughtExceptionFinallyProcessAction(performanceCounter);
							}
						}
					}
				}
			}
			if (OnCounterChangedProcessAction != null)
			{
				var catchedException = false;
				try
				{
					OnCounterChangedProcessAction(performanceCounter);
				}
				catch (Exception e)
				{
					catchedException = true;
					if (OnCaughtExceptionProcessFunc != null)
					{
						var b = OnCaughtExceptionProcessFunc(performanceCounter, e);
						if (b)
						{
							throw new Exception("OnCounterChangedProcessAction InnerExcepion", e);
						}
					}
				}
				finally
				{
					if (catchedException)
					{
						if (OnCaughtExceptionFinallyProcessAction != null)
						{
							OnCaughtExceptionFinallyProcessAction(performanceCounter);
						}
					}
				}
			}
			return r;
		}
		public static void ChangeAverageTimerCounterValueWithTryCatchExceptionFinally
														(
															this PerformanceCounter performanceCounter
															, bool enabled
															, PerformanceCounter basePerformanceCounter
															, Action OnCounterInnerProcessAction = null
															, Func<PerformanceCounter, Exception, bool> OnCaughtExceptionProcessFunc = null
															, Action<PerformanceCounter, PerformanceCounter> OnCaughtExceptionFinallyProcessAction = null
														)
		{
			if (enabled)
			{
				var stopwatch = Stopwatch.StartNew();
				if (OnCounterInnerProcessAction != null)
				{
					var catchedException = false;
					try
					{
						OnCounterInnerProcessAction();
					}
					catch (Exception e)
					{
						catchedException = true;
						if (OnCaughtExceptionProcessFunc != null)
						{
							var b = OnCaughtExceptionProcessFunc(performanceCounter, e);
							if (b)
							{
								throw new Exception("OnCounterInnerProcessAction InnerExcepion", e);
							}
						}
					}
					finally
					{
						stopwatch.Stop();
						performanceCounter.IncrementBy(stopwatch.ElapsedTicks);
						stopwatch = null;
						basePerformanceCounter.Increment();
						if (catchedException)
						{
							if (OnCaughtExceptionFinallyProcessAction != null)
							{
								OnCaughtExceptionFinallyProcessAction(performanceCounter, basePerformanceCounter);
							}
						}
					}
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class ReaderWriterLockSlimHelper
	{
		public static bool TryEnterWriterLockSlimWrite<T>
												(
													 ref T target
													, T newValue
													, int enterTimeOutSeconds
												)
													where T : class
		{
			bool r = false;
			var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutSeconds >= 0)
			{
				timeOut = enterTimeOutSeconds * 1000;
			}
			try
			{
				r = (rwls.TryEnterWriteLock(timeOut));
				if (r)
				{
					Interlocked.Exchange<T>(ref target, newValue);
					r = true;
				}
			}
			finally
			{
				if (r)
				{
					rwls.ExitWriteLock();
				}
			}
			return r;
		}
		public static bool TryEnterWriterLockSlim
								(
									Action action
									, int enterTimeOutSeconds
								)
		{
			bool r = false;
			if (action != null)
			{
				var rwls = new ReaderWriterLockSlim();
				int timeOut = Timeout.Infinite;
				if (enterTimeOutSeconds >= 0)
				{
					timeOut = enterTimeOutSeconds * 1000;
				}
				try
				{
					r = (rwls.TryEnterWriteLock(timeOut));
					if (r)
					{
						action();
						r = true;
					}
				}
				finally
				{
					if (r)
					{
						rwls.ExitWriteLock();
					}
				}
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	public static class BytesHelper
	{
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Linq.Expressions;
	public class DynamicPropertyAccessor
	{
		public static Func<object, object> CreateGetPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object), "p");
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object), "p");
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName, typeof(TProperty));
			var getPropertyValue = Expression.Property(null, property);
			var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var getPropertyValue = Expression.Property(null, property);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object), "p");
			var propertyValue = Expression.Parameter(typeof(object), "p");
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, object> CreateSetPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object), "p");
			var propertyValue = Expression.Parameter(typeof(TProperty), "p");
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			return Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue).Compile();
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(object), "p");
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<object> CreateSetStaticPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(TProperty), "p");
			//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, propertyValue);
			var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = AppDomain.CurrentDomain.GetAssemblies().First
																(
																	(a) =>
																	{
																		return a.GetTypes().Any
																							(
																								(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																							);
																	}
																);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}

#T=PerformanceCountersHelper
namespace ConsoleApplication
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Reflection;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class PerformanceCountersCategoryCreater
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			string assemblyPath = args[0];
			string typeName = args[1];
			string category = args[2];
			var assembly = Assembly.LoadFile(assemblyPath);
			var typesList = assembly.GetTypes().Where
												(
													(x) =>
													{
														return (x.Name.ToLower().IndexOf(typeName.ToLower()) >= 0);
													}
												).ToList();
			typesList.ForEach
						(
							(x) =>
							{
								PerformanceCountersHelper.CreatePerformanceCountersCategory
																	(
																		category
																		, x
																	);
							}
						);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Diagnostics;
	using System.Reflection;
	using System.Collections.Generic;
	//interface IPerformanceCountersManager
	//{
	//	public string PerformanceCountersInstanceName { set; get; }
	//	public string PerformanceCountersCategoryName { set; get; }
	//}
	public static class PerformanceCountersHelper
	{
		public static void CreatePerformanceCountersCategory
									(
										string performanceCountersCategoryName
										, Type type
									)
		{
			//var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList.Where
												(
													(pi) =>
													{
														return (pi.PropertyType == typeof(PerformanceCounter));
													}
												).ToList();
			if (PerformanceCounterCategory.Exists(performanceCountersCategoryName))
			{
				propertiesList.ForEach
									(
										(pi) =>
										{
											if (PerformanceCounterCategory.CounterExists(pi.Name, performanceCountersCategoryName))
											{
												//if (PerformanceCounterCategory.InstanceExists(performanceCountersInstanceName, category))
												//{
												//	//var pc = new PerformanceCounter(category, pi.Name, instanceName, false);
												//	//pc.InstanceName = instanceName;
												//	//pc.RemoveInstance();
												//}
											}
										}
									);
				PerformanceCounterCategory.Delete(performanceCountersCategoryName);
			}
			var ccdc = new CounterCreationDataCollection();
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var ccd = PerformanceCounterHelper.GetCounterCreationData
																			(
																				propertyName
																				, PerformanceCounterType.NumberOfItems64
																			);
									ccdc.Add(ccd);
								}
							);
			PerformanceCounterCategory.Create
							(
								performanceCountersCategoryName,
								string.Format("{0} Category Help.", performanceCountersCategoryName),
								PerformanceCounterCategoryType.MultiInstance,
								ccdc
							);
		}
		
		public static void AttachPerformanceCountersToProperties<T>
									(
										string performanceCounterInstanceName
										, string category
										, T target = default(T)
									)
		{
			var type = typeof(T);
			var propertiesList = type.GetProperties().ToList();
			propertiesList = propertiesList.Where
												(
													(pi) =>
													{
														return (pi.PropertyType == typeof(PerformanceCounter));
													}
												).ToList();
			propertiesList.ForEach
							(
								(pi) =>
								{
									var propertyName = pi.Name;
									var pc = new PerformanceCounter()
									{
										CategoryName = category
										, CounterName = propertyName
										, InstanceLifetime = PerformanceCounterInstanceLifetime.Process
										, InstanceName = performanceCounterInstanceName
										, ReadOnly = false
										, RawValue = 0
									};
									if (pi.GetGetMethod().IsStatic)
									{
										var setter = DynamicPropertyAccessor.CreateSetStaticPropertyValueAction<PerformanceCounter>(type, propertyName);
										setter(pc);
									}
									else
									{
										if (target != null)
										{
											var setter = DynamicPropertyAccessor.CreateSetPropertyValueAction<PerformanceCounter>(type, propertyName);
											setter(target, pc);
										}
									}
								}
							);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			return new CounterCreationData()
			{
				CounterName = counterName
				, CounterHelp = string.Format("{0} Help", counterName)
				, CounterType = performanceCounterType
			};
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	public class DynamicPropertyAccessor
	{
		private static Assembly GetAssemblyByTypeName(string typeName)
		{
			return AppDomain.CurrentDomain.GetAssemblies().First
														(
															(a) =>
																{
																	return a.GetTypes().Any
																						(
																							(t) =>
																								{
																									return (t.FullName == typeName);
																								}
																						);
																}
														);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc(type, propertyName);
		}
		public static Func<object, object> CreateGetPropertyValueFunc(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object, object>>(castPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<object, TProperty> CreateGetPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var target = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var getPropertyValue = Expression.Property(castTarget, propertyName);
			var lambda = Expression.Lambda<Func<object, TProperty>>(getPropertyValue, target);
			return lambda.Compile();
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc<TProperty>(type, propertyName);
		}
		public static Func<TProperty> CreateGetStaticPropertyValueFunc<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName, typeof(TProperty));
			var getPropertyValue = Expression.Property(null, property);
			var lambda = Expression.Lambda<Func<TProperty>>(getPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var getPropertyValue = Expression.Property(null, property);
			var castPropertyValue = Expression.Convert(getPropertyValue, typeof(object));
			var lambda = Expression.Lambda<Func<object>>(castPropertyValue, null);
			return lambda.Compile();
		}
		public static Func<object> CreateGetStaticPropertyValueFunc(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateGetStaticPropertyValueFunc(type, propertyName);
		}
		public static Action<object, object> CreateSetPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object));
			var propertyValue = Expression.Parameter(typeof(object));
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, object>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, object> CreateSetPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction(type, propertyName);
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var target = Expression.Parameter(typeof(object));
			var propertyValue = Expression.Parameter(typeof(TProperty));
			var castTarget = Expression.Convert(target, type);
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(castTarget, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object, TProperty>>(call, target, propertyValue);
			return lambda.Compile();
		}
		public static Action<object, TProperty> CreateSetPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetPropertyValueAction<TProperty>(type, propertyName);
		}
		public static Action<object> CreateSetStaticPropertyValueAction(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(object));
			var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, castPropertyValue);
			var lambda = Expression.Lambda<Action<object>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<object> CreateSetStaticPropertyValueAction(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction(type, propertyName);
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(Type type, string propertyName)
		{
			var property = type.GetProperty(propertyName);
			var propertyValue = Expression.Parameter(typeof(TProperty));
			//var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
			var getSetMethod = property.GetSetMethod();
			if (getSetMethod == null)
			{
				getSetMethod = property.GetSetMethod(true);
			}
			var call = Expression.Call(null, getSetMethod, propertyValue);
			var lambda = Expression.Lambda<Action<TProperty>>(call, propertyValue);
			return lambda.Compile();
		}
		public static Action<TProperty> CreateSetStaticPropertyValueAction<TProperty>(string typeName, string propertyName, bool isTypeFromAssembly = false)
		{
			Type type;
			if (isTypeFromAssembly)
			{
				var assembly = GetAssemblyByTypeName(typeName);
				type = assembly.GetType(typeName);
			}
			else
			{
				type = Type.GetType(typeName);
			}
			return CreateSetStaticPropertyValueAction<TProperty>(type, propertyName);
		}
	}
}
#T=PerfView
namespace Microshaoft
{
	// This program uses code hyperlinks available as part of the HyperAddin Visual Studio plug-in.
	// It is available from http://www.codeplex.com/hyperAddin 
	using System;
	using System.Collections.Generic;

	class Program
	{
		public static int aStatic = 0;
		// Spin is a simple compute bound program that lasts for 5 seconds
		// It is a useful test program for CPU profilers.  
		static int Main(string[] args)
		{
			int numSec = 5;
			if (args.Length == 1)
				numSec = int.Parse(args[0]);

			Console.WriteLine("Spinning for {0} seconds", numSec);
			RecSpin(numSec);
			return 0;
		}

		// Spin for 'timeSec' seconds.   We do only 1 second in this
		// method, doing the rest in the helper.   
		static void RecSpin(int timeSec)
		{
			if (timeSec <= 0)
				return;
			--timeSec;
			SpinForASecond();
			RecSpinHelper(timeSec);
		}

		// RecSpinHelper is a clone of RecSpin.   It is repeated 
		// to simulate mutual recursion (more interesting example)
		static void RecSpinHelper(int timeSec)
		{
			if (timeSec <= 0)
				return;
			--timeSec;
			SpinForASecond();
			RecSpin(timeSec);
		}

		// SpingForASecond repeatedly calls DateTime.Now until for
		// 1 second.  It also does some work of its own in this
		// methods so we get some exclusive time to look at.  
		static void SpinForASecond()
		{
			DateTime start = DateTime.Now;
			for (; ; )
			{
				if ((DateTime.Now - start).TotalSeconds > 1)
					break;

				// Do some work in this routine as well.   
				for (int i = 0; i < 10; i++)
					aStatic += i;
			}
		}
	}


}
#T=Ping Client
//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------

namespace Microsoft.Samples.PingClient
{
	using System;
	using System.Collections.Generic;
	using System.Windows.Forms;
	static class PingClient
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.Run(new PingClientForm());
		}
	}
}

//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------

namespace Microsoft.Samples.PingClient
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Windows.Forms;
	using System.Net.NetworkInformation;
	using System.Globalization;

	partial class PingClientForm : Form
	{
		Ping pingClient = new Ping();

		public PingClientForm()
		{
			InitializeComponent();
			pingClient.PingCompleted +=
				new PingCompletedEventHandler(pingClient_PingCompleted);
		}

		private void pingClient_PingCompleted(object sender, PingCompletedEventArgs e)
		{
			// Check to see if an error occurred.  If no error, then display 
			// the address used and the ping time in milliseconds.
			if (e.Error == null)
			{
				if (e.Cancelled)
				{
					pingDetailsTextBox.Text += "  Ping cancelled. \r\n";
				}
				else
				{
					if (e.Reply.Status == IPStatus.Success)
					{
						pingDetailsTextBox.Text +=
							"  " + e.Reply.Address.ToString() + " " +
							e.Reply.RoundtripTime.ToString(
							NumberFormatInfo.CurrentInfo) + "ms" + "\r\n";
					}
					else
					{
						pingDetailsTextBox.Text +=
							"  " + GetStatusString(e.Reply.Status) + "\r\n";
					}
				}
			}
			else
			{
				// Otherwise display the error.
				pingDetailsTextBox.Text += "  Ping error.\r\n";
				MessageBox.Show(
					"An error occurred while sending this ping. " +
					e.Error.InnerException.Message);
			}
			sendButton.Enabled = true;
		}

		private string GetStatusString(IPStatus status)
		{
			switch (status)
			{
				case IPStatus.Success:
					return "Success.";
				case IPStatus.DestinationHostUnreachable:
					return "Destination host unreachable.";
				case IPStatus.DestinationNetworkUnreachable:
					return "Destination network unreachable.";
				case IPStatus.DestinationPortUnreachable:
					return "Destination port unreachable.";
				case IPStatus.DestinationProtocolUnreachable:
					return "Destination protocol unreachable.";
				case IPStatus.PacketTooBig:
					return "Packet too big.";
				case IPStatus.TtlExpired:
					return "TTL expired.";
				case IPStatus.ParameterProblem:
					return "Parameter problem.";
				case IPStatus.SourceQuench:
					return "Source quench.";
				case IPStatus.TimedOut:
					return "Timed out.";
				default:
					return "Ping failed.";
			}
		}

		private void sendButton_Click(object sender, EventArgs e)
		{
			// Select all the text in the address box.
			addressTextBox.SelectAll();

			if (addressTextBox.Text.Length != 0)
			{
				// Disable the Send button.
				sendButton.Enabled = false;

				pingDetailsTextBox.Text +=
					"Pinging " + addressTextBox.Text + " . . .\r\n";

				// Send ping request.
				pingClient.SendAsync(addressTextBox.Text, null);
			}
			else
			{
				MessageBox.Show("Please enter an IP address or host name.");
			}

		}

		private void cancelButton_Click(object sender, EventArgs e)
		{
			// Cancel any pending pings.
			pingClient.SendAsyncCancel();
		}
	}
}
namespace Microsoft.Samples.PingClient
{
	partial class PingClientForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.pingLabel = new System.Windows.Forms.Label();
			this.addressTextBox = new System.Windows.Forms.TextBox();
			this.sendButton = new System.Windows.Forms.Button();
			this.pingDetailsTextBox = new System.Windows.Forms.TextBox();
			this.cancelButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// pingLabel
			// 
			this.pingLabel.AutoSize = true;
			this.pingLabel.Location = new System.Drawing.Point(12, 17);
			this.pingLabel.Name = "pingLabel";
			this.pingLabel.Size = new System.Drawing.Size(51, 14);
			this.pingLabel.TabIndex = 0;
			this.pingLabel.Text = "Name/IP:";
			// 
			// addressTextBox
			// 
			this.addressTextBox.Location = new System.Drawing.Point(69, 14);
			this.addressTextBox.Name = "addressTextBox";
			this.addressTextBox.Size = new System.Drawing.Size(211, 20);
			this.addressTextBox.TabIndex = 0;
			// 
			// sendButton
			// 
			this.sendButton.Location = new System.Drawing.Point(124, 231);
			this.sendButton.Name = "sendButton";
			this.sendButton.TabIndex = 1;
			this.sendButton.Text = "Send";
			this.sendButton.Click += new System.EventHandler(this.sendButton_Click);
			// 
			// pingDetailsTextBox
			// 
			this.pingDetailsTextBox.AutoSize = false;
			this.pingDetailsTextBox.Location = new System.Drawing.Point(12, 41);
			this.pingDetailsTextBox.Multiline = true;
			this.pingDetailsTextBox.Name = "pingDetailsTextBox";
			this.pingDetailsTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.pingDetailsTextBox.Size = new System.Drawing.Size(268, 184);
			this.pingDetailsTextBox.TabIndex = 3;
			// 
			// cancelButton
			// 
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(205, 231);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.TabIndex = 2;
			this.cancelButton.Text = "Cancel";
			this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
			// 
			// PingClientForm
			// 
			this.AcceptButton = this.sendButton;
			this.CancelButton = this.cancelButton;
			this.ClientSize = new System.Drawing.Size(292, 266);
			this.Controls.Add(this.cancelButton);
			this.Controls.Add(this.pingDetailsTextBox);
			this.Controls.Add(this.sendButton);
			this.Controls.Add(this.addressTextBox);
			this.Controls.Add(this.pingLabel);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.Name = "PingClientForm";
			this.Text = "Ping Client";
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.Label pingLabel;
		private System.Windows.Forms.TextBox addressTextBox;
		private System.Windows.Forms.Button sendButton;
		private System.Windows.Forms.TextBox pingDetailsTextBox;
		private System.Windows.Forms.Button cancelButton;
	}
}

#T=PowerShell
/****************************** Module Header ******************************\
* Module Name:	Program.cs
* Project:		CSPowershell
* Copyright (c) Microsoft Corporation.
* 
* This sample indicates how to call Powershell from C# language. It first
* creats a Runspace object in System.Management.Automation namespace. Then 
* it creats a Pipeline from Runspace. The Pipeline is used to host a line of
* commands which are supposed to be executed. The example call Get-Process 
* command to get all processes whose name are started with "C"
* 
* This source is subject to the Microsoft Public License.
* See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
* All other rights reserved.
* 
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
* EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
* WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
\***************************************************************************/

^#region Using directives
using System;
using System.Collections.Generic;
using System.Text;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Diagnostics;
using System.Collections.ObjectModel;
^#endregion


namespace CSPowerShell
{
	class Program
	{
		static void Main(string[] args)
		{
			// Create a RunSpace to host the Powershell script enviroment 
			// using RunspaceFactory.CreateRunSpace
			Runspace runSpace = RunspaceFactory.CreateRunspace();
			runSpace.Open();

			// Create a Pipeline to host commands to be executed using 
			// Runspace.CreatePipeline
			Pipeline pipeLine = runSpace.CreatePipeline();

			// Create a Command object by passing the command to the constructor
			Command getProcessCStarted = new Command("Get-Process");

			// Add parameters to the Command. 
			getProcessCStarted.Parameters.Add("name", "C*");

			// Add the commands to the Pipeline
			pipeLine.Commands.Add(getProcessCStarted);

			// Run all commands in the current pipeline by calling Pipeline.Invoke. 
			// It returns a System.Collections.ObjectModel.Collection object. 
			// In this example, the executed script is "Get-Process -name C*".
			Collection<PSObject> cNameProcesses = pipeLine.Invoke();

			foreach (PSObject psObject in cNameProcesses)
			{
				Process process = psObject.BaseObject as Process;
				Console.WriteLine("Process Name: {0}", process.ProcessName);
			}
		}
	}
}

#T=PowerShell Invoker
// /r:"C:\Program Files\Reference Assemblies\Microsoft\WindowsPowerShell\v1.0\System.Management.Automation.dll"
namespace PowershellInvoker
{
	using System;
	using System.Linq;
	using System.Management.Automation;
	using System.Management.Automation.Runspaces;
	using System.Diagnostics;
	class Program
	{
		static void Main(string[] args)
		{
			var runspace = RunspaceFactory.CreateRunspace();
			runspace.Open();
			var piple = runspace.CreatePipeline("Get-Process");
			var result = piple.Invoke().Select
											(
												p =>
													p.BaseObject
											).Cast<Process>();
			foreach (var item in result)
			{
				Console.WriteLine
							(
								"{0}\t{1}\t{2}",
									item.Id.ToString().PadRight(30),
									item.ProcessName.PadRight(30),
									item.Threads.Count
							);
			}
			Console.Read();
		}
	}
}
#T=PriorityQueue KeyedPriorityQueue
// <copyright file="KeyedPriorityQueue.cs" company="Microsoft">Copyright (c) Microsoft Corporation.  All rights reserved.</copyright>
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.Diagnostics;
	//internal sealed class KeyedPriorityQueueHeadChangedEventArgs<T> : EventArgs where T : class
	//{
	//	private T oldFirstElement;
	//	private T newFirstElement;
	//	public KeyedPriorityQueueHeadChangedEventArgs(T oldFirstElement, T newFirstElement)
	//	{
	//		this.oldFirstElement = oldFirstElement;
	//		this.newFirstElement = newFirstElement;
	//	}
	//	public T OldFirstElement { get { return oldFirstElement; } }
	//	public T NewFirstElement { get { return newFirstElement; } }
	//}
	///// <summary> Combines the functionality of a dictionary and a heap-sorted priority queue.
	///// Enqueue and Dequeue operations are O(log n), Peek is O(1) and Remove is O(n).
	///// Used by the SchedulerService classes to maintain an ordered list of running timers, etc.
	///// Lesser priority values are higher priority.</summary>
	///// <typeparam name="K">Key</typeparam>
	///// <typeparam name="V">Value</typeparam>
	///// <typeparam name="P">Priority</typeparam>
	[Serializable]
	public class KeyedPriorityQueue<TKey, TValue, TPriority>
							where TValue : class
	{
		//private ConcurrentBag<HeapNode<TKey, TValue, TPriority>> _heap = new ConcurrentBag<HeapNode<TKey, TValue, TPriority>>();
		private List<HeapNode<TKey, TValue, TPriority>> _heap = new List<HeapNode<TKey, TValue, TPriority>>();
		private int _size;
		private Comparer<TPriority> _priorityComparer = Comparer<TPriority>.Default;
		private HeapNode<TKey, TValue, TPriority> _placeHolder = default(HeapNode<TKey, TValue, TPriority>);
		//public event EventHandler<KeyedPriorityQueueHeadChangedEventArgs<V>> FirstElementChanged;
		private Action<TValue, TValue> _onKeyedPriorityQueueHeadChangedProcessAction = null;
		private Func<HeapNode<TKey, TValue, TPriority>, HeapNode<TKey, TValue, TPriority>, bool> _onPriorityComparerProcessFunction = null;
		public KeyedPriorityQueue
					(
						Action<TValue, TValue> onKeyedPriorityQueueHeadChangedProcessAction = null
						, Func<HeapNode<TKey, TValue, TPriority>, HeapNode<TKey, TValue, TPriority>, bool> onPriorityComparerProcessFunction = null
					)
		{
			_onKeyedPriorityQueueHeadChangedProcessAction = onKeyedPriorityQueueHeadChangedProcessAction;
			_onPriorityComparerProcessFunction = onPriorityComparerProcessFunction;
			_heap.Add(default(HeapNode<TKey, TValue, TPriority>));	   // Dummy zeroth element, heap is 1-based
		}
		public void Enqueue
						(
							TKey key
							, TValue value
							, TPriority priority
						)
		{
			TValue oldHead = _size > 0 ? _heap[1].Value : null;
			int i = ++_size;
			int parent = i / 2;
			if (i == _heap.Count)
			{
				_heap.Add(_placeHolder);
			}
			var heapNode = new HeapNode<TKey, TValue, TPriority>(key, value, priority);
			bool isHigher = IsHigher(heapNode, _heap[parent]);
			while (i > 1 && isHigher)
			{
				_heap[i] = _heap[parent];
				i = parent;
				parent = i / 2;
			}
			_heap[i] = heapNode;
			TValue newHead = _heap[1].Value;
			if (!newHead.Equals(oldHead))
			{
				RaiseHeadChangedEvent(oldHead, newHead);
			}
		}
		public TValue Dequeue()
		{
			TValue oldHead = (_size < 1) ? null : DequeueImpl();
			TValue newHead = (_size < 1) ? null : _heap[1].Value;
			RaiseHeadChangedEvent(null, newHead);
			return oldHead;
		}
		private TValue DequeueImpl()
		{
			Debug.Assert(_size > 0, "Queue Underflow");
			TValue oldHead = _heap[1].Value;
			_heap[1] = _heap[_size];
			_heap[_size--] = _placeHolder;
			Heapify(1);
			return oldHead;
		}
		public TValue Remove(TKey key)
		{
			if (_size < 1)
			{
				return null;
			}
			TValue oldHead = _heap[1].Value;
			for (int i = 1; i <= _size; i++)
			{
				if (_heap[i].Key.Equals(key))
				{
					TValue retval = _heap[i].Value;
					Swap(i, _size);
					_heap[_size--] = _placeHolder;
					Heapify(i);
					TValue newHead = _heap[1].Value;
					if (!oldHead.Equals(newHead))
					{
						RaiseHeadChangedEvent(oldHead, newHead);
					}
					return retval;
				}
			}
			return null;
		}
		public TValue Peek()
		{
			return (_size < 1) ? null : _heap[1].Value;
		}
		public int Count
		{
			get
			{
				return _size;
			}
		}
		public TValue FindByPriority(TPriority priority, Predicate<TValue> match)
		{
			return _size < 1 ? null : Search(priority, 1, match);
		}
		public ReadOnlyCollection<TValue> Values
		{
			get
			{
				List<TValue> values = new List<TValue>();
				for (int i = 1; i <= _size; i++)
				{
					values.Add(_heap[i].Value);
				}
				return new ReadOnlyCollection<TValue>(values);
			}
		}
		public ReadOnlyCollection<TKey> Keys
		{
			get
			{
				List<TKey> keys = new List<TKey>();
				for (int i = 1; i <= _size; i++)
				{
					keys.Add(_heap[i].Key);
				}
				return new ReadOnlyCollection<TKey>(keys);
			}
		}
		public void Clear()
		{
			_heap.Clear();
			_size = 0;
		}
		private void RaiseHeadChangedEvent(TValue oldHead, TValue newHead)
		{
			if (oldHead != newHead)
			{
				//EventHandler<KeyedPriorityQueueHeadChangedEventArgs<V>> fec = FirstElementChanged;
				if (_onKeyedPriorityQueueHeadChangedProcessAction != null)
				{
					_onKeyedPriorityQueueHeadChangedProcessAction(oldHead, newHead);
				}
			}
		}
		private TValue Search(TPriority priority, int i, Predicate<TValue> match)
		{
			Debug.Assert(i >= 1 || i <= _size, "Index out of range: i = " + i + ", size = " + _size);
			TValue value = null;
			var isHigher = IsHigher(_heap[i], priority);
			if (isHigher)
			{
				if (match(_heap[i].Value))
				{
					value = _heap[i].Value;
				}
				int left = 2 * i;
				int right = left + 1;
				if (value == null && left <= _size)
				{
					value = Search(priority, left, match);
				}
				if (value == null && right <= _size)
				{
					value = Search(priority, right, match);
				}
			}
			return value;
		}
		private void Heapify(int i)
		{
			Debug.Assert(i >= 1 || i <= _size, "Index out of range: i = " + i + ", size = " + _size);
			int left = 2 * i;
			int right = left + 1;
			int highest = i;
			if (left <= _size && IsHigher(_heap[left], _heap[i]))
			{
				highest = left;
			}
			if (right <= _size && IsHigher(_heap[right], _heap[highest]))
			{
				highest = right;
			}
			if (highest != i)
			{
				Swap(i, highest);
				Heapify(highest);
			}
		}
		private void Swap(int i, int j)
		{
			Debug.Assert(i >= 1 || j >= 1 || i <= _size || j <= _size, "Index out of range: i = " + i + ", j = " + j + ", size = " + _size);
			HeapNode<TKey, TValue, TPriority> temp = _heap[i];
			_heap[i] = _heap[j];
			_heap[j] = temp;
		}
		private bool IsHigher
						(
							HeapNode<TKey, TValue, TPriority> compare
							, TPriority compareWithPriority
						)
		{
			var r = false;
			if (_onPriorityComparerProcessFunction != null)
			{
				var compareWithHeapNode
						= new HeapNode<TKey, TValue, TPriority>
							(default(TKey), default(TValue), compareWithPriority);
				r = _onPriorityComparerProcessFunction(compare, compareWithHeapNode);
			}
			else
			{
				r = _priorityComparer.Compare(compare.Priority, compareWithPriority) < 1;
			}
			return r;
		}
		private bool IsHigher
						(
							HeapNode<TKey, TValue, TPriority> compare
							, HeapNode<TKey, TValue, TPriority> compareWith
						)
		{
			var r = false;
			if (_onPriorityComparerProcessFunction != null)
			{
				r = _onPriorityComparerProcessFunction(compare, compareWith);
			}
			else
			{
				r = _priorityComparer.Compare(compare.Priority, compareWith.Priority) < 1;
			}
			return r;
		}
		[Serializable]
		public struct HeapNode<KeyT, ValueT, PriorityT>
		{
			public KeyT Key;
			public ValueT Value;
			public PriorityT Priority;
			public HeapNode(KeyT key, ValueT value, PriorityT priority)
			{
				Key = key;
				Value = value;
				Priority = priority;
			}
		}
	}
}

#T=Program.cs WinForm Console 开关
namespace WindowsFormsApplication1
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Security.Principal;
	using System.Threading;

	using Microshaoft.Win32;

	static class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			bool needFreeConsole = false;
			if (args != null)
			{
				if (args.Length > 0)
				{
					if (args[0].ToLower() == "/c")
					{
						needFreeConsole = true;
						NativeMethods.AllocConsole();
						Console.WriteLine("Alloc Console ...");

						Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
						Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());

					}
				}
			}

			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);

			Form1 x = new Form1();
			Thread thread = new Thread(new ThreadStart(x.ConsoleThreadProcess));
			thread.Start(); //监视线程: 显示滚动计数器
			Application.Run(x);

			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
	}
}


namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}

namespace WindowsFormsApplication1
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Data;


	/// <summary>
	/// Form1 的摘要说明。
	/// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button button1;
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form1()
		{
			//
			// Windows 窗体设计器支持所必需的
			//
			InitializeComponent();

			//
			// TODO: 在 InitializeComponent 调用后添加任何构造函数代码
			//
		}

		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要使用代码编辑器修改
		/// 此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(96, 112);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(88, 32);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// Form1
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
			this.ClientSize = new System.Drawing.Size(292, 273);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new System.EventHandler(this.Form1_Load);
			this.ResumeLayout(false);

		}
		#endregion

		private void Form1_Load(object sender, System.EventArgs e)
		{
		
		}
		
		private void button1_Click(object sender, System.EventArgs e)
		{
			Console.WriteLine("test");

		}
		public void ConsoleThreadProcess()
		{
			string s;
			while ((s = Console.ReadLine()) != "q")
			{
				button1.Text = s;
			}
			
		}
	}
}

#T=Proxy HttpHandler
<%@ WebHandler Language="C#" Debug="True" Class="Microshaoft.HttpProxyHandler" %>
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Linq;
	using System.Net;
	using System.Web;
	public class HttpProxyHandler : IHttpHandler
	{
		public void ProcessRequest(HttpContext context)
		{
			HttpWebRequest httpWebRequest = null;
			WebResponse webResponse = null;
			try
			{
				var request = context.Request;
				string url = request["fw"];
				byte[] buffer = ReadStreamToBytes(request.InputStream);
				httpWebRequest = (HttpWebRequest) WebRequest.Create(url);
				httpWebRequest.Method = request.HttpMethod;
				httpWebRequest.ContentType = request.ContentType;
				httpWebRequest.UserAgent = request.UserAgent;
				httpWebRequest.KeepAlive = false;
				ServicePointManager.Expect100Continue = false;
				//httpWebRequest.SendChunked = true;
				//httpWebRequest.TransferEncoding = request.ContentEncoding.EncodingName;
				if
					(
						request.Headers.AllKeys.Any
												(
													(x) =>
													{
														return (x.ToLower() == "soapaction");
													}
												)
					)
				{
					httpWebRequest.Headers.Add("SOAPAction", request.Headers["SOAPAction"]);
				}
				httpWebRequest.Headers.Add("X-Forwarded-For", request.UserHostAddress);
				httpWebRequest.Timeout = 10 * 1000;
				if (buffer.Length > 0)
				{
					using (Stream stream = httpWebRequest.GetRequestStream())
					{
						stream.Write(buffer, 0, buffer.Length);
						stream.Close();
					}
				}
				webResponse = httpWebRequest.GetResponse();
				using (Stream stream = webResponse.GetResponseStream())
				{
					buffer = ReadStreamToBytes(stream);
					stream.Close();
				}
				var response = context.Response;
				response.BinaryWrite(buffer);
			}
			catch (Exception e)
			{
				throw new Exception("OrignalInnerException", e);
			}
			finally
			{
				if (webResponse != null)
				{
					webResponse.Close();
					webResponse = null;
				}
				if (httpWebRequest != null)
				{
					httpWebRequest.Abort();
					httpWebRequest = null;
				}
			}
		}
		private byte[] ReadStreamToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
		public bool IsReusable
		{
			get
			{
				return false;
			}
		}
	}
}
/*
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title> new document </title>
	<META NAME="Generator" CONTENT="EditPlus,Microshaoft">
	<META NAME="Author" CONTENT="EditPlus,Microshaoft">
	<META NAME="Keywords" CONTENT="EditPlus,Microshaoft">
	<META NAME="Description" CONTENT="EditPlus,Microshaoft">
</head>
<body>
<form method="post" action="http://local.asp.net/proxy.ashx" target="_blank">
	<input type="text" name="a" />
	<input type="text" name="fw" value="http://interface.morsing.local/test.aspx" />
	<input type="submit" />
</form>
</body>
</html>
*/
#T=RasDialADSL
namespace Microshaoft
{
	using System;
	using RAS;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());

			Console.WriteLine("Pls Input EntryName (网络连接名称):");
			string EntryName = Console.ReadLine();

			Console.WriteLine("Pls Input UserName (用户名):");
			string UserName = Console.ReadLine();
			
			Console.WriteLine("Pls Input Password (密码):");
			string Password = ConsoleReadMaskLine('*',true);

			RasManager rm = new RasManager();
			rm.EntryName = EntryName; // entry name in phonebook
			rm.UserName = UserName;
			rm.Password = Password;

			int r = -1;
			r = rm.Connect();

			string s = "失败";
			if (r == 0)
			{
				s = "成功";
			}
			Console.WriteLine("\n网络连接: \"{0}\" 拨号上网{1},Result: {2}", EntryName, s, r);
			Console.ReadLine();

		}

		public static string ConsoleReadMaskLine
			(
				char PasswordChar
				, bool WithMask
			)
		{
			string password = "";
			ConsoleKey ck;
			string s = @"~!@#$%&*()_+`1234567890-="; //可输入字符
			s += @"QWERTYUIOP{}|qwertyuiop[]\";
			s += "ASDFGHJKL:\"asdfghjkl;'";
			s += "ZXCVBNM<>?zxcvbnm,./ ";

			do
			{
				ConsoleKeyInfo cki = Console.ReadKey(true);
				char c = cki.KeyChar;
				ck = cki.Key;
				int p = Console.CursorLeft;
				if (ck == ConsoleKey.Backspace)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p - 1);
					}
					string right = password.Substring(p);
					password  = left + right;
					Console.Write(c);

					string output = right;
					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}

					output += "\0";
					Console.Write(output);
					if (p > 0)
					{
						p --;
					}
				}
				else if (ck == ConsoleKey.Delete)
				{
					string left = "";
					if (p > 0)
					{
						left = password.Substring(0, p);
					}
					string right = "";
					if (p < password.Length)
					{
						right = password.Substring(p + 1);
					}
					password = left + right;
					//Console.Write(right + " ");

					string output = right;

					if (WithMask)
					{
						output = GetPasswordChars(right, PasswordChar);
					}
					output += "\0";

					Console.Write(output);
				}
				else
				{
					if (s.IndexOf(c) >= 0)
					{
						string left = password.Substring(0, p);
						string right = password.Substring(p);
						password = left + c + right;

						string output = c + right;

						if (WithMask)
						{
							output = GetPasswordChars(c + right, PasswordChar);
						}
						Console.Write(output);

						p ++;
					}
					else
					{
						switch (ck)
						{
							case ConsoleKey.LeftArrow :
								if (p > 0)
								{
									p --;
								}
								break;
							case ConsoleKey.RightArrow :
								if (p < password.Length)
								{
									p ++;
								}
								break;
							case ConsoleKey.Home :
								p = 0;
								break;
							case ConsoleKey.End :
								p = password.Length;
								break;
							default :
								Console.Beep();
								break;
						}
					}
				}
				Console.CursorLeft = p;
			} while (ck != ConsoleKey.Enter);
			return password;
		}
		private static string GetPasswordChars(string s, char c)
		{
			string passwordChars = "";
			for (int i = 0; i < s.Length; i++)
			{
				passwordChars += c;
			}
			return passwordChars;
		}
	}
}

namespace RAS
{
	using System;
	using System.Runtime.InteropServices;
	public class RasManager
	{
		public const int RAS_MaxEntryName = 256;
		public const int RAS_MaxPhoneNumber = 128;
		public const int UNLEN = 256;
		public const int PWLEN = 256;
		public const int DNLEN = 15;
		public const int MAX_PATH = 260;
		public const int RAS_MaxDeviceType = 16;
		public const int RAS_MaxCallbackNumber = RAS_MaxPhoneNumber;

		public delegate void Callback(uint unMsg, int rasconnstate, int dwError);

		[StructLayout(LayoutKind.Sequential, Pack = 4,CharSet = CharSet.Auto)]
		public struct RASDIALPARAMS
		{
			public int dwSize;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = RAS_MaxEntryName + 1)]
			public string szEntryName;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst= RAS_MaxPhoneNumber + 1)]
			public string szPhoneNumber;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst= RAS_MaxCallbackNumber + 1)]
			public string szCallbackNumber;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst= UNLEN + 1)]
			public string szUserName;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst= PWLEN + 1)]
			public string szPassword;
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst= DNLEN + 1)]
			public string szDomain;
			public int dwSubEntry;
			public int dwCallbackId;
		}


		[DllImport("rasapi32.dll", CharSet=CharSet.Auto)]
		public static extern int RasDial
									(
										int lpRasDialExtensions
										, string lpszPhonebook
										, ref RASDIALPARAMS lprasdialparams
										, int dwNotifierType
										, Callback lpvNotifier
										, ref int lphRasConn
									);


		private RASDIALPARAMS RasDialParams;
		private int Connection;

		public RasManager()
		{
			Connection = 0;
			RasDialParams = new RASDIALPARAMS();
			RasDialParams.dwSize = Marshal.SizeOf(RasDialParams);
		}


		#region Properties
		public string UserName
		{
			get
			{
				return RasDialParams.szUserName;
			}
			set
			{
				RasDialParams.szUserName = value;
			}
		}

		public string Password
		{
			get
			{
				return RasDialParams.szPassword;
			}
			set
			{
				RasDialParams.szPassword = value;
			}
		}


		public string EntryName
		{
			get
			{
				return RasDialParams.szEntryName;
			}
			set
			{
				RasDialParams.szEntryName = value;
			}
		}
		#endregion


		public int Connect()
		{
			Callback rasDialFunc = new Callback(RasManager.RasDialFunc);
			RasDialParams.szEntryName += "\0";
			RasDialParams.szUserName += "\0";
			RasDialParams.szPassword += "\0";
			int result = RasDial (0, null, ref RasDialParams, 0, rasDialFunc, ref Connection);
			return result;
		}

		public static void RasDialFunc
								(
									uint unMsg
									, int rasconnstate
									, int dwError
								)
		{
			Console.WriteLine
						(
							"CallBack: unMsg={0},rasconnstate={1},dwError={2}"
							, unMsg
							, rasconnstate
							, dwError
						);
		}
	}
}

#T=ReaderWriterLockSlim
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class SynchronizedCache
	{
		private ReaderWriterLockSlim cacheLock = new ReaderWriterLockSlim();
		private Dictionary<int, string> innerCache = new Dictionary<int, string>();
		public string Read(int key)
		{
			cacheLock.EnterReadLock();
			try
			{
				return innerCache[key];
			}
			finally
			{
				cacheLock.ExitReadLock();
			}
		}
		public void Add(int key, string value)
		{
			cacheLock.EnterWriteLock();
			try
			{
				innerCache.Add(key, value);
			}
			finally
			{
				cacheLock.ExitWriteLock();
			}
		}
		public bool AddWithTimeout(int key, string value, int timeout)
		{
			if (cacheLock.TryEnterWriteLock(timeout))
			{
				try
				{
					innerCache.Add(key, value);
				}
				finally
				{
					cacheLock.ExitWriteLock();
				}
				return true;
			}
			else
			{
				return false;
			}
		}
		public AddOrUpdateStatus AddOrUpdate(int key, string value)
		{
			cacheLock.EnterUpgradeableReadLock();
			try
			{
				string result = null;
				if (innerCache.TryGetValue(key, out result))
				{
					if (result == value)
					{
						return AddOrUpdateStatus.Unchanged;
					}
					else
					{
						cacheLock.EnterWriteLock();
						try
						{
							innerCache[key] = value;
						}
						finally
						{
							cacheLock.ExitWriteLock();
						}
						return AddOrUpdateStatus.Updated;
					}
				}
				else
				{
					cacheLock.EnterWriteLock();
					try
					{
						innerCache.Add(key, value);
					}
					finally
					{
						cacheLock.ExitWriteLock();
					}
					return AddOrUpdateStatus.Added;
				}
			}
			finally
			{
				cacheLock.ExitUpgradeableReadLock();
			}
		}
		public void Delete(int key)
		{
			cacheLock.EnterWriteLock();
			try
			{
				innerCache.Remove(key);
			}
			finally
			{
				cacheLock.ExitWriteLock();
			}
		}
		public enum AddOrUpdateStatus
		{
			Added,
			Updated,
			Unchanged
		};
	}
}

#T=ReaderWriterLockSlim Easy 按需写读互斥
namespace Microshaoft
{
	using System;
	using System.Threading;
	public class EasyReaderWriterLockSlim
						: ReaderWriterLockSlim
	{
		public EasyReaderWriterLockSlim()
			: base()
		{
		}
		public EasyReaderWriterLockSlim(LockRecursionPolicy recursionPolicy)
			: base(recursionPolicy)
		{
		}
		private int _isWriteLocked = 0;
		public bool IsWriteLocked
		{
			get
			{
				return (_isWriteLocked != 0);
			}
		}
		public void SafeRead
						(
							//int enterReadLockTimeOutInSeconds
							//, 
							Action<EasyReaderWriterLockSlim> onReadProcessAction
						)
		{
			var r = false;
			try
			{
				if (_isWriteLocked == 1)
				{
					//r = TryEnterReadLock(enterReadLockTimeOutInSeconds);
					EnterReadLock();
					r = true;
				}
				onReadProcessAction(this);
			}
			finally
			{
				if (r)
				{
					//if (IsReadLockHeld)
					{
						ExitReadLock();
					}
				}
			}
		}
		public void SafeWrite
								(
									//int enterWriteLockTimeOutInSeconds
									//,
									Action<EasyReaderWriterLockSlim> onWriteProcessAction
								)
		{
			var r = false;
			try
			{
				//r = TryEnterWriteLock(enterWriteLockTimeOutInSeconds);
				EnterWriteLock();
				r = true;
				if (r)
				{
					Interlocked.Exchange(ref _isWriteLocked, 1);
				}
				//if (r)
				{
					onWriteProcessAction(this);
				}
			}
			finally
			{
				if (r)
				{
					//if
					//	(
					//		IsWriteLockHeld
					//		&&
					//		_isWriteLocked == 1
					//	)
					{
						ExitWriteLock();
						Interlocked.Exchange(ref _isWriteLocked, 0);
					}
				}
			}
		}
	}
}
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Diagnostics;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			string input = string.Empty;
			var withLock = true;
			while ((input = Console.ReadLine()) != "q")
			{
				//ParallelProcess2(true);
				ParallelProcess2(withLock);
				withLock = !withLock;
				//ParallelProcess();
			}
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
		private static EasyReaderWriterLockSlim _easyReaderWriterLockSlim
					= new EasyReaderWriterLockSlim();


		private static void ParallelProcess2(bool withLock = true)
		{
			var stopWatch = Stopwatch.StartNew();
			ReaderWriterLockSlim readerWriterLockSlim = new ReaderWriterLockSlim();
			Parallel.For
				(
					0
					, 1024 * 1000
					, new ParallelOptions()
					{
						MaxDegreeOfParallelism = 32
					}
					, (x) =>
					{
						if (withLock)
						{
							readerWriterLockSlim.EnterReadLock();
							readerWriterLockSlim.ExitReadLock();
						}
						
					}
				);
			stopWatch.Stop();
			Console.WriteLine(stopWatch.ElapsedTicks);
		}
		//private /*volatile*/ static int _isWriteLocked = 0;
		private static void ParallelProcess()
		{
			var stopWatch = Stopwatch.StartNew();
			Parallel.For
				(
					0
					, 1024 * 10
					, new ParallelOptions()
					{
						MaxDegreeOfParallelism = 32
					}
					, (x) =>
					{
						DateTime? now = null;
						//var r = false;
						if (x == 10)
						{
							_easyReaderWriterLockSlim
								.SafeWrite
									(
										//10 * 1000
										//, 
										(xx) =>
										{
											Console.WriteLine
														(
															"EnterWriteLock Current Thread [{0}], X [{1}], IsWriteLocked [{2}]"
															, Thread.CurrentThread.ManagedThreadId
															, x
															, xx.IsWriteLocked
														);
											Console.WriteLine("EnterWriteLock {0}", x);
											Console.WriteLine("Write {0}", x);
											Thread.Sleep(5 * 1000);
											now = DateTime.Now;
										}
									);
							return;
						}
						else
						{
							_easyReaderWriterLockSlim
								.SafeRead
									(
										//10 * 1000
										//,
										(xx) =>
										{
											if
												(
													xx.IsReadLockHeld
													||
													xx.IsWriteLocked
												)
											{
												Console.WriteLine
													(
														"read: {0}, IsWriteLocked {1}, IsWriteLockHeld {2}, IsReadLockHeld {3}"
														, x
														, xx.IsWriteLocked
														, xx.IsWriteLockHeld
														, xx.IsReadLockHeld
													//, DateTime.Now
													);
											}
										}
									);
						}
					}
				);
			stopWatch.Stop();
			Console.WriteLine(stopWatch.ElapsedMilliseconds);
		}
	}
}

#T=ReaderWriterLockSlim 按需写读互斥
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Diagnostics;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			string input = string.Empty;
			while ((input = Console.ReadLine()) != "q")
			{
				ParallelProcess();
			}
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
		private static ReaderWriterLockSlim _readerWriterLockSlim
					= new ReaderWriterLockSlim
								(
									//LockRecursionPolicy.NoRecursion
								);
		private /*volatile*/ static int _isWriteLocked = 0;
		private static void ParallelProcess()
		{
			var stopWatch = Stopwatch.StartNew();
			Parallel.For
				(
					0
					, 128
					, new ParallelOptions()
					{
						MaxDegreeOfParallelism = 32
					}
					, (x) =>
					{
						DateTime? now;
						var r = false;
						if (x == 10)
						{
							try
							{
								r = _readerWriterLockSlim
										.TryEnterWriteLock(1000);
								if (r)
								{
									Interlocked.Exchange(ref _isWriteLocked, 1);
									Console.WriteLine
												(
													"EnterWriteLock Current Thread [{0}], X [{1}], IsWriteLockHeld [{2}]"
													, Thread.CurrentThread.ManagedThreadId
													, x
													, _readerWriterLockSlim.IsWriteLockHeld
												);
									Console.WriteLine("EnterWriteLock {0}", x);
									Console.WriteLine("Write {0}", x);
									Thread.Sleep(5 * 1000);		
								}
							}
							finally
							{
								if (r)
								{
									if 
										(
											_readerWriterLockSlim.IsWriteLockHeld
											&&
											_isWriteLocked == 1
										)
									{
										_readerWriterLockSlim.ExitWriteLock();
										Interlocked.Exchange(ref _isWriteLocked, 0);
										Console.WriteLine
												(
													"ExitWriteLock Current Thread [{0}], X [{1}], IsWriteLockHeld [{2}]"
													, Thread.CurrentThread.ManagedThreadId
													, x
													, _readerWriterLockSlim.IsWriteLockHeld
												);
									}
								}
							}
							return;
						}
						try
						{
							r = true;
							if (_isWriteLocked == 1)
							{
								r = _readerWriterLockSlim
										.TryEnterReadLock(1000);
								if (r)
								{
									Console.WriteLine("EnterReadLock {0}", x);
								}
							}
							//if (r)
							{
								Console.WriteLine
											(
												"Read {0}, IsReadLockHeld {1}"
												, x
												, _readerWriterLockSlim.IsReadLockHeld
											);
								//Console.WriteLine("IsWriteLockHeld {0}, {1}", x, _readerWriterLockSlim.IsWriteLockHeld);
								now = DateTime.Now;
							}
						}
						finally
						{
							if (r)
							{
								if (_readerWriterLockSlim.IsReadLockHeld)
								{
									_readerWriterLockSlim.ExitReadLock();
									Console.WriteLine("ExitReadLock {0}", x);
								}
							}
						}
						//now = DateTime.Now;
					}
				);
			stopWatch.Stop();
			Console.WriteLine(stopWatch.ElapsedMilliseconds);
		}
	}
}

#T=ReaderWriterLockSlimHelper
namespace Microshaoft.Web.ShareCache
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Diagnostics;
	using Microshaoft;
	public static class DataManager
	{
		//[STAThread]
		static void Main(string[] args)
		{
			//var enableCounters =
			//					 MultiPerformanceCountersTypeFlags.ProcessCounter
			//					 | MultiPerformanceCountersTypeFlags.ProcessingCounter
			//					 | MultiPerformanceCountersTypeFlags.ProcessedCounter
			//					 | MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
			//					 | MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter;
			// var perfCN = "Microshaoft-RWLS-Test";
			// var perfCNI = "Microshaoft-RWLS-Test";
			//EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
			//			.AttachPerformanceCountersCategoryInstance
			//				(
			//					perfCN
			//					, perfCNI
			//				);
			Console.ReadLine();
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			//new Thread
			//		(
			//			new ThreadStart
			//					(
			//						() =>
			//						{
			//							ParallelProcess(enableCounters, perfCN, perfCNI);
			//						}
			//					)
			//		).Start();
			string r = string.Empty;
			while ((r = Console.ReadLine()) != "q")
			{
				if (r == "w")
				{
					Tuple<string, DateTime, bool>[] a =
								new Tuple<string, DateTime, bool>[]
										{
											new Tuple<string, DateTime, bool>("aspx cs AAA", DateTime.Now, true)
											, new Tuple<string, DateTime, bool>("aspx cs BBB", DateTime.Now, false)
											, new Tuple<string, DateTime, bool>("aspx cs CCC", DateTime.Now, true)
										};
					var list = a.ToList();
					DataManager.ShareData = list;
					ShareData
						.ForEach
							(
								(x) =>
								{
									Console.WriteLine(x.Item2);
								}
							);
				}
				else
				{
					ParallelProcess();
				}
			}
			Console.WriteLine(DataManager.F2);
			Console.WriteLine(Environment.Version.ToString());
		}
		private static void ParallelProcess()
		{
			var stopWatch = Stopwatch.StartNew();
			Parallel.For
				(
					0
					, 10000 * 50
					, new ParallelOptions()
					{
						MaxDegreeOfParallelism = 32
					}
					, (x) =>
					{
						var z =
							DataManager.ShareData;
							z.ForEach
								(
									(xx) =>
									{
										//Console.WriteLine(x.Item2);
									}
								);
					}
				);
			stopWatch.Stop();
			Console.WriteLine(stopWatch.ElapsedMilliseconds);
		}
		static DataManager()
		{
			Tuple<string, DateTime, bool>[] a = new Tuple<string, DateTime, bool>[]
												{
													new Tuple<string, DateTime, bool>("A", DateTime.Now, true)
													, new Tuple<string, DateTime, bool>("B", DateTime.Now, false)
													, new Tuple<string, DateTime, bool>("C", DateTime.Now, true)
												};
			ShareData = a.ToList();
		}
		private static List<Tuple<string, DateTime, bool>> _shareData;
		private static ReaderWriterLockSlim _readerWriterLockSlim = new ReaderWriterLockSlim();
		public static List<Tuple<string, DateTime, bool>> ShareData
		{
			set
			{
				_readerWriterLockSlim
					.TryEnterWriterLockSlimWrite<List<Tuple<string, DateTime, bool>>>(ref _shareData, value, 2);
			}
			get
			{
				return
					_readerWriterLockSlim
						.TryEnterReadLockSlimRead<List<Tuple<string, DateTime, bool>>>
							(
								(x) =>
									{
										return _shareData;
									}
								, 10
							);
					//_shareData;
			}
		}
		public volatile static int F1 = 99, F2 = 100;
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	public static class ReaderWriterLockSlimExtensionsMethodsManager
	{
		public static bool TryEnterWriterLockSlimWrite<T>
								(
									this ReaderWriterLockSlim writerLockSlim
									, ref T target
									, T newTarget
									, int enterTimeOutInSeconds
								)
									where T : class
		{
			return
				ReaderWriterLockSlimHelper
					.TryEnterWriterLockSlimWrite<T>
						(
							writerLockSlim
							, ref target
							, newTarget
							, enterTimeOutInSeconds
						);
		}
		public static T TryEnterReadLockSlimRead<T>
						(
							this ReaderWriterLockSlim readerLockSlim
							, Func<ReaderWriterLockSlim, T> onReadedProcessFunc
							, int enterTimeOutInSeconds
						)
		{
			return
				ReaderWriterLockSlimHelper
					.TryEnterReadLockSlimRead<T>
						(
							readerLockSlim
							, onReadedProcessFunc
							, enterTimeOutInSeconds
						);
		}
		public static bool TryEnterLockSlim
								(
									this ReaderWriterLockSlim lockSlim
									, Func<ReaderWriterLockSlim, bool> onEnterProcessFunc
									, Action action
									, Action<ReaderWriterLockSlim> onExitProcessAction
								)
		{
			return
				ReaderWriterLockSlimHelper
					.TryEnterLockSlim
						(
							lockSlim
							, onEnterProcessFunc
							, action
							, onExitProcessAction
						);
		}
	}
	public static class ReaderWriterLockSlimHelper
	{
		public static bool TryEnterWriterLockSlimWrite<T>
												(
													ReaderWriterLockSlim writerLockSlim
													, ref T target
													, T newTarget
													, int enterTimeOutInSeconds
												)
													where T : class
		{
			bool r = false;
			//var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutInSeconds >= 0)
			{
				timeOut = enterTimeOutInSeconds * 1000;
			}
			try
			{
				r = (writerLockSlim.TryEnterWriteLock(timeOut));
				if (r)
				{
					Interlocked.Exchange<T>(ref target, newTarget);
					r = true;
				}
			}
			finally
			{
				if (r)
				{
					writerLockSlim.ExitWriteLock();
				}
			}
			return r;
		}
		public static T TryEnterReadLockSlimRead<T>
								(
									ReaderWriterLockSlim readerLockSlim
									, Func<ReaderWriterLockSlim, T> onReadedProcessFunc
									, int enterTimeOutInSeconds
								)
		{
			T r = default(T);
			var rr = false;
			//var rwls = new ReaderWriterLockSlim();
			int timeOut = Timeout.Infinite;
			if (enterTimeOutInSeconds >= 0)
			{
				timeOut = enterTimeOutInSeconds * 1000;
			}
			try
			{
				rr = (readerLockSlim.TryEnterReadLock(timeOut));
				if (rr)
				{
					r = onReadedProcessFunc(readerLockSlim);
					rr = true;
				}
			}
			finally
			{
				if (rr)
				{
					readerLockSlim.ExitReadLock();
				}
			}
			return r;
		}
		public static bool TryEnterLockSlim
								(
									ReaderWriterLockSlim lockSlim
									, Func<ReaderWriterLockSlim, bool> onEnterProcessFunc
									, Action action
									, Action<ReaderWriterLockSlim> onExitProcessAction
								)
		{
			bool r = false;
			if (action != null)
			{
				try
				{
					r = onEnterProcessFunc(lockSlim);
					if (r)
					{
						action();
						r = true;
					}
				}
				finally
				{
					if (r)
					{
						onExitProcessAction(lockSlim);
					}
				}
			}
			return r;
		}
	}
}

#T=ReadSocketStreamDataToFixedLengthBytes
		internal static void ReadSocketStreamDataToBytes
								(
									Socket socket
									, ref byte[] buffer
								)
		{
			int p = 0;
			int l = buffer.Length;
			while (p < l)
			{
				int r = socket.Receive
									(
										buffer
										, p
										, l - p
										, SocketFlags.None
									);
				p += r;
			}
		}

		internal static byte[] ReadSocketStreamDataToBytes(int length, Socket socket)
		{
			int i;
			byte[] bytes = new byte[length];
			for (int r = socket.Receive(bytes); r < length; r += i)
			{
				byte[] buffer = new byte[length - r];
				i = socket.Receive(buffer);
				Buffer.BlockCopy(buffer, 0, bytes, r, i);
			}
			return bytes;
		}
	}
#T=ReadStreamToBytes
		private static byte[] ReadStreamToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;

			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}

			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		
		}
#T=Redis
namespace RedisStudy
{
	using ServiceStack.Redis;
	using ServiceStack.Redis.Generic;
	using System;
	using System.Threading;
	public class User
	{
		public string Name { get; set; }
	}
	class Program
	{
		static void Main(string[] args)
		{
			var messagesReceived = 0;
			var maxMessage = 5;
			var channelName = "幸福框架";
			using (var redisConsumer = new RedisClient())
			{
				using (var subscription = redisConsumer.CreateSubscription())
				{
					subscription.OnSubscribe = channel =>
					{
						Console.WriteLine(String.Format("订阅频道：'{0}'", channel));
					};
					subscription.OnUnSubscribe = channel =>
					{
						Console.WriteLine(String.Format("取消订阅频道：'{0}'", channel));
					};
					subscription.OnMessage = (channel, msg) =>
					{
						Console.WriteLine(String.Format("从频道：'{0}'获取了消息：'{1}'", channel, msg));
						if (++messagesReceived == maxMessage)
						{
							subscription.UnSubscribeFromAllChannels();
						}
					};
					ThreadPool.QueueUserWorkItem(x =>
					{
						Thread.Sleep(200);
						Console.WriteLine("开始发布消息");
						using (var redisPublisher = new RedisClient())
						{
							for (var i = 1; i <= 5; i++)
							{
								var message = "段光伟：" + DateTime.Now;
								Console.WriteLine(String.Format("发布消息：'{0}'到频道：'{1}'", message, channelName));
								redisPublisher.PublishMessage(channelName, message);
							}
						}
					});
					Console.WriteLine(String.Format("开始监听频道：'{0}'", channelName));
					subscription.SubscribeToChannels(channelName); //blocking
					Console.ReadLine();
				}
			}
		}
		private static void Write()
		{
			using (var redisClient = new RedisClient())
			{
				IRedisTypedClient<User> redis = redisClient.As<User>();
				var users = redis.Lists["urn:users"];
				users.Add(new User { Name = "段光伟" });
				users.Add(new User { Name = "段光宇" });
				redis.Save();
			}
		}
		private static void Read()
		{
			using (var redisClient = new RedisClient())
			{
				IRedisTypedClient<User> redis = redisClient.As<User>();
				var users = redis.Lists["urn:users"];
				Console.WriteLine(users.Count);
				redis.Save();
			}
		}
		private static void Remove()
		{
			using (var redisClient = new RedisClient())
			{
				IRedisTypedClient<User> redis = redisClient.As<User>();
				var users = redis.Lists["urn:users"];
				redis.RemoveEntry(users);
			}
		}
	}
}

#T=Reflection
namespace ConsoleApplication
{
	using System;
	using System.Reflection;
	public class Class1
	{
		public static void Main()
		{

			Class1 x = new Class1();

			Type t = x.GetType();//typeof(Class1);
			MemberInfo[] mia = t.GetMembers(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
			foreach (MemberInfo var in mia)
			{
				Console.WriteLine("成员{0}", var.Name);
			}

			FieldInfo[] fia = t.GetFields(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
			foreach (FieldInfo var in fia)
			{
				if (var.IsPrivate)
				{
					Console.WriteLine("字段成员{0}: {1}", var.Name, var.GetValue(x));
				}
			}

			MethodInfo[] methods = t.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
			foreach (MethodInfo var in methods)
			{
				if (var.IsPrivate)
				{
					Console.WriteLine("方法成员{0}: {1}", var.Name, var.Invoke(x,new object[0]));
				}
			}

		}
		private string _privateMember = "asdasdas";
		private static string _privateStaticMember = "asdasdas";
		private void _foo()
		{
			Console.WriteLine("Invoke Private Instance Method");
		}
		private static void _Foo()
		{
			Console.WriteLine("Invoke Private static Method");
		}
	}
}
#T=Reflection FindType 查找类型类浏览器应用程序示例
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

/*=====================================================================
  File:	  FindType.cs
  Summary:   Command Line utility to help find and display information
			 on .NET types.
  Classes:   FindType
		  Indented Writer
  Origin:	.NET Samples Team
=====================================================================*/
using System;
using System.Reflection;
using System.IO;
using System.Collections;
using System.Text;
using System.Runtime.InteropServices;
using System.Security;
using Microsoft.Win32;
using System.Globalization;
namespace Microsoft.Samples
{
	public sealed class App
	{
		private App() { }
		public static void Main(string[] args)
		{
			FindType ft = new FindType();
			SetOptions(args, ft);
			ft.Search();
		}
		// Prints out usage information to the user
		private static void PrintUsage()
		{
			Console.WriteLine();
			Console.WriteLine("FindType [SystemOptions] [MatchOptions] [ShowOptions] [MiscOptions] Name");
			Console.WriteLine("");
			Console.WriteLine("  where SystemOptions");
			Console.WriteLine("   d:[Directory] - Additional directory to search");
			Console.WriteLine("  where MatchOptions");
			Console.WriteLine("	x - Name = Exact Type Name (including namespace)");
			Console.WriteLine("	n - Name = Namespace ");
			Console.WriteLine("	w - Match the name anywhere in the namespace");
			Console.WriteLine("  where ShowOptions");
			Console.WriteLine("	i - Show Interfaces");
			Console.WriteLine("	f - Show Fields");
			Console.WriteLine("	p - Show Properties");
			Console.WriteLine("	e - Show Events");
			Console.WriteLine("	m - Show Methods");
			Console.WriteLine("	a - Show All Info");
			Console.WriteLine("	l - Show Module Information");
			Console.WriteLine("  where MiscOptions");
			Console.WriteLine("	v = Verbose");
			Console.WriteLine("	r = For every type find display base type information");
			Console.WriteLine("	? = Prints Usage information");
			Console.WriteLine();
			Console.WriteLine("Examples");
			Console.WriteLine();
			Console.WriteLine(" FindType String");
			Console.WriteLine("   Finds all types that have 'String' as part of their type name\n");
			Console.WriteLine(" FindType -r String");
			Console.WriteLine("   Finds all types that have 'String' as part of their name");
			Console.WriteLine("   and prints out all base classes\n");
			Console.WriteLine(" FindType -n System.Reflection");
			Console.WriteLine("   Displays all types in the 'System.Reflection' namespace\n");
			Console.WriteLine(" FindType -xipm System.String");
			Console.WriteLine("   Displays the interfaces, properties and methods on the 'System.String' type\n");
			Console.WriteLine(" FindType -d:C:\\ -d:\"C:\\Program Files\\Microsoft.NET\\FrameworkSDK\\Lib\" String");
			Console.WriteLine("   Searches DLLs C:\\ and C:\\Program Files\\Microsoft.NET\\FrameworkSDK\\Lib");
			Console.WriteLine("   as well as in the current directory \n");
			Console.WriteLine();
		}
		// Processes all of the options specified in the arguments   
		private static void SetOptions(string[] args, FindType ft)
		{
			if (args.Length == 0)
			{
				PrintUsage();
				return;
			}
			ft.VerbosePrint = false;
			char[] backslash = new char[1];
			backslash[0] = '\\';
			for (int i = 0; i < args.Length; i++)
			{
				string curArg = args[i];
				if (curArg[0] == '-' || curArg[0] == '/')
				{
					if (Char.ToUpper(curArg[1], CultureInfo.InvariantCulture) == 'D')
					{
						if (curArg.Length > 2 && curArg[2] == ':')
						{
							String dir = curArg.Substring(3).TrimEnd(backslash).ToUpper(CultureInfo.InvariantCulture);
							if (dir.Length > 0)
								ft.DirAdd(dir);
							else
								Console.WriteLine("Directory not specified");
						}
						else
							Console.WriteLine("Directory not specified");
					}
					else
					{
						for (int j = 1; j < curArg.Length; j++)
						{
							switch (Char.ToUpper(curArg[j], CultureInfo.InvariantCulture))
							{
								case 'X':
									ft.ExactMatchOnly = true;
									break;
								case 'R':
									ft.RecurseTypes = true;
									break;
								case 'V':
									ft.VerbosePrint = true;
									break;
								case 'N':
									ft.MatchOnlyNamespace = true;
									break;
								case 'W':
									ft.WideSearch = true;
									break;
								case 'I':
									ft.ShowInterfaces = true;
									break;
								case 'M':
									ft.ShowMethods = true;
									break;
								case 'F':
									ft.ShowFields = true;
									break;
								case 'P':
									ft.ShowProperties = true;
									break;
								case 'E':
									ft.ShowEvents = true;
									break;
								case 'L':
									ft.ShowModuleInfo = true;
									break;
								case 'A':
									ft.ShowAll();
									break;
								case '?':
									PrintUsage();
									break;
								case 'D':
									Console.WriteLine("Directory not specified");
									break;
								default:
									Console.WriteLine("Invalid Option[{0}]", curArg[j]);
									break;
							}
						}
					}
				}
				else
				{
					ft.ClassAdd(curArg);
				}
			}
		}
	}
// Utility class that holds methods that can be used to find and 
// display information about types. Use this utility to:
//		  
// (1) Find a specific type
// (2) Optionally display information about the type including 
//	 interfaces, properties, events and methods
//		  
// This utility dumps information directly contained in the type 
// specified. In order to get a complete dump of a type and all 
// base type information you must use the "recurse" mode of the 
// utility.
	class FindType
	{
		//   Searches based on settings set in the instance
		public void Search()
		{
			if (myClassList.Count != 0)
			{
				for (int i = 0; i < myClassList.Count; i++)
				{
					Search((string)myClassList[i]);
				}
			}
		}
		// Searchs for the passed string in the type names of all
		// .NET Framework assemblies and all DLLs in the specified paths.   
		public void Search(String theSearchString)
		{
			//
			// Search the .NET Framework Directory
			//
			Assembly testAssy = typeof(object).Assembly;
			myVerboseWriter.WriteLine("Searching System Libraries");
			String dirFrameworks = Path.GetDirectoryName(testAssy.Location);
			ArrayList l = new ArrayList();
			BuildDLLFileList(dirFrameworks, l);
			for (int j = 0; j < l.Count; j++)
			{
				Search(theSearchString, (String)l[j]);
			}
			//
			// Search the current directory
			//
			myVerboseWriter.WriteLine("Searching the current directory...");
			l = new ArrayList();
			BuildDLLFileList(".", l);
			for (int j = 0; j < l.Count; j++)
			{
				Search(theSearchString, (String)l[j]);
			}
			//
			// Search the specified directories
			//
			Object[] dir = DirList.ToArray();
			for (int i = 0; i < dir.Length; i++)
			{
				myVerboseWriter.WriteLine("Searching directory  {0}...", dir[i]);
				l = new ArrayList();
				BuildDLLFileList((String)dir[i], l);
				for (int j = 0; j < l.Count; j++)
				{
					Search(theSearchString, (String)l[j]);
				}
			}
		}
		// Loads the specified module and searchs through all 
		// the types defined in it for the type name specified.   
		public void Search(String theSearchString, String theModule)
		{
			try
			{
				//
				// Load the module - expect to fail if it is not a .NET Framework 
				// module.
				//
				Assembly a = Assembly.LoadFrom(theModule);
				Module[] m = a.GetModules();
				// We are case insensitive
				theSearchString = theSearchString.ToUpper(CultureInfo.InvariantCulture);
				for (int j = 0; j < m.Length; j++)
				{
					myVerboseWriter.WriteLine("Searching Module {0}", theModule);
					if (m != null)
					{
						//
						// Get all the types from the module
						//
						Type[] types = m[j].GetTypes();
						for (int i = 0; i < types.Length; i++)
						{
							Type curType = types[i];
							// Case insensitive
							String name = curType.FullName.ToUpper(CultureInfo.InvariantCulture);
							//
							// How has the user indicated they want to search. Note that 
							// even if the user has specified several ways to search we only 
							// respect one of them (from most specific to most general)
							//				  
							if (ExactMatchOnly)
							{
								if (name == theSearchString)
								{
									DumpType(curType);
								}
							}
							else if (MatchOnlyNamespace)
							{
								if (curType.Namespace != null)
								{
									if (curType.Namespace.ToUpper(CultureInfo.InvariantCulture) == theSearchString)
									{
										DumpType(curType);
									}
								}
							}
							else if (WideSearch)
							{
								if (curType.Namespace.ToUpper(CultureInfo.InvariantCulture).IndexOf(theSearchString) != -1)
								{
									DumpType(curType);
								}
							}
							else
							{
								//
								// User has not specified a search criteria - so we have some 
								// defaults:
								//   (1) If the search string supplied matches a complete type
								//	   name then assume they want to get all information about 
								//	   the type. If they have actually set display options then 
								//	   respect them.
								//   (2) If we are going to dump all information save the show 
								//	   properties so they can be reset after this type (in case the 
								//	   user is searching for multiple types).
								//
								if (name == theSearchString)
								{
									int oldOptions = showOptions;
									if (showOptions == 0)
									{
										ShowAll();
									}
									DumpType(curType);
									showOptions = oldOptions;
								}
								else if (name.IndexOf(theSearchString) != -1)
								{
									DumpType(curType);
								}
							}
						}
					}
				}
			}
			catch (ReflectionTypeLoadException rcle)
			{
				Type[] loadedTypes = rcle.Types;
				Exception[] exceptions = rcle.LoaderExceptions;
				int exceptionCount = 0;
				for (int i = 0; i < loadedTypes.Length; i++)
				{
					if (loadedTypes[i] == null)
					{
						// The following line would output the TypeLoadException.
						// myWriter.WriteLine("Unable to load a type because {0}", exceptions[exceptionCount] );
						exceptionCount++;
					}
				}
			}
			catch (FileNotFoundException fnfe)
			{
				myVerboseWriter.WriteLine(fnfe.Message);
			}
			catch { }
		}
		// Do an exact match of passed types - the name passed must 
		// be the same as the fully qualified type name.   
		public bool ExactMatchOnly
		{
			get { return exactMatchOnly; }
			set { exactMatchOnly = value; }
		}
		// Load all base types and display the same information 
		// (methods, properties etc) for the base type.   
		public bool RecurseTypes
		{
			get { return recurseTypes; }
			set { recurseTypes = value; }
		}
		// Match only against the namespace component of a type
		// Use this to display all members of a namespace.   
		public bool MatchOnlyNamespace
		{
			get { return matchOnlyNamespace; }
			set { matchOnlyNamespace = value; }
		}
		// Match anywhere in the name (namespace and type name)
		public bool WideSearch
		{
			get { return wideSearch; }
			set { wideSearch = value; }
		}
		// Print verbose information   
		public bool VerbosePrint
		{
			get { return myVerboseWriter.Print; }
			set { myVerboseWriter.Print = value; }
		}
		// Show any interfaces implemented by this type   
		public bool ShowInterfaces
		{
			get { return (showOptions & SHOW_INTERFACES) != 0; }
			set
			{
				if (value)
					showOptions |= SHOW_INTERFACES;
				else
					showOptions &= ~SHOW_INTERFACES;
			}
		}
		// Show any public fields in the type found   
		public bool ShowFields
		{
			get { return (showOptions & SHOW_FIELDS) != 0; }
			set
			{
				if (value)
					showOptions |= SHOW_FIELDS;
				else
					showOptions &= ~SHOW_FIELDS;
			}
		}
		// Show any public properties in the type found   
		public bool ShowProperties
		{
			get { return (showOptions & SHOW_PROPERTIES) != 0; }
			set
			{
				if (value)
					showOptions |= SHOW_PROPERTIES;
				else
					showOptions &= ~SHOW_PROPERTIES;
			}
		}
		// Show any public events in the type found.   
		public bool ShowEvents
		{
			get { return (showOptions & SHOW_EVENTS) != 0; }
			set
			{
				if (value)
					showOptions |= SHOW_EVENTS;
				else
					showOptions &= ~SHOW_EVENTS;
			}
		}
		// Show any public methods in the type found.   
		public bool ShowMethods
		{
			get { return (showOptions & SHOW_METHODS) != 0; }
			set
			{
				if (value)
					showOptions |= SHOW_METHODS;
				else
					showOptions &= ~SHOW_METHODS;
			}
		}
		// Show the module information for any type found - this is useful when 
		// trying to determine what DLL contains what type.   
		public bool ShowModuleInfo
		{
			get { return (showOptions & SHOW_MODULE_INFO) != 0; }
			set
			{
				if (value)
					showOptions |= SHOW_MODULE_INFO;
				else
					showOptions &= ~SHOW_MODULE_INFO;
			}
		}
		// Sets all display options on.   
		public void ShowAll()
		{
			ShowInterfaces = true;
			ShowMethods = true;
			ShowFields = true;
			ShowProperties = true;
			ShowEvents = true;
			ShowModuleInfo = true;
		}
		// Add a directory to the search set
		public void DirAdd(string dir)
		{
			DirList.Add(dir);
		}
		// Add a class to the search set
		public void ClassAdd(string newClass)
		{
			myClassList.Add(newClass);
		}
		// Given a directory this method appends the fullly qualified path name of 
		// all DLLs in the directory to the list passed in.   
		private void BuildDLLFileList(String directory, ArrayList list)
		{
			try
			{
				if (Directory.Exists(directory))
				{
					String[] e = Directory.GetFiles(directory, "*.dll");
					for (int i = 0; i < e.Length; i++)
					{
						list.Add(e[i]);
					}
				}
				else
				{
					myVerboseWriter.WriteLine("Directory [{0}] does not exist!", directory);
				}
			}
			catch (Exception Ex)
			{
				//
				// Trap Exception: System.InvalidOperationException  This occurs when the file is an unmanaged dll
				//
				if (Ex.GetType() == typeof(System.InvalidOperationException))
				{
				}
			}
			
		}
		// A short description of the type.   
		private String GetTypeDescription(Type aType)
		{
			String str = null;
			if (aType.IsClass)
			{
				str = "class";
			}
			if (aType.IsInterface)
			{
				str = "interface";
			}
			if (aType.IsValueType)
			{
				str = "struct";
			}
			if (aType.IsArray)
			{
				str = "array";
			}
			return str;
		}
		// Dumps information about the specified type.   
		private void DumpType(Type aType)
		{
			Type baseType = aType.BaseType;
			myWriter.WriteLine("{0,-10} {1}", GetTypeDescription(aType), aType);
			if (ShowModuleInfo)
			{
				myWriter.WriteLine("{0,-10} {1}", "Module:", aType.Module.FullyQualifiedName);
			}
			DumpInterfaces(aType);
			DumpFields(aType);
			DumpProperties(aType);
			DumpEvents(aType);
			DumpMethods(aType);
			if (RecurseTypes)
			{
				myWriter.WriteLine();
			}
			//
			// If recursing then pop the indent on the writers so we 
			// can easily see the nesting for the base type information.
			//									   
			if (RecurseTypes && baseType != null)
			{
				myWriter.PushIndent();
				myVerboseWriter.PushIndent();
				DumpType(baseType);
				myWriter.PopIndent();
				myVerboseWriter.PopIndent();
			}
		}
		// Dumps the interfaces implemented by the specified type.   
		private void DumpInterfaces(Type aType)
		{
			if (!ShowInterfaces)
				return;
			Type[] info = aType.GetInterfaces();
			if (info.Length != 0)
			{
				myWriter.WriteLine("{0} {1}", "# Interfaces:", info.Length);
				for (int i = 0; i < info.Length; i++)
				{
					myWriter.PushIndent();
					myWriter.WriteLine("interface {0}", info[i].FullName);
					//
					// Only show method information only if requested
					//
					if (ShowMethods)
					{
						myWriter.PushIndent();
						DumpType(info[i]);
						myWriter.PopIndent();
					}
					myWriter.PopIndent();
				}
			}
		}
		// Dumps the public properties directly contained in the specified type   
		private void DumpProperties(Type aType)
		{
			if (!ShowProperties)
				return;
			PropertyInfo[] pInfo = aType.GetProperties();
			myWriter.WriteLine("Properties");
			bool found = false;
			if (pInfo.Length != 0)
			{
				PropertyInfo curInfo = null;
				for (int i = 0; i < pInfo.Length; i++)
				{
					curInfo = pInfo[i];
					//
					// Only display properties declared in this type.
					//		  
					if (curInfo.DeclaringType != aType)
					{
						continue;
					}
					found = true;
					String flags = null;
					if (curInfo.CanRead && curInfo.CanWrite)
					{
						flags = "get; set;";
					}
					else if (curInfo.CanRead)
					{
						flags = "get";
					}
					else if (curInfo.CanWrite)
					{
						flags = "set";
					}
					myWriter.WriteLine("  {0,-10} '{1}' ", curInfo, flags);
				}
			}
			if (!found)
			{
				myWriter.WriteLine("  (none)");
			}
		}
		// Dumps the public events directly contained in the specified type   
		private void DumpEvents(Type aType)
		{
			if (!ShowEvents)
				return;
			EventInfo[] eInfo = aType.GetEvents();
			myWriter.WriteLine("Events:");
			bool found = false;
			if (eInfo.Length != 0)
			{
				for (int i = 0; i < eInfo.Length; i++)
				{
					//
					// Only display events declared in this type.
					//		  
					if (eInfo[i].DeclaringType == aType)
					{
						found = true;
						myWriter.WriteLine("  {0}", eInfo[i]);
					}
				}
			}
			if (!found)
			{
				myWriter.WriteLine("  (none)");
			}
		}
		// Dumps the public fields directly contained in the specified type   
		private void DumpFields(Type aType)
		{
			if (!ShowFields)
				return;
			FieldInfo[] info = aType.GetFields();
			myWriter.WriteLine("Fields:");
			bool found = false;
			if (info.Length != 0)
			{
				for (int i = 0; i < info.Length; i++)
				{
					//
					// Only display fields declared in this type.
					//		  
					if (info[i].DeclaringType == aType)
					{
						myWriter.WriteLine("  {0}", info[i]);
						found = true;
					}
				}
			}
			if (!found)
			{
				myWriter.WriteLine("  (none)");
			}
		}
		// Dumps the public methods directly contained in the specified type. 
		// Note "special name" methods are not displayed.   
		private void DumpMethods(Type aType)
		{
			if (!ShowMethods)
				return;
			MethodInfo[] mInfo = aType.GetMethods();
			myWriter.WriteLine("Methods");
			bool found = false;
			if (mInfo.Length != 0)
			{
				for (int i = 0; i < mInfo.Length; i++)
				{
					//
					// Only display methods declared in this type. Also 
					// filter out any methods with special names - these
					// cannot be generally called by the user (i.e their 
					// functionality is usually exposed in other ways e.g
					// property get/set methods are exposed as properties.
					//		  
					if (mInfo[i].DeclaringType == aType && !mInfo[i].IsSpecialName)
					{
						found = true;
						StringBuilder modifiers = new StringBuilder();
						if (mInfo[i].IsStatic) { modifiers.Append("static "); }
						if (mInfo[i].IsPublic) { modifiers.Append("public "); }
						if (mInfo[i].IsFamily) { modifiers.Append("protected "); }
						if (mInfo[i].IsAssembly) { modifiers.Append("internal "); }
						if (mInfo[i].IsPrivate) { modifiers.Append("private "); }
						myWriter.WriteLine("  {0} {1}", modifiers, mInfo[i]);
					}
				}
			}
			if (!found)
			{
				myWriter.WriteLine("  (none)");
			}
		}
		private const int SHOW_INTERFACES = 0x01;
		private const int SHOW_FIELDS = 0x02;
		private const int SHOW_PROPERTIES = 0x04;
		private const int SHOW_EVENTS = 0x08;
		private const int SHOW_METHODS = 0x10;
		private const int SHOW_MODULE_INFO = 0x20;
		private IndentedWriter myVerboseWriter = new IndentedWriter();
		private IndentedWriter myWriter = new IndentedWriter();
		private bool exactMatchOnly = false;
		private bool recurseTypes = false;
		private bool matchOnlyNamespace = false;
		private bool wideSearch = false;
		private int showOptions = 0;
		private ArrayList myClassList = new ArrayList();
		private ArrayList DirList = new ArrayList();
	}
// Utility class that performs basic text output operations that can be 
// indented via "push" and "pop". The text writer used to write 
// information out can be changed by setting the appropriate property.
// The default text writer is System.Console.Out
	public class IndentedWriter
	{
		// Controls whether printing is performed or not. This can be useful 
		// for clients that require a "verbose" writer that only displays 
		// information when the verbose mode is set   
		public bool Print
		{
			get { return myPrintFlag; }
			set { myPrintFlag = value; }
		}
		// Sets the TextWriter to use when writing strings out   
		public TextWriter TextWriter
		{
			get { return myTextWriter; }
			set { myTextWriter = value; }
		}
		public void PushIndent()
		{
			myIndent += 2;
		}
		public void PopIndent()
		{
			if (myIndent > 0)
			{
				myIndent -= 2;
			}
		}
		// Writes out an empty line   
		public void WriteLine()
		{
			WriteLine("");
		}
		// Writes a formatted string   
		public void WriteLine(String format, params Object[] arguments)
		{
			WriteLine(String.Format(format, arguments));
		}
		// Writes out a string (indenting it as required)   
		public void WriteLine(string message)
		{
			if (myPrintFlag)
			{
				StringBuilder sb = new StringBuilder();
				for (int i = 0; i < myIndent; i++)
				{
					sb.Append(' ');
				}
				sb.Append(message);
				myTextWriter.WriteLine(sb.ToString());
			}
		}
		private TextWriter myTextWriter = Console.Out;
		private bool myPrintFlag = true;
		private int myIndent = 0;
	}
}
#T=ReflectionUtil
// http://www.cnblogs.com/XINLG/archive/2011/06/13/2079863.html
namespace Microshaoft
{
	using System;
	using System.Reflection;
	using System.ComponentModel;
	/// <summary>
	/// 反射操作类
	/// </summary>	
	public class ReflectionUtil
	{
		#region 加载程序集
		/// <summary>
		/// 加载程序集
		/// </summary>
		/// <param name="assemblyName">程序集名称,不要加上程序集的后缀，如.dll</param>		
		public static Assembly LoadAssembly(string assemblyName)
		{
			try
			{
				return Assembly.Load(assemblyName);
			}
			catch (Exception ex)
			{
				string errMsg = ex.Message;
				return null;
			}
		}
		#endregion
		#region 获取程序集中的类型
		/// <summary>
		/// 获取本地程序集中的类型
		/// </summary>
		/// <param name="typeName">类型名称，范例格式："命名空间.类名",类型名称必须在本地程序集中</param>		
		public static Type GetType(string typeName)
		{
			try
			{
				return Type.GetType(typeName);
			}
			catch (Exception ex)
			{
				string errMsg = ex.Message;
				return null;
			}
		}
		/// <summary>
		/// 获取指定程序集中的类型
		/// </summary>
		/// <param name="assembly">指定的程序集</param>
		/// <param name="typeName">类型名称，范例格式："命名空间.类名",类型名称必须在assembly程序集中</param>
		/// <returns></returns>
		public static Type GetType(Assembly assembly , string typeName)
		{
			try
			{
				return assembly.GetType(typeName);
			}
			catch (Exception ex)
			{
				string errMsg = ex.Message;
				return null;
			}
		}
		#endregion
		#region 动态创建对象实例
		/// <summary>
		/// 创建类型的实例
		/// </summary>
		/// <param name="type">类型</param>
		/// <param name="parameters">传递给构造函数的参数</param>		
		public static object CreateInstance(Type type,params object[] parameters)
		{
			return Activator.CreateInstance(type, parameters);
		}
		/// <summary>
		/// 创建类的实例
		/// </summary>
		/// <param name="className">类名，格式:"命名空间.类名"</param>
		/// <param name="parameters">传递给构造函数的参数</param>		
		public static object CreateInstance(string className,params object[] parameters)
		{
			try
			{
				//获取类型
				Type type = GetType(className);
				//类型为空则返回
				if (type == null)
				{
					return null;
				}
				return CreateInstance(type, parameters);
			}
			catch (Exception ex)
			{
				string errMsg = ex.Message;
				return null;
			}
		}	 
		#endregion
		#region 获取类的命名空间
		/// <summary>
		/// 获取类的命名空间
		/// </summary>
		/// <typeparam name="T">类名或接口名</typeparam>		
		public static string GetNamespace<T>()
		{   
			return typeof(T).Namespace;
		}
		#endregion
		#region 设置成员的值
		#region 设置属性值
		/// <summary>
		/// 将值装载到目标对象的指定属性中
		/// </summary>
		/// <param name="target">要装载数据的目标对象</param>
		/// <param name="propertyName">目标对象的属性名</param>
		/// <param name="value">要装载的值</param>
		public static void SetPropertyValue(object target, string propertyName, object value)
		{
			PropertyInfo propertyInfo = target.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.FlattenHierarchy);
			SetValue(target, propertyInfo, value);
		}
		#endregion
		#region 设置成员的值
		/// <summary>
		/// 设置成员的值
		/// </summary>
		/// <param name="target">要装载数据的目标对象</param>
		/// <param name="memberInfo">目标对象的成员</param>
		/// <param name="value">要装载的值</param>
		private static void SetValue(object target, MemberInfo memberInfo, object value)
		{
			if (value != null)
			{
				//获取成员类型
				Type pType;
				if (memberInfo.MemberType == MemberTypes.Property)
					pType = ((PropertyInfo)memberInfo).PropertyType;
				else
					pType = ((FieldInfo)memberInfo).FieldType;
				//获取值的类型
				Type vType = GetPropertyType(value.GetType());
				//强制将值转换为属性类型
				value = CoerceValue(pType, vType, value);
			}
			if (memberInfo.MemberType == MemberTypes.Property)
				((PropertyInfo)memberInfo).SetValue(target, value, null);
			else
				((FieldInfo)memberInfo).SetValue(target, value);
		} 
		#endregion
		#region 强制将值转换为指定类型
		/// <summary>
		/// 强制将值转换为指定类型
		/// </summary>
		/// <param name="propertyType">目标类型</param>
		/// <param name="valueType">值的类型</param>
		/// <param name="value">值</param>
		private static object CoerceValue(Type propertyType, Type valueType, object value)
		{
			//如果值的类型与目标类型相同则直接返回,否则进行转换
			if (propertyType.Equals(valueType))
			{				
				return value;
			}
			else
			{
				if (propertyType.IsGenericType)
				{
					if (propertyType.GetGenericTypeDefinition() == typeof(Nullable<>))
					{
						if (value == null)
							return null;
						else if (valueType.Equals(typeof(string)) && (string)value == string.Empty)
							return null;
					}
					propertyType = GetPropertyType(propertyType);
				}
				if (propertyType.IsEnum && valueType.Equals(typeof(string)))
					return Enum.Parse(propertyType, value.ToString());
				if (propertyType.IsPrimitive && valueType.Equals(typeof(string)) && string.IsNullOrEmpty((string)value))
					value = 0;
				try
				{
					return Convert.ChangeType(value, GetPropertyType(propertyType));
				}
				catch(Exception ex)
				{
					TypeConverter cnv = TypeDescriptor.GetConverter(GetPropertyType(propertyType));
					if (cnv != null && cnv.CanConvertFrom(value.GetType()))
						return cnv.ConvertFrom(value);
					else
						throw ex;
				}
			}
		}
		#endregion
		#region 获取类型,如果类型为Nullable<>，则返回Nullable<>的基础类型
		/// <summary>
		/// 获取类型,如果类型为Nullable(of T)，则返回Nullable(of T)的基础类型
		/// </summary>
		/// <param name="propertyType">需要转换的类型</param>
		private static Type GetPropertyType(Type propertyType)
		{
			Type type = propertyType;
			if (type.IsGenericType && (type.GetGenericTypeDefinition() == typeof(Nullable<>)))
				return Nullable.GetUnderlyingType(type);
			return type;
		}
		#endregion
		#endregion
	}
}

namespace ConsoleApplication
{
	using System;
	using System.Data;
	using System.Reflection;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
///		/// <summary>
///		/// 获取用户数据库分页数据
///		/// </summary>
///		/// <param name="TableName"></param>
///		/// <param name="PageSize"></param>
///		/// <param name="PageIndex"></param>
///		/// <param name="SqlWhere"></param>
///		/// <returns></returns>
///		public DataSet GetList(string TableName,int PageSize,int PageIndex,string SqlWhere)
///		{
///			try
///			{
///				Assembly a = ReflectionUtil.LoadAssembly(Globals.UserDATA_Assembly + ".BLL");//创建一个程序集
///				Type t = ReflectionUtil.GetType(a, Globals.UserDATA_Assembly + ".BLL." + TableName + "BLL");
///				object o = ReflectionUtil.CreateInstance(t, null);
///				Type[] types = new Type[3];
///				types[0] = Type.GetType("System.Int32");
///				types[1] = Type.GetType("System.Int32");
///				types[2] = Type.GetType("System.String");
///				MethodInfo mi = t.GetMethod("GetList", types);
///				Object[] obj = new Object[3];
///				obj[0] = PageSize;
///				obj[1] = PageIndex;
///				obj[2] = SqlWhere;
///				DataSet ds = (DataSet) mi.Invoke(o, obj);
///				return ds;
///			}
///			catch
///			{
///				return null;
///			}
///		}
	}
}
#T=RegEx
using System;
using System.Text.RegularExpressions;
public class Class1
{
	/// <summary>
	/// 应用程序的主入口点。
	/// </summary>
	//[STAThread]
	static void Main(string[] args)
	{
		//
		// TODO: 在此处添加代码以启动应用程序
		//
		System.Console.WriteLine("Hello World");
		System.Console.WriteLine("E-Mail: " + IsValidEmail("v-playyuer@Microshaoft.com"));
		System.Console.WriteLine("Date: " + IsValidDate("2000-02-28"));
		System.Console.WriteLine("DateTime: " + IsValidDate("2000-02-28 13-15-14"));
	}
	static bool IsValidEmail(string s)
	{
		return Regex.IsMatch(s, @"([\w-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([\w-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$"); 
	}
	static bool IsValidDate(string s)
	{
		return Regex.IsMatch(s, @"((((1[6-9]|[2-9]\d)\d{2})-(0?[13578]|1[02])-(0?[1-9]|[12]\d|3[01]))|(((1[6-9]|[2-9]\d)\d{2})-(0?[13456789]|1[012])-(0?[1-9]|[12]\d|30))|(((1[6-9]|[2-9]\d)\d{2})-0?2-(0?[1-9]|1\d|2[0-8]))|(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))-0?2-29-))$"); 
	}
	static bool IsValidDateTime(string s)
	{
		return Regex.IsMatch(s, @"((((1[6-9]|[2-9]\d)\d{2})-(0?[13578]|1[02])-(0?[1-9]|[12]\d|3[01]))|(((1[6-9]|[2-9]\d)\d{2})-(0?[13456789]|1[012])-(0?[1-9]|[12]\d|30))|(((1[6-9]|[2-9]\d)\d{2})-0?2-(0?[1-9]|1\d|2[0-8]))|(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))-0?2-29-)) (20|21|22|23|[0-1]?\d):[0-5]?\d:[0-5]?\d$"); 
	}
}
/*
17种正则表达式
March 25,2004 

"\d+$"　　//非负整数（正整数 + 0）

"[0-9]*[1-9][0-9]*$"　　//正整数

"((-\d+)|(0+))$"　　//非正整数（负整数 + 0）

"-[0-9]*[1-9][0-9]*$"　　//负整数

"-?\d+$"　　　　//整数

"\d+(\.\d+)?$"　　//非负浮点数（正浮点数 + 0）

"(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数

"((-\d+(\.\d+)?)|(0+(\.0+)?))$"　　//非正浮点数（负浮点数 + 0）

"(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数

"(-?\d+)(\.\d+)?$"　　//浮点数

"[A-Za-z]+$"　　//由26个英文字母组成的字符串

"[A-Z]+$"　　//由26个英文字母的大写组成的字符串

"[a-z]+$"　　//由26个英文字母的小写组成的字符串

"[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串

"\w+$"　　//由数字、26个英文字母或者下划线组成的字符串

"[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$"　　　　//email地址

"[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$"　　//url

//日期时间
string regex = @"^((\d{2}(([02468][048])|([13579][26]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|([1-2][0-9])))))|(\d{2}(([02468][1235679])|([13579][01345789]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\s(((0?[0-9])|([1-2][0-3]))\:([0-5]?[0-9])((\s)|(\:([0-5]?[0-9])))))?$";
string regex = @"^((\d{2}(([02468][048])|([13579][26]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|([1-2][0-9])))))|(\d{2}(([02468][1235679])|([13579][01345789]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))"; //日期部分
regex += @"(\s(((0?[0-9])|([1-2][0-3]))\:([0-5]?[0-9])((\s)|(\:([0-5]?[0-9])))))?$"; //时间部分
//from ccf
regex = @"^((\d{2}(([02468][048])|([13579][26]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|([1-2][0-9])))))|(\d{2}(([02468][1235679])|([13579][01345789]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\s(((0?[0-9])|(1[0-9])|(2[0-3]))\:(([0-5][0-9])|([0-9]))((\s)|(\:(([0-5][0-9])|([0-9]))))))?$";
*/

#T=Remoting AsyncQueue 不受生存期过期约束
/*
Remoting 异步队列实现,流程如下
1.并发若干客户端程序通过调用 RemotingQueue Server 提供的公开远程方法 Enqueue 将数据元素入队尾
2.RemotingQueue Server 发现队列不为空,则并发若干线程陆续 Dequeue 队首数据元素并处理
注意:
1.队列的数据元素定义需自行实现
2.对出列数据元素的处理程序需自行实现
不受 Remoting 生命周期租约过期的约束
*/
//AsyncQueue.cs
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		private long _EnqueueCount = 0; //入列计数器
		public long EnqueueCount
		{
			get
			{
				return _EnqueueCount;
			}
		}
		private long _DequeueCount = 0; //出列计数器
		public long DequeueCount
		{
			get
			{
				return _DequeueCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}
namespace Test
{
	using System;
	using System.Threading;
	using Microshaoft;
	public class Class1
	{
		static AsyncQueue<Item> _queue;
		public static void Main1()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
			Console.ReadLine();
		}
		public void Run()
		{
			_queue = new AsyncQueue<Item>();
			_queue.OnDequeue += new AsyncQueue<Item>.QueueEventHandler(_queue_OnDequeue);
			_queue.OnQueueLog += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnException += new AsyncQueue<Item>.ExceptionEventHandler(_queue_OnException);
			_queue.MaxConcurrentThreadsCount = 200;
			Thread t = new Thread(new ThreadStart(ConsoleMonitor));
			t.Start();
			//Microshaoft 以下是耗时的主程序
			for (int i = 0; i < 1000; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public void ConsoleMonitor()
		{
			Console.WriteLine("press any key to check queue status ...");
			while (Console.ReadLine() != "q")
			{
				Console.WriteLine
							(
								"Queue elements: {0},Threads count: {1},{2},{3}"
								, _queue.Count
								, _queue.ConcurrentThreadsCount
								, _queue.EnqueueCount
								, _queue.DequeueCount
							);
			}
		}
		void _queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		void _queue_OnQueueLog(string logMessage)
		{
			///			Console.WriteLine(logMessage);
		}
		void _queue_OnDequeue(Item element)
		{
			///			DateTime DequeueBeginTime = DateTime.Now;
			///			DateTime DequeueEndTime = DateTime.Now;
			///			Console.WriteLine
			///						(
			///							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
			///							, _queue.Count
			///							, element.EnqueueTime
			///							, DequeueBeginTime
			///							, (DequeueBeginTime.Ticks - element.EnqueueTime.Ticks) / 10000 /1000
			///							, DequeueEndTime
			///							, (DequeueEndTime.Ticks - DequeueBeginTime.Ticks) / 10000 /1000
			///							, _queue.ConcurrentThreadsCount
			///						);
			///			Console.WriteLine(element.EnqueueTime);
			Thread.Sleep(1);
		}
		public void ThreadProcess()
		{
			for (int i = 0; i < 1000; i++)
			{
				Item x = new Item();
				DateTime EnqueueTime = DateTime.Now;
				x.Name = EnqueueTime.ToString();
				x.EnqueueTime = EnqueueTime;
				_queue.Enqueue(x);
				///				Console.WriteLine
				///							(
				///								"Enqueue: {0},[{1}]"
				///								, EnqueueTime
				///								, (DateTime.Now.Ticks - EnqueueTime.Ticks) / 10000 / 1000
				///							);
			}
		}
	}
}
namespace Test
{
	using System;
	public class Item
	{
		private string _Name;
		public string Name
		{
			get
			{
				return _Name;
			}
			set
			{
				_Name = value;
			}
		}
		private DateTime _EnqueueTime;
		public DateTime EnqueueTime
		{
			get
			{
				return _EnqueueTime;
			}
			set
			{
				_EnqueueTime = value;
			}
		}
	}
}
//Server.cs
namespace Microshaoft
{
	using System;
	using Microshaoft.RemotingObjects.Share;
	public class AsyncQueueProcessor
	{
		private AsyncQueue<Item> _queue;
		public AsyncQueue<Item> Queue
		{
			get
			{
				return _queue;
			}
		}
		public AsyncQueueProcessor(AsyncQueue<Item> queue)
		{
			_queue = queue;
			_queue.OnDequeue += new AsyncQueue<Item>.QueueEventHandler(_queue_OnDequeue);
			_queue.OnQueueLog += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnException += new AsyncQueue<Item>.ExceptionEventHandler(_queue_OnException);
			_queue.MaxConcurrentThreadsCount = 200;
		}
		public void Enqueue(Item item)
		{
			_queue.Enqueue(item);
		}
		void _queue_OnQueueLog(string logMessage)
		{
			Console.WriteLine(logMessage);
		}
		void _queue_OnDequeue(Item item)
		{
			DateTime DequeueBeginTime = DateTime.Now;
			DateTime DequeueEndTime = DateTime.Now;
			Console.WriteLine
						(
							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
							, _queue.Count
							, item.EnqueueTime
							, DequeueBeginTime
							, (DequeueBeginTime.Ticks - item.EnqueueTime.Ticks) / 10000 /1000
							, DequeueEndTime
							, (DequeueEndTime.Ticks - DequeueBeginTime.Ticks) / 10000 /1000
							, _queue.ConcurrentThreadsCount
						);
		}
		void _queue_OnException(Exception e)
		{
			Console.WriteLine(e.ToString());
		}
	}
}
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Configuration.Install;
	using System.Security.Principal;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.Win32;
	using Microshaoft;
	public class ServiceHost : ServiceBase
	{
		///// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		public static readonly string serviceName = "RemotingAsyncQueueService";
		private static AsyncQueueProcessor _asyncQueueProcessor;
		public static AsyncQueueProcessor AsyncQueueProcessor
		{
			get 
			{ 
				return _asyncQueueProcessor;
			}
		}
		static void Main(string[] args)
		{
			//Microshaoft
			//Microshaoft TODO: 在此处添加代码以启动应用程序
			//Microshaoft 
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
				}
				Console.Title = "Server"; //不能以服务运行
				Console.WriteLine("Console");
				service.OnStart(null);
				Console.ReadLine();
				return;
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			AsyncQueue<Item> queue = new AsyncQueue<Item>();
			_asyncQueueProcessor = new AsyncQueueProcessor(queue);
			RemotingHelper.StartRemoting<RemotingAsyncQueue>
								(
									"queueurl"
									, 8080
								);
			Console.WriteLine("Server . , Press Enter key to exit.");
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}
namespace Microshaoft.RemotingObjects
{
	using System;
	using System.IO;
	using System.Net;
	using System.Web;
	using System.Text;
	using System.Threading;
	using System.Configuration;
	using System.Collections.Generic;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.RemotingObjects.Server;
	public class RemotingAsyncQueue : MarshalByRefObject
	{
		public void Enqueue(Item item)
		{
			//Microshaoft 队列的数据元素定义需自行实现 Item
			ServiceHost.AsyncQueueProcessor.Enqueue(item);
		}
	}
}
//=============================================================
//===============================================
// Share.cs
//Server、Client 均需引用此 share.dll
//C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc.exe /t:library share.cs
//TO DO
//队列的数据元素定义需自行实现,示例如下:
namespace Microshaoft.RemotingObjects.Share
{
	using System;
	[Serializable]
	public class Item
	{
		private string _Name;
		public string Name
		{
			get
			{
				return _Name;
			}
			set
			{
				_Name = value; 
			}
		}
		private DateTime _EnqueueTime;
		public DateTime EnqueueTime
		{
			get
			{
				return _EnqueueTime;
			}
			set
			{
				_EnqueueTime = value; 
			}
		}
	}
}
// remoting helper
//Share.cs
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Text;
	public static class RemotingHelper
	{
		public static void StartRemoting
			(
				Type RemotingType
				, string Url
				, int Port
			)
		{
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
			IDictionary ht = new Hashtable();
			ht["port"] = Port;
			TcpChannel tc = new TcpChannel(ht, null, provider);
			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, WellKnownObjectMode.Singleton);
			Console.WriteLine("Remoting Object Started ...");
		}
		public static void StartRemoting<T>
			(
				string Url
				, int Port
			)
		{
			StartRemoting(typeof(T), Url, Port);
		}
		public static T GetRemotingLocalClientProxyObject<T>
			(
				string Url
			)
		{
			return (T) Activator.GetObject
									(
										typeof(T)
										, Url
										//, "tcp://127.0.0.1:8080/queueUrl"
									);
		}
	}
}
//============================================================================
//============================================
// Client.cs
//C:\WINDOWS\Microsoft.NET\Framework\v1.1.4322\csc.exe client.cs /r:share.dll
namespace Microshaoft.RemotingObjects.Client
{
	using System;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Threading;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static RemotingAsyncQueue _queue;
		public static void Main()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
		}
		public void Run()
		{
			_queue = RemotingHelper.GetRemotingLocalClientProxyObject<RemotingAsyncQueue>("tcp://127.0.0.1:8080/queueUrl");
			//Microshaoft 以下是耗时的主程序
			for (int i = 0; i < 50; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public void ThreadProcess()
		{
			for (int i = 0; i < 800; i++)
			{
				Item x = new Item();
				DateTime EnqueueTime = DateTime.Now;
				x.Name = EnqueueTime.ToString();
				x.EnqueueTime = EnqueueTime;
				_queue.Enqueue(x);
				Console.WriteLine
							(
								"Enqueue: {0},[{1}]"
								, EnqueueTime
								, (DateTime.Now.Ticks - EnqueueTime.Ticks)/10000/1000
							);
			}
		}
	}
}
//Microshaoft =========================================
//Microshaoft Remoting Object Client Local Proxy
namespace Microshaoft.RemotingObjects
{
	using System;
	using Microshaoft.RemotingObjects.Share;
	public interface RemotingAsyncQueue
	{
		void Enqueue(Item item);
	}
}

#T=Remoting Concurrent Queue C# 4.0
/*
Remoting 异步队列实现,流程如下
1.并发若干客户端程序通过调用 Remoting CocurrentQueue Server 提供的公开远程方法 Enqueue 将数据元素入队尾
2.Remoting CocurrentQueue Server 发现队列不为空,则并发若干线程陆续 Dequeue 队首数据元素并处理
注意:
1.队列的数据元素定义需自行实现
2.对出列数据元素的处理程序需自行实现
不受 Remoting 生命周期租约过期的约束
*/
//AsyncQueue.cs
^#define c4 //C# 4.0+
//#define c2
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Diagnostics;
	using System.Collections.Generic;
^#if c4
	using System.Collections.Concurrent;
^#endif
	using Microshaoft;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		//public event QueueLogEventHandler OnQueueLog;
		public event QueueLogEventHandler OnQueueRunningThreadStart;
		public event QueueLogEventHandler OnQueueRunningThreadEnd;
		public event QueueLogEventHandler OnDequeueThreadStart;
		public event QueueLogEventHandler OnDequeueThreadEnd;
		public event QueueLogEventHandler OnDequeueAllThreadsEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
^#if c2
		private Queue<T> _queue = new Queue<T>();
^#elif c4
		private ConcurrentQueue<T> _queue = new ConcurrentQueue<T>();
^#endif
		private object _syncQueueLockObject = new object();
		//private object _syncQueueRunningLockObject = new object();
		private long _isQueueRunning = 0;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private PerformanceCounter _enqueuePerformanceCounter;
		private PerformanceCounter _dequeuePerformanceCounter;
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		private PerformanceCounter _queueLengthPerformanceCounter;
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		private PerformanceCounter _queueRunningThreadStartPerformanceCounter;
		private PerformanceCounter _queueRunningThreadEndPerformanceCounter;
		private PerformanceCounter _queueRunningThreadsCountPerformanceCounter;
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCounters(string instanceNamePrefix)
		{
			string category = "Microshaoft AsyncConurrentQueue Counters";
			string counter = string.Empty;
			Process process = Process.GetCurrentProcess();
			//int processID = 0;//process.Id;
			string processName = process.ProcessName;
			//string processStartTime = "";//process.StartTime;
			string instanceName = string.Empty;
			instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
										//, processID
										//, processStartTime.ToString("yyyy-MM-dd HH:mm:ss.fff")
									);
			CounterCreationDataCollection ccdc = new CounterCreationDataCollection();
			if (PerformanceCounterCategory.Exists(category))
			{
				PerformanceCounterCategory.Delete(category);
			}
			CounterCreationData ccd = null;
			counter = "EnqueueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueLengthCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueProcessedCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			PerformanceCounterCategory.Create
											(
												category,
												string.Format("{0} Category Help.", category),
												PerformanceCounterCategoryType.MultiInstance,
												ccdc
											);
			counter = "EnqueueCounter";
			_enqueuePerformanceCounter = new PerformanceCounter();
			_enqueuePerformanceCounter.CategoryName = category;
			_enqueuePerformanceCounter.CounterName = counter;
			_enqueuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_enqueuePerformanceCounter.InstanceName = instanceName;
			_enqueuePerformanceCounter.ReadOnly = false;
			_enqueuePerformanceCounter.RawValue = 0;
			counter = "DequeueCounter";
			_dequeuePerformanceCounter = new PerformanceCounter();
			_dequeuePerformanceCounter.CategoryName = category;
			_dequeuePerformanceCounter.CounterName = counter;
			_dequeuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeuePerformanceCounter.InstanceName = instanceName;
			_dequeuePerformanceCounter.ReadOnly = false;
			_dequeuePerformanceCounter.RawValue = 0;
			counter = "DequeueProcessedCounter";
			_dequeueProcessedPerformanceCounter = new PerformanceCounter();
			_dequeueProcessedPerformanceCounter.CategoryName = category;
			_dequeueProcessedPerformanceCounter.CounterName = counter;
			_dequeueProcessedPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueProcessedPerformanceCounter.InstanceName = instanceName;
			_dequeueProcessedPerformanceCounter.ReadOnly = false;
			_dequeueProcessedPerformanceCounter.RawValue = 0;
			counter = "QueueLengthCounter";
			_queueLengthPerformanceCounter = new PerformanceCounter();
			_queueLengthPerformanceCounter.CategoryName = category;
			_queueLengthPerformanceCounter.CounterName = counter;
			_queueLengthPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueLengthPerformanceCounter.InstanceName = instanceName;
			_queueLengthPerformanceCounter.ReadOnly = false;
			_queueLengthPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadStartCounter";
			_dequeueThreadStartPerformanceCounter = new PerformanceCounter();
			_dequeueThreadStartPerformanceCounter.CategoryName = category;
			_dequeueThreadStartPerformanceCounter.CounterName = counter;
			_dequeueThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadStartPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadStartPerformanceCounter.ReadOnly = false;
			_dequeueThreadStartPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadEndCounter";
			_dequeueThreadEndPerformanceCounter = new PerformanceCounter();
			_dequeueThreadEndPerformanceCounter.CategoryName = category;
			_dequeueThreadEndPerformanceCounter.CounterName = counter;
			_dequeueThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadEndPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadEndPerformanceCounter.ReadOnly = false;
			_dequeueThreadEndPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadsCountCounter";
			_dequeueThreadsCountPerformanceCounter = new PerformanceCounter();
			_dequeueThreadsCountPerformanceCounter.CategoryName = category;
			_dequeueThreadsCountPerformanceCounter.CounterName = counter;
			_dequeueThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadsCountPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadsCountPerformanceCounter.ReadOnly = false;
			_dequeueThreadsCountPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadStartCounter";
			_queueRunningThreadStartPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadStartPerformanceCounter.CategoryName = category;
			_queueRunningThreadStartPerformanceCounter.CounterName = counter;
			_queueRunningThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadStartPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadStartPerformanceCounter.ReadOnly = false;
			_queueRunningThreadStartPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadEndCounter";
			_queueRunningThreadEndPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadEndPerformanceCounter.CategoryName = category;
			_queueRunningThreadEndPerformanceCounter.CounterName = counter;
			_queueRunningThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadEndPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadEndPerformanceCounter.ReadOnly = false;
			_queueRunningThreadEndPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadsCountCounter";
			_queueRunningThreadsCountPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadsCountPerformanceCounter.CategoryName = category;
			_queueRunningThreadsCountPerformanceCounter.CounterName = counter;
			_queueRunningThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadsCountPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadsCountPerformanceCounter.ReadOnly = false;
			_queueRunningThreadsCountPerformanceCounter.RawValue = 0;
			_isAttachedPerformanceCounters = true;
		}
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (Interlocked.Read(ref _concurrentDequeueThreadsCount) < _maxConcurrentThreadsCount)
			{
				if (Interlocked.CompareExchange(ref _isQueueRunning, 0, 1) == 0)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunningThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadStartPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Increment();
			}
			if (OnQueueRunningThreadStart != null)
			{
				OnQueueRunningThreadStart
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}({4}) at {5}"
									, "Queue Running Start ..."
									, _concurrentDequeueThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
									, Thread.CurrentThread.ManagedThreadId
									, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
								)
					);
			}
^#if c2
			while ((_queue.Count > 0)) //Microshaoft 死循环
^#elif c4
			while (!_queue.IsEmpty) //Microshaoft 死循环
^#endif
			{
				int threadID = -1;
				{
					int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
					if (r < _maxConcurrentThreadsCount)
					{
						//if (_queue.Count > 0)
						{
							r = (int) Interlocked.Increment(ref _concurrentDequeueThreadsCount);
							threadID = (int) _concurrentDequeueThreadsCount;
							//ThreadProcessState tps = new ThreadProcessState();
							//tps.element = element;
							//tps.Sender = this;
							Thread t = new Thread(new ThreadStart(DequeueThreadProcess));
							t.Name = string.Format("ConcurrentDequeueProcessThread[{0}]", threadID);
							t.Start();
						}
///						else
///						{
///							break;
///						}
					}
					else
					{
						break;
					}
				}
			}
			//Interlocked.CompareExchange(ref _queueRuning, 0, 1);
			if (OnQueueRunningThreadEnd != null)
			{
				int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnQueueRunningThreadEnd
							(
								string.Format
										(
											"{0} Threads Count {1}, Queue Count {2}, Current Thread: {3}({4}) at {5}"
											, "Queue Running Stop ..."
											, r
											, _queue.Count
											, Thread.CurrentThread.Name
											, Thread.CurrentThread.ManagedThreadId
											, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
										)
							);
			}
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadEndPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Decrement();
			}
			Interlocked.Exchange(ref _isQueueRunning, 0);
		}
		public void Enqueue(T element)
		{
			try
			{
^#if c2
				lock (_syncQueueLockObject) //还算并发吗?
^#endif
				{
					_queue.Enqueue(element);
				}
				if (_isAttachedPerformanceCounters)
				{
					_enqueuePerformanceCounter.Increment();
					_queueLengthPerformanceCounter.Increment();
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			//int r = Interlocked.CompareExchange(ref _queueRuning, 1, 0))
			//if (r == 1)
			//{
			QueueRun();
			//}
		}
		private void DequeueThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_dequeueThreadStartPerformanceCounter.Increment();
				_dequeueThreadsCountPerformanceCounter.Increment();
			}
			if (OnDequeueThreadStart != null)
			{
				int r = (int) Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnDequeueThreadStart
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads ++ !"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
			}
			bool queueWasNotEmpty = false;
			try
			{
^#if c2
				while (true)
^#elif c4
				while (!_queue.IsEmpty)
^#endif
				{
					T element = null;
^#if c2
					lock (_syncQueueLockObject)
					{
						if (_queue.Count > 0)
						{
							element = _queue.Dequeue();
						}
						else
						{
							//避免QueueRun 死循环
							break;
						}
					}
^#elif c4
					if (_queue.TryDequeue(out element))
					{
^#elif c2
						if (element != null)
						{
^#endif
							if (!queueWasNotEmpty)
							{
								queueWasNotEmpty = true;
							}
							if (_isAttachedPerformanceCounters)
							{
								_dequeuePerformanceCounter.Increment();
								_queueLengthPerformanceCounter.Decrement();
							}
							if (OnDequeue != null)
							{
								OnDequeue(element);
							}
							if (_isAttachedPerformanceCounters)
							{
								_dequeueProcessedPerformanceCounter.Increment();
							}
^#if c2
						}
^#elif c4
					}
				}
^#endif
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				int r = (int) Interlocked.Decrement(ref _concurrentDequeueThreadsCount);
				if (OnDequeueThreadEnd != null)
				{
					OnDequeueThreadEnd
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads--"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
				}
				if (r == 0)
				{
					if (OnDequeueAllThreadsEnd != null)
					{
						OnDequeueAllThreadsEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
													, "All Threads End"
													, r
													, _queue.Count
													, Thread.CurrentThread.Name
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
												)
									);
					}
				}
				if (_isAttachedPerformanceCounters)
				{
					_dequeueThreadEndPerformanceCounter.Increment();
					_dequeueThreadsCountPerformanceCounter.Decrement();
				}
				if (queueWasNotEmpty)
				{
					QueueRun(); //死循环???
				}
				
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			CounterCreationData ccd = new CounterCreationData();
			ccd.CounterName = counterName;
			ccd.CounterHelp = string.Format("{0} Help", counterName);
			ccd.CounterType = performanceCounterType;
			return ccd;
		}
	}
}
//Server.cs
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Data;
	using System.Data.SqlClient;
	using Microshaoft.RemotingObjects.Share;
	public class AsyncQueueProcessor
	{
		private AsyncQueue<Item> _queue;
		public AsyncQueue<Item> Queue
		{
			get
			{
				return _queue;
			}
		}
		public AsyncQueueProcessor(AsyncQueue<Item> queue)
		{
			_queue = queue;
			_queue.OnDequeue += new AsyncQueue<Item>.QueueEventHandler(_queue_OnDequeue);
			//_queue.OnDequeueThreadStart += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnDequeueAllThreadsEnd += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnDequeueThreadEnd += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			//_queue.OnQueueRunningThreadStart += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			//_queue.OnQueueRunningThreadEnd += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnException += new AsyncQueue<Item>.ExceptionEventHandler(_queue_OnException);
			_queue.MaxConcurrentThreadsCount = 64;
		}
		public void Enqueue(Item item)
		{
			_queue.Enqueue(item);
		}
		void _queue_OnQueueLog(string logMessage)
		{
			Console.WriteLine(logMessage);
		}
		void _queue_OnDequeue(Item item)
		{
			DateTime DequeueBeginTime = DateTime.Now;
///			SqlConnection connection = null;
///			try
///			{
///				connection = new SqlConnection(item.ConnectionString);
///				SqlCommand command = new SqlCommand(item.SqlCommandText, connection);
///				command.CommandType = CommandType.Text;
///				connection.Open();
///				command.ExecuteNonQuery();
///			}
///			catch (Exception e)
///			{
///				Console.WriteLine("Exception on Dequeue Process:{0}{1}", "\r\n", e.ToString());
///			}
///			finally
///			{
///				connection.Close();
///				connection.Dispose();
///				connection = null;
///			}
			DateTime DequeueEndTime = DateTime.Now;
			Console.WriteLine
						(
							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
							, _queue.Count
							, item.EnqueueTime
							, DequeueBeginTime
							, (DequeueBeginTime.Ticks - item.EnqueueTime.Ticks) / 10000 / 1000
							, DequeueEndTime
							, (DequeueEndTime.Ticks - DequeueBeginTime.Ticks) / 10000 / 1000
							, _queue.ConcurrentThreadsCount
						);
		}
		void _queue_OnException(Exception e)
		{
			Console.WriteLine(e.ToString());
		}
	}
}
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Configuration.Install;
	using System.Security.Principal;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.Win32;
	using Microshaoft;
	//using eHome.UserProfile;
	public class ServiceHost : ServiceBase
	{
		///// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		public static readonly string serviceName = "RemotingAsyncConcurrentQueueService";
		private static AsyncQueueProcessor _asyncQueueProcessor;
		public static AsyncQueueProcessor AsyncQueueProcessor
		{
			get
			{
				return _asyncQueueProcessor;
			}
		}
		static void Main(string[] args)
		{
			//Microshaoft
			//Microshaoft TODO: 在此处添加代码以启动应用程序
			//Microshaoft 
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
					Console.Title = "Server"; //不能以服务运行
					Console.WriteLine("Console");
					service.OnStart(null);
					Console.ReadLine();
					return;
				}
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			AsyncQueue<Item> queue = new AsyncQueue<Item>();
			queue.AttachPerformanceCounters("Q1");
			_asyncQueueProcessor = new AsyncQueueProcessor(queue);
			RemotingHelper.StartRemoting<RemotingAsyncQueue>
								(
									"queueurl"
									, 8080
								);
			Console.WriteLine("Server . , Press Enter key to exit.");
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}
namespace Microshaoft.RemotingObjects
{
	using System;
	using System.IO;
	using System.Net;
	using System.Web;
	using System.Text;
	using System.Threading;
	using System.Configuration;
	using System.Collections.Generic;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.RemotingObjects.Server;
	public class RemotingAsyncQueue : MarshalByRefObject
	{
		public void Enqueue(Item item)
		{
			//Microshaoft 队列的数据元素定义需自行实现 Item
			ServiceHost.AsyncQueueProcessor.Enqueue(item);
		}
	}
}
//=============================================================
//===============================================
// Share.cs
//Server、Client 均需引用此 share.dll
//C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc.exe /t:library share.cs
//TO DO
//队列的数据元素定义需自行实现,示例如下:
namespace Microshaoft.RemotingObjects.Share
{
	using System;
	[Serializable]
	public class Item
	{
		private DateTime _EnqueueTime;
		public DateTime EnqueueTime
		{
			get
			{
				return _EnqueueTime;
			}
			set
			{
				_EnqueueTime = value; 
			}
		}
		private string _sql;
		public string SqlCommandText
		{
			get
			{
				return _sql;
			}
			set
			{
				_sql = value; 
			}
		}
		private string _connectionString;
		public string ConnectionString
		{
			get
			{
				return _connectionString;
			}
			set
			{
				_connectionString = value; 
			}
		}
	}
}
// remoting helper
//Share.cs
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Text;
	public static class RemotingHelper
	{
			public static void StartRemoting
						(
							Type RemotingType
							, string Url
							, int Port
						)
			{
				BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
				provider.TypeFilterLevel = TypeFilterLevel.Full;
				IDictionary ht = new Hashtable();
				ht["port"] = Port;
				TcpChannel tc = new TcpChannel(ht, null, provider);
				ChannelServices.RegisterChannel(tc, false);
				RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, WellKnownObjectMode.Singleton);
				Console.WriteLine("Remoting Object Started ...");
			}
			public static void StartRemoting<T>
										(
											string Url
											, int Port
										)
			{
				StartRemoting(typeof(T), Url, Port);
			}
			public static T GetRemotingLocalClientProxyObject<T>
						(
							string Url
						)
			{
				return (T) Activator.GetObject
										(
											typeof(T)
											, Url
											//, "tcp://127.0.0.1:8080/queueUrl"
										);
			}
	}
}
//============================================================================
//============================================
// Client.cs
//C:\WINDOWS\Microsoft.NET\Framework\v1.1.4322\csc.exe client.cs /r:share.dll
namespace Microshaoft.RemotingObjects.Client
{
	using System;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Threading;
	using System.Data;
	using System.Data.SqlClient;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static RemotingAsyncQueue _queue;
		public static void Main()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
		}
		public void Run()
		{
			_queue = RemotingHelper.GetRemotingLocalClientProxyObject<RemotingAsyncQueue>("tcp://127.0.0.1:8080/queueUrl");
			//Microshaoft 以下是耗时的主程序
			for (int i = 0; i < 20; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public void ThreadProcess()
		{
			for (int i = 0; i < 1000; i++)
			{
				Item x = new Item();
				DateTime EnqueueTime = DateTime.Now;
				x.EnqueueTime = EnqueueTime;
				x.SqlCommandText = @"
						--==========================
						declare @ varchar(10)
						set @ = 'aaa'
						exec zsp_test @
						--==========================
				";
				x.ConnectionString = "";
				_queue.Enqueue(x);
				Console.WriteLine
							(
								"Enqueue: {0},[{1}]"
								, EnqueueTime
								, (DateTime.Now.Ticks - EnqueueTime.Ticks)/10000
							);
			}
		}
	}
}
//Microshaoft =========================================
//Microshaoft Remoting Object Client Local Proxy
namespace Microshaoft.RemotingObjects
{
	using System;
	using Microshaoft.RemotingObjects.Share;
	public interface RemotingAsyncQueue
	{
		void Enqueue(Item item);
	}
}
#T=Remoting Queue InitializeLifetimeService return null
/*
Remoting 异步队列实现,流程如下
1.并发若干客户端程序通过调用 RemotingQueue Server 提供的公开远程方法 Enqueue 将数据元素入队尾
2.RemotingQueue Server 发现队列不为空,则并发若干线程陆续 Dequeue 队首数据元素并处理
注意:
1.队列的数据元素定义需自行实现
2.对出列数据元素的处理程序需自行实现
*/
//AsyncQueue.cs
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		private long _EnqueueCount = 0; //入列计数器
		public long EnqueueCount
		{
			get
			{
				return _EnqueueCount;
			}
		}
		private long _DequeueCount = 0; //出列计数器
		public long DequeueCount
		{
			get
			{
				return _DequeueCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}
namespace Test
{
	using System;
	using System.Threading;
	using Microshaoft;
	public class Class1
	{
		static AsyncQueue<Item> _queue;
		public static void Main1()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
			Console.ReadLine();
		}
		public void Run()
		{
			_queue = new AsyncQueue<Item>();
			_queue.OnDequeue += new AsyncQueue<Item>.QueueEventHandler(_queue_OnDequeue);
			_queue.OnQueueLog += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnException += new AsyncQueue<Item>.ExceptionEventHandler(_queue_OnException);
			_queue.MaxConcurrentThreadsCount = 200;
			Thread t = new Thread(new ThreadStart(ConsoleMonitor));
			t.Start();
			//Microshaoft 以下是耗时的主程序
			for (int i = 0; i < 1000; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public void ConsoleMonitor()
		{
			Console.WriteLine("press any key to check queue status ...");
			while (Console.ReadLine() != "q")
			{
				Console.WriteLine
							(
								"Queue elements: {0},Threads count: {1},{2},{3}"
								, _queue.Count
								, _queue.ConcurrentThreadsCount
								, _queue.EnqueueCount
								, _queue.DequeueCount
							);
			}
		}
		void _queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		void _queue_OnQueueLog(string logMessage)
		{
///			Console.WriteLine(logMessage);
		}
		void _queue_OnDequeue(Item element)
		{
///			DateTime DequeueBeginTime = DateTime.Now;
///			DateTime DequeueEndTime = DateTime.Now;
///			Console.WriteLine
///						(
///							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
///							, _queue.Count
///							, element.EnqueueTime
///							, DequeueBeginTime
///							, (DequeueBeginTime.Ticks - element.EnqueueTime.Ticks) / 10000 /1000
///							, DequeueEndTime
///							, (DequeueEndTime.Ticks - DequeueBeginTime.Ticks) / 10000 /1000
///							, _queue.ConcurrentThreadsCount
///						);
///			Console.WriteLine(element.EnqueueTime);
			Thread.Sleep(1);
		}
		public void ThreadProcess()
		{
			for (int i = 0; i < 1000; i++)
			{
				Item x = new Item();
				DateTime EnqueueTime = DateTime.Now;
				x.Name = EnqueueTime.ToString();
				x.EnqueueTime = EnqueueTime;
				_queue.Enqueue(x);
///				Console.WriteLine
///							(
///								"Enqueue: {0},[{1}]"
///								, EnqueueTime
///								, (DateTime.Now.Ticks - EnqueueTime.Ticks) / 10000 / 1000
///							);
			}
		}
	}
}
namespace Test
{
	using System;
	public class Item
	{
		private string _Name;
		public string Name
		{
			get
			{
				return _Name;
			}
			set
			{
				_Name = value;
			}
		}
		private DateTime _EnqueueTime;
		public DateTime EnqueueTime
		{
			get
			{
				return _EnqueueTime;
			}
			set
			{
				_EnqueueTime = value;
			}
		}
	}
}
//Server.cs
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Configuration.Install;
	using System.Security.Principal;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.Win32;
	public class ServiceHost : ServiceBase
	{
		///// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		public static readonly string serviceName = "RemotingAsyncQueueService";
		static void Main(string[] args)
		{
			//Microshaoft
			//Microshaoft TODO: 在此处添加代码以启动应用程序
			//Microshaoft 
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
				}
				Console.Title = "Server"; //不能以服务运行
				Console.WriteLine("Console");
				service.OnStart(null);
				Console.ReadLine();
				return;
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			RemotingHelper.StartRemoting<RemotingAsyncQueue>
								(
									"queueurl"
									, 8080
								);
			RemotingAsyncQueue.OnDequeue += new RemotingAsyncQueue.RemotingAsyncQueueEventHandler(DequeueProcess);
			Console.WriteLine("Server . , Press Enter key to exit.");
		}
		public static void DequeueProcess(Item item)
		{
			//Microshaoft TO DO
			//Microshaoft 队列的数据元素定义需自行实现
			//Microshaoft 数据库访问
			//Microshaoft 发邮件等
			//Microshoaft Thread.Sleep(10);
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller: Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}
namespace Microshaoft.RemotingObjects
{
	using System;
	using System.IO;
	using System.Net;
	using System.Web;
	using System.Text;
	using System.Threading;
	using System.Configuration;
	using System.Collections.Generic;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	public class RemotingAsyncQueue : MarshalByRefObject
	{
		//private static AsyncQueue<Item> _AsyncQueue;
		public delegate void RemotingAsyncQueueEventHandler(Item item);
		public static event RemotingAsyncQueueEventHandler OnDequeue;
		private AsyncQueue<Item> _AsyncQueue;
		public RemotingAsyncQueue()
		{
			_AsyncQueue = new AsyncQueue<Item>();
			_AsyncQueue.OnDequeue += new AsyncQueue<Item>.QueueEventHandler(DequeueProcess);
			_AsyncQueue.OnQueueLog += new AsyncQueue<Item>.QueueLogEventHandler(QueueLog);
			_AsyncQueue.MaxConcurrentThreadsCount = 10;
		}
		public override object InitializeLifetimeService()
		{
			return null;
		}
		public void QueueLog(string message)
		{
			//Microshaoft 队列的数据元素定义需自行实现 Item
			Console.WriteLine(message);
		}
		public void Enqueue(Item item)
		{
			//Microshaoft 队列的数据元素定义需自行实现 Item
			_AsyncQueue.Enqueue(item);
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _AsyncQueue.ConcurrentThreadsCount;
			}
		}
		public int Count
		{
			get
			{
				return _AsyncQueue.Count;
			}
		}
		public void DequeueProcess(Item item)
		{
			DateTime DequeueBeginTime = DateTime.Now;
			if (OnDequeue != null)
			{
				OnDequeue(item);
			}
			DateTime DequeueEndTime = DateTime.Now;
			Console.WriteLine
						(
							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
							, _AsyncQueue.Count
							, item.EnqueueTime
							, DequeueBeginTime
							, (DequeueBeginTime.Ticks - item.EnqueueTime.Ticks) / 10000 /1000
							, DequeueEndTime
							, (DequeueEndTime.Ticks - DequeueBeginTime.Ticks) / 10000 /1000
							, _AsyncQueue.ConcurrentThreadsCount
						);
		}
	}
}
//===============================================
// Share.cs
//Server、Client 均需引用此 share.dll
//C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc.exe /t:library share.cs
//TO DO
//队列的数据元素定义需自行实现,示例如下:
namespace Microshaoft.RemotingObjects.Share
{
	using System;
	[Serializable]
	public class Item
	{
		private string _Name;
		public string Name
		{
			get
			{
				return _Name;
			}
			set
			{
				_Name = value; 
			}
		}
		private DateTime _EnqueueTime;
		public DateTime EnqueueTime
		{
			get
			{
				return _EnqueueTime;
			}
			set
			{
				_EnqueueTime = value; 
			}
		}
	}
}
// remoting helper
//Share.cs
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Text;
	public static class RemotingHelper
	{
		public static void StartRemoting
			(
				Type RemotingType
				, string Url
				, int Port
			)
		{
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
			IDictionary ht = new Hashtable();
			ht["port"] = Port;
			TcpChannel tc = new TcpChannel(ht, null, provider);
			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, WellKnownObjectMode.Singleton);
			Console.WriteLine("Remoting Object Started ...");
		}
		public static void StartRemoting<T>
			(
				string Url
				, int Port
			)
		{
			StartRemoting(typeof(T), Url, Port);
		}
		public static T GetRemotingLocalClientProxyObject<T>
			(
				string Url
			)
		{
			return (T) Activator.GetObject
									(
										typeof(T)
										, Url
										//, "tcp://127.0.0.1:8080/queueUrl"
									);
		}
	}
}
//============================================
// Client.cs
//C:\WINDOWS\Microsoft.NET\Framework\v1.1.4322\csc.exe client.cs /r:share.dll
namespace Microshaoft.RemotingObjects.Client
{
	using System;
	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Threading;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static RemotingAsyncQueue _queue;
		public static void Main()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
		}
		public void Run()
		{
			_queue = RemotingHelper.GetRemotingLocalClientProxyObject<RemotingAsyncQueue>("tcp://127.0.0.1:8080/queueUrl");
			//Microshaoft 以下是耗时的主程序
			for (int i = 0; i < 50; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public void ThreadProcess()
		{
			for (int i = 0; i < 800; i++)
			{
				Item x = new Item();
				DateTime EnqueueTime = DateTime.Now;
				x.Name = EnqueueTime.ToString();
				x.EnqueueTime = EnqueueTime;
				_queue.Enqueue(x);
				Console.WriteLine
							(
								"Enqueue: {0},[{1}]"
								, EnqueueTime
								, (DateTime.Now.Ticks - EnqueueTime.Ticks)/10000/1000
							);
			}
		}
	}
}
//Microshaoft =========================================
//Microshaoft Remoting Object Client Local Proxy
namespace Microshaoft.RemotingObjects
{
	using System;
	using Microshaoft.RemotingObjects.Share;
	public interface RemotingAsyncQueue
	{
		void Enqueue(Item item);
	}
}

#T=RemotingHelper
//Server.cs
namespace Microshaoft.RemotingObjects
{
	using System;
	using System.Collections;
	
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;

	using Microshaoft.RemotingObjects.Share;
	using Microshaoft;

	
	class BillingServiceRemoting : MarshalByRefObject
	{
		public static readonly string ServiceName = "Billing Remoting Service";
		public string HelloWorld
			(
				string User
			)
		{
			Console.WriteLine("Helo");
			return "Hello " + User;
		}


		public BillingResponse Billing
			(
				string UserID
				, string ProductID
				, string BizModel
				, string IP
				, string TimeStamp
			)
		{
			BillingResponse response = new BillingResponse();
			response.Result = 0; //表示成功
			response.Description = "成功了耶";
			Console.WriteLine("bill");
			return response;
		}
	}
}


namespace Microshaoft
{
	using System;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Security.Principal;
	using System.Configuration.Install;
	using System.Runtime.Remoting;

	using Microshaoft.RemotingObjects;

	public class SimpleService : ServiceBase //继承于 ServiceBase
	{
		public static readonly string serviceName = "Hello-World Service1";

		public static void Main(string[] args)
		{
			SimpleService x = new SimpleService();
			int l = 0;
			if (args != null)
			{
				l = args.Length;
			}

			if (l > 0) //有参数时以 console 方式运行
			{
				Console.WriteLine("Run as Console");
				x.OnStart(null);
				Console.ReadLine();
			}
			else 
			//intallutil 成服务后
			//即: 无参数时,以 Service 方式运行
			{
				Console.WriteLine("Run as Service");
				ServiceBase.Run(x);
			}
		}
		public SimpleService()
		{
			CanPauseAndContinue = true;
			ServiceName = SimpleService.serviceName;
		}

		protected override void OnStart(string[] args)
		{

			Console.WriteLine(".Net Version: {0}", Environment.Version.ToString());
			Console.WriteLine("Current Identity: {0}", WindowsIdentity.GetCurrent().Name);
			Console.WriteLine("{0} started,at {1}", SimpleService.serviceName, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ss"));

			RemotingHelper.StartRemoting<BillingServiceRemoting>
								(
									"testurl"
									, 9090
									, WellKnownObjectMode.Singleton
								);

			//log 写入 windows 应用程序日志
			EventLog.WriteEntry(string.Format(".Net Version: {0}", Environment.Version.ToString()));
			EventLog.WriteEntry(string.Format("Current Identity: {0}", WindowsIdentity.GetCurrent().Name));
			EventLog.WriteEntry(string.Format("{0} started, at {1}", SimpleService.serviceName, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ss")));

			//在这里写你的程序
		}

///		protected override void OnStop()
///		{
///			EventLog.WriteEntry("Hello-World Service stopped");
///		}
///
///		protected override void OnPause()
///		{
///			EventLog.WriteEntry("Hello-World Service paused");
///		}
///
///		protected override void OnContinue()
///		{
///			EventLog.WriteEntry("Hello-World Service continued");
///		}
	}

	//以下就是比普通应用程序多出的 ProjectInstaller
	[RunInstallerAttribute(true)]
	public class ProjectInstaller: Installer
	{

		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;

		public ProjectInstaller()
		{

			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();

			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;

			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;

			serviceInstaller.ServiceName = SimpleService.serviceName;

			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
//Share.cs
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	using System.Text;

	public static class RemotingHelper
	{
		public static void StartRemoting
			(
				Type RemotingType
				, string Url
				, int Port
				, WellKnownObjectMode ServiceMode
			)
		{
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
			IDictionary ht = new Hashtable();
			ht["port"] = Port;
			TcpChannel tc = new TcpChannel(ht, null, provider);
			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, ServiceMode);
			Console.WriteLine("Remoting Object Started ...");
		}
		public static void StartRemoting<T>
			(
				string Url
				, int Port
				, WellKnownObjectMode Mode
			)
		{
			StartRemoting(typeof(T), Url, Port, Mode);
		}
		public static T GetRemotingLocalClientProxyObject<T>
			(
				string Url
			)
		{
			return (T) Activator.GetObject
									(
										typeof(T)
										, Url
									);
		}
	}
}

namespace Microshaoft.RemotingObjects.Share
{
	using System;

	[Serializable]
	public class BillingResponse
	{
		private int _Result;
		public int Result
		{
			get
			{
				return _Result;
			}
			set
			{
				_Result = value;
			}
		}

		private string _Description;

		public string Description
		{
			get
			{
				return _Description;
			}
			set
			{
				_Description = value;
			}
		}

	}
}
//client.cs
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
	using Microshaoft.RemotingObjects;
	using Microshaoft.RemotingObjects.Share;

		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			

			BillingServiceRemoting x = RemotingHelper.GetRemotingLocalClientProxyObject<BillingServiceRemoting>("tcp://127.0.0.1:9090/testUrl");
			BillingResponse y = x.Billing("1", "2", "3", "4", "5");
			//x.HelloWorld("asdas");
			Console.WriteLine(x.HelloWorld("asdas"));
			Console.WriteLine(y.Description);
			Console.WriteLine(Environment.Version.ToString());
		}
	}

}


namespace Microshaoft.RemotingObjects
{
	using System;
	using Microshaoft.RemotingObjects.Share;


	public interface BillingServiceRemoting
	{
		BillingResponse Billing
			(
				string UserID
				, string ProductID
				, string BizModel
				, string IP
				, string TimeStamp
			);
		string HelloWorld(string s);
	}
}

#T=RemotingQueue HeartBeat
/*
Remoting 异步队列实现,流程如下
1.并发若干客户端程序通过调用 RemotingQueue Server 提供的公开远程方法 Enqueue 将数据元素入队尾
2.RemotingQueue Server 发现队列不为空,则并发若干线程陆续 Dequeue 队首数据元素并处理

注意:
1.队列的数据元素定义需自行实现
2.对出列数据元素的处理程序需自行实现
*/
// server.cs
//C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc.exe server.cs /r:share.dll
//.Net 2.0 Remoting 宿主程序 服务 + Console
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;

	using System.Collections;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;

	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Configuration.Install;

	using Com.Gsta.Remoting.Share;
	using	Com.Gsta.Remoting.Server;

	using System.Data.SqlClient;
	using System.Data;

	public class RemotingQueueServiceHost : ServiceBase
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//Microshaoft
			//Microshaoft TODO: 在此处添加代码以启动应用程序
			//Microshaoft 
			RemotingQueueServiceHost service = new RemotingQueueServiceHost();
			if (args != null)
			{
				Console.WriteLine("Console");
				service.OnStart(null);
				Console.ReadLine();
				return;
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
		}
		TcpChannel tc = null;
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
//
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
//
			IDictionary props = new Hashtable();
			props["port"] = 9080;

			//tc = new TcpChannel(9080);
				tc = new TcpChannel(props, null, provider);

			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType
									(
										typeof(RemotingQueue)
										, "msgqueueurl"
										, WellKnownObjectMode.Singleton
									);
			RemotingQueue.OnDequeue += new RemotingQueue.QueueEventHandler(DequeueProcess);
			Console.WriteLine("Server . , Press Enter key to exit.");
		}

		private static SqlConnection _sqlConnection = new SqlConnection(@"Application Name=MaxTest;server=vnetappdbsvr;Integrated Security=SSPI;Persist Security Info=False;database=pluginbackend");
//		private static SqlConnection _sqlConnection = new SqlConnection(@"Application Name=MaxTest;server=vnetappdbsvr;Integrated Security=SSPI;Persist Security Info=False;database=pluginbackend;connection reset=false;connection lifetime=5;min pool size=1;max pool size=100");
		public static void DequeueProcess(RemoteHBInfo item)
		{
			//Microshaoft TO DO
			//Microshaoft 队列的数据元素定义需自行实现
			//Microshaoft 数据库访问
			//Microshaoft 发邮件等

			DateTime DequeueTime = DateTime.Now;

			//Microshaoft Thread.Sleep(100); //Microshaoft 模拟长时间任务

						   
			   Console.WriteLine("insert {0}",DequeueTime);
			//读数据库
			//发邮件等
			//使用 .Net 2.0 SmtpClient
			//Thread.Sleep(200); //长时间任务

//			using (SqlConnection conn = new SqlConnection(_ConnectionString))
//			{
				
				try
				{

					SqlCommand sqlCommand = new SqlCommand("p_heartbeat_proc", _sqlConnection);
					sqlCommand.CommandType = CommandType.StoredProcedure;
					sqlCommand.Parameters.Add("@token", SqlDbType.VarChar, 40).Value = item.Token;
					sqlCommand.Parameters.Add("@heartbeattime", SqlDbType.DateTime).Value = item.HeartBeatTime;
					if (_sqlConnection.State != ConnectionState.Open)
					{
						_sqlConnection.Open();
					}

					sqlCommand.ExecuteNonQuery();
				}
				catch (Exception e)
				{
					//LogHelper.WriteLog(LogHelper.LogPath + DateTime.Now.ToString("yyyy-MM-dd") + ".log.txt", e.Message, "Exception");
					Console.WriteLine("SQL e: {0}",e.Message);
				}
				finally
				{
					if (RemotingQueue.Count == 0)
					{
						_sqlConnection.Close();
						Console.WriteLine("Close");
					}

				//	conn.Dispose();
				}
//			}

			DateTime EndTime = DateTime.Now;
			Console.WriteLine
						(
							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
							, RemotingQueue.Count
							, item.HeartBeatTime
							, DequeueTime
							, (DequeueTime.Ticks - item.HeartBeatTime.Ticks)/10000
							, EndTime
							, (EndTime.Ticks - DequeueTime.Ticks)/10000
							, RemotingQueue.ConcurrentThreadsCount
						);
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller: Installer
	{

		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;

		public ProjectInstaller()
		{

			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();

			//Microshaoft  Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;

			//Microshaoft  Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;

			serviceInstaller.ServiceName = "RemotingQueueService";

			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
//Microshaoft =====================
//Microshaoft Remoting Server Object

namespace Com.Gsta.Remoting.Server
{
	using System;
	using System.IO;
	using System.Net;
	using System.Web;
	using System.Text;

	using System.Threading;
	using System.Configuration;

	using System.Collections.Generic;

	using Com.Gsta.Remoting.Share;

	public class RemotingQueue : MarshalByRefObject
	{
		public delegate void QueueEventHandler(RemoteHBInfo item);
		public static event QueueEventHandler OnDequeue;

		private static Queue<RemoteHBInfo> _Queue = new Queue<RemoteHBInfo>();
		private static object _SyncLockObject = new object();
		private static int _MaxConcurrentThreadsCount = 10; //Microshaoft 允许并发出列处理线程数为 10
		private static int _ConcurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数 

		private static bool _QueueRuning = false;


		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private static void QueueRun() //Microshaoft ThreadStart
		{
			if (!_QueueRuning)
			{
				_QueueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}

		public static int Count
		{
			get
			{
				return _Queue.Count;
			}
		}

		public static int ConcurrentThreadsCount
		{
			get
			{
				return _ConcurrentThreadsCount;
			}
		}

		private static void QueueRunThreadProcess()
		{
			Console.WriteLine("Queue Runing ");
			while (_Queue.Count > 0) //Microshaoft 死循环
			{
				RemoteHBInfo item = null;
				lock(_SyncLockObject)
				{
					if (_ConcurrentThreadsCount < _MaxConcurrentThreadsCount)
					{
						if (_Queue.Count > 0)
						{
							_ConcurrentThreadsCount ++;
							item = _Queue.Dequeue();
						}
					}
				}
				if (item != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkRemoteHBInfo(new WaitCallback(OnDequeueThreadProcess), item);
					ThreadProcessState tps = new ThreadProcessState();

					tps.RemoteHBInfo = item;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", _ConcurrentThreadsCount);
					t.Start();
				}
			}
			_QueueRuning = false;
			Console.WriteLine("Queue Running Stopped ");
		}

		public void Enqueue(RemoteHBInfo item)
		{
			//Microshaoft 队列的数据元素定义需自行实现 RemoteHBInfo
			item.HeartBeatTime = DateTime.Now;
			Console.WriteLine("Enqueue {0},qL {1}", item.Token, _Queue.Count);
			_Queue.Enqueue(item);

			if (!_QueueRuning)
			{
				QueueRun();
			}
		}

		private static void OnDequeueThreadProcess(RemoteHBInfo item)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(item);
				}
				DequeueThreadProcess();
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
			}
			finally
			{
				lock (_SyncLockObject)
				{
					//Microshaoft Console.WriteLine("工作线程数: {0}", _ConcurrentThreadsCount - 1);
					_ConcurrentThreadsCount --;
				}
			}
		}
		static int count = 0;
		private static void DequeueThreadProcess()
		{
			while (_Queue.Count > 0)
			{
				RemoteHBInfo item = null;
				lock (_SyncLockObject)
				{
					if (_Queue.Count > 0)
					{
						item = _Queue.Dequeue();
						count ++;
						//Microshaoft Console.WriteLine("Queue Count: {0},count: {1}", _Queue.Count, count);
					}
				}
				if (item != null)
				{

					if (OnDequeue != null)
					{
						OnDequeue(item);
					}

				}
			}
		}

		private class ThreadProcessState
		{
			private RemoteHBInfo _item;
			public RemoteHBInfo RemoteHBInfo
			{
				get
				{
					return _item;
				}
				set
				{
					_item = value;
				}
			}
			public void ThreadProcess()
			{
				//Microshaoft Console.WriteLine("{0} Thread Start:", Thread.CurrentThread.Name);
				RemotingQueue.OnDequeueThreadProcess(_item);
				//Microshaoft Console.WriteLine("{0} Thread End!", Thread.CurrentThread.Name);
				if (RemotingQueue._ConcurrentThreadsCount == 0)
				{
					Console.WriteLine("All Threads Finished! Queue Count {0}", RemotingQueue.Count);
				}
			}
		}
	}
}
///*
namespace Com.Gsta.Remoting.Share {
	using System;
	[Serializable]
	public class RemoteHBInfo {
		private string _Token;
		private DateTime _HeartBeatTime;

		public string Token {
			get {
				return _Token;
			}
			set {
				_Token = value;
			}
		}

		public DateTime HeartBeatTime {
			get {
				return _HeartBeatTime;
			}
			set {
				_HeartBeatTime = value;
			}
		}
	}

}
//*/
#T=Request Test Aspx
<%@
	Page
	language="c#"
	AutoEventWireup="true"
%>

<%@ Import Namespace="System.Data" %>
<%@ Import Namespace="System.Data.SqlClient" %>
<%@ Import Namespace="System.Security.Principal" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.Threading" %>

<script language="C#" runat="server">
	private static byte[] ReadStreamToBytes(Stream stream)
	{
		byte[] buffer = new byte[64 * 1024];
		MemoryStream ms = new MemoryStream();
		int r = 0;
		int l = 0;
		long position = -1;

		if (stream.CanSeek)
		{
			position = stream.Position;
			stream.Position = 0;
		}

		while (true)
		{
			r = stream.Read(buffer, 0, buffer.Length);
			if (r > 0)
			{
				l += r;
				ms.Write(buffer, 0, r);
			}
			else
			{
				break;
			}
		}
		byte[] bytes = new byte[l];
		ms.Position = 0;
		ms.Read(bytes, 0, (int)l);
		ms.Close();
		ms = null;
		if (position >= 0)
		{
			stream.Position = position;
		}
		return bytes;

	}
protected void Page_Load(object sender, EventArgs ea) 
{

		Response.Write("Request.InputStream body<br>");
		byte[] buffer = ReadStreamToBytes(Request.InputStream);
		Response.Write(buffer.Length + "<br>");
		Response.Write(Request.ContentLength + "<br>");
		buffer = HttpUtility.UrlDecodeToBytes(buffer);
		string s = Encoding.ASCII.GetString(buffer);
		Response.Write(Server.HtmlEncode(s) + "<br>");
		s = Encoding.UTF8.GetString(buffer);
		Response.Write(Server.HtmlEncode(s) + "<br>");
		s = Encoding.GetEncoding("gb2312").GetString(buffer);
		Response.Write(Server.HtmlEncode(s) + "<br>");

		Response.Write("============================================<br>");

	WindowsPrincipal wp = new WindowsPrincipal(WindowsIdentity.GetCurrent());
	IIdentity identity = WindowsIdentity.GetCurrent();
	string username = identity.Name;
	Response.Write("<br>WindowsIdentity.GetCurrent(): " + username );
	identity = Thread.CurrentPrincipal.Identity;
	username = identity.Name;
	Response.Write("<br>Thread.CurrentPrincipal.Identity: " + username );
	identity = Context.User.Identity;
	Response.Write("<br>HttpContext.User.Identity: " + username );

	Response.Write("<br>.Net Framework version: " + Environment.Version.ToString()+ "<br>" );

	Response.Write("IP:<br>");
	Response.Write(string.Format("Your current IP is {0}<br>", Request.UserHostAddress));

	Response.Write("Request.ContentEncoding:<br>");
	Encoding e = Request.ContentEncoding;
	Response.Write(string.Format("&nbsp;&nbsp;&nbsp;&nbsp;{0},{1}<br>", e.EncodingName, e.HeaderName));

	Response.Write("Request.Cookies:<br>");
	foreach (string var in Request.Cookies.AllKeys)
	{
		Response.Write(string.Format("&nbsp;&nbsp;&nbsp;&nbsp;{0}:{1}<br>", var, Request.Cookies[var].Value));
	}

	Response.Write("Request.Form:<br>");
	foreach (string var in Request.Form.AllKeys)
	{
		Response.Write(string.Format("&nbsp;&nbsp;&nbsp;&nbsp;{0}:{1}<br>", var, Request.Form[var]));
	}

	Response.Write("Request.QueryString:<br>");
	foreach (string var in Request.QueryString.AllKeys)
	{
		Response.Write(string.Format("&nbsp;&nbsp;&nbsp;&nbsp;{0}:{1}<br>", var, Request.QueryString[var]));
	}

	Response.Write("Request.ServerVariables:<br>");
	foreach (string var in Request.ServerVariables.AllKeys)
	{
		Response.Write(string.Format("&nbsp;&nbsp;&nbsp;&nbsp;{0}:{1}<br>", var, Request.ServerVariables[var]));
	}
}
</script>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
	<title></title>
</head>
<body>
	<form id="form1" runat="server">
		<div>

		</div>
	</form>
</body>
</html>
#T=RSA CSP Sample
namespace Microshaoft
{
	using System;
	using System.Security.Cryptography;
	using System.Text;

	class RSACSPSample
	{

		static void Main()
		{

			UTF8Encoding e = new UTF8Encoding();

			byte[] dataToEncrypt = e.GetBytes("于溪h@microshaoft.com");
			byte[] encryptedData;
			byte[] decryptedData;

			RSACryptoServiceProvider x = new RSACryptoServiceProvider();

			string privateKey = x.ToXmlString(true);
			string publicKey = x.ToXmlString(false);

			encryptedData = RSAEncrypt(dataToEncrypt, publicKey, false);

			//公钥加密
			decryptedData = RSADecrypt(encryptedData, privateKey, false);

			//私钥解密
			Console.WriteLine("Decrypted plaintext: {0}", e.GetString(decryptedData));


			//私钥签名
			byte[] signature = RSASignSHA1(dataToEncrypt, privateKey);
			//公钥验签
			Console.WriteLine(RSAVerifySHA1(dataToEncrypt,publicKey,signature));


		}


		static public byte[] RSASignSHA1
			(
				byte[] data
				, string privateKey
			)
		{
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			x.FromXmlString(privateKey);
			return x.SignHash
						(
							new SHA1CryptoServiceProvider().ComputeHash(data)
							, "SHA1"
						);
		}

		static public bool RSAVerifySHA1
								(
									byte[] data
									, string publicKey
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.VerifyHash
								(
									new SHA1CryptoServiceProvider().ComputeHash(data)
									, "SHA1"
									, signature
								);
		}

		static public byte[] RSASignMD5
			(
				byte[] data
				, string privateKey
			)
		{
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			x.FromXmlString(privateKey);
			return x.SignHash
						(
							new MD5CryptoServiceProvider().ComputeHash(data)
							, "MD5"
						);
		}

		static public bool RSAVerifyMD5
								(
									byte[] data
									, string publicKey
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.VerifyHash
								(
									new MD5CryptoServiceProvider().ComputeHash(data)
									, "MD5"
									, signature
								);
		}


		static public byte[] RSAEncrypt
								(
									byte[] data
									, string publicKey
									, bool DoOAEPPadding
								)
		{
				RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
				provider.FromXmlString(publicKey);
				return provider.Encrypt(data, DoOAEPPadding);
		}

		static public byte[] RSADecrypt
								(
									byte[] data
									, string privateKey
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKey);
			return provider.Decrypt(data, DoOAEPPadding);
		}
	}

}
#T=Scroll Zoom Image View
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;
	public partial class Form1 : Form
	{
		public Form1()
		{
			InitializeComponent();
		}

		private void imagePanel1_Click(object sender, EventArgs e)
		{
			if (openFileDialog1.ShowDialog() == DialogResult.OK)
			{
				Bitmap b = new Bitmap(openFileDialog1.FileName);
			   //imagePanel1.CanvasSize = b.Size;
				imagePanel1.Image = b;
			}
		}

		private void trackBar1_Scroll(object sender, EventArgs e)
		{
			imagePanel1.Zoom = trackBar1.Value * 0.02f;
		}
	}
}

namespace Test
{
	using Microshaoft;
	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
			this.trackBar1 = new System.Windows.Forms.TrackBar();
			this.imagePanel1 = new ImagePanel();
			((System.ComponentModel.ISupportInitialize)(this.trackBar1)).BeginInit();
			this.SuspendLayout();
			// 
			// openFileDialog1
			// 
			this.openFileDialog1.FileName = "openFileDialog1";
			// 
			// trackBar1
			// 
			this.trackBar1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.trackBar1.Location = new System.Drawing.Point(143, 301);
			this.trackBar1.Maximum = 200;
			this.trackBar1.Minimum = 1;
			this.trackBar1.Name = "trackBar1";
			this.trackBar1.Size = new System.Drawing.Size(159, 45);
			this.trackBar1.TabIndex = 1;
			this.trackBar1.TickFrequency = 10;
			this.trackBar1.Value = 100;
			this.trackBar1.Scroll += new System.EventHandler(this.trackBar1_Scroll);
			// 
			// imagePanel1
			// 
			this.imagePanel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
						| System.Windows.Forms.AnchorStyles.Left)
						| System.Windows.Forms.AnchorStyles.Right)));
			this.imagePanel1.CanvasSize = new System.Drawing.Size(600, 400);
			this.imagePanel1.Image = null;
			this.imagePanel1.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.Default;
			this.imagePanel1.Location = new System.Drawing.Point(12, 12);
			this.imagePanel1.Name = "imagePanel1";
			this.imagePanel1.Size = new System.Drawing.Size(411, 283);
			this.imagePanel1.TabIndex = 0;
			this.imagePanel1.Zoom = 1F;
			this.imagePanel1.Click += new System.EventHandler(this.imagePanel1_Click);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(435, 347);
			this.Controls.Add(this.trackBar1);
			this.Controls.Add(this.imagePanel1);
			this.Name = "Form1";
			this.Text = "Form1";
			((System.ComponentModel.ISupportInitialize)(this.trackBar1)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private ImagePanel imagePanel1;
		private System.Windows.Forms.OpenFileDialog openFileDialog1;
		private System.Windows.Forms.TrackBar trackBar1;
	}
}


// user control begin
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Drawing;
	using System.Drawing.Drawing2D;
	using System.Data;
	using System.Text;
	using System.Windows.Forms;
	public partial class ImagePanel : UserControl
	{
		public ImagePanel()
		{
			InitializeComponent();

			// Set the value of the double-buffering style bits to true.
			this.SetStyle(ControlStyles.AllPaintingInWmPaint |
			  ControlStyles.UserPaint | ControlStyles.ResizeRedraw |
			  ControlStyles.UserPaint | ControlStyles.DoubleBuffer, true);
		}

		int viewRectWidth, viewRectHeight; // view window width and height

		float zoom = 1.0f;
		public float Zoom
		{
			get { return zoom; }
			set
			{
				if (value < 0.001f) value = 0.001f;
				zoom = value;

				displayScrollbar();
				setScrollbarValues();
				Invalidate();
			}
		}

		Size canvasSize = new Size(60, 40);
		public Size CanvasSize
		{
			get { return canvasSize; }
			set
			{
				canvasSize = value;
				displayScrollbar();
				setScrollbarValues();
				Invalidate();
			}
		}

		Bitmap image;
		public Bitmap Image
		{
			get { return image; }
			set 
			{
				image = value;
				displayScrollbar();
				setScrollbarValues(); 
				Invalidate();
			}
		}

		InterpolationMode interMode = InterpolationMode.HighQualityBilinear;
		public InterpolationMode InterpolationMode
		{
			get{return interMode;}
			set{interMode=value;}
		}

		protected override void OnLoad(EventArgs e)
		{
			displayScrollbar();
			setScrollbarValues();
			base.OnLoad(e);
		}

		protected override void OnResize(EventArgs e)
		{
			displayScrollbar();
			setScrollbarValues();
			base.OnResize(e);
		}

		protected override void OnPaint(PaintEventArgs e)
		{
			 base.OnPaint(e);

			//draw image
			if(image!=null)
			{
				Rectangle srcRect,distRect;
				Point pt=new Point((int)(hScrollBar1.Value/zoom),(int)(vScrollBar1.Value/zoom));
				if (canvasSize.Width * zoom < viewRectWidth && canvasSize.Height * zoom < viewRectHeight)
					srcRect = new Rectangle(0, 0, canvasSize.Width, canvasSize.Height);  // view all image
				else srcRect = new Rectangle(pt, new Size((int)(viewRectWidth / zoom), (int)(viewRectHeight / zoom))); // view a portion of image

				distRect=new Rectangle((int)(-srcRect.Width/2),-srcRect.Height/2,srcRect.Width,srcRect.Height); // the center of apparent image is on origin
 
				Matrix mx=new Matrix(); // create an identity matrix
				mx.Scale(zoom,zoom); // zoom image
				mx.Translate(viewRectWidth/2.0f,viewRectHeight/2.0f, MatrixOrder.Append); // move image to view window center

				Graphics g=e.Graphics;
				g.InterpolationMode=interMode;
				g.Transform=mx;
				g.DrawImage(image,distRect,srcRect, GraphicsUnit.Pixel);
			}

		}

		private void displayScrollbar()
		{
			viewRectWidth = this.Width;
			viewRectHeight = this.Height;

			if (image != null) canvasSize = image.Size;

			// If the zoomed image is wider than view window, show the HScrollBar and adjust the view window
			if (viewRectWidth > canvasSize.Width*zoom)
			{
				hScrollBar1.Visible = false;
				viewRectHeight = Height;
			}
			else
			{
				hScrollBar1.Visible = true;
				viewRectHeight = Height - hScrollBar1.Height;
			}

			// If the zoomed image is taller than view window, show the VScrollBar and adjust the view window
			if (viewRectHeight > canvasSize.Height*zoom)
			{
				vScrollBar1.Visible = false;
				viewRectWidth = Width;
			}
			else
			{
				vScrollBar1.Visible = true;
				viewRectWidth = Width - vScrollBar1.Width;
			}

			// Set up scrollbars
			hScrollBar1.Location = new Point(0, Height - hScrollBar1.Height);
			hScrollBar1.Width = viewRectWidth;
			vScrollBar1.Location = new Point(Width - vScrollBar1.Width, 0);
			vScrollBar1.Height = viewRectHeight;
		}

		private void setScrollbarValues()
		{
			// Set the Maximum, Minimum, LargeChange and SmallChange properties.
			this.vScrollBar1.Minimum = 0;
			this.hScrollBar1.Minimum = 0;

			// If the offset does not make the Maximum less than zero, set its value. 
			if ((canvasSize.Width * zoom - viewRectWidth) > 0)
			{
				this.hScrollBar1.Maximum =(int)( canvasSize.Width * zoom) - viewRectWidth;
			}
			// If the VScrollBar is visible, adjust the Maximum of the 
			// HSCrollBar to account for the width of the VScrollBar.  
			if (this.vScrollBar1.Visible)
			{
				this.hScrollBar1.Maximum += this.vScrollBar1.Width;
			}
			this.hScrollBar1.LargeChange = this.hScrollBar1.Maximum / 10;
			this.hScrollBar1.SmallChange = this.hScrollBar1.Maximum / 20;

			// Adjust the Maximum value to make the raw Maximum value 
			// attainable by user interaction.
			this.hScrollBar1.Maximum += this.hScrollBar1.LargeChange;

			// If the offset does not make the Maximum less than zero, set its value.	
			if ((canvasSize.Height * zoom - viewRectHeight) > 0)
			{
				this.vScrollBar1.Maximum = (int)(canvasSize.Height * zoom) - viewRectHeight;
			}

			// If the HScrollBar is visible, adjust the Maximum of the 
			// VSCrollBar to account for the width of the HScrollBar.
			if (this.hScrollBar1.Visible)
			{
				this.vScrollBar1.Maximum += this.hScrollBar1.Height;
			}
			this.vScrollBar1.LargeChange = this.vScrollBar1.Maximum / 10;
			this.vScrollBar1.SmallChange = this.vScrollBar1.Maximum / 20;

			// Adjust the Maximum value to make the raw Maximum value 
			// attainable by user interaction.
			this.vScrollBar1.Maximum += this.vScrollBar1.LargeChange;
		}

		private void vScrollBar1_Scroll(object sender, ScrollEventArgs e)
		{
			this.Invalidate();
		}
	}
}
namespace Microshaoft
{
	partial class ImagePanel
	{
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Component Designer generated code

		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.hScrollBar1 = new System.Windows.Forms.HScrollBar();
			this.vScrollBar1 = new System.Windows.Forms.VScrollBar();
			this.SuspendLayout();
			// 
			// hScrollBar1
			// 
			this.hScrollBar1.Location = new System.Drawing.Point(32, 119);
			this.hScrollBar1.Name = "hScrollBar1";
			this.hScrollBar1.Size = new System.Drawing.Size(80, 17);
			this.hScrollBar1.TabIndex = 0;
			this.hScrollBar1.Scroll += new System.Windows.Forms.ScrollEventHandler(this.vScrollBar1_Scroll);
			// 
			// vScrollBar1
			// 
			this.vScrollBar1.Location = new System.Drawing.Point(95, 21);
			this.vScrollBar1.Name = "vScrollBar1";
			this.vScrollBar1.Size = new System.Drawing.Size(17, 80);
			this.vScrollBar1.TabIndex = 1;
			this.vScrollBar1.Scroll += new System.Windows.Forms.ScrollEventHandler(this.vScrollBar1_Scroll);
			// 
			// ImagePanel
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.Controls.Add(this.vScrollBar1);
			this.Controls.Add(this.hScrollBar1);
			this.Name = "ImagePanel";
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.HScrollBar hScrollBar1;
		private System.Windows.Forms.VScrollBar vScrollBar1;
	}
}

#T=Search disk Directory and Files
namespace Microshaoft
{
	/// <summary>
	/// .Net/C# 实现磁盘目录文件搜索的工具类 (搜索事件)
	/// </summary>
	using System;
	using System.IO;
	using System.Collections.Generic;
	public class Search
	{
		/// <summary>
		/// 递归
		/// </summary>
		/// <param name="SourceDirectory">被搜索的源目录</param>
		/// <param name="DirectoryPatterns">源目录下面的所有子目录的搜索匹配模式</param>
		/// <param name="FilePatterns">源目录下面的所有文件的搜索匹配模式</param>
		/// <param name="DestinationDirectory">存储相对路径</param>
		private void Searching(string SourceDirectory, string DirectoryPatterns, string FilePatterns, string DestinationDirectory)
		{
			this._DirectoryPatterns = DirectoryPatterns;
			this._FilePatterns = FilePatterns;
			string[] Patterns = this._DirectoryPatterns.Split(';');
			string[] patterns = this._FilePatterns.Split(';');
			this._DirectoryID = 0;
			this._FileID = 0;
			DestinationDirectory += (DestinationDirectory.EndsWith(@"\") ? "" : @"\");
			if (this._DirectoriesCount == 0) //处理源目录的当前的文件
			{
				this._DirectoriesCount++;
				this._DirectoryID++;
				this._CurrentDirectoryName = SourceDirectory;
				if (SourceDirectory.EndsWith(@"\"))
				{
					this._CurrentDirectoryName = SourceDirectory.Substring(0, SourceDirectory.Length - 1);
				}
				this._ParentDirectoryName = this._CurrentDirectoryName.Substring(this._CurrentDirectoryName.LastIndexOf(@"\") + 1);
				DestinationDirectory += this._ParentDirectoryName + @"\";
				this._CurrentDestinationDirectoryName = DestinationDirectory;
				if (this.AddSearchedDirectory(this._CurrentDirectoryName))
				{
					this._DirectoryUID++;
				}
				if (SearchedDirectory != null) //触发一次找到源目录的事件
				{
					OnSearchedDirectory(SourceDirectory, this._DirectoriesCount, this._DirectoryID, this._CurrentDestinationDirectoryName);
				}
				foreach (string p in patterns)
				{
					foreach (string f in Directory.GetFiles(SourceDirectory, p.Trim()))
					{
						this._FilesCount++;
						this._FileID++;
						if (this.AddSearchedFile(f))
						{
							this._FileUID++;
						}
						if (SearchedFile != null)
						{
							OnSearchedFile(f, DirectoryUID, FileUID, this._DirectoryID, this.FileID, this._CurrentDestinationDirectoryName);
						}
						if (this._Cancel != CancelActions.No)
						{
							break;
						}
					}
					if (this._Cancel != CancelActions.No)
					{
						break;
					}
				}
			}
			if (this._Cancel != CancelActions.AllDirectories)
			{
				this._FileID = 0;
				this._DirectoryID = 0;
				foreach (string P in Patterns)
				{
					if (this._Cancel != CancelActions.AllDirectories)
					{
						foreach (string d in Directory.GetDirectories(SourceDirectory, P.Trim()))
						{
							if (this._Cancel != CancelActions.AllDirectories)
							{
								this._DirectoriesCount++;
								this._DirectoryID++;
								this._CurrentDirectoryName = d + (d.EndsWith(@"\") ? "" : @"\");
								this._CurrentDestinationDirectoryName = DestinationDirectory + d.Substring(d.LastIndexOf(@"\") + 1) + @"\";
								if (this.AddSearchedDirectory(this._CurrentDirectoryName))
								{
									this._DirectoryUID++;
								}
								if (SearchedDirectory != null)
								{
									OnSearchedDirectory(d, DirectoryUID, this._DirectoryID, this._CurrentDestinationDirectoryName);
								}
								if (this._Cancel == CancelActions.CurrentDirectory)
								{
									this._Cancel = CancelActions.No;
									continue;
								}
								else if (this._Cancel == CancelActions.AllDirectories)
								{
									break;
								}
								if (this._Cancel != CancelActions.AllDirectories)
									foreach (string p in patterns)
									{
										foreach (string f in Directory.GetFiles(d, p.Trim()))
										{
											this._FilesCount++;
											this._FileID++;
											if (this.AddSearchedFile(f))
											{
												this._FileUID++;
											}
											if (SearchedFile != null)
											{
												OnSearchedFile(f, DirectoryUID, FileUID, this._DirectoryID, this.FileID, this._CurrentDestinationDirectoryName);
											}
											if (this._Cancel != CancelActions.No)
											{
												break;
											}
										}
										if (this._Cancel != CancelActions.No)
										{
											break;
										}
									}
								if (this._Cancel == CancelActions.CurrentDirectory)
								{
									this._Cancel = CancelActions.No;
									continue;
								}
								else if (this._Cancel == CancelActions.AllDirectories)
								{
									break;
								}
								if (this._Cancel != CancelActions.AllDirectories)
								{
									this._Nest++;
									Searching(d, this._DirectoryPatterns, this._FilePatterns, this._CurrentDestinationDirectoryName);
									this._Nest--;
								}
							}
						}
					}
					if (this._Cancel == CancelActions.CurrentDirectory)
					{
						this._Cancel = CancelActions.No;
						continue;
					}
					else if (this._Cancel == CancelActions.AllDirectories)
					{
						break;
					}
				}
			}
			if ((this._Nest == 0))
			{
				if (Searched != null)
				{
					OnSearched(this.DirectoryUID, this.FileUID, this._CurrentDestinationDirectoryName);
				}
			}
		}
		public void Searching(string SourceDirectory)
		{
			Searching(SourceDirectory, "*", "*", this._DestinationDirectory);
		}
		public void Searching(string SourceDirectory, string FilePatterns)
		{
			Searching(SourceDirectory, "*", FilePatterns, this._DestinationDirectory);
		}
		public void Searching(string SourceDirectory, string DirectoryPatterns, string FilePatterns)
		{
			Searching(SourceDirectory, DirectoryPatterns, FilePatterns, this._DestinationDirectory);
		}
		private void OnSearched(int DirectoryUID, int FileUID, string CurrentDestinationDirectoryName)
		{
			SearchEventArgs sea = new SearchEventArgs(DirectoryUID, FileUID, CurrentDestinationDirectoryName);
			Searched(this, sea);
		}
		private void OnSearchedFile(string f, int DirectoryUID, int FileUID, int DirectoryID, int FileID, string CurrentDestinationDirectoryName)
		{
			SearchEventArgs sea = new SearchEventArgs(f, DirectoryUID, FileUID, DirectoryID, FileID, CurrentDestinationDirectoryName);
			//new SearchEventHandler(SearchedFile).BeginInvoke(this,sea,new AsyncCallback(this.SearchedFileCallBack),sea);
			SearchedFile(this, sea);
		}
		private void SearchedFileCallBack(IAsyncResult iar)
		{
			throw new NotImplementedException();
		}
		private void SearchedDirectoryCallBack(IAsyncResult iar)
		{
			throw new NotImplementedException();
		}
		private void OnSearchedDirectory(string d, int DirectoryUID, int DirectoryID, string CurrentDestinationDirectoryName)
		{
			SearchEventArgs sea = new SearchEventArgs(d, DirectoryUID, DirectoryID, CurrentDestinationDirectoryName);
			//new SearchEventHandler(SearchedDirectory).BeginInvoke(this,sea,new AsyncCallback(this.SearchedDirectoryCallBack),sea);
			SearchedDirectory(this, sea);
		}
		public delegate void SearchEventHandler(Search Sender, SearchEventArgs e);
		private int _Nest; //递归嵌套层数
		public event SearchEventHandler SearchedDirectory; //"搜索到某个目录" 的事件
		public event SearchEventHandler SearchedFile; //"搜索到某个文件" 的事件
		public event SearchEventHandler Searched; //"搜索完毕" 的事件
		private int _DirectoriesCount; //搜索目录的次数
		private int _FilesCount; //搜索文件的次数
		private string _FilePatterns = "*"; //文件名匹配模式
		private string _DirectoryPatterns = "*"; //目录名匹配模式
		private CancelActions _Cancel; //取消
		private string _CurrentDirectoryName; //搜索的当前目录名
		private string _FileName = null;
		private int _FileID; //搜索的文件在当前目录的 ID
		private int _DirectoryID; //搜索的目录在当前目录的父目录的 ID
		private string _CurrentDestinationDirectoryName; //存储相对路径目录,可由于复制目录
		private string _DestinationDirectory;
		private string _ParentDirectoryName;
		private int _FileUID; //本次搜索的"文件的唯一 ID"
		private int _DirectoryUID; //本次搜索的"目录的唯一 ID"
		private List<string> _SearchedDirectories; //存储已搜索的目录
		private List<string> _SearchedFiles; //存储已搜索的文件
		public List<string> SearchedDirectories
		{
			get
			{
				//SearchedDirectories is ReadOnly
				return this._SearchedDirectories;
			}
		}
		public List<string> SearchedFiles
		{
			get
			{
				//SearchedFiles is ReadOnly
				return this._SearchedFiles;
			}
		}
		public int DirectoriesCount
		{
			get
			{
				return _DirectoriesCount;
			}
		}
		public int FilesCount
		{
			get
			{
				return _FilesCount;
			}
		}
		public string DirectoriesPatterns
		{
			get
			{
				return _DirectoryPatterns;
			}
			set
			{
				_DirectoryPatterns = value;
			}
		}
		public string DestinationDirectory
		{
			get
			{
				return _DestinationDirectory;
			}
			set
			{
				_DestinationDirectory = value;
			}
		}
		public string CurrentDirectoryName
		{
			get
			{
				return _CurrentDirectoryName + (_CurrentDirectoryName.EndsWith(@"\") ? "" : @"\");
			}
			set
			{
				_CurrentDirectoryName = value;
			}
		}
		public string FileName
		{
			get
			{
				return _FileName;
			}
		}
		public string ParentDirectoryName
		{
			get
			{
				return _ParentDirectoryName;
			}
		}
		/// <summary>
		/// 根据源目录的目录结构信息存储相对路径信息
		/// </summary>
		public string CurrentDestinationDirectoryName
		{
			get
			{
				return _CurrentDestinationDirectoryName + (_CurrentDestinationDirectoryName.EndsWith(@"\") ? "" : @"\");
			}
		}
		public int FileID
		{
			get
			{
				return _FileID;
			}
		}
		public int DirectoryID
		{
			get
			{
				return _DirectoryID;
			}
		}
		public CancelActions Cancel
		{
			get
			{
				return _Cancel;
			}
			set
			{
				_Cancel = value;
			}
		}
		public int DirectoryUID
		{
			get
			{
				return _DirectoryUID;
			}
		}
		public int FileUID
		{
			get
			{
				return _FileUID;
			}
		}
		public string FilesPatterns
		{
			get
			{
				return _FilePatterns;
			}
			set
			{
				_FilePatterns = value;
			}
		}
		private bool AddSearchedDirectory(string Key)
		{
			if (this._SearchedDirectories == null)
			{
				this._SearchedDirectories = new List<string>();
			}
			bool b = this._SearchedDirectories.Contains(Key);
			if (!b)
			{
				this._SearchedDirectories.Add(Key);
			}
			return !b;
		}
		private bool AddSearchedFile(string Key)
		{
			if (this._SearchedFiles == null)
			{
				this._SearchedFiles = new List<string>();
			}
			bool b = this._SearchedFiles.Contains(Key);
			if (!b)
			{
				this._SearchedFiles.Add(Key);
			}
			return !b;
		}
	}
	public enum CancelActions
	{
		No //不取消,继续
		 ,
		CurrentDirectory //只取消当前目录
		 ,
		AllDirectories //取消后面的所有搜索
	}
	public class SearchEventArgs : EventArgs
	{
		private int _FileID;
		private int _DirectoryID;
		private string _CurrentDirectoryName;
		private string _CurrentDestinationDirectoryName;
		private string _FileName;
		private int _DirectoriesCount = 0;
		private int _FileUID;
		private int _DirectoryUID;
		private int _FilesCount = 0;
		public int FilesCount
		{
			get
			{
				return _FilesCount;
			}
		}
		public int DirectoriesCount
		{
			get
			{
				return _DirectoriesCount;
			}
		}
		public string CurrentDirectoryName
		{
			get
			{
				return _CurrentDirectoryName + (_CurrentDirectoryName.EndsWith(@"\") ? "" : @"\");
			}
		}
		public string FileName
		{
			get
			{
				return _FileName;
			}
		}
		public string ParentDirectoryName
		{
			get
			{
				return _CurrentDirectoryName.Substring(_CurrentDirectoryName.LastIndexOf(@"\") + 1);
			}
		}
		public string CurrentDestinationDirectoryName
		{
			get
			{
				return _CurrentDestinationDirectoryName + (_CurrentDestinationDirectoryName.EndsWith(@"\") ? "" : @"\");
			}
		}
		public int FileUID
		{
			get
			{
				return _FileUID;
			}
		}
		public int DirectoryUID
		{
			get
			{
				return _DirectoryUID;
			}
		}
		public int FileID
		{
			get
			{
				return _FileID;
			}
		}
		public int DirectoryID
		{
			get
			{
				return _DirectoryID;
			}
		}
		internal SearchEventArgs(int DirectoryUID, int FileUID, string CurrentDestinationDirectoryName)
		{
			this._FileUID = FileUID;
			this._DirectoryUID = DirectoryUID;
			this._CurrentDestinationDirectoryName = CurrentDestinationDirectoryName;
		}
		internal SearchEventArgs(string FileName, int DirectoryUID, int FileUID, int DirectoryID, int FileID, string CurrentDestinationDirectoryName)
		{
			this._FileName = Path.GetFileName(FileName);
			this._CurrentDirectoryName = Path.GetDirectoryName(FileName);
			this._FileUID = FileUID;
			this._DirectoryUID = DirectoryUID;
			this._DirectoryID = DirectoryID;
			this._FileID = FileID;
			this._CurrentDestinationDirectoryName = CurrentDestinationDirectoryName;
		}
		internal SearchEventArgs(string DirectoryName, int DirectoryUID, int DirectoryID, string CurrentDestinationDirectoryName)
		{
			this._CurrentDirectoryName = DirectoryName;
			this._DirectoryUID = DirectoryUID;
			this._DirectoryID = DirectoryID;
			this._CurrentDestinationDirectoryName = CurrentDestinationDirectoryName;
		}
	}
}
// 下面是测试程序
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using Microshaoft;
	public class AppTest
	{
		private static void Main()
		{
			Search x = new Search();
			AppTest a = new AppTest();
			//订阅 "搜索到某个目录" 的事件
			x.SearchedDirectory += new Search.SearchEventHandler(a.x_SearchedDirectory);
			//订阅 "搜索到某个文件" 的事件
			x.SearchedFile += new Search.SearchEventHandler(a.x_SearchedFile);
			//订阅 "搜索完毕" 的事件
			x.Searched += new Search.SearchEventHandler(a.x_Searched);
			//指定目标目录
			x.DestinationDirectory = @"d:\temp\temp1\新建文件夹";
			x.Searching(@"d:\myc#\", "*", "*.cs;*.exe");
			Console.WriteLine("处理了 {0} 个目录中的 {1} 个文件!", x.DirectoryUID, x.FileUID);
			Console.ReadLine();
		}
		private void x_SearchedDirectory(Search Sender, SearchEventArgs e)
		{
			Console.WriteLine("{0}:\n{1}\n{2}", Sender.DirectoryUID, Sender.CurrentDirectoryName, e.CurrentDestinationDirectoryName);
			//根据搜索到的原目录,在指定文件夹下创建同名新目录 (复制目录)
			if (!Directory.Exists(Sender.CurrentDestinationDirectoryName))
			{
				Directory.CreateDirectory(e.CurrentDestinationDirectoryName);
			}
			if (Sender.DirectoriesCount > 5) //该事件将被触发6次
			{
				//找到 6 个目录就不继续找了
				//Sender.Cancel = CancelActions.AllDirectories;
			}
			//Sender.Cancel = CancelActions.CurrentDirectory;
		}
		private void x_SearchedFile(Search Sender, SearchEventArgs e)
		{
			if (e.FileID == 1) //如果找到某目录下的第一个文件创建该新目录
			{
				//如果找到第一个文件创建该新目录
				//if (!Directory.Exists(Sender.CurrentDestinationDirectoryName))
				//{
				//Directory.CreateDirectory(e.CurrentDestinationDirectoryName);
				//}
				//Console.WriteLine("{0}", e.CurrentDestinationDirectoryName);
				//Sender.Cancel = CancelActions.AllDirectories;
			}
			//处理搜索到的文件
			//在该处理程序中可实现纯文本文件的全文检索关键字(如: 有非法言论可处理该文件)
			if (Path.GetExtension(e.FileName) != ".exe")
			{
				//这里实现的是将搜索到的纯文本文件 *.cs 的文字从简体中文转换到繁体中文并另存到指定目录的功能
				FileProcess(Sender.CurrentDirectoryName + e.FileName, e.CurrentDestinationDirectoryName + e.FileName);
			}
			else
			{
				//实现 *.exe 文件复制到指定目录的功能
				File.Copy(Sender.CurrentDirectoryName + e.FileName, e.CurrentDestinationDirectoryName + e.FileName, true);
			}
			if (Sender.FilesCount > 100) //该事件将被触发101次
			{
				//找到 101 次文件就不继续找了
				//Sender.Cancel = CancelActions.AllDirectories;
			}
			//Sender.Cancel = CancelActions.AllDirectories;
			Console.WriteLine("\t{0}: {1}", e.FileUID, e.FileName);
		}
		private void FileProcess(string Source, string Destination)
		{
			//这里实现的是将搜索到的纯文本文件的文字从简体中文转换到繁体中文并另存到指定目录的功能
			StreamReader sr = new StreamReader(Source, Encoding.Default);
			StreamWriter sw = new StreamWriter(Destination, false, Encoding.Default);
			string s;
			while ((s = sr.ReadLine()) != null)
			{
				//sw.WriteLine(Microsoft.VisualBasic.Strings.StrConv(s, Microsoft.VisualBasic.VbStrConv.TraditionalChinese, Globalization.CultureInfo.CurrentCulture.LCID));
			}
			sr.Close();
			sr = null;
			sw.Close();
			sw = null;
		}
		private void x_Searched(Search Sender, SearchEventArgs e)
		{
			Console.WriteLine("Finished 处理了 {0} 次目录, {1} 次文件!", Sender.DirectoriesCount, Sender.FilesCount);
			Console.WriteLine("按 \"Y\" 键列印: 已搜索的目录");
			if (Console.ReadLine().ToLower() == "y")
			{
				foreach (string s in Sender.SearchedDirectories)
				{
					Console.WriteLine(s);
					//Sender.SearchedDirectories is ReadOnly
					//Sender.SearchedDirectories.Add("kkk"); //如果执行此句将跑出异常
				}
			}
		}
	}
}

#T=SecureString console
//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security.Permissions;

[assembly: CLSCompliant(true)]
[assembly: ComVisible(false)]
[assembly: FileIOPermissionAttribute(SecurityAction.RequestMinimum)]
namespace Microsoft.Samples
{
	using System;
	using System.Globalization;
	using System.Security;
	using System.Security.Permissions;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	class ConsoleDemo
	{
		string loginName;
		int mainCursorLeft;
		int mainCursorTop;
		SecureString password;

		[STAThread]
		static void Main(string[] args)
		{
			int initialWindowWidth = Console.WindowWidth;
			int initialWindowHeight = Console.WindowHeight;
			int initialBufferWidth = Console.BufferWidth;
			int initialBufferHeight = Console.BufferHeight;
			ConsoleColor originalBack = Console.BackgroundColor;
			ConsoleColor originalFore = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.White;
			Console.BackgroundColor = ConsoleColor.Black;
			ConsoleDemo cd = new ConsoleDemo();
			cd.Run();
			Console.SetWindowSize(1, 1);
			Console.SetBufferSize(initialBufferWidth, initialBufferHeight);
			Console.SetWindowSize(initialWindowWidth, initialWindowHeight);
			Console.ForegroundColor = originalFore;
			Console.BackgroundColor = originalBack;
			Console.Clear();
		}

		void Run() {
			Console.SetWindowSize(1, 1);

            Console.Title = "Fanatical Health Entry System";
            Console.CursorSize = 100;
            
			Console.SetBufferSize(100, 17);
			Console.SetWindowSize(45, 16);

			while (true)
			{
				PaintMainScreen();

				// ShowPoint: get a key, as it's pressed
				switch (Console.ReadKey().KeyChar)
				{
					case '1':
						if (LogInOut())
						{
							Console.Clear();
						} else
						{
							Console.CursorVisible = false;
							Console.Clear();
							Console.SetCursorPosition(2, 7);
							Console.ForegroundColor = ConsoleColor.White;
							Console.Write("Login unsuccessful: canceling application");
							System.Threading.Thread.Sleep(2500);
							return;
						}
						break;
					case '2':
						if (CheckLoggedIn())
						{
							PaintPatientScreen();
						}
						break;
					case '3':
						if (CheckLoggedIn())
						{
							OpenDoctorFile();
						}
						break;
					case '4':
						if (CheckLoggedIn())
						{
							OpenNurseFile();
						}
						break;
					case '5':
						return;
					default:
						Console.Clear();
						break;
				}
			}
		}

		bool CheckLoggedIn()
		{
			if (loginName == null)
			{
				// ShowPoint: Clear the screen
				Console.Clear();
				PaintBorder();
				Console.CursorVisible = false;
				Console.SetCursorPosition(5, 5);
				Console.ForegroundColor = ConsoleColor.Cyan;
				Console.Write("You must login first!!!");
				// ShowPoint: beep!
				Console.Beep();
				Stopwatch sw = new Stopwatch();
				sw.Start();
				while (sw.ElapsedMilliseconds < 2500) {}
				return false;
			} else
			{
				return true;
			}
		}

		void PaintMainScreen()
		{
			// ShowPoint: Make the cursor invisible
			Console.CursorVisible = false;
			Console.Clear();
			PaintBorder();
			Console.SetCursorPosition(5, 1);
			int top = 1;
			WriteEntry("", ConsoleColor.Magenta, false, top++);
			WriteEntry("Welcome to Fanatical Health!", ConsoleColor.Green, true, top++);

			if (loginName == null)
			{
				WriteEntry("", ConsoleColor.Magenta, false, top++);
				WriteEntry(" You are currently not logged in", ConsoleColor.Red, true, top++);
			} else
			{
				WriteEntry("", ConsoleColor.Magenta, false, top++);
				WriteEntry(" You are currently logged in as " + loginName, ConsoleColor.Red, true, top++);
			}

			WriteEntry("", ConsoleColor.Magenta, false, top++);
			WriteEntry(" Options:", ConsoleColor.Yellow, false, top++);
			WriteEntry(String.Format(CultureInfo.InvariantCulture, " 1. {0}", loginName == null ? "Login" : "Logout"), ConsoleColor.White, false, top++);

			WriteEntry(" 2. Patient Data", loginName == null ? ConsoleColor.Gray : ConsoleColor.White, false, top++);
			WriteEntry(" 3. Open Doctor Data File", loginName == null ? ConsoleColor.Gray : ConsoleColor.White, false, top++);
			WriteEntry(" 4. Open Nurse Data File", loginName == null ? ConsoleColor.Gray : ConsoleColor.White, false, top++);
			WriteEntry(" 5. Exit", ConsoleColor.White, false, top++);

			Console.ForegroundColor = ConsoleColor.White;
			Console.SetCursorPosition(1, Console.WindowHeight - 1);
			Console.Write("Please enter a selection (1 - 5) ==> ");
			mainCursorLeft = Console.CursorLeft;
			mainCursorTop = Console.CursorTop;
			Console.CursorVisible = true;
		}

		void PaintBorder()
		{
			Console.SetCursorPosition(0, 0);
			// ShowPoint: Change the screen color
			Console.ForegroundColor = ConsoleColor.Magenta;
			Console.Write("*********************************************");
			Console.SetCursorPosition(0, Console.WindowHeight - 3);
			Console.Write("*********************************************");
			for (int i = 1; i < Console.WindowHeight - 2; i++)
			{
				Console.SetCursorPosition(0, i);
				Console.Write("*");
				Console.SetCursorPosition(Console.WindowWidth - 1, i);
				Console.Write("*");
			}
		}

		void WriteEntry(string entry, ConsoleColor color, bool enterMidway, int top)
		{
			Console.ForegroundColor = ConsoleColor.Magenta;
			Console.ForegroundColor = color;
			int firstWidth = 0;
			int secondWidth = 0;
			if (enterMidway)
			{
				firstWidth = ((int)(Math.Ceiling((43d - entry.Length) / 2) + entry.Length));
				secondWidth = ((int)(Math.Floor((43d - entry.Length) / 2)));
			}
			else
			{
				firstWidth = entry.Length;
				secondWidth = 43 - entry.Length;
			}

			Console.SetCursorPosition(1, top);
			Console.Write("{0," + firstWidth + "}{1," + secondWidth + "}", entry, "");
			Console.ForegroundColor = ConsoleColor.Magenta;
		}

		bool LogInOut()
		{
			if (loginName == null)
				return LogIn();
			else
			{
				loginName = null;
				return true;
			}
		}


		bool LogIn()
		{
			password = new SecureString();

			string name = null;
			int top = 5;
			int count = 0;
			string prompt = "Login name ==> ";

			Console.Clear();
			PaintBorder();
			Console.ForegroundColor = ConsoleColor.White;
			Console.SetCursorPosition(3, top++);

			Console.Write(prompt);
			Console.ForegroundColor = ConsoleColor.Magenta;
			// task: turn this into non-blocking code, like the code below
			name = Console.ReadLine();

			Console.ForegroundColor = ConsoleColor.White;
			Console.SetCursorPosition(3, top);
			Console.Write("Password ==> ");
			Console.ForegroundColor = ConsoleColor.Magenta;

			while (true)
			{
				// ShowPoint: intercept the keypress,
				// so we can blank out the password with asterisks
				ConsoleKeyInfo cki = Console.ReadKey(true);
				//SecureString s = new SecureString();

				if (cki.Key == ConsoleKey.Enter)
				{
					count++;
					if (LoginValid(name, prompt))
					{
						loginName = name;
						return true;
					}
					else
					{
						if (count >= 3) {
							return false;
						}

						Console.ForegroundColor = ConsoleColor.White;
						Console.SetCursorPosition(3, top);
						Console.Write("{0,41}", " ");
						Console.SetCursorPosition(3, top);
						Console.Write("Password ==> ");
						Console.ForegroundColor = ConsoleColor.Magenta;
						password.Clear();
					}
				}
				else if (cki.Key == ConsoleKey.Backspace)
				{
					// remove the last asterisk from the screen...
					if (password.Length > 0)
					{
						ReplaceEntry(" ", Console.CursorLeft - 1, Console.CursorTop);
						password.RemoveAt(password.Length - 1);
					}
				}
				else if (cki.Key == ConsoleKey.Escape)
				{
					Console.Clear();
					PaintMainScreen();
					return true;
				}
				else if (Char.IsLetterOrDigit(cki.KeyChar) || Char.IsSymbol(cki.KeyChar))
				{
					if (password.Length < 15)
					{
						password.AppendChar(cki.KeyChar);
						Console.Write("*");
					}
					else
					{
						Console.Beep();
					}
				} else
				{
					Console.Beep();
				}
			}
		}

		bool LoginValid(string name, string prompt)
		{
			IntPtr tokenHandle = IntPtr.Zero;
			const int LOGON32_PROVIDER_DEFAULT = 0;
            const int LOGON32_LOGON_INTERACTIVE = 2;

			try
			{
				tokenHandle = Marshal.SecureStringToGlobalAllocUnicode(password);

				if (NativeMethods.LogonUser(name, "", tokenHandle,
					LOGON32_LOGON_INTERACTIVE,
					LOGON32_PROVIDER_DEFAULT,
					ref tokenHandle))
				{
					return true;
				}
				else
				{
					Console.SetCursorPosition(3, 5);
					Console.Write("{0,41}", " ");
					Console.SetCursorPosition(3, 5);
					Console.ForegroundColor = ConsoleColor.White;
					Console.Write(prompt);
					Console.ForegroundColor = ConsoleColor.Magenta;
					Console.Write(name);
					Console.ForegroundColor = ConsoleColor.Red;
					Console.SetCursorPosition(5, 8);
					Console.Write("That password is invalid!");

					Stopwatch sw = new Stopwatch();

					int count = 0;

					Console.Beep();
					while (count < 2)
					{
						sw.Start();

						if (sw.ElapsedMilliseconds > 100)
						{
							Console.Beep();
							count++;
						}
					}
					Console.SetCursorPosition(5, 8);
					Console.Write("{0,38}", " ");
				}
			}
			finally
			{
				if (tokenHandle != IntPtr.Zero)
				{
					Marshal.ZeroFreeGlobalAllocUnicode(tokenHandle);
				}
			}

			return false;
		}

		void ReplaceEntry(string replacement, int left, int top)
		{
			Console.SetCursorPosition(left, top);
			Console.Write(replacement);
			Console.SetCursorPosition(left, top);
		}

		void PaintPatientScreen()
		{
			Console.CursorVisible = false;
			MoveMainScreen(true);
			Console.SetCursorPosition(0,0);

			while (true)
			{
				PaintBorder();
				int top = 1;
				WriteEntry("", ConsoleColor.Magenta, false, top++);
				WriteEntry("Patient Maintenance Screen!", ConsoleColor.Green, true, top++);

				if (loginName == null)
				{
					WriteEntry("", ConsoleColor.Magenta, false, top++);
					WriteEntry(" You are currently not logged in", ConsoleColor.Red, true, top++);
				}
				else
				{
					WriteEntry("", ConsoleColor.Magenta, false, top++);
					WriteEntry(" You are currently logged in as " + loginName, ConsoleColor.Red, true, top++);
				}

				WriteEntry("", ConsoleColor.Magenta, false, top++);
				WriteEntry(" Options:", ConsoleColor.Yellow, false, top++);
				WriteEntry(" 1. New Patient", ConsoleColor.White, false, top++);
				WriteEntry(" 2. View Existing Patient", ConsoleColor.White, false, top++);
				WriteEntry(" 3. Patient in Trouble!", ConsoleColor.White, false, top++);
				WriteEntry(" 4. Exit", ConsoleColor.White, false, top++);

				WriteEntry("", ConsoleColor.Magenta, false, top++);

				Console.ForegroundColor = ConsoleColor.White;
				Console.SetCursorPosition(1, Console.WindowHeight - 1);
				Console.Write("Please enter a selection (1 - 4) ==> ");
				Console.CursorVisible = true;

				ConsoleKeyInfo cki = Console.ReadKey();

				if (cki.Key == ConsoleKey.D1 ||
							cki.Key == ConsoleKey.D2 ||
							cki.Key == ConsoleKey.D3)
				{
					ShowNotImplementedScreen("Please enter a selection (1 - 4) ==> ");
				}
				else if (cki.Key == ConsoleKey.Escape || cki.Key == ConsoleKey.D4)
				{
					MoveMainScreen(false);
					Console.SetCursorPosition(mainCursorLeft, mainCursorTop);
					return;
				}
			}
		}

		void MoveMainScreen(bool moveOff)
		{
			Stopwatch sw = new Stopwatch();

			if (moveOff)
			{
				for (int i = 0; i < Console.WindowWidth; i++)
				{
					Console.MoveBufferArea(i, 0, Console.WindowWidth, Console.WindowHeight, i + 1, 0);
					sw.Start();
					while (sw.ElapsedMilliseconds < 50) {}
					sw.Reset();
				}
			} 
			else
			{
				for (int i = Console.WindowWidth; i > 0; i--)
				{
					Console.MoveBufferArea(i, 0, Console.WindowWidth, Console.WindowHeight, i - 1, 0);
					sw.Start();
					while (sw.ElapsedMilliseconds < 50) {}
					sw.Reset();
				}
			}
		}

		void ShowNotImplementedScreen(string line)
		{
			Console.Clear();
			PaintBorder();
			bool cursorVisible = Console.CursorVisible;
			Console.CursorVisible = false;
			int cursorLeft = Console.CursorLeft;
			int cursorTop = Console.CursorTop;
			Console.SetCursorPosition(3, 7);
			Console.WriteLine(line);
			System.Threading.Thread.Sleep(3000);
			Console.SetCursorPosition(cursorLeft, cursorTop);
			Console.Clear();
			Console.CursorVisible = cursorVisible;
		}

		void OpenDoctorFile()
		{

			// this code attempts to open the doctor file, for the current user.
			// if the user has access to the file, then notepad will open, and you will see the file
			// If they DON'T have access (simulating that they aren't a doctor), then notepad
			// will still run, but the file won't open

			// See the instructions in the Doctor file for simulating 
			// someone not being allowed to open the file
			Process p = new Process();
			ProcessStartInfo psi = new ProcessStartInfo();
			psi.Password = password;
			psi.UserName = loginName;
			psi.UseShellExecute = false;

			psi.FileName = "notepad";
			psi.Arguments = Environment.CurrentDirectory + @"\doctorFile.txt";
			p.StartInfo = psi;

			p.Start();

		}
		void OpenNurseFile() {
			// this code attempts to open the doctor file, for the current user.
			// if the user has access to the file, then notepad will open, and you will see the file
			// If they DON'T have access (simulating that they aren't a doctor), then notepad
			// will still run, but the file won't open

			// See the instructions in the Nurse file for simulating someone being allowed to open the file
			Process p = new Process();
			ProcessStartInfo psi = new ProcessStartInfo();
			psi.Password = password;
			psi.UserName = loginName;
			psi.UseShellExecute = false;

			psi.FileName = "notepad";
			psi.Arguments = Environment.CurrentDirectory + @"\nurseFile.txt";
			p.StartInfo = psi;

			p.Start();
		}
	}
}
//---------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------


namespace Microsoft.Samples
{
	using System;
	using System.Runtime.InteropServices;
	internal sealed class NativeMethods
	{
		private NativeMethods() { }

		// this import is necessary, to allow us to check if someone can login ...
		[DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
		internal static extern bool LogonUser(String username,
				String domain, IntPtr password,
				int logonType, int logonProvider, ref IntPtr token);
	}
}

#T=SelectMany Linq
namespace ConsoleApplication
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			List<string> animals =
									new List<string>
										{
											"cat",
											"dog",
											"donkey"
										};
			List<int> number = new List<int>
								{
									10,
									20
								};
			var mix = number.SelectMany
								(
									num => animals
									, (n, a) =>
										new
										{
											n,
											a
										}
								);
			mix.ToList().ForEach
					(
						(x) =>
						{
							Console.WriteLine("{0},{1}", x.a, x.n);
						}
					);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}

#T=Semaphore
using System;
using System.Threading;

public class Example
{
	// A semaphore that simulates a limited resource pool.
	//
	private static Semaphore _pool;

	// A padding interval to make the output more orderly.
	private static int _padding;

	public static void Main()
	{
		// Create a semaphore that can satisfy up to three
		// concurrent requests. Use an initial count of zero,
		// so that the entire semaphore count is initially
		// owned by the main program thread.
		//
		_pool = new Semaphore(0, 3);

		// Create and start five numbered threads. 
		//
		for(int i = 1; i <= 5; i++)
		{
			Thread t = new Thread(new ParameterizedThreadStart(Worker));

			// Start the thread, passing the number.
			//
			t.Start(i);
		}

		// Wait for half a second, to allow all the
		// threads to start and to block on the semaphore.
		//
		Thread.Sleep(500);

		// The main thread starts out holding the entire
		// semaphore count. Calling Release(3) brings the 
		// semaphore count back to its maximum value, and
		// allows the waiting threads to enter the semaphore,
		// up to three at a time.
		//
		Console.WriteLine("Main thread calls Release(3).");
		_pool.Release(3);

		Console.WriteLine("Main thread exits.");
	}

	private static void Worker(object num)
	{
		// Each worker thread begins by requesting the
		// semaphore.
		Console.WriteLine("Thread {0} begins " +
			"and waits for the semaphore.", num);
		_pool.WaitOne();

		// A padding interval to make the output more orderly.
		int padding = Interlocked.Add(ref _padding, 100);

		Console.WriteLine("Thread {0} enters the semaphore.", num);

		// The thread's "work" consists of sleeping for 
		// about a second. Each thread "works" a little 
		// longer, just to make the output more orderly.
		//
		Thread.Sleep(1000 + padding);

		Console.WriteLine("Thread {0} releases the semaphore.", num);
		Console.WriteLine("Thread {0} previous semaphore count: {1}",
			num, _pool.Release());
	}
}

#T=SendMessage IPC WindowsMessage
namespace Microshaoft
{
	using System;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Runtime.InteropServices;
	using System.Windows.Forms;
	/// <summary>
	/// API函数引用及常数定义
	/// </summary>
	internal static class Win32
	{
		/// <summary>
		/// 当一个应用程序传递数据给另一个应用程序时发送此消息
		/// </summary>
		internal const int WM_COPYDATA = 0x004A;
		/// <summary>
		/// 窗体被销毁
		/// </summary>
		internal const int WM_DESTROY = 0x0002;
		/// <summary>
		/// 应用程序创建一个窗口
		/// </summary>
		internal const int WM_CREATE = 0x0001;
		/// <summary>
		/// 当用户选择结束对话框或程序自己调用ExitWindows函数
		/// </summary>
		internal const int WM_QUERYENDSESSION = 0x0011;
		/// <summary>
		/// 发出连接消息的标识
		/// </summary>
		internal const int CONNECTION = 1;
		/// <summary>
		/// 回复连接消息的标识
		/// </summary>
		internal const int REVERSION = -1;
		/// <summary>
		/// 断开连接消息的标识
		/// </summary>
		internal const int DISCONNECTION = 0;
		/// <summary>
		/// 注册一个消息通道
		/// </summary>
		/// <param name="lpString">通道名称</param>
		/// <returns>返回一个唯一的消息代码</returns>
		[DllImport("user32")]
		internal static extern int RegisterWindowMessage(string lpString);
		/// <summary>
		/// 发送一个Windows消息到目标窗口的消息队列
		/// </summary>
		/// <param name="hWnd">要发送的窗口的句柄</param>
		/// <param name="Msg">消息标识</param>
		/// <param name="wParam">WParam参数</param>
		/// <param name="lParam">LParam参数</param>
		/// <returns>如果函数调用成功，返回非零值：如果函数调用失败，返回值是零。</returns>
		[DllImport("user32")]
		internal static extern int PostMessage(IntPtr hWnd, int Msg, int wParam, int lParam);
		/// <summary>
		/// 发送一个Windows消息到目标窗口的消息队列
		/// </summary>
		/// <param name="hWnd">要发送的窗口的句柄</param>
		/// <param name="Msg">消息标识</param>
		/// <param name="wParam">WParam参数</param>
		/// <param name="lParam">LParam参数</param>
		/// <returns>如果函数调用成功，返回非零值：如果函数调用失败，返回值是零。</returns>
		[DllImport("user32")]
		internal static extern int PostMessage(IntPtr hwnd, int wMsg, IntPtr wParam, IntPtr lParam);
		/// <summary>
		/// 发送一个Windows消息到目标窗口
		/// </summary>
		/// <param name="hWnd">要发送的窗口的句柄</param>
		/// <param name="Msg">消息标识</param>
		/// <param name="wParam">WParam参数</param>
		/// <param name="lParam">LParam参数，发送一个COPYDATASTRUCT结构的指针</param>
		/// <returns>如果函数调用成功，返回非零值：如果函数调用失败，返回值是零。</returns>
		[DllImport("user32")]
		internal static extern int SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, ref COPYDATASTRUCT lParam);
		/// <summary>
		/// 广播消息句柄
		/// </summary>
		internal static readonly IntPtr HWND_BROADCAST = new IntPtr(0xFFFF);
	}
	internal class WinMsg : Form
	{
		private string _messageString;
		private List<IntPtr> _windowList;
		private int _message;
		private int _intHandler;
		private bool _isConnected;
		private WindowsMessage _parent;
		internal WinMsg()
			: this(null, "Common.WinMsg.DefaultConnectString")
		{ }
		internal WinMsg(WindowsMessage parent)
			: this(parent, "Common.WinMsg.DefaultConnectString")
		{ }
		internal WinMsg(WindowsMessage parent, string messageString)
		{
			_parent = parent;
			_messageString = messageString;
			_isConnected = false;
			_intHandler = Handle.ToInt32();
			_windowList = new List<IntPtr>();
			_message = Win32.RegisterWindowMessage(_messageString);//注册一个消息通道
			int errCode = Win32.PostMessage(Win32.HWND_BROADCAST, _message, Win32.CONNECTION, _intHandler);//向此通道内所有的窗口广播自己的句柄
			if (errCode == 0)
			{
				throw new Win32Exception(errCode);//发生错误，抛出异常
			}
			else
			{
				_isConnected = true;
			}
		}
		protected override void WndProc(ref Message m)
		{
			if (m.Msg == _message)//接收到广播消息，进行处理
			{
				int LParam = m.LParam.ToInt32();
				int WParam = m.WParam.ToInt32();
				if (LParam != 0 && LParam != _intHandler)
				{
					if (WParam == Win32.DISCONNECTION)
					{
						_windowList.Remove(m.WParam);
					}
					else
					{
						if (WParam == Win32.CONNECTION)
						{
							Win32.PostMessage(m.LParam, _message, Win32.REVERSION, _intHandler);
						}
						_windowList.Add(m.LParam);
					}
				}
				return;
			}
			switch (m.Msg)
			{
				case Win32.WM_COPYDATA://接收到其它窗口发送过来的数据
					{
						COPYDATASTRUCT data = new COPYDATASTRUCT();
						data = (COPYDATASTRUCT)m.GetLParam(data.GetType());
						byte[] message = new byte[data.cbData];
						Marshal.Copy(data.lpData, message, 0, data.cbData);
						if (_parent != null)
							_parent.Anyzler(m.WParam, message);
					}
					break;
				case Win32.WM_DESTROY:
				case Win32.WM_QUERYENDSESSION://窗口被关闭，向其它窗口广播通知从队列中删除自己
					Win32.PostMessage(Win32.HWND_BROADCAST, _message, Win32.DISCONNECTION, _intHandler);
					base.WndProc(ref m);
					break;
				default:
					base.WndProc(ref m);
					break;
			}
		}
		internal void Send(byte[] message)
		{
			if (_isConnected)
			{
				int length = message.Length;
				IntPtr ptr = Marshal.AllocHGlobal(length);
				Marshal.Copy(message, 0, ptr, length);
				COPYDATASTRUCT data = new COPYDATASTRUCT();
				data.dwData = IntPtr.Zero;
				data.cbData = length;
				data.lpData = ptr;
				//向其它所有窗口发送数据，这里不能发广播消息。必须一个一个发送。
				foreach (IntPtr window in _windowList)
				{
					Win32.SendMessage(window, Win32.WM_COPYDATA, this.Handle, ref data);
				}
				Marshal.FreeHGlobal(ptr);
			}
		}
	}
	/// <summary>
	/// 这个类只是用来封装WinMsg的，以免太多的属性被暴露而使用户不知所措。
	/// </summary>
	public abstract class WindowsMessage
	{
		private WinMsg _winMsg;
		private string _channelName;
		public string ChannelName
		{
			get { return _channelName; }
			set { _channelName = value; }
		}
		public WindowsMessage()
			: this("Common.WinMsg.DefaultConnectString")
		{ }
		public WindowsMessage(string channelName)
		{
			_channelName = channelName;
		}
		public abstract void Anyzler(IntPtr target, byte[] message);
		public void SendMessage(byte[] message)
		{
			_winMsg.Send(message);
		}
		public void StartMessage()
		{
			if (_winMsg == null)
				_winMsg = new WinMsg(this, _channelName);
		}
		public void StartMessage(string channelName)
		{
			if (_winMsg == null)
			{
				_channelName = channelName;
				_winMsg = new WinMsg(this, channelName);
			}
		}
		public void Close()
		{
			_winMsg.Dispose();
			_winMsg = null;
		}
	}
	/// <summary>
	/// 发送WM_COPYDATA消息的数据结构
	/// </summary>
	internal struct COPYDATASTRUCT
	{
		/// <summary>
		/// 用户自定义数据
		/// </summary>
		internal IntPtr dwData;
		/// <summary>
		/// 数据长度
		/// </summary>
		internal int cbData;
		/// <summary>
		/// 数据首地址指针
		/// </summary>
		internal IntPtr lpData;
	}
}
namespace Microshaoft
{
	using System;
	using System.Text;
	using System.Windows.Forms;
	public partial class Form1 : Form
	{
		MyWindowsMessage msgData;
		public Form1()
		{
			InitializeComponent();
		}
		protected override void OnLoad(EventArgs e)
		{
			msgData = new MyWindowsMessage("testProject");
			msgData.Parent = this;
			msgData.StartMessage();
		}
		private void button1_Click(object sender, EventArgs e)
		{
			msgData.SendMessage(Encoding.Default.GetBytes(textBox1.Text));
			//for (int i = 0; i < 1000; i++)
			//{
			//	msgData.SendMessage(Encoding.Default.GetBytes(i.ToString()));
			//}
		}
		class MyWindowsMessage : WindowsMessage
		{
			private Form1 _parent;
			public Form1 Parent
			{
				get { return _parent; }
				set { _parent = value; }
			}
			public MyWindowsMessage()
				: base()
			{
			}
			public MyWindowsMessage(string channelName)
				: base(channelName)
			{
			}
			public override void Anyzler(IntPtr target, byte[] message)
			{
				_parent.listBox1.Items.Add(Encoding.Default.GetString(message));
			}
		}
	}
}
namespace Microshaoft
{
	using System.ComponentModel;
	using System.Drawing;
	using System.Windows.Forms;
	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.panel1 = new Panel();
			this.button1 = new Button();
			this.textBox1 = new TextBox();
			this.panel2 = new Panel();
			this.listBox1 = new ListBox();
			this.panel1.SuspendLayout();
			this.panel2.SuspendLayout();
			this.SuspendLayout();
			// 
			// panel1
			// 
			this.panel1.Controls.Add(this.button1);
			this.panel1.Controls.Add(this.textBox1);
			this.panel1.Dock = DockStyle.Top;
			this.panel1.Location = new Point(0, 0);
			this.panel1.Name = "panel1";
			this.panel1.Size = new Size(579, 49);
			this.panel1.TabIndex = 3;
			// 
			// button1
			// 
			this.button1.Anchor = ((AnchorStyles)((AnchorStyles.Top | AnchorStyles.Right)));
			this.button1.Location = new Point(492, 12);
			this.button1.Name = "button1";
			this.button1.Size = new Size(75, 23);
			this.button1.TabIndex = 4;
			this.button1.Text = "发送";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// textBox1
			// 
			this.textBox1.Anchor = ((AnchorStyles)(((AnchorStyles.Top | AnchorStyles.Left)
						| AnchorStyles.Right)));
			this.textBox1.Location = new Point(12, 14);
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new Size(474, 21);
			this.textBox1.TabIndex = 3;
			// 
			// panel2
			// 
			this.panel2.Controls.Add(this.listBox1);
			this.panel2.Dock = DockStyle.Fill;
			this.panel2.Location = new Point(0, 49);
			this.panel2.Name = "panel2";
			this.panel2.Size = new Size(579, 394);
			this.panel2.TabIndex = 4;
			// 
			// listBox1
			// 
			this.listBox1.Dock = DockStyle.Fill;
			this.listBox1.FormattingEnabled = true;
			this.listBox1.HorizontalScrollbar = true;
			this.listBox1.ItemHeight = 12;
			this.listBox1.Location = new Point(0, 0);
			this.listBox1.Name = "listBox1";
			this.listBox1.Size = new Size(579, 388);
			this.listBox1.TabIndex = 1;
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new SizeF(6F, 12F);
			this.AutoScaleMode = AutoScaleMode.Font;
			this.ClientSize = new Size(579, 443);
			this.Controls.Add(this.panel2);
			this.Controls.Add(this.panel1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.panel1.ResumeLayout(false);
			this.panel1.PerformLayout();
			this.panel2.ResumeLayout(false);
			this.ResumeLayout(false);
		}
		#endregion
		private Panel panel1;
		private Button button1;
		private TextBox textBox1;
		private Panel panel2;
		private ListBox listBox1;
	}
}

#T=SendMessage Move Window
namespace MoveWindow
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Data;

	//for DLL's
	using System.Runtime.InteropServices;
	/// <summary>
	/// Zusammenfassung fr Form1.
	/// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		/// <summary>
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form1()
		{
			//
			// Erforderlich fr die Windows Form-Designeruntersttzung
			//
			InitializeComponent();

			//
			// TODO: Fgen Sie den Konstruktorcode nach dem Aufruf von InitializeComponent hinzu
			//
		}

		/// <summary>
		/// Die verwendeten Ressourcen bereinigen.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Vom Windows Form-Designer generierter Code
		/// <summary>
		/// Erforderliche Methode fr die Designeruntersttzung. 
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor gendert werden.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(8, 240);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(280, 24);
			this.label1.TabIndex = 0;
			this.label1.Text = "To move window, click anywhere on the form and move the mouse (hold button presse" +
				"d!)";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// Form1
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(292, 273);
			this.Controls.Add(this.label1);
			this.Name = "Form1";
			this.Text = "Move me!";
			this.MouseDown += new System.Windows.Forms.MouseEventHandler(this.Form1_MouseDown);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// Der Haupteinstiegspunkt fr die Anwendung.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new Form1());
		}

		//const and dll functions for moving form
		public const int WM_NCLBUTTONDOWN = 0xA1;
		public const int HT_CAPTION = 0x2;

		[DllImportAttribute ("user32.dll")]
		public static extern int SendMessage(IntPtr hWnd, 
			int Msg, int wParam, int lParam);
		
		[DllImportAttribute ("user32.dll")]
		public static extern bool ReleaseCapture();

		//call functions to move the form in your form's MouseDown event
		private void Form1_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if (e.Button == MouseButtons.Left)
			{
				ReleaseCapture();
				SendMessage(Handle, WM_NCLBUTTONDOWN, HT_CAPTION, 0);
			}
		}
	}
}

#T=Serial Port
namespace TestSerialPort
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.IO.Ports;
	using System.Windows.Forms;
	/// <summary>
	/// 串口开发辅助类
	/// </summary>
	public class SerialPortUtil
	{
		/// <summary>
		/// 接收事件是否有效 false表示有效
		/// </summary>
		public bool ReceiveEventFlag = false;
		/// <summary>
		/// 结束符比特
		/// </summary>
		public byte EndByte = 0x23;//string End = "#";
		/// <summary>
		/// 完整协议的记录处理事件
		/// </summary>
		public event DataReceivedEventHandler DataReceived;
		public event SerialErrorReceivedEventHandler Error;
		#region 变量属性
		private string _portName = "COM1";//串口号，默认COM1
		private SerialPortBaudRates _baudRate = SerialPortBaudRates.BaudRate_57600;//波特率
		private Parity _parity = Parity.None;//校验位
		private StopBits _stopBits = StopBits.One;//停止位
		private SerialPortDatabits _dataBits = SerialPortDatabits.EightBits;//数据位
		private SerialPort comPort = new SerialPort();
		/// <summary>
		/// 串口号
		/// </summary>
		public string PortName
		{
			get { return _portName; }
			set { _portName = value; }
		}
		/// <summary>
		/// 波特率
		/// </summary>
		public SerialPortBaudRates BaudRate
		{
			get { return _baudRate; }
			set { _baudRate = value; }
		}
		/// <summary>
		/// 奇偶校验位
		/// </summary>
		public Parity Parity
		{
			get { return _parity; }
			set { _parity = value; }
		}
		/// <summary>
		/// 数据位
		/// </summary>
		public SerialPortDatabits DataBits
		{
			get { return _dataBits; }
			set { _dataBits = value; }
		}
		/// <summary>
		/// 停止位
		/// </summary>
		public StopBits StopBits
		{
			get { return _stopBits; }
			set { _stopBits = value; }
		}
		#endregion
		#region 构造函数
		/// <summary>
		/// 参数构造函数（使用枚举参数构造）
		/// </summary>
		/// <param name="baud">波特率</param>
		/// <param name="par">奇偶校验位</param>
		/// <param name="sBits">停止位</param>
		/// <param name="dBits">数据位</param>
		/// <param name="name">串口号</param>
		public SerialPortUtil(string name, SerialPortBaudRates baud, Parity par, SerialPortDatabits dBits, StopBits sBits)
		{
			_portName = name;
			_baudRate = baud;
			_parity = par;
			_dataBits = dBits;
			_stopBits = sBits;
			comPort.DataReceived += new SerialDataReceivedEventHandler(comPort_DataReceived);
			comPort.ErrorReceived += new SerialErrorReceivedEventHandler(comPort_ErrorReceived);
		}
		/// <summary>
		/// 参数构造函数（使用字符串参数构造）
		/// </summary>
		/// <param name="baud">波特率</param>
		/// <param name="par">奇偶校验位</param>
		/// <param name="sBits">停止位</param>
		/// <param name="dBits">数据位</param>
		/// <param name="name">串口号</param>
		public SerialPortUtil(string name, string baud, string par, string dBits, string sBits)
		{
			_portName = name;
			_baudRate = (SerialPortBaudRates)Enum.Parse(typeof(SerialPortBaudRates), baud);
			_parity = (Parity)Enum.Parse(typeof(Parity), par);
			_dataBits = (SerialPortDatabits)Enum.Parse(typeof(SerialPortDatabits), dBits);
			_stopBits = (StopBits)Enum.Parse(typeof(StopBits), sBits);
			comPort.DataReceived += new SerialDataReceivedEventHandler(comPort_DataReceived);
			comPort.ErrorReceived += new SerialErrorReceivedEventHandler(comPort_ErrorReceived);
		}
		/// <summary>
		/// 默认构造函数
		/// </summary>
		public SerialPortUtil()
		{
			_portName = "COM1";
			_baudRate = SerialPortBaudRates.BaudRate_9600;
			_parity = Parity.None;
			_dataBits = SerialPortDatabits.EightBits;
			_stopBits = StopBits.One;
			comPort.DataReceived += new SerialDataReceivedEventHandler(comPort_DataReceived);
			comPort.ErrorReceived += new SerialErrorReceivedEventHandler(comPort_ErrorReceived);
		} 
		#endregion
		/// <summary>
		/// 端口是否已经打开
		/// </summary>
		public bool IsOpen
		{
			get
			{
				return comPort.IsOpen;
			}
		}
		/// <summary>
		/// 打开端口
		/// </summary>
		/// <returns></returns>
		public void OpenPort()
		{
			if (comPort.IsOpen) comPort.Close();
			comPort.PortName = _portName;
			comPort.BaudRate = (int)_baudRate;
			comPort.Parity = _parity;
			comPort.DataBits = (int)_dataBits;
			comPort.StopBits = _stopBits;
			comPort.Open();
		}
		/// <summary>
		/// 关闭端口
		/// </summary>
		public void ClosePort()
		{
			if (comPort.IsOpen) comPort.Close();
		}
		/// <summary>
		/// 丢弃来自串行驱动程序的接收和发送缓冲区的数据
		/// </summary>
		public void DiscardBuffer()
		{
			comPort.DiscardInBuffer();
			comPort.DiscardOutBuffer();
		}
		/// <summary>
		/// 数据接收处理
		/// </summary>
		void comPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
		{
			//禁止接收事件时直接退出
			if (ReceiveEventFlag) return;
			#region 根据结束字节来判断是否全部获取完成
			List<byte> _byteData = new List<byte>();
			bool found = false;//是否检测到结束符号
			while (comPort.BytesToRead > 0 || !found)
			{
				byte[] readBuffer = new byte[comPort.ReadBufferSize + 1];
				int count = comPort.Read(readBuffer, 0, comPort.ReadBufferSize);
				for (int i = 0; i < count; i++)
				{
					_byteData.Add(readBuffer[i]);
					if (readBuffer[i] == EndByte)
					{
						found = true;
					}
				}
			} 
			#endregion
			
			//字符转换
			string readString = System.Text.Encoding.Default.GetString(_byteData.ToArray(), 0, _byteData.Count);
			
			//触发整条记录的处理
			if (DataReceived != null)
			{
				DataReceived(new DataReceivedEventArgs(readString));
			}
		}
		/// <summary>
		/// 错误处理函数
		/// </summary>
		void comPort_ErrorReceived(object sender, SerialErrorReceivedEventArgs e)
		{
			if (Error != null)
			{
				Error(sender, e);
			}
		}
		#region 数据写入操作
		/// <summary>
		/// 写入数据
		/// </summary>
		/// <param name="msg"></param>
		public void WriteData(string msg)
		{
			if (!(comPort.IsOpen)) comPort.Open();
			comPort.Write(msg);
		}
		/// <summary>
		/// 写入数据
		/// </summary>
		/// <param name="msg">写入端口的字节数组</param>
		public void WriteData(byte[] msg)
		{
			if (!(comPort.IsOpen)) comPort.Open();
			comPort.Write(msg, 0, msg.Length);
		}
		/// <summary>
		/// 写入数据
		/// </summary>
		/// <param name="msg">包含要写入端口的字节数组</param>
		/// <param name="offset">参数从0字节开始的字节偏移量</param>
		/// <param name="count">要写入的字节数</param>
		public void WriteData(byte[] msg, int offset, int count)
		{
			if (!(comPort.IsOpen)) comPort.Open();
			comPort.Write(msg, offset, count);
		}
		/// <summary>
		/// 发送串口命令
		/// </summary>
		/// <param name="SendData">发送数据</param>
		/// <param name="ReceiveData">接收数据</param>
		/// <param name="Overtime">重复次数</param>
		/// <returns></returns>
		public int SendCommand(byte[] SendData, ref  byte[] ReceiveData, int Overtime)
		{
			if (!(comPort.IsOpen)) comPort.Open();
			ReceiveEventFlag = true;		//关闭接收事件
			comPort.DiscardInBuffer();	  //清空接收缓冲区				 
			comPort.Write(SendData, 0, SendData.Length);
			
			int num = 0, ret = 0;
			while (num++ < Overtime)
			{
				if (comPort.BytesToRead >= ReceiveData.Length) break;
				System.Threading.Thread.Sleep(1);
			}
			if (comPort.BytesToRead >= ReceiveData.Length)
			{
				ret = comPort.Read(ReceiveData, 0, ReceiveData.Length);
			}
			ReceiveEventFlag = false;	   //打开事件
			return ret;
		}
		#endregion
		#region 常用的列表数据获取和绑定操作
		/// <summary>
		/// 封装获取串口号列表
		/// </summary>
		/// <returns></returns>
		public static string[] GetPortNames()
		{
			return SerialPort.GetPortNames();
		}
		/// <summary>
		/// 设置串口号
		/// </summary>
		/// <param name="obj"></param>
		public static void SetPortNameValues(ComboBox obj)
		{
			obj.Items.Clear();
			foreach (string str in SerialPort.GetPortNames())
			{
				obj.Items.Add(str);
			}
		}
		/// <summary>
		/// 设置波特率
		/// </summary>
		public static void SetBauRateValues(ComboBox obj)
		{
			obj.Items.Clear();
			foreach (SerialPortBaudRates rate in Enum.GetValues(typeof(SerialPortBaudRates)))
			{
				obj.Items.Add(((int)rate).ToString());
			}
		}
		/// <summary>
		/// 设置数据位
		/// </summary>
		public static void SetDataBitsValues(ComboBox obj)
		{
			obj.Items.Clear();
			foreach (SerialPortDatabits databit in Enum.GetValues(typeof(SerialPortDatabits)))
			{
				obj.Items.Add(((int)databit).ToString());
			}
		}
		/// <summary>
		/// 设置校验位列表
		/// </summary>
		public static  void SetParityValues(ComboBox obj)
		{
			obj.Items.Clear();
			foreach (string str in Enum.GetNames(typeof(Parity)))
			{
				obj.Items.Add(str);
			}
			//foreach (Parity party in Enum.GetValues(typeof(Parity)))
			//{
			//	obj.Items.Add(((int)party).ToString());
			//}
		}
		/// <summary>
		/// 设置停止位
		/// </summary>
		public static void SetStopBitValues(ComboBox obj)
		{
			obj.Items.Clear();
			foreach (string str in Enum.GetNames(typeof(StopBits)))
			{
				obj.Items.Add(str);
			}
			//foreach (StopBits stopbit in Enum.GetValues(typeof(StopBits)))
			//{
			//	obj.Items.Add(((int)stopbit).ToString());
			//}   
		}
		#endregion
		#region 格式转换
		/// <summary>
		/// 转换十六进制字符串到字节数组
		/// </summary>
		/// <param name="msg">待转换字符串</param>
		/// <returns>字节数组</returns>
		public static byte[] HexToByte(string msg)
		{
			msg = msg.Replace(" ", "");//移除空格
			//create a byte array the length of the
			//divided by 2 (Hex is 2 characters in length)
			byte[] comBuffer = new byte[msg.Length / 2];
			for (int i = 0; i < msg.Length; i += 2)
			{
				//convert each set of 2 characters to a byte and add to the array
				comBuffer[i / 2] = (byte)Convert.ToByte(msg.Substring(i, 2), 16);
			}
			return comBuffer;
		}
		/// <summary>
		/// 转换字节数组到十六进制字符串
		/// </summary>
		/// <param name="comByte">待转换字节数组</param>
		/// <returns>十六进制字符串</returns>
		public static string ByteToHex(byte[] comByte)
		{
			StringBuilder builder = new StringBuilder(comByte.Length * 3);
			foreach (byte data in comByte)
			{
				builder.Append(Convert.ToString(data, 16).PadLeft(2, '0').PadRight(3, ' '));
			}
			return builder.ToString().ToUpper();
		}
		#endregion
		/// <summary>
		/// 检查端口名称是否存在
		/// </summary>
		/// <param name="port_name"></param>
		/// <returns></returns>
		public static bool Exists(string port_name)
		{
			foreach (string port in SerialPort.GetPortNames()) if (port == port_name) return true;
			return false;
		}
		/// <summary>
		/// 格式化端口相关属性
		/// </summary>
		/// <param name="port"></param>
		/// <returns></returns>
		public static string Format(SerialPort port)
		{
			return String.Format("{0} ({1},{2},{3},{4},{5})", 
				port.PortName, port.BaudRate, port.DataBits, port.StopBits, port.Parity, port.Handshake);
		}
	}
	public class DataReceivedEventArgs : EventArgs
	{
		public string DataReceived;
		public DataReceivedEventArgs(string m_DataReceived)
		{
			this.DataReceived = m_DataReceived;
		}
	}
	public delegate void DataReceivedEventHandler(DataReceivedEventArgs e);
	/// <summary>
	/// 串口数据位列表（5,6,7,8）
	/// </summary>
	public enum SerialPortDatabits : int
	{
		FiveBits = 5,
		SixBits = 6,
		SeventBits = 7,
		EightBits = 8
	}
	/// <summary>
	/// 串口波特率列表。
	/// 75,110,150,300,600,1200,2400,4800,9600,14400,19200,28800,38400,56000,57600,
	/// 115200,128000,230400,256000
	/// </summary>
	public enum SerialPortBaudRates : int
	{
		BaudRate_75 = 75,
		BaudRate_110 = 110,
		BaudRate_150 = 150,
		BaudRate_300 = 300,
		BaudRate_600 = 600,
		BaudRate_1200 = 1200,
		BaudRate_2400 = 2400,
		BaudRate_4800 = 4800,
		BaudRate_9600 = 9600,
		BaudRate_14400 = 14400,
		BaudRate_19200 = 19200,
		BaudRate_28800 = 28800,
		BaudRate_38400 = 38400,
		BaudRate_56000 = 56000,
		BaudRate_57600 = 57600,
		BaudRate_115200 = 115200,
		BaudRate_128000 = 128000,
		BaudRate_230400 = 230400,
		BaudRate_256000 = 256000
	}
}

#T=Serialize.cs
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
/*=====================================================================
  File:	  Serialize.cs

  Summary:   Demonstrates how to use runtime serialization.

=====================================================================*/

namespace Microsoft.Samples
{
	using System;
	using System.Text;
	using System.IO;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Formatters.Binary;
	using System.Runtime.Serialization.Formatters.Soap;
	using System.Xml;
	public class App
	{
		private static void Usage()
		{
			Console.WriteLine("Usage:\n" + "   -sb [filename] [nodecount]\tSerialize a linked list with " + "[nodecount]\n\t\t\t\tnodes to [filename] using binary formatter\n\n" + "   -sx [filename] [nodecount]\tSerialize a linked list with " + "[nodecount]\n\t\t\t\tnodes to [filename] using XML formatter\n\n" + "   -db [filename] \t\tDe-Serialize and display a linked list " + "from\n\t\t\t\t[filename] using binary formatter\n\n" + "   -dx [filename] \t\tDe-Serialize and display a linked list " + "from\n\t\t\t\t[filename] using XML formatter\n");
		}
		public static void Main(String[] args)
		{
			try
			{
				// Parse command line args
				bool useBinary = false;
				bool serialize = false;
				int shiftArgs = 0;

				if (args[0][0] == '-' || args[0][0] == '/')
				{
					if (args[0][1] == '?')
					{
						Usage();
						return;
					}

					useBinary = (args[0][2] == 'b');
					serialize = (args[0][1] == 's');
					shiftArgs = 1;
				}

				// Serialize or Deserialize an object graph
				if (serialize)
				{
					SerializeGraph(useBinary, args[0 + shiftArgs], int.Parse(args[1 + shiftArgs]));
				}
				else
				{
					DeserializeGraph(useBinary, args[0 + shiftArgs]);
				}
			}
			catch (IndexOutOfRangeException)
			{
				Usage();
			}
		}
		private static void SerializeGraph(bool useBinary, string fileName, int nodeCount)
		{
			// Create a filestream object
			Console.WriteLine("\nSerializing LinkedList to file: {0} ..\n", fileName);

			Stream file = File.Open(fileName, FileMode.Create);

			// Create a linked list object and populate it with random nodes
			LinkedList list = new LinkedList();

			list.PopulateRandom(nodeCount);
			Console.WriteLine(list);

			// Create a formatter object based on command line arguments
			IFormatter formatter = useBinary ? (IFormatter)new BinaryFormatter() : (IFormatter)new SoapFormatter();

			// Serialize the object graph to stream
			formatter.Serialize(file, list);

			// All done
			file.Close();
		}
		private static void DeserializeGraph(bool useBinary, string fileName)
		{
			// Verify that the input file exists
			if (!File.Exists(fileName))
			{
				Console.WriteLine("Input file not found: {0}\n", fileName);
				Usage();
				return;
			}

			// Open the requested file to a stream object
			Console.WriteLine("\nDeserializing LinkedList from file: {0} ..\n", fileName);

			Stream file = File.Open(fileName, FileMode.Open);

			// Create a formatter object based on command line arguments
			IFormatter formatter = useBinary ? (IFormatter)new BinaryFormatter() : (IFormatter)new SoapFormatter();

			// Deserialize the object graph from stream
			try
			{
				LinkedList list = formatter.Deserialize(file) as LinkedList;

				// Tests like this are relevant in projects which 
				// serialize multiple object types
				if (list != null)
				{
					Console.WriteLine(list);
				}
				else
				{
					Console.WriteLine("The deserialized object graph" + " is not a LinkedList.");
				}
			}
				// Handler for BinaryFormatter exception
				catch (SerializationException)
			{
				Console.WriteLine("Could not deserialize file.  Check that the input file is valid and the requested serialization format is correct.");
			}
				// Handler for SoapException
				catch (ArgumentException)
			{
				Console.WriteLine("Could not deserialize file.  Check that the input file is valid and the requested serialization format is correct.");
			}
				// Handler for XmlFormatter exception
				catch (XmlException)
			{
				Console.WriteLine("Could not deserialize file.  Check that the input file is valid and the requested serialization format is correct.");
			}

			// All done
			file.Close();
		}
	}
	// Note that this type is attributed as serializable
	[Serializable]
	class LinkedList
	{
		// Construct an empty LinkedList
		public LinkedList()
		{
			nodeHead = new Node();
		}
		// Represent the LinkedList as a string
		public override string ToString()
		{
			StringBuilder list = new StringBuilder("List:\n");
			int index = 0;
			Node nodeIterator = nodeHead.Next;

			while (nodeIterator != null)
			{
				list.Append("Node #" + (index++) + "\n" + nodeIterator + "\n");
				nodeIterator = nodeIterator.Next;
			}

			return list.ToString();
		}
		// Populate the list with an arbitrary number of nodes with random data
		public void PopulateRandom(int numNodes)
		{
			Random rand = new Random();

			while (numNodes-- != 0)
			{
				Add("Semi-Random String: " + rand.Next(1001), rand.Next(1001));
			}
		}
		// Add a node
		public void Add(String text, int number)
		{
			Node node = new Node();

			node.TextData = text;
			node.NumberData = number;
			node.Add(nodeHead);
		}
		// Reference to the empty head node
		private Node nodeHead;
		// This nested type is also attributed as serializable
		[Serializable]
		public class Node
		{
			// Construct a Node object
			public Node()
			{
				next = null;
			}
			// Add a node object to a list
			public void Add(Node nodeHead)
			{
				Node nodeIterator = nodeHead;

				while (nodeIterator.next != null)
					nodeIterator = nodeIterator.next;

				nodeIterator.next = this;
				next = null;
			}
			// Accessor property for textData private field
			public string TextData
			{
				get { return textData; }
				set { textData = value; }
			}
			// Accessor property for numberData private field
			public int NumberData
			{
				get { return numberData; }
				set { numberData = value; }
			}
			// Read-only property for next private field
			public Node Next
			{
				get { return next; }
			}
			// Represent the node as a string
			public override string ToString()
			{
				return "\tTextData   = \"" + TextData + "\"\n\tNumberData = " + NumberData;
			}
			// Private field referencing the next node in the list
			private Node next;
			// Private fields containing node data
			private string textData;
			private int numberData;
		}
	}
}
#T=Serializer 对比测试
namespace Test
{
	using System;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Json;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using Microshaoft;
	using Test.Share;
	public class Class1
	{
		static WebDirectory _wd = null;
		static void Main(string[] args)
		{
			WebDirectory x = new WebDirectory();
			x.Name = "Microshaoft";
			DateTime now = DateTime.Now;
			WebFile y1 = new WebFile();
			y1.Name = "Microshaoft简体繁w中文";
			y1.IsReadOnly = false;
			y1.Url = "http://www.microshaoft.com";
			y1.CreateTime = now;
			y1.LastWriteTime = now;
			WebDirectory x1 = new WebDirectory();
			x1.Name = "Sub1";
			//y1.Directory = x; //循环引用
			WebFile y2 = new WebFile();
			y2.Name = "Microshaoft中文";
			y2.Flag = FlagEnum.Value2;
			y2.CreateTime = now;
			y2.LastWriteTime = now;
			WebFile[] a = new WebFile[2];
			a[0] = y1;
			a[1] = y2;
			x.WebFiles = a;
			_wd = x;
			int iteration = 10000;
			Type t = _wd.GetType();
			int length = 0;
			XmlSerializer serializer1 = new XmlSerializer(t);
			CodeTimer.ParallelTime
						(
							"TestXmlSerializer"
							, iteration
							, () =>
							{
								length = TestXmlSerializerOnce(serializer1);
							}
						);
			Console.WriteLine("Length: {0}", length);
			DataContractSerializer serializer2 = new DataContractSerializer(t);
			CodeTimer.ParallelTime
						(
							"TestDataContractSerializer"
							, iteration
							, () =>
							{
								length = TestDataContractSerializerOnce(serializer2);
							}
						);
			Console.WriteLine("Length: {0}", length);
			DataContractJsonSerializer serializer3 = new DataContractJsonSerializer(t);
			CodeTimer.ParallelTime
						(
							"TestDataContractJsonSerializer"
							, iteration
							, () =>
							{
								length = TestDataContractJsonSerializerOnce(serializer3);
							}
						);
			Console.WriteLine("Length: {0}", length);
			CodeTimer.ParallelTime
						(
							"TestSoapFormatter"
							, iteration
							, () =>
							{
								length = TestSoapFormatterOnce();
							}
						);
			Console.WriteLine("Length: {0}", length);
			CodeTimer.ParallelTime
						(
							"TestBinaryFormatter"
							, iteration
							, () =>
							{
								length = TestBinaryFormatterOnce();
							}
						);
			Console.WriteLine("Length: {0}", length);
			Console.WriteLine();
			Console.WriteLine();
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		static int TestXmlSerializerOnce(XmlSerializer serializer)
		{
			string xml = string.Empty;
			xml = SerializerHelper.XmlSerializerObjectToXml<WebDirectory>
											(
												_wd
												, serializer
												, new XmlWriterSettings()
													{
														// = true
														OmitXmlDeclaration = true
														, Encoding= Encoding.UTF8
													}
											);
			//Console.WriteLine(xml.Length);
			WebDirectory wd = SerializerHelper.XmlSerializerXmlToObject<WebDirectory>(xml, serializer);
			return xml.Length;
		}
		static int TestDataContractSerializerOnce(DataContractSerializer serializer)
		{
			string xml = string.Empty;
			xml = SerializerHelper.DataContractSerializerObjectToXml<WebDirectory>(_wd, serializer);
			//Console.WriteLine(xml.Length);
			WebDirectory wd = SerializerHelper.DataContractSerializerXmlToObject<WebDirectory>(xml, serializer);
			return xml.Length;
		}
		static int TestDataContractJsonSerializerOnce(DataContractJsonSerializer serializer)
		{
			string json = string.Empty;
			json = SerializerHelper.DataContractSerializerObjectToJson<WebDirectory>(_wd, serializer);
			//Console.WriteLine(xml.Length);
			WebDirectory wd = SerializerHelper.DataContractSerializerJsonToObject<WebDirectory>(json, serializer);
			return json.Length;
		}
		static int TestSoapFormatterOnce()
		{
			string soap = string.Empty;
			soap = SerializerHelper.FormatterObjectToSoap<WebDirectory>(_wd);
			//Console.WriteLine(xml.Length);
			WebDirectory wd = SerializerHelper.FormatterSoapToObject<WebDirectory>(soap);
			return soap.Length;
		}
		static int TestBinaryFormatterOnce()
		{
			byte[] buffer;
			//xml = SerializerHelper.XmlSerializerObjectToXml<WebDirectory>(_wd, Encoding.UTF8);
			//WebDirectory wd = SerializerHelper.XmlSerializerXmlToObject<WebDirectory>(xml);
			buffer = SerializerHelper.FormatterObjectToBinary<WebDirectory>(_wd);
			//Console.WriteLine(xml.Length);
			WebDirectory wd = SerializerHelper.FormatterBinaryToObject<WebDirectory>(buffer);
			return buffer.Length;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	using System.Threading;
	using System.Threading.Tasks;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void ParallelTime(string name, int iteration, Action action)
		{
			InternalIterationProcess
					 (
						name
						, iteration
						, () =>
						{
							Parallel.For
									(
										0
										, iteration
										, new ParallelOptions()
										{
											MaxDegreeOfParallelism = 1
											//, TaskScheduler = null
										}
												, i =>
												{
													action();
												}
									);
						}
					);
		}
		private static void InternalIterationProcess(string name, int iteration, Action action)
		{
			if (string.IsNullOrEmpty(name))
			{
				return;
			}
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCycleCount();
			action();
			ulong cpuCycles = GetCycleCount() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine
							(
								"{0}Time Elapsed:{0}{1}ms"
								, "\t"
								, watch.ElapsedMilliseconds.ToString("N0")
							);
			Console.WriteLine
							(
								"{0}CPU Cycles:{0}{1}"
								, "\t"
								, cpuCycles.ToString("N0")
							);
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine
							(
								"{0}Gen {1}: {0}{0}{2}"
								, "\t"
								, i
								, count
							);
			}
			Console.WriteLine();
		}
		public static void Time(string name, int iteration, Action action)
		{
			InternalIterationProcess
								(
									name
									, iteration
									, () =>
									{
										for (int i = 0; i < iteration; i++)
										{
											action();
										}
									}
								);
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
	}
}
namespace Test.Share
{
	using System;
	using System.Runtime.Serialization;
	using System.Xml.Serialization;
	[XmlRoot("WebDirectory")]
	[Serializable]
	[DataContract]
	public class WebDirectory
	{
		[XmlAttribute("Name")]
		[DataMember]
		public string Name;
		[XmlArrayItem("WebFile", typeof(WebFile))]
		[XmlArray("WebFiles")]
		[DataMember]
		public WebFile[] WebFiles;
	}
	[DataContract]
	public enum FlagEnum : uint
	{
		[EnumMember]
		Value1
		,
		[EnumMember]
		Value2
	}
	[Serializable]
	[DataContract]
	public class WebFile
	{
		[XmlAttribute("Name")]
		[DataMember]
		public string Name;
		[XmlAttribute("CreateTime")]
		[DataMember]
		public DateTime CreateTime;
		[XmlAttribute("LastWriteTime")]
		[XmlIgnore()]
		[DataMember]
		public DateTime LastWriteTime;
		[XmlAttribute("Length")]
		[DataMember]
		public long Length;
		//[XmlAttribute("Url")]
		[XmlElement("Url")]
		[DataMember]
		public string Url;
		[XmlAttribute("IsReadOnly")]
		[DataMember]
		public bool IsReadOnly;
		[XmlAttribute("Flag")]
		[DataMember]
		public FlagEnum Flag;
		[XmlElement("Directory")]
		[DataMember]
		public WebDirectory Directory;
	}
}
namespace Microshaoft
{
	using System.IO;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Formatters.Binary;
	using System.Runtime.Serialization.Formatters.Soap;
	using System.Runtime.Serialization.Json;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	public static class SerializerHelper
	{
		public static T XmlSerializerXmlToObject<T>(string xml, XmlSerializer serializer = null)
		{
			StringReader stringReader = new StringReader(xml);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			if (serializer == null)
			{
				serializer = new XmlSerializer(typeof(T));
			}
			return (T) serializer.Deserialize(xmlReader);
		}
		public static string XmlSerializerObjectToXml<T>(T target, XmlSerializer serializer = null, XmlWriterSettings settings = null)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				using (XmlWriter writer = XmlTextWriter.Create(stream, settings))
				{
					if (serializer == null)
					{
						serializer = new XmlSerializer(typeof(T));
					}
					serializer.Serialize(writer, target);
					byte[] buffer = StreamDataHelper.ReadDataToBytes(stream);
					if (settings == null)
					{
						settings = writer.Settings;
					}
					var e = settings.Encoding;
					var p = e.GetPreamble().Length;
					string s = e.GetString(buffer, p, buffer.Length - p);
					writer.Close();
					return s;
				}
			}
		}
		public static string DataContractSerializerObjectToXml<T>(T target, DataContractSerializer serializer)
		{
			using (MemoryStream ms = new MemoryStream())
			{
				serializer.WriteObject(ms, target);
				byte[] buffer = StreamDataHelper.ReadDataToBytes(ms);
				string xml = Encoding.UTF8.GetString(buffer);
				ms.Close();
				return xml;
			}
		}
		public static string DataContractSerializerObjectToXml<T>(T target)
		{
			DataContractSerializer serializer = new DataContractSerializer(typeof(T));
			string xml = DataContractSerializerObjectToXml<T>(target, serializer);
			return xml;
		}
		public static T DataContractSerializerXmlToObject<T>(string xml, DataContractSerializer serializer)
		{
			byte[] buffer = Encoding.UTF8.GetBytes(xml);
			using (MemoryStream ms = new MemoryStream(buffer))
			{
				T target = (T) serializer.ReadObject(ms);
				ms.Close();
				return target;
			}
		}
		public static T DataContractSerializerXmlToObject<T>(string xml)
		{
			DataContractSerializer serializer = new DataContractSerializer(typeof(T));
			byte[] buffer = Encoding.UTF8.GetBytes(xml);
			using (MemoryStream ms = new MemoryStream(buffer))
			{
				T target = (T) serializer.ReadObject(ms);
				ms.Close();
				return target;
			}
		}
		public static string FormatterObjectToSoap<T>(T target)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				SoapFormatter formatter = new SoapFormatter();
				formatter.Serialize(stream, target);
				string soap = Encoding.UTF8.GetString(stream.GetBuffer());
				return soap;
			}
		}
		public static T FormatterSoapToObject<T>
									(
										string soap
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				SoapFormatter formater = new SoapFormatter();
				byte[] data = Encoding.UTF8.GetBytes(soap);
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T target = (T) formater.Deserialize(stream);
				return target;
			}
		}
		public static byte[] FormatterObjectToBinary<T>
									(
										T target
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				formater.Serialize(stream, target);
				byte[] buffer = stream.ToArray();
				return buffer;
			}
		}
		public static T FormatterBinaryToObject<T>
									(
										byte[] data
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T target = (T) formater.Deserialize(stream);
				return target;
			}
		}
		public static string DataContractSerializerObjectToJson<T>(T target)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			string json = DataContractSerializerObjectToJson<T>(target);
			return json;
		}
		public static string DataContractSerializerObjectToJson<T>(T target, DataContractJsonSerializer serializer)
		{
			using (MemoryStream ms = new MemoryStream())
			{
				serializer.WriteObject(ms, target);
				string json = Encoding.UTF8.GetString(ms.GetBuffer());
				ms.Close();
				return json;
			}
		}
		public static T DataContractSerializerJsonToObject<T>(string json)
		{
			DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(T));
			T target = DataContractSerializerJsonToObject<T>(json, serializer);
			return target;
		}
		public static T DataContractSerializerJsonToObject<T>(string json, DataContractJsonSerializer serializer)
		{
			MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
			T target = (T) serializer.ReadObject(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return target;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=Services Daemon
namespace Microshaoft
{
	using System;
	using System.Timers;
	using System.Management;
	using System.ServiceProcess;
	using System.Diagnostics;
	using System.ComponentModel;
	using System.Collections.Generic;
	using System.Security.Principal;
	using System.Configuration.Install;
	using Microshaoft;
	public class SimpleService : ServiceBase //继承于 ServiceBase
	{
		public const string serviceName = "ServicesDaemon";
		private Timer _timer;
		public static void Main(string[] args)
		{
			SimpleService x = new SimpleService();
			int l = 0;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0) //有参数时以 console 方式运行
			{
				Console.Title = "serviceName";
				Console.WriteLine("Run as Console");
				x.OnStart(null);
				Console.ReadLine();
			}
			else
			//intallutil 成服务后
			//即: 无参数时,以 Service 方式运行
			{
				Console.WriteLine("Run as Service");
				ServiceBase.Run(x);
			}
		}
		public SimpleService()
		{
			CanPauseAndContinue = true;
			ServiceName = SimpleService.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(".Net Version: {0}", Environment.Version.ToString());
			Console.WriteLine("Current Identity: {0}", WindowsIdentity.GetCurrent().Name);
			Console.WriteLine("{0} started,at {1}", SimpleService.serviceName, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ss"));
			_timer = new Timer();
			_timer.Interval = 60 * 1000;
			_timer.Elapsed += new ElapsedEventHandler(_timer_Elapsed);
			_timer.Start();
			_timer_Elapsed(null, null);
			//在这里写你的程序
		}
		void _timer_Elapsed(object sender, ElapsedEventArgs e)
		{
			_timer.Stop();
			try
			{
				Process();
			}
			catch
			{
			}
			finally
			{
				_timer.Start();
			}
		}
		private void Process()
		{
			ManagementObjectSearcher searcher = new ManagementObjectSearcher
																(
																	"root\\CIMV2",
																	"SELECT * FROM Win32_Service where name like 'hello%'"
																);
			ManagementObjectCollection moc = searcher.Get();
			foreach (ManagementObject mo in moc)
			{
				string logMessage;
				string service = null;
				try
				{
					service = mo["Name"].ToString();
					if (mo["State"].ToString().ToLower() != "running")
					{
						logMessage = string.Format
												(
													"主机[{0}],[{1}],[{2}] 服务于[{3}]没有运行"
													, Environment.MachineName
													, service
													, mo["StartMode"].ToString()
													, DateTime.Now
												 );
						EventLogHelper.WriteEventLogEntry
											(
												this.ServiceName + " log",
												service + " source",
												logMessage,
												EventLogEntryType.Error
											);
						if (mo["StartMode"].ToString().ToLower() == "auto")
						{
							ServiceController controller = new ServiceController(service);
							if (controller.Status != ServiceControllerStatus.Running)
							{
								controller.Start();
							}
							logMessage = string.Format
													(
														"主机[{0}],[{1}],[{2}] 服务于[{3}]成功重新启动"
														, Environment.MachineName
														, service
														, mo["StartMode"].ToString()
														, DateTime.Now
													);
							EventLogHelper.WriteEventLogEntry
												(
													this.ServiceName + " log",
													service + " source",
													logMessage,
													EventLogEntryType.Information
												);
						}
					}
				}
				catch (ManagementException me)
				{
					logMessage = string.Format
											(
												"主机[{0}],[{1}],[{2}] 服务查询发生[{3}]异常[{4}],于[{5}]"
												, Environment.MachineName
												, service
												, mo["StartMode"].ToString()
												, "ManagementException"
												, me.ToString()
												, DateTime.Now
											);
					EventLogHelper.WriteEventLogEntry
											(
												this.ServiceName + " log",
												service + " source",
												logMessage,
												EventLogEntryType.Error
											);
				}
				catch (Exception e)
				{
					logMessage = string.Format
											(
												"主机[{0}],[{1}],[{2}] 服务查询发生[{3}]异常[{4}],于[{5}]"
												, Environment.MachineName
												, service
												, mo["StartMode"].ToString()
												, "Exception"
												, e.ToString()
												, DateTime.Now
											);
					EventLogHelper.WriteEventLogEntry
											(
												this.ServiceName + " log",
												service + " source",
												logMessage, EventLogEntryType.Error
											);
				}
			}
		}
	}
	//以下就是比普通应用程序多出的 ProjectInstaller
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = SimpleService.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	class EventLogHelper
	{
		public static void WriteEventLogEntry
										(
											string logName,
											string sourceName,
											string logMessage,
											EventLogEntryType logEntryType
										)
		{
			if (!EventLog.SourceExists(sourceName))
			{
				EventLog.CreateEventSource(sourceName, logName);
			}
			EventLog log = new EventLog();
			log.Source = sourceName;
			log.WriteEntry(logMessage, logEntryType);
		}
	}
}
#T=SetTimeout SetInterval
namespace ConsoleApplication
{
	using System;
	using System.Timers;
	using System.Windows.Forms;

	using WindowsApplication;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			int i = 1;

			int timeout = 3000;

			SetTimeout
				(
					timeout
					, delegate
						{
							Console.WriteLine("Console SetTimeout {0} 毫秒 执行 1 次", timeout);
						}
				);
			int interval = 1000;
			SetInterval
					(
						interval
						, e => Console.WriteLine("Console {0} SetInterval 执行第 {1} 次", e.SignalTime, i++)
					);
					
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());


			Application.Run(new Form1());

			//Console.ReadLine();
		}
		/// <summary>
		/// 在指定时间过后执行指定的表达式
		/// </summary>
		/// <param name="interval">事件之间经过的时间（以毫秒为单位）</param>
		/// <param name="action">要执行的表达式</param>
		public static void SetTimeout(double interval, Action action)
		{
			System.Timers.Timer timer = new System.Timers.Timer(interval);
			timer.Elapsed += delegate(object sender, System.Timers.ElapsedEventArgs e)
			{
				timer.Enabled = false;
				action();
			};
			timer.Enabled = true;
		}
		/// <summary>
		/// 在指定时间周期重复执行指定的表达式
		/// </summary>
		/// <param name="interval">事件之间经过的时间（以毫秒为单位）</param>
		/// <param name="action">要执行的表达式</param>
		public static void SetInterval(double interval, Action<ElapsedEventArgs> action)
		{
			System.Timers.Timer timer = new System.Timers.Timer(interval);
			timer.Elapsed += delegate(object sender, System.Timers.ElapsedEventArgs e)
			{
				action(e);
			};
			timer.Enabled = true;
		}
	}

}




namespace WindowsApplication
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Data;


	using ConsoleApplication;
	//// <summary>
	//// Form1 的摘要说明。
	//// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button button1;
		//// <summary>
		//// 必需的设计器变量。
		//// </summary>
		private System.ComponentModel.Container components = null;

		public Form1()
		{
			///
			/// Windows 窗体设计器支持所必需的
			///
			InitializeComponent();

			///
			/// TODO: 在 InitializeComponent 调用后添加任何构造函数代码
			///
		}

		//// <summary>
		//// 清理所有正在使用的资源。
		//// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows 窗体设计器生成的代码
		//// <summary>
		//// 设计器支持所需的方法 - 不要使用代码编辑器修改
		//// 此方法的内容。
		//// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.SuspendLayout();
			/// 
			/// button1
			/// 
			this.button1.Location = new System.Drawing.Point(96, 112);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(88, 32);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			/// 
			/// Form1
			/// 
			this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
			this.ClientSize = new System.Drawing.Size(292, 273);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new System.EventHandler(this.Form1_Load);
			this.ResumeLayout(false);

		}
		#endregion

		//// <summary>
		//// 应用程序的主入口点。
		//// </summary>
///		[STAThread]
///		static void Main() 
///		{
///			Application.Run(new Form1());
///		}

		private void Form1_Load(object sender, System.EventArgs e)
		{
		
		}

		private void button1_Click(object sender, System.EventArgs e)
		{
			int n = 1;
			Class1.SetInterval
				(
					1000
					, ee =>
						{
							Action action = delegate()
												{
													Console.WriteLine("Windows 第 {0} 次重复, {1}", n++, ee.SignalTime.ToString());
												};
						
							this.Invoke(action);
						}
				);
					
		
		}
	}
}
#T=SetWindowLong GetWindowLong
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	public class test
	{
		public delegate int WindowProcessHandler(int Wnd, int Msg, int WParam, int LParam);
		public const int HH_DISPLAY_INDEX = 0x0002;
		public const int GWL_WNDPROC = -4;
		public static int _hWndPrevious = 0;
		//[STAThread]
		static void Main(string[] args)
		{
			int hWnd = HtmlHelp(0, @"D:\Script56(12.7.2005)\script56.chm", HH_DISPLAY_INDEX, "");
			Console.WriteLine(hWnd);
			_hWndPrevious = GetWindowLong(hWnd, GWL_WNDPROC);
			Console.WriteLine("old: " + _hWndPrevious);
			WindowProcessHandler handler = new WindowProcessHandler(WndProc);
			IntPtr fnPtr = Marshal.GetFunctionPointerForDelegate(handler);
			SetWindowLong(hWnd, GWL_WNDPROC, (int) fnPtr);
			//Application.Run();
			Console.ReadLine();
		}
		private static int WndProc(int hWnd, int msg, int WParam, int LParam)
		{
			//在这里监控消息
			Console.WriteLine(msg);
			return CallWindowProc(_hWndPrevious, hWnd, msg, WParam, LParam);
		}
		[DllImport("user32.dll")]
		public static extern int GetWindowLong(int hWindow, int nIndex);
		[DllImport("user32.dll")]
		static extern int CallWindowProc(int lpPrevWndFunc, int hWnd, int msg, int wParam, int lParam);  
		[DllImport("user32.dll")]
		public static extern int SetWindowLong(int hWnd, int nIndex, int dwNewLong);
		[DllImport("hhctrl.ocx", CharSet = CharSet.Unicode, EntryPoint = "HtmlHelpW")]
		protected static extern int HtmlHelp(int caller, string file, uint command, string str);
	}
}
#T=SharePoint 初始化铺底
^#######powershell -Command "& {.\Cnblogs.ps1}" -NoExit
^#######pause


^# check to ensure Microsoft.SharePoint.PowerShell is loaded
$snapin = Get-PSSnapin | Where-Object {$_.Name -eq 'Microsoft.SharePoint.Powershell'}
if ($snapin -eq $null) {
    Write-Host "Loading SharePoint Powershell Snapin"
    Add-PSSnapin "Microsoft.SharePoint.Powershell"
}

$WebAppPoolAccount = "T\Administrator"
$WebAppName = "SharePoint - XXX.com80"
$WebAppPort = 80
$WebAppPool = "SharePoint - XXX.com80"
$WebAppDBName = "WSS_Content_XXX"
$WebAppUrl = "http://XXX.com"
$WebAppUrl_XXX = "http://XXX.com/XXX"
$WebAppHostHeader = "XXX.com"
$SiteTemplate_WorkGroup = "STS#0"    #STS#0 是工作组网站
$SiteTemplate_DocCenter = "BDR#0"    #STS#0 是文档中心
^################################################ WebApplication #################################################

^#Delete any existing Webapplication by name
$targetUrl = Get-SPWebApplication  $WebAppUrl
if($targetUrl -ne $null){
    Write-host "Deleting existing webapplication:" $WebAppName
    Remove-SPWebApplication $WebAppName -confirm -DeleteIISSite -removeContentDatabase
    Write-host "Deleted Site and ContentDatabase successful." -foregroundcolor red
}

Write-Host "Starting create WebApplication"
Write-Host "Please waiting......" -foregroundcolor green
$WebApp = New-SPWebApplication -Name $WebAppName -Port $WebAppPort -HostHeader $WebAppHostHeader -URL $WebAppUrl -ApplicationPool $WebAppPool -DatabaseName $WebAppDBName -ApplicationPoolAccount (get-SPManagedAccount $WebAppPoolAccount)
Write-Host "WebApplication Created successfully"

^#display WebApplication Info
Write-Host
Write-Host "------------------------------" -foregroundcolor Green
Write-Host "Name:" $WebApp.Name -foregroundcolor green
Write-Host "URL:" $WebApp.Url   -foregroundcolor green
Write-Host "------------------------------" -foregroundcolor Green
^########### 自定义方法 Add Web #############
Function Add_Web($webUrl,$webName,$template){
    Write-Host "Creating new web "  $webUrl " please waiting......"
    New-SPWeb -Url $webUrl  -Template $template -Name $webName
    Write-Host "Created " $webUrl " sucessful!" -foregroundcolor green
}
^########### Site #####################
if($WebApp -ne $null){
    Write-host $WebApp.Url -foregroundcolor green
    $SiteUrl = $WebApp.Url
    $SiteTitle = "XXX"
    
    # 创建网站集
    Write-Host "Creating new site "  $SiteTitle " ,please waiting......"
    $NewSite = New-SPSite -Url $SiteUrl -OwnerAlias $WebAppPoolAccount -Template $SiteTemplate_WorkGroup -Name $SiteTitle
    Write-host "Finish Createed successful" -foregroundcolor green    
    
    # 激活网站集功能
    Write-host "Starting active PublishingSite feature" 
    Enable-SPFeature CIdentity PublishingSite Curl $WebAppUrl
    Write-host "PublishingSite Actived" -foregroundcolor green
    
    #创建子站点
    Add_Web $WebAppUrl_XXX "XXX" $SiteTemplate_WorkGroup
    
    $NewSite.Dispose()     
}
else{
    Write-host "WebApplication " $WebApp.Name " is not existing"
}

^################################################### SPGROUP
^# 获取网站集
$Web = Get-SPWeb $WebAppUrl
$GroupCount = $Web.SiteGroups.Count # 获取站点用户组的个数
^#删除目前已有的用户组
While($GroupCount -ne 0){
    $Web.SiteGroups.Remove($Web.SiteGroups[$GroupCount-1])
    $GroupCount--
}
$Web.Update();
^################################ 自定义方法 
^# 给用户组分配相应的权限
function AddRoleAssignment($group,$role){
    $RoleAssignment = New-Object Microsoft.SharePoint.SPRoleAssignment($group);    
    $RoleAssignment.RoleDefinitionBindings.Add($role)     
    $Web.RoleAssignments.Add($RoleAssignment)
}
$Domain = "T\"
^#添加用户
function AddUser($group,$userName){
   $User = $web.Site.RootWeb.EnsureUser($Domain + $userName)
   $group.AddUser($User)
}
^# 给相应的组添加成员
function AddUser_DeptLeader($group){
    foreach($user in $group.Users){
        $group.RemoveUser($user);
    }
    AddUser $group "zhangjiangfeng"
}
^# 获取相应的角色
$RoleName_Discuss = "参与讨论"
$RoleDiscuss = $Web.RoleDefinitions[$RoleName_Discuss]
$RoleName_Contribution = "完全控制"
$RoleContribution = $Web.RoleDefinitions[$RoleName_Contribution]
^#用户组名
$DeptLeader = "XXX"
^################################################################# 
^# 添加组及人员
$Group = $Web.SiteGroups[$DeptLeader]
if($Group -eq $null){  # 判断组是否存在
  $Web.SiteGroups.Add($DeptLeader,$Web.CurrentUser, $Web.CurrentUser,"");  #添加组
  $Group = $Web.SiteGroups[$DeptLeader]  #获取组
  AddUser_DeptLeader $Group   #添加人员
  AddRoleAssignment $Group $RoleDiscuss  #分配权限
}
else{
    AddUser_DeptLeader $Group
}

$Web.Update();
foreach($Group in $Web.SiteGroups){        
   write-host $Group.Name
}
$Web.Dispose()
Write-Host "Finished" -foregroundcolor green

^###################### 添加导航
$Web = Get-SPWeb $WebAppUrl_XXX
$NodeList_XXX = $Web.Navigation.QuickLaunch  # 获取快速启动栏
$NodeList_XXXCount = $NodeList_XXX.Count  #获取菜单个数
Foreach($node in $NodeList_XXX){  # 遍历输出所有菜单
  write-host $node.Title
}
While($NodeList_XXXCount -ne 0){ # 删除已有菜单
    $NodeList_XXX[$NodeList_XXXCount - 1].Delete()
    $NodeList_XXXCount --
}
^##########我的菜单
$NewNode = New-Object Microsoft.SharePoint.Navigation.SPNavigationNode("我的菜单", "",$true)
$NodeList_XXX.AddAsLast($NewNode)

$NewChild =  New-Object Microsoft.SharePoint.Navigation.SPNavigationNode("我的子菜单", "/SitePages/XXX.aspx",$true)
$NewNode.Children.AddAsLast($NewChild)
$NewChild.Properties["Audience"] = ";;;;用户组名"  #给菜单分配相应的访问权限
$NewChild.Update()


^#################################### 添加文档库及文件夹
^# SPListTemplateType
$DocTemp = [Microsoft.SharePoint.SPListTemplateType]::DocumentLibrary
$Folder = [Microsoft.SharePoint.SPFileSystemObjectType]::Folder

^# Delete List
Function DeleteList($web,$listName){
    $list = $web.Lists.TryGetList($listName)
    if($list -ne $null){
        Write-Host "............." $listName "already exists,deleting................" -foregroundcolor red
        $list.Delete()
        Write-host "............." $listName "already is deleted....................." -foregroundcolor Green
        Write-host ""
    }
}
^# Add List
Function AddList($web,$listName,$listDescription,$listTemplate){
    DeleteList $web $listName
    Write-host ".............Starting create " $listName ",please waiting............." 
    $web.Lists.Add($listName,$listDescription,$listTemplate)
    Write-host ".............. " $listName " already is created......................." -foregroundcolor green
}


^# List OnQuickLaunch
Function OnQuickLaunchList($list,$bool){
    $list.OnQuickLaunch = $bool
    $list.Update()
}

^# Add Item
Function AddItemFolder($web,$url,$listName,$name){
    Write-host ".............Starting create " $name " Folder,please waiting............." -foregroundcolor blue
    $list = $web.Lists.TryGetList($listName)
    if($list -ne $null){
       $folder = $list.AddItem($url,$Folder,$name)
       $folder.Update()
       Write-host ".............. " $name " Folder already is created......................." -foregroundcolor green
    }
}

^##
$Web = Get-SPWeb $WebAppUrl_XXX
^################# 添加文档库
AddList $Web "我是文档库" "我是文档库" $DocTemp
AddItemFolder $Web "我是文件夹" "我是文件夹"

$Web.Dispose() 

^############################################################ 分配权限

$RoleName_Discuss = "参与讨论"
$RoleName_Contribution = "完全控制"
$RoleName_Read = "读取"

^# 断开继承
Function BreakRoleInheritance($web,$listName){
    $list = $web.Lists.TryGetList($listName)
    if($list -ne $null){
        Write-Host "............." $listName "BreakRoleInheritance ................" 
        $list.BreakRoleInheritance($false,$false)
        Write-host "............." $listName "BreakRoleInheritance sucessed....................." -foregroundcolor Green
        return $list
    }
}
^# 分配权限
Function AssignPermission($web,$list,$groupName,$roleDefinition){
    $group = $web.SiteGroups[$groupName];
    if($group -ne $null){
        write-host  "............." $list.Title "Add RoleAssignment" $groupName
        $roleAssignment = New-Object Microsoft.SharePoint.SPRoleAssignment($group);
        $permLevel = $web.RoleDefinitions[$roleDefinition];
        $roleAssignment.RoleDefinitionBindings.Add($permLevel);
        $list.RoleAssignments.Add($roleAssignment);
    }
}

$Web = Get-SPWeb $WebAppUrl_XXX

$List = BreakRoleInheritance $Web "我是文档库"
if($List -ne $null){
  AssignPermission $Web $List "XXX" $RoleName_Read
}
$Web.Update();
$Web.Dispose();
#T=Shell Ext ContextMenu
/********************************** Module Header **********************************\
Module Name:  FileContextMenuExt.cs
Project:	  CSShellExtContextMenuHandler
Copyright (c) Microsoft Corporation.
The FileContextMenuExt.cs file defines a context menu handler by implementing the 
IShellExtInit and IContextMenu interfaces.
This source is subject to the Microsoft Public License.
See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
All other rights reserved.
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
\***********************************************************************************/
namespace CSShellExtContextMenuHandler
{
	#region Using directives
	using System;
	using System.Text;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	#endregion
	[ClassInterface(ClassInterfaceType.None)]
	[Guid("B1F1405D-94A1-4692-B72F-FC8CAF8B8700"), ComVisible(true)]
	public class FileContextMenuExt : IShellExtInit, IContextMenu
	{
		// The name of the selected file.
		private string selectedFile;
		private string menuText = "&Display File Name (C#)";
		private string verb = "csdisplay";
		private string verbCanonicalName = "CSDisplayFileName";
		private string verbHelpText = "Display File Name (C#)";
		private uint IDM_DISPLAY = 0;
		void OnVerbDisplayFileName(IntPtr hWnd)
		{
			System.Windows.Forms.MessageBox.Show(
				"The selected file is \r\n\r\n" + this.selectedFile,
				"CSShellExtContextMenuHandler");
		}
		#region Shell Extension Registration
		[ComRegisterFunction()]
		public static void Register(Type t)
		{
			try
			{
				ShellExtReg.RegisterShellExtContextMenuHandler(t.GUID, ".*", 
					"CSShellExtContextMenuHandler.FileContextMenuExt Class");
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message); // Log the error
				throw;  // Re-throw the exception
			}
		}
		[ComUnregisterFunction()]
		public static void Unregister(Type t)
		{
			try
			{
				ShellExtReg.UnregisterShellExtContextMenuHandler(t.GUID, ".*");
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message); // Log the error
				throw;  // Re-throw the exception
			}
		}
		#endregion
		#region IShellExtInit Members
		/// <summary>
		/// Initialize the context menu handler.
		/// </summary>
		/// <param name="pidlFolder">
		/// A pointer to an ITEMIDLIST structure that uniquely identifies a folder.
		/// </param>
		/// <param name="pDataObj">
		/// A pointer to an IDataObject interface object that can be used to retrieve 
		/// the objects being acted upon.
		/// </param>
		/// <param name="hKeyProgID">
		/// The registry key for the file object or folder type.
		/// </param>
		public void Initialize(IntPtr pidlFolder, IntPtr pDataObj, IntPtr hKeyProgID)
		{
			if (pDataObj == IntPtr.Zero)
			{
				throw new ArgumentException();
			}
			FORMATETC fe = new FORMATETC();
			fe.cfFormat = (short)CLIPFORMAT.CF_HDROP;
			fe.ptd = IntPtr.Zero;
			fe.dwAspect = DVASPECT.DVASPECT_CONTENT;
			fe.lindex = -1;
			fe.tymed = TYMED.TYMED_HGLOBAL;
			STGMEDIUM stm = new STGMEDIUM();
			// The pDataObj pointer contains the objects being acted upon. In this 
			// example, we get an HDROP handle for enumerating the selected files 
			// and folders.
			IDataObject dataObject = (IDataObject)Marshal.GetObjectForIUnknown(pDataObj);
			dataObject.GetData(ref fe, out stm);
			try
			{
				// Get an HDROP handle.
				IntPtr hDrop = stm.unionmember;
				if (hDrop == IntPtr.Zero)
				{
					throw new ArgumentException();
				}
				// Determine how many files are involved in this operation.
				uint nFiles = NativeMethods.DragQueryFile(hDrop, UInt32.MaxValue, null, 0);
				// This code sample displays the custom context menu item when only 
				// one file is selected. 
				if (nFiles == 1)
				{
					// Get the path of the file.
					StringBuilder fileName = new StringBuilder(260);
					if (0 == NativeMethods.DragQueryFile(hDrop, 0, fileName,
						fileName.Capacity))
					{
						Marshal.ThrowExceptionForHR(WinError.E_FAIL);
					}
					this.selectedFile = fileName.ToString();
				}
				else
				{
					Marshal.ThrowExceptionForHR(WinError.E_FAIL);
				}
				// [-or-]
				// Enumerate the selected files and folders.
				//if (nFiles > 0)
				//{
				//	StringCollection selectedFiles = new StringCollection();
				//	StringBuilder fileName = new StringBuilder(260);
				//	for (uint i = 0; i < nFiles; i++)
				//	{
				//		// Get the next file name.
				//		if (0 != NativeMethods.DragQueryFile(hDrop, i, fileName,
				//			fileName.Capacity))
				//		{
				//			// Add the file name to the list.
				//			selectedFiles.Add(fileName.ToString());
				//		}
				//	}
				//
				//	// If we did not find any files we can work with, throw 
				//	// exception.
				//	if (selectedFiles.Count == 0)
				//	{
				//		Marshal.ThrowExceptionForHR(WinError.E_FAIL);
				//	}
				//}
				//else
				//{
				//	Marshal.ThrowExceptionForHR(WinError.E_FAIL);
				//}
			}
			finally
			{
				NativeMethods.ReleaseStgMedium(ref stm);
			}
		}
		#endregion
		#region IContextMenu Members
		/// <summary>
		/// Add commands to a shortcut menu.
		/// </summary>
		/// <param name="hMenu">A handle to the shortcut menu.</param>
		/// <param name="iMenu">
		/// The zero-based position at which to insert the first new menu item.
		/// </param>
		/// <param name="idCmdFirst">
		/// The minimum value that the handler can specify for a menu item ID.
		/// </param>
		/// <param name="idCmdLast">
		/// The maximum value that the handler can specify for a menu item ID.
		/// </param>
		/// <param name="uFlags">
		/// Optional flags that specify how the shortcut menu can be changed.
		/// </param>
		/// <returns>
		/// If successful, returns an HRESULT value that has its severity value set 
		/// to SEVERITY_SUCCESS and its code value set to the offset of the largest 
		/// command identifier that was assigned, plus one.
		/// </returns>
		public int QueryContextMenu(
			IntPtr hMenu,
			uint iMenu,
			uint idCmdFirst,
			uint idCmdLast,
			uint uFlags)
		{
			// If uFlags include CMF_DEFAULTONLY then we should not do anything.
			if (((uint)CMF.CMF_DEFAULTONLY & uFlags) != 0)
			{
				return WinError.MAKE_HRESULT(WinError.SEVERITY_SUCCESS, 0, 0);
			}
			// Use either InsertMenu or InsertMenuItem to add menu items.
			MENUITEMINFO mii = new MENUITEMINFO();
			mii.cbSize = (uint)Marshal.SizeOf(mii);
			mii.fMask = MIIM.MIIM_ID | MIIM.MIIM_TYPE | MIIM.MIIM_STATE;
			mii.wID = idCmdFirst + IDM_DISPLAY;
			mii.fType = MFT.MFT_STRING;
			mii.dwTypeData = menuText;
			mii.fState = MFS.MFS_ENABLED;
			if (!NativeMethods.InsertMenuItem(hMenu, iMenu, true, ref mii))
			{
				return Marshal.GetHRForLastWin32Error();
			}
			// Add a separator.
			MENUITEMINFO sep = new MENUITEMINFO();
			sep.cbSize = (uint)Marshal.SizeOf(sep);
			sep.fMask = MIIM.MIIM_TYPE;
			sep.fType = MFT.MFT_SEPARATOR;
			if (!NativeMethods.InsertMenuItem(hMenu, iMenu + 1, true, ref sep))
			{
				return Marshal.GetHRForLastWin32Error();
			}
			// Return an HRESULT value with the severity set to SEVERITY_SUCCESS. 
			// Set the code value to the offset of the largest command identifier 
			// that was assigned, plus one (1).
			return WinError.MAKE_HRESULT(WinError.SEVERITY_SUCCESS, 0,
				IDM_DISPLAY + 1);
		}
		/// <summary>
		/// Carry out the command associated with a shortcut menu item.
		/// </summary>
		/// <param name="pici">
		/// A pointer to a CMINVOKECOMMANDINFO or CMINVOKECOMMANDINFOEX structure 
		/// containing information about the command. 
		/// </param>
		public void InvokeCommand(IntPtr pici)
		{
			bool isUnicode = false;
			// Determine which structure is being passed in, CMINVOKECOMMANDINFO or 
			// CMINVOKECOMMANDINFOEX based on the cbSize member of lpcmi. Although 
			// the lpcmi parameter is declared in Shlobj.h as a CMINVOKECOMMANDINFO 
			// structure, in practice it often points to a CMINVOKECOMMANDINFOEX 
			// structure. This struct is an extended version of CMINVOKECOMMANDINFO 
			// and has additional members that allow Unicode strings to be passed.
			CMINVOKECOMMANDINFO ici = (CMINVOKECOMMANDINFO)Marshal.PtrToStructure(
				pici, typeof(CMINVOKECOMMANDINFO));
			CMINVOKECOMMANDINFOEX iciex = new CMINVOKECOMMANDINFOEX();
			if (ici.cbSize == Marshal.SizeOf(typeof(CMINVOKECOMMANDINFOEX)))
			{
				if ((ici.fMask & CMIC.CMIC_MASK_UNICODE) != 0)
				{
					isUnicode = true;
					iciex = (CMINVOKECOMMANDINFOEX)Marshal.PtrToStructure(pici,
						typeof(CMINVOKECOMMANDINFOEX));
				}
			}
			// Determines whether the command is identified by its offset or verb.
			// There are two ways to identify commands:
			// 
			//   1) The command's verb string 
			//   2) The command's identifier offset
			// 
			// If the high-order word of lpcmi->lpVerb (for the ANSI case) or 
			// lpcmi->lpVerbW (for the Unicode case) is nonzero, lpVerb or lpVerbW 
			// holds a verb string. If the high-order word is zero, the command 
			// offset is in the low-order word of lpcmi->lpVerb.
			// For the ANSI case, if the high-order word is not zero, the command's 
			// verb string is in lpcmi->lpVerb. 
			if (!isUnicode && NativeMethods.HighWord(ici.verb.ToInt32()) != 0)
			{
				// Is the verb supported by this context menu extension?
				if (Marshal.PtrToStringAnsi(ici.verb) == this.verb)
				{
					OnVerbDisplayFileName(ici.hwnd);
				}
				else
				{
					// If the verb is not recognized by the context menu handler, it 
					// must return E_FAIL to allow it to be passed on to the other 
					// context menu handlers that might implement that verb.
					Marshal.ThrowExceptionForHR(WinError.E_FAIL);
				}
			}
			// For the Unicode case, if the high-order word is not zero, the 
			// command's verb string is in lpcmi->lpVerbW. 
			else if (isUnicode && NativeMethods.HighWord(iciex.verbW.ToInt32()) != 0)
			{
				// Is the verb supported by this context menu extension?
				if (Marshal.PtrToStringUni(iciex.verbW) == this.verb)
				{
					OnVerbDisplayFileName(ici.hwnd);
				}
				else
				{
					// If the verb is not recognized by the context menu handler, it 
					// must return E_FAIL to allow it to be passed on to the other 
					// context menu handlers that might implement that verb.
					Marshal.ThrowExceptionForHR(WinError.E_FAIL);
				}
			}
			// If the command cannot be identified through the verb string, then 
			// check the identifier offset.
			else
			{
				// Is the command identifier offset supported by this context menu 
				// extension?
				if (NativeMethods.LowWord(ici.verb.ToInt32()) == IDM_DISPLAY)
				{
					OnVerbDisplayFileName(ici.hwnd);
				}
				else
				{
					// If the verb is not recognized by the context menu handler, it 
					// must return E_FAIL to allow it to be passed on to the other 
					// context menu handlers that might implement that verb.
					Marshal.ThrowExceptionForHR(WinError.E_FAIL);
				}
			}
		}
		/// <summary>
		/// Get information about a shortcut menu command, including the help string 
		/// and the language-independent, or canonical, name for the command.
		/// </summary>
		/// <param name="idCmd">Menu command identifier offset.</param>
		/// <param name="uFlags">
		/// Flags specifying the information to return. This parameter can have one 
		/// of the following values: GCS_HELPTEXTA, GCS_HELPTEXTW, GCS_VALIDATEA, 
		/// GCS_VALIDATEW, GCS_VERBA, GCS_VERBW.
		/// </param>
		/// <param name="pReserved">Reserved. Must be IntPtr.Zero</param>
		/// <param name="pszName">
		/// The address of the buffer to receive the null-terminated string being 
		/// retrieved.
		/// </param>
		/// <param name="cchMax">
		/// Size of the buffer, in characters, to receive the null-terminated string.
		/// </param>
		public void GetCommandString(
			UIntPtr idCmd,
			uint uFlags,
			IntPtr pReserved,
			StringBuilder pszName,
			uint cchMax)
		{
			if (idCmd.ToUInt32() == IDM_DISPLAY)
			{
				switch ((GCS)uFlags)
				{
					case GCS.GCS_VERBW:
						if (this.verbCanonicalName.Length > cchMax - 1)
						{
							Marshal.ThrowExceptionForHR(WinError.STRSAFE_E_INSUFFICIENT_BUFFER);
						}
						else
						{
							pszName.Clear();
							pszName.Append(this.verbCanonicalName);
						}
						break;
					case GCS.GCS_HELPTEXTW:
						if (this.verbHelpText.Length > cchMax - 1)
						{
							Marshal.ThrowExceptionForHR(WinError.STRSAFE_E_INSUFFICIENT_BUFFER);
						}
						else
						{
							pszName.Clear();
							pszName.Append(this.verbHelpText);
						}
						break;
				}
			}
		}
		#endregion
	}
}
/********************************** Module Header **********************************\
Module Name:  ShellExtLib.cs
Project:	  CSShellExtContextMenuHandler
Copyright (c) Microsoft Corporation.
The file declares the imported Shell interfaces: IShellExtInit and IContextMenu, 
implements the helper functions for registering and unregistering a shell context 
menu handler, and declares the Win32 enums, structs, consts, and functions used by 
the code sample.
This source is subject to the Microsoft Public License.
See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
All other rights reserved.
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
\***********************************************************************************/
namespace CSShellExtContextMenuHandler
{
	#region Using directives
	using System;
	using System.Text;
	using Microsoft.Win32;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	#endregion
	#region Shell Interfaces
	[ComImport(), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("000214e8-0000-0000-c000-000000000046")]
	internal interface IShellExtInit
	{
		void Initialize(
			IntPtr /*LPCITEMIDLIST*/ pidlFolder,
			IntPtr /*LPDATAOBJECT*/ pDataObj,
			IntPtr /*HKEY*/ hKeyProgID);
	}
	[ComImport(), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("000214e4-0000-0000-c000-000000000046")]
	internal interface IContextMenu
	{
		[PreserveSig]
		int QueryContextMenu(
			IntPtr /*HMENU*/ hMenu,
			uint iMenu,
			uint idCmdFirst,
			uint idCmdLast,
			uint uFlags);
		void InvokeCommand(IntPtr pici);
		void GetCommandString(
			UIntPtr idCmd,
			uint uFlags,
			IntPtr pReserved,
			StringBuilder pszName,
			uint cchMax);
	}
	#endregion
	#region Shell Registration
	internal class ShellExtReg
	{
		/// <summary>
		/// Register the context menu handler.
		/// </summary>
		/// <param name="clsid">The CLSID of the component.</param>
		/// <param name="fileType">
		/// The file type that the context menu handler is associated with. For 
		/// example, '*' means all file types; '.txt' means all .txt files. The 
		/// parameter must not be NULL or an empty string. 
		/// </param>
		/// <param name="friendlyName">The friendly name of the component.</param>
		public static void RegisterShellExtContextMenuHandler(Guid clsid, 
			string fileType, string friendlyName)
		{
			if (clsid == Guid.Empty)
			{
				throw new ArgumentException("clsid must not be empty");
			}
			if (string.IsNullOrEmpty(fileType))
			{
				throw new ArgumentException("fileType must not be null or empty");
			}
			// If fileType starts with '.', try to read the default value of the 
			// HKCR\<File Type> key which contains the ProgID to which the file type 
			// is linked.
			if (fileType.StartsWith("."))
			{
				using (RegistryKey key = Registry.ClassesRoot.OpenSubKey(fileType))
				{
					if (key != null)
					{
						// If the key exists and its default value is not empty, use 
						// the ProgID as the file type.
						string defaultVal = key.GetValue(null) as string;
						if (!string.IsNullOrEmpty(defaultVal))
						{
							fileType = defaultVal;
						}
					}
				}
			}
			// Create the key HKCR\<File Type>\shellex\ContextMenuHandlers\{<CLSID>}.
			string keyName = string.Format(@"{0}\shellex\ContextMenuHandlers\{1}",
				fileType, clsid.ToString("B"));
			using (RegistryKey key = Registry.ClassesRoot.CreateSubKey(keyName))
			{
				// Set the default value of the key.
				if (key != null && !string.IsNullOrEmpty(friendlyName))
				{
					key.SetValue(null, friendlyName);
				}
			}
		}
		/// <summary>
		/// Unregister the context menu handler.
		/// </summary>
		/// <param name="clsid">The CLSID of the component.</param>
		/// <param name="fileType">
		/// The file type that the context menu handler is associated with. For 
		/// example, '*' means all file types; '.txt' means all .txt files. The 
		/// parameter must not be NULL or an empty string. 
		/// </param>
		public static void UnregisterShellExtContextMenuHandler(Guid clsid, 
			string fileType)
		{
			if (clsid == null)
			{
				throw new ArgumentException("clsid must not be null");
			}
			if (string.IsNullOrEmpty(fileType))
			{
				throw new ArgumentException("fileType must not be null or empty");
			}
			// If fileType starts with '.', try to read the default value of the 
			// HKCR\<File Type> key which contains the ProgID to which the file type 
			// is linked.
			if (fileType.StartsWith("."))
			{
				using (RegistryKey key = Registry.ClassesRoot.OpenSubKey(fileType))
				{
					if (key != null)
					{
						// If the key exists and its default value is not empty, use 
						// the ProgID as the file type.
						string defaultVal = key.GetValue(null) as string;
						if (!string.IsNullOrEmpty(defaultVal))
						{
							fileType = defaultVal;
						}
					}
				}
			}
			// Remove the key HKCR\<File Type>\shellex\ContextMenuHandlers\{<CLSID>}.
			string keyName = string.Format(@"{0}\shellex\ContextMenuHandlers\{1}",
				fileType, clsid.ToString("B"));
			Registry.ClassesRoot.DeleteSubKeyTree(keyName, false);
		}
	}
	#endregion
	#region Enums & Structs
	internal enum GCS : uint
	{
		GCS_VERBA = 0x00000000,
		GCS_HELPTEXTA = 0x00000001,
		GCS_VALIDATEA = 0x00000002,
		GCS_VERBW = 0x00000004,
		GCS_HELPTEXTW = 0x00000005,
		GCS_VALIDATEW = 0x00000006,
		GCS_VERBICONW = 0x00000014,
		GCS_UNICODE = 0x00000004
	}
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal struct CMINVOKECOMMANDINFO
	{
		public uint cbSize;
		public CMIC fMask;
		public IntPtr hwnd;
		public IntPtr verb;
		[MarshalAs(UnmanagedType.LPStr)]
		public string parameters;
		[MarshalAs(UnmanagedType.LPStr)]
		public string directory;
		public int nShow;
		public uint dwHotKey;
		public IntPtr hIcon;
	}
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal struct CMINVOKECOMMANDINFOEX
	{
		public uint cbSize;
		public CMIC fMask;
		public IntPtr hwnd;
		public IntPtr verb;
		[MarshalAs(UnmanagedType.LPStr)]
		public string parameters;
		[MarshalAs(UnmanagedType.LPStr)]
		public string directory;
		public int nShow;
		public uint dwHotKey;
		public IntPtr hIcon;
		[MarshalAs(UnmanagedType.LPStr)]
		public string title;
		public IntPtr verbW;
		public string parametersW;
		public string directoryW;
		public string titleW;
		POINT ptInvoke;
	}
	[Flags]
	internal enum CMIC : uint
	{
		CMIC_MASK_ICON = 0x00000010,
		CMIC_MASK_HOTKEY = 0x00000020,
		CMIC_MASK_NOASYNC = 0x00000100,
		CMIC_MASK_FLAG_NO_UI = 0x00000400,
		CMIC_MASK_UNICODE = 0x00004000,
		CMIC_MASK_NO_CONSOLE = 0x00008000,
		CMIC_MASK_ASYNCOK = 0x00100000,
		CMIC_MASK_NOZONECHECKS = 0x00800000,
		CMIC_MASK_FLAG_LOG_USAGE = 0x04000000,
		CMIC_MASK_SHIFT_DOWN = 0x10000000,
		CMIC_MASK_PTINVOKE = 0x20000000,
		CMIC_MASK_CONTROL_DOWN = 0x40000000
	}
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	public struct POINT
	{
		public int X;
		public int Y;
	}
	internal enum CLIPFORMAT : uint
	{
		CF_TEXT = 1,
		CF_BITMAP = 2,
		CF_METAFILEPICT = 3,
		CF_SYLK = 4,
		CF_DIF = 5,
		CF_TIFF = 6,
		CF_OEMTEXT = 7,
		CF_DIB = 8,
		CF_PALETTE = 9,
		CF_PENDATA = 10,
		CF_RIFF = 11,
		CF_WAVE = 12,
		CF_UNICODETEXT = 13,
		CF_ENHMETAFILE = 14,
		CF_HDROP = 15,
		CF_LOCALE = 16,
		CF_MAX = 17,
		CF_OWNERDISPLAY = 0x0080,
		CF_DSPTEXT = 0x0081,
		CF_DSPBITMAP = 0x0082,
		CF_DSPMETAFILEPICT = 0x0083,
		CF_DSPENHMETAFILE = 0x008E,
		CF_PRIVATEFIRST = 0x0200,
		CF_PRIVATELAST = 0x02FF,
		CF_GDIOBJFIRST = 0x0300,
		CF_GDIOBJLAST = 0x03FF
	}
	[Flags]
	internal enum CMF : uint
	{
		CMF_NORMAL = 0x00000000,
		CMF_DEFAULTONLY = 0x00000001,
		CMF_VERBSONLY = 0x00000002,
		CMF_EXPLORE = 0x00000004,
		CMF_NOVERBS = 0x00000008,
		CMF_CANRENAME = 0x00000010,
		CMF_NODEFAULT = 0x00000020,
		CMF_INCLUDESTATIC = 0x00000040,
		CMF_ITEMMENU = 0x00000080,
		CMF_EXTENDEDVERBS = 0x00000100,
		CMF_DISABLEDVERBS = 0x00000200,
		CMF_ASYNCVERBSTATE = 0x00000400,
		CMF_OPTIMIZEFORINVOKE = 0x00000800,
		CMF_SYNCCASCADEMENU = 0x00001000,
		CMF_DONOTPICKDEFAULT = 0x00002000,
		CMF_RESERVED = 0xFFFF0000
	}
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal struct MENUITEMINFO
	{
		public uint cbSize;
		public MIIM fMask;
		public MFT fType;
		public MFS fState;
		public uint wID;
		public IntPtr hSubMenu;
		public IntPtr hbmpChecked;
		public IntPtr hbmpUnchecked;
		public UIntPtr dwItemData;
		public string dwTypeData;
		public uint cch;
		public IntPtr hbmpItem;
	}
	[Flags]
	internal enum MIIM : uint
	{
		MIIM_STATE = 0x00000001,
		MIIM_ID = 0x00000002,
		MIIM_SUBMENU = 0x00000004,
		MIIM_CHECKMARKS = 0x00000008,
		MIIM_TYPE = 0x00000010,
		MIIM_DATA = 0x00000020,
		MIIM_STRING = 0x00000040,
		MIIM_BITMAP = 0x00000080,
		MIIM_FTYPE = 0x00000100
	}
	internal enum MFT : uint
	{
		MFT_STRING = 0x00000000,
		MFT_BITMAP = 0x00000004,
		MFT_MENUBARBREAK = 0x00000020,
		MFT_MENUBREAK = 0x00000040,
		MFT_OWNERDRAW = 0x00000100,
		MFT_RADIOCHECK = 0x00000200,
		MFT_SEPARATOR = 0x00000800,
		MFT_RIGHTORDER = 0x00002000,
		MFT_RIGHTJUSTIFY = 0x00004000
	}
	internal enum MFS : uint
	{
		MFS_ENABLED = 0x00000000,
		MFS_UNCHECKED = 0x00000000,
		MFS_UNHILITE = 0x00000000,
		MFS_GRAYED = 0x00000003,
		MFS_DISABLED = 0x00000003,
		MFS_CHECKED = 0x00000008,
		MFS_HILITE = 0x00000080,
		MFS_DEFAULT = 0x00001000
	}
	#endregion
	internal class NativeMethods
	{
		/// <summary>
		/// Retrieve the names of dropped files that result from a successful drag-
		/// and-drop operation.
		/// </summary>
		/// <param name="hDrop">
		/// Identifier of the structure that contains the file names of the dropped 
		/// files.
		/// </param>
		/// <param name="iFile">
		/// Index of the file to query. If the value of this parameter is 0xFFFFFFFF, 
		/// DragQueryFile returns a count of the files dropped. 
		/// </param>
		/// <param name="pszFile">
		/// The address of a buffer that receives the file name of a dropped file 
		/// when the function returns.
		/// </param>
		/// <param name="cch">
		/// The size, in characters, of the pszFile buffer.
		/// </param>
		/// <returns>A non-zero value indicates a successful call.</returns>
		[DllImport("shell32", CharSet = CharSet.Unicode)]
		public static extern uint DragQueryFile(
			IntPtr hDrop,
			uint iFile,
			StringBuilder pszFile,
			int cch);
		/// <summary>
		/// Free the specified storage medium.
		/// </summary>
		/// <param name="pmedium">
		/// Reference of the storage medium that is to be freed.
		/// </param>
		[DllImport("ole32.dll", CharSet = CharSet.Unicode)]
		public static extern void ReleaseStgMedium(ref STGMEDIUM pmedium);
		/// <summary>
		/// Insert a new menu item at the specified position in a menu.
		/// </summary>
		/// <param name="hMenu">
		/// A handle to the menu in which the new menu item is inserted. 
		/// </param>
		/// <param name="uItem">
		/// The identifier or position of the menu item before which to insert the 
		/// new item. The meaning of this parameter depends on the value of 
		/// fByPosition.
		/// </param>
		/// <param name="fByPosition">
		/// Controls the meaning of uItem. If this parameter is false, uItem is a 
		/// menu item identifier. Otherwise, it is a menu item position. 
		/// </param>
		/// <param name="mii">
		/// A reference of a MENUITEMINFO structure that contains information about 
		/// the new menu item.
		/// </param>
		/// <returns>
		/// If the function succeeds, the return value is true.
		/// </returns>
		[DllImport("user32", CharSet = CharSet.Unicode, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool InsertMenuItem(
			IntPtr hMenu,
			uint uItem,
			[MarshalAs(UnmanagedType.Bool)]bool fByPosition,
			ref MENUITEMINFO mii);
		public static int HighWord(int number)
		{
			return ((number & 0x80000000) == 0x80000000) ?
				(number >> 16) : ((number >> 16) & 0xffff);
		}
		public static int LowWord(int number)
		{
			return number & 0xffff;
		}
	}
	internal static class WinError
	{
		public const int S_OK = 0x0000;
		public const int S_FALSE = 0x0001;
		public const int E_FAIL = -2147467259;
		public const int E_INVALIDARG = -2147024809;
		public const int E_OUTOFMEMORY = -2147024882;
		public const int STRSAFE_E_INSUFFICIENT_BUFFER = -2147024774;
		public const uint SEVERITY_SUCCESS = 0;
		public const uint SEVERITY_ERROR = 1;
		/// <summary>
		/// Create an HRESULT value from component pieces.
		/// </summary>
		/// <param name="sev">The severity to be used</param>
		/// <param name="fac">The facility to be used</param>
		/// <param name="code">The error number</param>
		/// <returns>A HRESULT constructed from the above 3 values</returns>
		public static int MAKE_HRESULT(uint sev, uint fac, uint code)
		{
			return (int)((sev << 31) | (fac << 16) | code);
		}
	}
}
/********************************** Module Header **********************************\
Module Name:  ProjectInstaller.cs
Project:	  CSShellExtContextMenuHandler
Copyright (c) Microsoft Corporation.
The installer class defines the custom actions in the setup. We use the custom 
actions to register and unregister the COM-visible classes in the current managed 
assembly.
This source is subject to the Microsoft Public License.
See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
All other rights reserved.
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
\***********************************************************************************/
namespace CSShellExtContextMenuHandler
{
	#region Using directives
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Configuration.Install;
	using System.Runtime.InteropServices;
	#endregion
	[RunInstaller(true), ComVisible(false)]
	public partial class ProjectInstaller : System.Configuration.Install.Installer
	{
		public ProjectInstaller()
		{
			InitializeComponent();
		}
		public override void Install(IDictionary stateSaver)
		{
			base.Install(stateSaver);
			// Call RegistrationServices.RegisterAssembly to register the classes in 
			// the current managed assembly to enable creation from COM.
			RegistrationServices regService = new RegistrationServices();
			regService.RegisterAssembly(
				this.GetType().Assembly, 
				AssemblyRegistrationFlags.SetCodeBase);
		}
		public override void Uninstall(IDictionary savedState)
		{
			base.Uninstall(savedState);
			// Call RegistrationServices.UnregisterAssembly to unregister the classes 
			// in the current managed assembly.
			RegistrationServices regService = new RegistrationServices();
			regService.UnregisterAssembly(this.GetType().Assembly);
		}
	}
}
namespace CSShellExtContextMenuHandler
{
	partial class ProjectInstaller
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
#T=ShowDialog test
namespace Test
{
	using System;
	using System.Windows.Forms;
	using System.Threading;
	public static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			MainForm form = new MainForm();
			MainFormWin = form;
			Application.Run(form);
		}
		public static MainForm MainFormWin;
		public static void ShowDialogFormsInNewThreads(Form dialogOwnerForm)
		{
			new Thread
				(
					() =>
					{
						dialogOwnerForm.Invoke
							(
								new Action
									(
										() =>
										{
											var currentActiveForm = Form.ActiveForm;
											Console.WriteLine("before showModel Active : {0}", currentActiveForm.Text);
											new Form1()
											{
												Text = DateTime.Now.ToString("HH:MM:ss.fffff")
											}
											.ShowDialog(Program.MainFormWin);
											currentActiveForm.Activate();
											Console.WriteLine("after showModel Active : {0}, Active: {1} ", currentActiveForm.Text, Form.ActiveForm.Text);
										}
									)
							);
					}
				).Start();
			new Thread
				(
					() =>
					{
						dialogOwnerForm.Invoke
							(
								new Action
									(
										() =>
										{
											var currentActiveForm = Form.ActiveForm;
											Console.WriteLine
													(
														"before showModel Active : {0}"
														, currentActiveForm.Text
													);
											new Form1()
											{
												Text = DateTime.Now.ToString("HH:MM:ss.fffff")
											}
											.ShowDialog(Program.MainFormWin);
											currentActiveForm.Activate();
											Console.WriteLine
												(
													"after showModel Active : {0}, Active: {1} "
													, currentActiveForm.Text
													, Form.ActiveForm.Text
												);
										}
									)
							);
					}
				).Start();
		}
	}
}
namespace Test
{
	using System;
	using System.Threading;
	using System.Windows.Forms;
	//using Microshaoft;
	partial class MainForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(119, 74);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(75, 23);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// MainForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(282, 253);
			this.Controls.Add(this.button1);
			this.Name = "MainForm";
			this.Text = "MainForm";
			this.ResumeLayout(false);
		}
		#endregion
		private System.Windows.Forms.Button button1;
	}
	public partial class MainForm : Form
	{
		public MainForm()
		{
			InitializeComponent();
		}
		private void button1_Click(object sender, EventArgs e)
		{
			Program.ShowDialogFormsInNewThreads(this);
		}
	}
}
namespace Test
{
	using System;
	//using System.Threading.Tasks;
	using System.Windows.Forms;
	using Test;
	public partial class Form1 : Form
	{
		public Form1()
		{
			InitializeComponent();
		}
		private void button1_Click(object sender, EventArgs e)
		{
			Program.ShowDialogFormsInNewThreads(this);
		}
	}
}
namespace Test
{
	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		//protected override void Dispose(bool disposing)
		//{
		//	if (disposing && (components != null))
		//	{
		//		components.Dispose();
		//	}
		//	base.Dispose(disposing);
		//}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(98, 70);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(75, 41);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(282, 253);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.ResumeLayout(false);
		}
		#endregion
		private System.Windows.Forms.Button button1;
	}
}

#T=SignalR simple Sample
namespace Microshaoft.Web.SignalR
{
	using Microsoft.AspNet.SignalR;
	public class ChatRoomHub : Hub
	{
		public void Send(string name, string message)
		{
			// Call the broadcastMessage method to update clients.
			Clients.All.broadcastMessage(name, message);
		}
	}
}
// Global.asax
/*
	<%@ Application Language="C#" Inherits="Microshaoft.Web.Global" %>
*/
namespace Microshaoft.Web
{
	using System.Web;
	using System.Web.Routing;
	// Note: For instructions on enabling IIS6 or IIS7 classic mode, 
	// visit http://go.microsoft.com/?LinkId=9394801
	public class Global : HttpApplication
	{
		protected void Application_Start()
		{
			RouteTable.Routes.MapHubs();
		}
	}
}
// ChatRoom.html
/*
<!DOCTYPE html>
<html>
<head>
	<META NAME="Generator" CONTENT="EditPlus,Microshaoft">
	<META NAME="Author" CONTENT="EditPlus,Microshaoft">
	<META NAME="Keywords" CONTENT="EditPlus,Microshaoft">
	<META NAME="Description" CONTENT="EditPlus,Microshaoft">
	<title>SignalR Simple Chat</title>
	<style type="text/css">
		.container {
			background-color: #99CCFF;
			border: thick solid #808080;
			padding: 20px;
			margin: 20px;
		}
	</style>
</head>
<body>
	<div class="container">
		<textarea id="message" rows="20" cols="50"></textarea>
		<input type="button" id="sendmessage" value="Send" />
		<input type="hidden" id="displayname" />
		<ul id="discussion">
		</ul>
	</div>
	<!--Script references. -->
	<!--Reference the jQuery library. -->
	<script src="/Scripts/jquery-1.6.4.js" ></script>
	<!--Reference the SignalR library. -->
	<script src="/Scripts/jquery.signalR-1.1.2.js"></script>
	<!--Reference the autogenerated SignalR hub script. -->
	<script src="/signalr/hubs"></script>
	<!--Add script to update the page and send messages.--> 
	<script type="text/javascript">
		$(function () {
			// Declare a proxy to reference the hub. 
			var chat = $.connection.chatRoomHub;
			// Create a function that the hub can call to broadcast messages.
			chat.client.broadcastMessage = function (name, message) {
				// Html encode display name and message. 
				var encodedName = $('<div />').text(name).html();
				var encodedMsg = $('<div />').text(message).html();
				// Add the message to the page. 
				$('#discussion').append('<li><strong>' + encodedName
					+ '</strong>:&nbsp;&nbsp;' + encodedMsg + '</li>');
			};
			// Get the user name and store it to prepend to messages.
			$('#displayname').val(prompt('Enter your name:', ''));
			// Set initial focus to message input box.  
			$('#message').focus();
			// Start the connection.
			$.connection.hub.start().done(function () {
				$('#sendmessage').click(function () {
					// Call the Send method on the hub. 
					chat.server.send($('#displayname').val(), $('#message').val());
					// Clear text box and reset focus for next comment. 
					$('#message').val('').focus();
				});
			});
		});
	</script>
</body>
</html>
*/
#T=Simple WebService
<%@ WebService Language="c#" Codebehind="Service1.asmx.cs" Class="Microshaoft.Service1Class" %>
namespace Microshaoft
{
	using System.Diagnostics;
	using System.Web;
	using System.Web.Services;
	[WebService(Namespace="http://www.microshaoft.com/")]
	public class Service1Class : System.Web.Services.WebService
	{
		[WebMethod]
		public string HelloWorld()
		{
			return "Hello World";
		}
	}
}
#T=SimpleClass
namespace ConsoleApplication
{
	using System;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class 
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}

}
#T=SMTP Direct
namespace SMTP
{
	using System;
	using System.Web.Mail;
	using System.Net.Sockets;
	using System.Net;
	using System.Threading;
	using System.Text;
	using System.IO;
	public class SmtpDirect
	{
		static string AuthUser;
		static string AuthPassword;
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			System.Console.WriteLine("Hello World");
			MailMessage mail=new MailMessage();
			mail.From = "elive_jifen@189.cn";
			mail.To = "microshaoft@gmail.com";
			mail.Subject = "smtp direct 119";
			mail.Priority = MailPriority.High;
			mail.BodyFormat = MailFormat.Text;
			mail.Body = "测试于溪h2";
			//mail.Headers.Add("Return-Path","v-wenluo@microsoft.com");
			SmtpDirect.SmtpServer = "smtp.189.cn";
			AuthUser = "elive_jifen@189.cn";
			AuthPassword = "!@#123QWE";
			SmtpDirect.Send(mail);
		}
		private static bool ReceiveResponse(Socket socket, SmtpDirect.Message message)
		{
			byte[] buffer = new byte[0x400];
			while (socket.Available == 0)
			{
				Thread.Sleep(100);
			}
			socket.Receive(buffer, 0, socket.Available, SocketFlags.None);
			string s = Encoding.ASCII.GetString(buffer);
			Console.WriteLine("Rec: {0}", s);
			int i = Convert.ToInt32(s.Substring(0, 3));
			if (((SmtpDirect.Message) i) != message)
			{
				return false;
			}
			return true;
		}
		private static void SendRequest(Socket socket, string message)
		{
			Console.WriteLine("Sent: {0}", message);
			byte[] buffer = Encoding.ASCII.GetBytes(message);
			socket.Send(buffer, 0, buffer.Length, SocketFlags.None);
		}
		static bool esmtp = true;
		public static bool Send(MailMessage mailMessage)
		{
			IPHostEntry iphe = Dns.Resolve(SmtpDirect.SmtpServer);
			IPEndPoint ipep = new IPEndPoint(iphe.AddressList[0], 0x19);
			Socket socket = new Socket(ipep.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
			socket.Connect(ipep);
			if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.a))
			{
				socket.Close();
				return false;
			}
			if (esmtp)
			{
				string cmd;
				cmd ="EHLO hh"  + "\r\n"; 
				SmtpDirect.SendRequest(socket,cmd);
				if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.b))
				{
					socket.Close();
					return false;
				}
				cmd = "AUTH LOGIN\r\n"; 
				SmtpDirect.SendRequest(socket,cmd);
				if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.f))
				{
					socket.Close();
					return false;
				}
				cmd = Base64Encode(AuthUser) + "\r\n"; 
				SmtpDirect.SendRequest(socket,cmd);
				if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.f))
				{
					socket.Close();
					return false;
				}
				cmd = Base64Encode(AuthPassword) + "\r\n"; 
				SmtpDirect.SendRequest(socket,cmd);
				if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.e))
				{
					socket.Close();
					return false;
				}
			}
			else
			{
				SmtpDirect.SendRequest(socket, string.Format("HELO {0}\r\n", Dns.GetHostName()));
				if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.b))
				{
					socket.Close();
					return false;
				}
			
			}
			
			SmtpDirect.SendRequest(socket, string.Format("MAIL From: {0}\r\n", mailMessage.From));
			if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.b))
			{
				socket.Close();
				return false;
			}
			char[] ca = new char[1] { ';' } ;
			string[] sa0 = mailMessage.To.Split(ca);
			string[] sa = sa0;
			int i = 0;
			while (i < sa.Length)
			{
				string s = sa[i];
				SmtpDirect.SendRequest(socket, string.Format("RCPT TO: {0}\r\n", s));
				if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.b))
				{
					socket.Close();
					return false;
				}
				i++;
			}
			if (mailMessage.Cc != null)
			{
				ca = new char[1] { ';' } ;
				sa0 = mailMessage.Cc.Split(ca);
				sa = sa0;
				for (i = 0; i < sa.Length; i++)
				{
					string s = sa[i];
					SmtpDirect.SendRequest(socket, string.Format("RCPT TO: {0}\r\n", s));
					if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.b))
					{
						socket.Close();
						return false;
					}
				}
			}
			StringBuilder SB = new StringBuilder(); //header
			//SB.Append("Return-Path: <bill.gates@microsoft.com>\r\n");
			SB.Append("From: " + mailMessage.From + "\r\n");
			ca = new char[1] { ';' } ;
			sa0 = mailMessage.To.Split(ca);
			SB.Append("To: ");
			for (int j = 0; j < sa0.Length; j++)
			{
				SB.Append((j > 0) ? "," : "");
				SB.Append(sa0[j]);
			}
			SB.Append("\r\n");
			if (mailMessage.Cc != null)
			{
				ca = new char[1] { ';' } ;
				sa0 = mailMessage.Cc.Split(ca);
				SB.Append("Cc: ");
				for (int j = 0; j < sa0.Length; j++)
				{
					SB.Append((j > 0) ? "," : "");
					SB.Append(sa0[j]);
				}
				SB.Append("\r\n");
			}
			SB.Append("Date: ");
			SB.Append(DateTime.Now.ToString());
			SB.Append("\r\n");
			
			
			
			
			SB.Append("Subject: " + mailMessage.Subject + "\r\n");
			SB.Append("X-Mailer: fixmail v1\r\n");
			SB.Append("Message-ID: <201003151744120314888@189.cn>\r\n");
			string priority = null;
			if (mailMessage.Priority == MailPriority.High)
			{
				priority = "high";
			}
			else if (mailMessage.Priority == MailPriority.Low)
			{
				priority = "low";
			}
			if (priority != null)
			{
				SB.Append("Importance: " + priority + "\r\n");
			}
			string body = mailMessage.Body;
			if (!body.EndsWith("\r\n"))
			{
				body = body + "\r\n";
			}
			if ((mailMessage.Attachments.Count > 0) || (mailMessage.BodyFormat == MailFormat.Html))
			{
				SB.Append("MIME-Version: 1.0\r\n");
				SB.Append("Content-Type: multipart/mixed; boundary=unique-boundary-1\r\n");
				SB.Append("\r\n");
				SB.Append("This is a multi-part mailMessage in MIME format.\r\n");
				StringBuilder sb = new StringBuilder();
				sb.Append("--unique-boundary-1\r\n");
				string bodyFormat = (mailMessage.BodyFormat == MailFormat.Text) ? "plain" : "html";
				sb.Append(string.Format("Content-Type: text/{0}\r\n", bodyFormat));
				
				sb.Append("Content-Transfer-Encoding: 7Bit\r\n");
				sb.Append("\r\n");
				sb.Append(body + "\r\n");
				sb.Append("\r\n");
				foreach (object o in mailMessage.Attachments)
				{
					MailAttachment ma = o as MailAttachment;
					if (ma != null)
					{
						int size;
						FileInfo fi = new FileInfo(ma.Filename);
						sb.Append("--unique-boundary-1\r\n");
						sb.Append("Content-Type: application/octet-stream; file=" + fi.Name + "\r\n");
						sb.Append("Content-Transfer-Encoding: base64\r\n");
						sb.Append("Content-Disposition: attachment; filename=" + fi.Name + "\r\n");
						sb.Append("\r\n");
						FileStream fs = fi.OpenRead();
						byte[] buffer = new byte[fs.Length];
						long l = fs.Read(buffer, 0, (int) fs.Length);
						fs.Close();
						string base64 = Convert.ToBase64String(buffer, 0, buffer.Length);
						for (int j = 0; j < base64.Length; j += size)
						{
							size = 100;
							if ((base64.Length - (j + size)) < 0)
							{
								size = base64.Length - j;
							}
							sb.Append(base64.Substring(j, size));
							sb.Append("\r\n");
						}
						sb.Append("\r\n");
					}
				}
				body = sb.ToString();
			}
			SmtpDirect.SendRequest(socket, "DATA\r\n");
			if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.c))
			{
				socket.Close();
				return false;
			}
			SB.Append("\r\n");
			SB.Append(body);
			SB.Append(".\r\n");
			SB.Append("\r\n");
			SB.Append("\r\n");
			SmtpDirect.SendRequest(socket, SB.ToString());
			if (!SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.b))
			{
				socket.Close();
				return false;
			}
			SmtpDirect.SendRequest(socket, "QUIT\r\n");
			SmtpDirect.ReceiveResponse(socket, SmtpDirect.Message.d);
			socket.Close();
			return true;
		}
		// Fields
		public static string SmtpServer;
		private static string Base64Encode(string s) 
		{
			byte[] buffer = Encoding.Default.GetBytes(s); 
			return Convert.ToBase64String(buffer); 
		}
		// Nested Types
		private enum Message
		{
			// Fields
			a = 220,
			b = 250,
			c = 0x162,
			d = 0xdd,
			e = 235,
			f =334
		}
	}
}

#T=smtp LinkedResource XSS attack
namespace ConsoleApplication
{
	using System;
	using System.Net;
	using System.Net.Mail;
	using System.Net.Mime;
	public class Class1
	{
		static void Main(string[] args)
		{
			string html = "<html><body><a href=\"http://www.live.com\"><img src=\"cid:attachment1\"></a>";
			html += "<script src=\"cid:attachment2\"></script>中国字";
			html += "<a href=\"http://www.google.com\"><br><img src=\"cid:attachment1\"></a><script>alert('mail body xss')<script></body></html>";
			AlternateView view = AlternateView.CreateAlternateViewFromString(html, null, MediaTypeNames.Text.Html);
			LinkedResource picture = new LinkedResource(@"pic.JPG", MediaTypeNames.Image.Jpeg);
			picture.ContentId = "attachment1";
			view.LinkedResources.Add(picture);
			LinkedResource script = new LinkedResource(@"a.js", MediaTypeNames.Text.Plain);
			script.ContentId = "attachment2";
			view.LinkedResources.Add(script);
			MailMessage mail = new MailMessage();
			mail.AlternateViews.Add(view);
			mail.From = new MailAddress("test@microshaoft.com", "<script>alert('mail from xss')</script>");
			mail.To.Add(new MailAddress("microshaoft@gmail.com", "<script>alert('mail to xss')</script>"));
			mail.To.Add(new MailAddress("microshaoft@qq.com", "<script>alert('mail to xss')</script>"));
			mail.Subject = "<script>alert('mail subject xss')</script>" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
			SmtpClient client = new SmtpClient("smtp.gmail.com");
			//client.Port = 465;
			client.Credentials = new NetworkCredential("test@microshaoft.com","!@#123QWE");
			client.EnableSsl = true;
			client.Send(mail);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}

#T=SMTP Service Fake
namespace SmtpConsoleApplication
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Net;
	using System.Net.Sockets;
	using System.IO;
	public class FakeSmtpService : IDisposable
	{
		public class ClientInfo
		{
			public Socket ClientSocket { get; set; }
			public Guid? UniqueId { get; set; }
			public bool DataMode { get; set; }
			public byte[] Buffer { get; set; }
			public int BufferSize { get; set; }

			public ClientInfo()
			{
				UniqueId = Guid.NewGuid();
				BufferSize = 1024;
				DataMode = false;
			}

			public void ResetBuffer()
			{
				Buffer = new byte[BufferSize];
			}
		}

		#region Server Reponses

		static String HELO = "220 smtp.fake.loopback ESMTP Postfix\r\n";
		static String OK = "250 Ok\r\n";
		static String DATA = "354 End data with <CR><LF>.<CR><LF>\r\n";
		static String BYE = "221 Bye\r\n";

		#endregion

		#region ctor

		TcpListener _listener = new TcpListener(new IPEndPoint(IPAddress.Loopback, 2525));
		Dictionary<Guid, ClientInfo> _clientRegistry = new Dictionary<Guid, ClientInfo>();

		public FakeSmtpService()
		{
			_listener.Start();
			BeginAcceptSocket();
		}

		#endregion

		#region Accept

		private void BeginAcceptSocket()
		{
			_listener.BeginAcceptSocket(
				new AsyncCallback(OnAcceptSocketCallbackHandler), null);
		}

		void OnAcceptSocketCallbackHandler(IAsyncResult ar)
		{
			try
			{
				Socket clientSocket = _listener.EndAcceptSocket(ar);

				ClientInfo clientInfo = SayHello(clientSocket);

				BeginReceiveData(clientInfo);

				BeginAcceptSocket();
			}
			catch (Exception error)
			{
				Console.Out.WriteLine(error.ToString());
			}
		}

		private ClientInfo SayHello(Socket clientSocket)
		{
			System.Diagnostics.Trace.TraceInformation(HELO);

			
			ClientInfo clientInfo = new ClientInfo();
			clientInfo.ClientSocket = clientSocket;
			_clientRegistry[(Guid)clientInfo.UniqueId] = clientInfo;

			clientSocket.Send(Encoding.ASCII.GetBytes(HELO));

			return clientInfo;
		}

		#endregion

		#region Data

		private void BeginReceiveData(ClientInfo clientInfo)
		{
			try
			{
				SocketError errorCode;

				clientInfo.ResetBuffer();

				if (clientInfo.ClientSocket.Connected)
				{
					clientInfo.ClientSocket.BeginReceive(
						clientInfo.Buffer, 0, clientInfo.BufferSize, SocketFlags.None, out errorCode,
						new AsyncCallback(OnReceiveSocketDataCallbackHandler),
						clientInfo.UniqueId);

					if (errorCode != SocketError.Success)
					{
						throw new ApplicationException(errorCode.ToString());
					}
				}
			}
			catch (Exception error)
			{
				System.Diagnostics.Trace.TraceError(error.ToString());
			}
		}

		void OnReceiveSocketDataCallbackHandler(IAsyncResult ar)
		{
			try
			{
				Guid? clientId = ar.AsyncState as Guid?;

				if (clientId.HasValue)
				{
					ClientInfo clientInfo = _clientRegistry[(Guid)clientId];
					SocketError errorCode;

					int numBytesReceived = clientInfo.ClientSocket.EndReceive(ar, out errorCode);

					if (errorCode != SocketError.Success)
					{
						throw new ApplicationException(errorCode.ToString());
					}

					if (numBytesReceived != 0)
					{
						RespondToClientData(clientInfo, numBytesReceived);

						BeginReceiveData(clientInfo);
					}
					else
					{
						System.Diagnostics.Trace.TraceInformation("Closing connection");
						clientInfo.ClientSocket.Close();
					}
				}
			}
			catch (Exception error)
			{
				System.Diagnostics.Trace.TraceError(error.ToString());
			}
		}

		private void RespondToClientData(ClientInfo clientInfo, int numBytesReceived)
		{
			String clientCommand = Encoding.ASCII.GetString(clientInfo.Buffer, 0, numBytesReceived).Trim();

			System.Diagnostics.Trace.TraceInformation(clientCommand);

			if (!clientInfo.DataMode)
			{
				if (String.Compare(clientCommand, "DATA", true) == 0)
				{
					clientInfo.DataMode = true;
					SendClientMessage(clientInfo, DATA);
				}
				else if (String.Compare(clientCommand, "QUIT", true) == 0)
				{
					SayGoodbye(clientInfo);
				}
				else
				{
					SendClientMessage(clientInfo, OK);
				}
			}
			else
			{
				if (clientCommand.EndsWith("\r\n."))
				{
					clientInfo.DataMode = false;
					SendClientMessage(clientInfo, OK);
				}
			}
		}

		private void SayGoodbye(ClientInfo clientInfo)
		{
			try
			{
				if ((clientInfo != null) && (clientInfo.UniqueId.HasValue))
				{
					_clientRegistry.Remove((Guid)clientInfo.UniqueId);
					SendClientMessage(clientInfo, BYE);
				}
			}
			catch (Exception error)
			{
				System.Diagnostics.Trace.TraceError(error.ToString());
			}
		}

		private static void SendClientMessage(ClientInfo clientInfo, String message)
		{
			System.Diagnostics.Trace.TraceInformation(message);
			clientInfo.ClientSocket.Send(Encoding.ASCII.GetBytes(message));
		}

		#endregion

		#region Dispose

		public void Dispose()
		{
			if (_listener != null)
			{
				_listener.Stop();
			}
		}

		#endregion

	}
	

	class Program
	{
		static void Main(string[] args)
		{
			using (FakeSmtpService svc = new FakeSmtpService())
			{
				Console.Out.WriteLine("Press <Enter> to quit");
				Console.ReadLine();
			}
		}
	}
}

#T=SmtpClient SendEmail
namespace SendEmail
{
	using System.Net.Mail;

	class SendEmail
	{
		/// <summary>
		/// Sends an e-mail message using the designated SMTP mail server.
		/// </summary>
		/// <param name="subject">The subject of the message being sent.</param>
		/// <param name="messageBody">The message body.</param>
		/// <param name="fromAddress">The sender's e-mail address.</param>
		/// <param name="toAddress">The recipient's e-mail address (separate multiple e-mail addresses
		/// with a semi-colon).</param>
		/// <param name="ccAddress">The address(es) to be CC'd (separate multiple e-mail addresses with
		/// a semi-colon).</param>
		/// <remarks>You must set the SMTP server within this method prior to calling.</remarks>
		/// <example>
		/// <code>
		///   // Send a quick e-mail message
		///   SendEmail.SendMessage("This is a Test", 
		///						 "This is a test message...",
		///						 "noboday@nowhere.com",
		///						 "somebody@somewhere.com", 
		///						 "ccme@somewhere.com");
		/// </code>
		/// </example>
		public static void SendMessage(string subject, string messageBody, string fromAddress, string toAddress, string ccAddress)
		{
			MailMessage message = new MailMessage();
			SmtpClient client = new SmtpClient();

			// Set the sender's address
			message.From = new MailAddress(fromAddress);

			// Allow multiple "To" addresses to be separated by a semi-colon
			if (toAddress.Trim().Length > 0)
			{
				foreach (string addr in toAddress.Split(';'))
				{
					message.To.Add(new MailAddress(addr));
				}
			}

			// Allow multiple "Cc" addresses to be separated by a semi-colon
			if (ccAddress.Trim().Length > 0)
			{
				foreach (string addr in ccAddress.Split(';'))
				{
					message.CC.Add(new MailAddress(addr));
				}
			}

			// Set the subject and message body text
			message.Subject = subject;
			message.Body = messageBody;

			// TODO: *** Modify for your SMTP server ***
			// Set the SMTP server to be used to send the message
			client.Host = "YourMailServer";

			// Send the e-mail message
			client.Send(message);
		}
	}
}

#T=Sniffer Socket raw
namespace Microshaoft
{
	public enum Protocol
	{
		TCP = 6,
		UDP = 17,
		Unknown = -1
	}
}
namespace Microshaoft
{
	using System.Net;
	using System;
	using System.IO;
	using System.Windows.Forms;
	public class TCPHeader
	{
		//TCP header fields
		private ushort usSourcePort;			 //Sixteen bits for the source port number
		private ushort usDestinationPort;		 //Sixteen bits for the destination port number
		private uint uiSequenceNumber=555;		 //Thirty two bits for the sequence number
		private uint uiAcknowledgementNumber=555; //Thirty two bits for the acknowledgement number
		private ushort usDataOffsetAndFlags=555;	 //Sixteen bits for flags and data offset
		private ushort usWindow=555;				 //Sixteen bits for the window size
		private short sChecksum=555;				 //Sixteen bits for the checksum
													//(checksum can be negative so taken as short)
		private ushort usUrgentPointer;		 //Sixteen bits for the urgent pointer
		//End TCP header fields
		private byte byHeaderLength;			//Header length
		private ushort usMessageLength;		 //Length of the data being carried
		private byte[] byTCPData = new byte[4096];//Data carried by the TCP packet
		public TCPHeader(byte [] byBuffer, int nReceived)
		{
			try
			{
				MemoryStream memoryStream = new MemoryStream(byBuffer, 0, nReceived);
				BinaryReader binaryReader = new BinaryReader(memoryStream);
				//The first sixteen bits contain the source port
				usSourcePort = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16 ());
				//The next sixteen contain the destiination port
				usDestinationPort = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16 ());
				//Next thirty two have the sequence number
				uiSequenceNumber = (uint)IPAddress.NetworkToHostOrder(binaryReader.ReadInt32());
				//Next thirty two have the acknowledgement number
				uiAcknowledgementNumber = (uint)IPAddress.NetworkToHostOrder(binaryReader.ReadInt32());
				//The next sixteen bits hold the flags and the data offset
				usDataOffsetAndFlags = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
				//The next sixteen contain the window size
				usWindow = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
				//In the next sixteen we have the checksum
				sChecksum = (short)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
				//The following sixteen contain the urgent pointer
				usUrgentPointer = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
				//The data offset indicates where the data begins, so using it we
				//calculate the header length
				byHeaderLength = (byte)(usDataOffsetAndFlags >> 12);
				byHeaderLength *= 4;
				//Message length = Total length of the TCP packet - Header length
				usMessageLength = (ushort)(nReceived - byHeaderLength);
				//Copy the TCP data into the data buffer
				Array.Copy(byBuffer, byHeaderLength, byTCPData, 0, nReceived - byHeaderLength);
			}
			catch (Exception ex)
			{
				MessageBox.Show(ex.Message, "MJsniff TCP" + (nReceived), MessageBoxButtons.OK, MessageBoxIcon.Error);
			}
		}
		public string SourcePort
		{
			get
			{
				return usSourcePort.ToString();
			}
		}
		public string DestinationPort
		{
			get
			{
				return usDestinationPort.ToString ();
			}
		}
		public string SequenceNumber
		{
			get
			{
				return uiSequenceNumber.ToString();
			}
		}
		public string AcknowledgementNumber
		{
			get
			{
				//If the ACK flag is set then only we have a valid value in
				//the acknowlegement field, so check for it beore returning 
				//anything
				if ((usDataOffsetAndFlags & 0x10) != 0)
				{
					return uiAcknowledgementNumber.ToString();
				}
				else
					return "";
			}
		}
		public string HeaderLength
		{
			get
			{
				return byHeaderLength.ToString();
			}
		}
		public string WindowSize
		{
			get
			{
				return usWindow.ToString();
			}
		}
		public string UrgentPointer
		{
			get
			{
				//If the URG flag is set then only we have a valid value in
				//the urgent pointer field, so check for it beore returning 
				//anything
				if ((usDataOffsetAndFlags & 0x20) != 0)
				{
					return usUrgentPointer.ToString();
				}
				else
					return "";
			}
		}
		public string Flags
		{
			get
			{
				//The last six bits of the data offset and flags contain the
				//control bits
				//First we extract the flags
				int nFlags = usDataOffsetAndFlags & 0x3F;
 
				string strFlags = string.Format ("0x{0:x2} (", nFlags);
				//Now we start looking whether individual bits are set or not
				if ((nFlags & 0x01) != 0)
				{
					strFlags += "FIN, ";
				}
				if ((nFlags & 0x02) != 0)
				{
					strFlags += "SYN, ";
				}
				if ((nFlags & 0x04) != 0)
				{
					strFlags += "RST, ";
				}
				if ((nFlags & 0x08) != 0)
				{
					strFlags += "PSH, ";
				}
				if ((nFlags & 0x10) != 0)
				{
					strFlags += "ACK, ";
				}
				if ((nFlags & 0x20) != 0)
				{
					strFlags += "URG";
				}
				strFlags += ")";
				if (strFlags.Contains("()"))
				{
					strFlags = strFlags.Remove(strFlags.Length - 3);
				}
				else if (strFlags.Contains(", )"))
				{
					strFlags = strFlags.Remove(strFlags.Length - 3, 2);
				}
				return strFlags;
			}
		}
		public string Checksum
		{
			get
			{
				//Return the checksum in hexadecimal format
				return string.Format("0x{0:x2}", sChecksum);
			}
		}
		public byte[] Data
		{
			get
			{
				return byTCPData;
			}
		}
		public ushort MessageLength
		{
			get
			{
				return usMessageLength;
			}
		}
	}
}
namespace Microshaoft
{
	using System.Net;
	using System;
	using System.IO;
	public class UDPHeader
	{
		//UDP header fields
		private ushort usSourcePort;			//Sixteen bits for the source port number		
		private ushort usDestinationPort;	 //Sixteen bits for the destination port number
		private ushort usLength;				//Length of the UDP header
		private short sChecksum;				//Sixteen bits for the checksum
												//(checksum can be negative so taken as short)			 
		//End UDP header fields
		private byte[] byUDPData = new byte[4096]; //Data carried by the UDP packet
		public UDPHeader(byte [] byBuffer, int nReceived)
		{
			MemoryStream memoryStream = new MemoryStream(byBuffer, 0, nReceived);
			BinaryReader binaryReader = new BinaryReader(memoryStream);
			//The first sixteen bits contain the source port
			usSourcePort = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
			//The next sixteen bits contain the destination port
			usDestinationPort = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
			//The next sixteen bits contain the length of the UDP packet
			usLength = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
			//The next sixteen bits contain the checksum
			sChecksum = IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());			
			//Copy the data carried by the UDP packet into the data buffer
			Array.Copy(byBuffer, 
					 8,			 //The UDP header is of 8 bytes so we start copying after it
					 byUDPData, 
					 0, 
					 nReceived - 8);
		}
		public string SourcePort
		{
			get
			{
				return usSourcePort.ToString();
			}
		}
		public string DestinationPort
		{
			get
			{
				return usDestinationPort.ToString();
			}
		}
		public string Length
		{
			get
			{
				return usLength.ToString ();
			}
		}
		public string Checksum
		{
			get
			{
				//Return the checksum in hexadecimal format
				return string.Format("0x{0:x2}", sChecksum);
			}
		}
		public byte[] Data
		{
			get
			{
				return byUDPData;
			}
		}
	}
}
namespace Microshaoft
{
	using System.Net;
	using System;
	using System.IO;
	using System.Windows.Forms;
	public class DNSHeader
	{
		//DNS header fields
		private ushort usIdentification;		//Sixteen bits for identification
		private ushort usFlags;				 //Sixteen bits for DNS flags
		private ushort usTotalQuestions;		//Sixteen bits indicating the number of entries 
												//in the questions list
		private ushort usTotalAnswerRRs;		//Sixteen bits indicating the number of entries
												//entries in the answer resource record list
		private ushort usTotalAuthorityRRs;	 //Sixteen bits indicating the number of entries
												//entries in the authority resource record list
		private ushort usTotalAdditionalRRs;	//Sixteen bits indicating the number of entries
												//entries in the additional resource record list
		//End DNS header fields
		public DNSHeader(byte []byBuffer, int nReceived)
		{
			MemoryStream memoryStream = new MemoryStream(byBuffer, 0, nReceived);
			BinaryReader binaryReader = new BinaryReader(memoryStream);	
 
			//First sixteen bits are for identification
			usIdentification = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
			//Next sixteen contain the flags
			usFlags = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
			//Read the total numbers of questions in the quesion list
			usTotalQuestions = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
			//Read the total number of answers in the answer list
			usTotalAnswerRRs = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
			//Read the total number of entries in the authority list
			usTotalAuthorityRRs = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
			//Total number of entries in the additional resource record list
			usTotalAdditionalRRs = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
		}
		public string Identification
		{
			get
			{
				return string.Format("0x{0:x2}", usIdentification);
			}
		}
		public string Flags
		{
			get
			{
				return string.Format("0x{0:x2}", usFlags);
			}
		}
		public string TotalQuestions
		{
			get
			{
				return usTotalQuestions.ToString();
			}
		}
		public string TotalAnswerRRs
		{
			get
			{
				return usTotalAnswerRRs.ToString();
			}
		}
		public string TotalAuthorityRRs
		{
			get
			{
				return usTotalAuthorityRRs.ToString();
			}
		}
		public string TotalAdditionalRRs
		{
			get
			{
				return usTotalAdditionalRRs.ToString();
			}
		}
	}
}
namespace Microshaoft
{
	using System.Net;
	using System.Text;
	using System;
	using System.IO;
	using System.Windows.Forms;
	public class IPHeader
	{
		//IP Header fields
		private byte	 byVersionAndHeaderLength; //Eight bits for version and header length
		private byte	 byDifferentiatedServices;	//Eight bits for differentiated services (TOS)
		private ushort	usTotalLength;			 //Sixteen bits for total length of the datagram (header + message)
		private ushort	usIdentification;		 //Sixteen bits for identification
		private ushort	usFlagsAndOffset;		 //Eight bits for flags and fragmentation offset
		private byte	 byTTL;					 //Eight bits for TTL (Time To Live)
		private byte	 byProtocol;				 //Eight bits for the underlying protocol
		private short	 sChecksum;				 //Sixteen bits containing the checksum of the header
													 //(checksum can be negative so taken as short)
		private uint	 uiSourceIPAddress;		 //Thirty two bit source IP Address
		private uint	 uiDestinationIPAddress;	 //Thirty two bit destination IP Address
		//End IP Header fields
		
		private byte	 byHeaderLength;			 //Header length
		private byte[]	byIPData = new byte[4096]; //Data carried by the datagram
		public IPHeader(byte[] byBuffer, int nReceived)
		{
			
			try
			{
				//Create MemoryStream out of the received bytes
				MemoryStream memoryStream = new MemoryStream(byBuffer, 0, nReceived);
				//Next we create a BinaryReader out of the MemoryStream
				BinaryReader binaryReader = new BinaryReader(memoryStream);
				//The first eight bits of the IP header contain the version and
				//header length so we read them
				byVersionAndHeaderLength = binaryReader.ReadByte();
				//The next eight bits contain the Differentiated services
				byDifferentiatedServices = binaryReader.ReadByte();
				//Next eight bits hold the total length of the datagram
				usTotalLength = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
				//Next sixteen have the identification bytes
				usIdentification = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
				//Next sixteen bits contain the flags and fragmentation offset
				usFlagsAndOffset = (ushort)IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
				//Next eight bits have the TTL value
				byTTL = binaryReader.ReadByte();
				//Next eight represnts the protocol encapsulated in the datagram
				byProtocol = binaryReader.ReadByte();
				//Next sixteen bits contain the checksum of the header
				sChecksum = IPAddress.NetworkToHostOrder(binaryReader.ReadInt16());
				//Next thirty two bits have the source IP address
				uiSourceIPAddress = (uint)(binaryReader.ReadInt32());
				//Next thirty two hold the destination IP address
				uiDestinationIPAddress = (uint)(binaryReader.ReadInt32());
				//Now we calculate the header length
				byHeaderLength = byVersionAndHeaderLength;
				//The last four bits of the version and header length field contain the
				//header length, we perform some simple binary airthmatic operations to
				//extract them
				byHeaderLength <<= 4;
				byHeaderLength >>= 4;
				//Multiply by four to get the exact header length
				byHeaderLength *= 4;
				//Copy the data carried by the data gram into another array so that
				//according to the protocol being carried in the IP datagram
				Array.Copy(byBuffer, 
						 byHeaderLength, //start copying from the end of the header
						 byIPData, 0, 
						 usTotalLength - byHeaderLength);
			}
		catch (Exception ex)
		{
			MessageBox.Show(ex.Message, "MJsniffer", MessageBoxButtons.OK, 
				MessageBoxIcon.Error);
		}
		}
		public string Version
		{
			get
			{
				//Calculate the IP version
				//The four bits of the IP header contain the IP version
				if ((byVersionAndHeaderLength >> 4) == 4)
				{
					return "IP v4";
				}
				else if ((byVersionAndHeaderLength >> 4) == 6)
				{
					return "IP v6";
				}
				else
				{
					return "Unknown";
				}
			}
		}
		public string HeaderLength
		{
			get
			{
				return byHeaderLength.ToString();				
			}
		}
		public ushort MessageLength
		{
			get
			{
				//MessageLength = Total length of the datagram - Header length
				return (ushort)(usTotalLength - byHeaderLength);
			}
		}
		public string DifferentiatedServices
		{
			get
			{
				//Returns the differentiated services in hexadecimal format
				return string.Format ("0x{0:x2} ({1})", byDifferentiatedServices, 
					byDifferentiatedServices);
			}
		}
		public string Flags
		{
			get
			{
				//The first three bits of the flags and fragmentation field 
				//represent the flags (which indicate whether the data is 
				//fragmented or not)
				int nFlags = usFlagsAndOffset >> 13;
				if (nFlags == 2)
				{
					return "Don't fragment";
				}
				else if (nFlags == 1)
				{
					return "More fragments to come";
				}
				else
				{
					return nFlags.ToString();
				}
			}
		}
		public string FragmentationOffset
		{
			get
			{
				//The last thirteen bits of the flags and fragmentation field 
				//contain the fragmentation offset
				int nOffset = usFlagsAndOffset << 3;
				nOffset >>= 3;
				return nOffset.ToString();
			}
		}
		public string TTL
		{
			get
			{
				return byTTL.ToString();
			}
		}
		public Protocol ProtocolType
		{
			get
			{
				//The protocol field represents the protocol in the data portion
				//of the datagram
				if (byProtocol == 6)		//A value of six represents the TCP protocol
				{
					return Protocol.TCP;
				}
				else if (byProtocol == 17) //Seventeen for UDP
				{
					return Protocol.UDP;
				}
				else
				{
					return Protocol.Unknown;
				}
			}
		}
		public string Checksum
		{
			get
			{
				//Returns the checksum in hexadecimal format
				return string.Format ("0x{0:x2}", sChecksum);
			}
		}
		public IPAddress SourceAddress
		{
			get
			{
				return new IPAddress(uiSourceIPAddress);
			}
		}
		public IPAddress DestinationAddress
		{
			get
			{
				return new IPAddress(uiDestinationIPAddress);
			}
		}
		public string TotalLength
		{
			get
			{
				return usTotalLength.ToString();
			}
		}
		public string Identification
		{
			get
			{
				return usIdentification.ToString();
			}
		}
		public byte[] Data
		{
			get
			{
				return byIPData;
			}
		}
	}
}
namespace Test
{
	using System;
	using System.ComponentModel;
	using System.Drawing;
	using System.Windows.Forms;
	using System.Net.Sockets;
	using System.Net;
	using Microshaoft;
	public partial class snifferForm : Form
	{
		private Socket mainSocket;						 //The socket which captures all incoming packets
		private byte[] byteData = new byte[4096];
		private bool bContinueCapturing = false;			//A flag to check if packets are to be captured or not
		private delegate void AddTreeNode(TreeNode node);
		public snifferForm()
		{
			InitializeComponent();
		}
		private void btnStart_Click(object sender, EventArgs e)
		{
			if (cmbInterfaces.Text == "")
			{
				MessageBox.Show("Select an Interface to capture the packets.", "sniffer", 
					MessageBoxButtons.OK, MessageBoxIcon.Error);
				return;
			}
			try
			{
				if (!bContinueCapturing)		
				{
					//Start capturing the packets...
					btnStart.Text = "&Stop";
					bContinueCapturing = true;
					//For sniffing the socket to capture the packets has to be a raw socket, with the
					//address family being of type internetwork, and protocol being IP
					mainSocket = new Socket(AddressFamily.InterNetwork,
						SocketType.Raw, ProtocolType.IP);
					
					//Bind the socket to the selected IP address
					mainSocket.Bind(new IPEndPoint(IPAddress.Parse(cmbInterfaces.Text), 0));
					//Set the socket options
					mainSocket.SetSocketOption(SocketOptionLevel.IP,			//Applies only to IP packets
											 SocketOptionName.HeaderIncluded, //Set the include the header
											 true);						 //option to true
					byte[] byTrue = new byte[4] {1, 0, 0, 0};
					byte[] byOut = new byte[4]{1, 0, 0, 0}; //Capture outgoing packets
					//Socket.IOControl is analogous to the WSAIoctl method of Winsock 2
					mainSocket.IOControl(IOControlCode.ReceiveAll,			 //Equivalent to SIO_RCVALL constant
																				//of Winsock 2
										 byTrue,									
										 byOut);
					//Start receiving the packets asynchronously
					mainSocket.BeginReceive(byteData, 0, byteData.Length, SocketFlags.None,
						new AsyncCallback(OnReceive), null);
				}
				else
				{
					btnStart.Text = "&Start";
					bContinueCapturing = false;
					//To stop capturing the packets close the socket
					mainSocket.Close ();
				}
			}
			catch (Exception ex)
			{
				MessageBox.Show(ex.Message, "sniffer", MessageBoxButtons.OK, MessageBoxIcon.Error);
			}
		}
		private void OnReceive(IAsyncResult ar)
		{
			try
			{
				int nReceived = mainSocket.EndReceive(ar);
				//Analyze the bytes received...
				
				ParseData (byteData, nReceived);
				if (bContinueCapturing)	 
				{
					byteData = new byte[4096];
					
					//Another call to BeginReceive so that we continue to receive the incoming
					//packets
					mainSocket.BeginReceive(byteData, 0, byteData.Length, SocketFlags.None,
						new AsyncCallback(OnReceive), null);
				}
			}
			catch (ObjectDisposedException)
			{
			}
			catch (Exception ex)
			{
				MessageBox.Show(ex.Message, "sniffer", MessageBoxButtons.OK, MessageBoxIcon.Error);
			}			
		}
		private void ParseData(byte[] byteData, int nReceived)
		{
			TreeNode rootNode = new TreeNode();
			//Since all protocol packets are encapsulated in the IP datagram
			//so we start by parsing the IP header and see what protocol data
			//is being carried by it
			IPHeader ipHeader = new IPHeader(byteData, nReceived);
			TreeNode ipNode = MakeIPTreeNode(ipHeader);
			rootNode.Nodes.Add(ipNode);
			//Now according to the protocol being carried by the IP datagram we parse 
			//the data field of the datagram
			switch (ipHeader.ProtocolType)
			{
				case Protocol.TCP:
					TCPHeader tcpHeader = new TCPHeader(ipHeader.Data,			 //IPHeader.Data stores the data being 
																					//carried by the IP datagram
														ipHeader.MessageLength);//Length of the data field					
					TreeNode tcpNode = MakeTCPTreeNode(tcpHeader);
					rootNode.Nodes.Add(tcpNode);
					//If the port is equal to 53 then the underlying protocol is DNS
					//Note: DNS can use either TCP or UDP thats why the check is done twice
					if (tcpHeader.DestinationPort == "53" || tcpHeader.SourcePort == "53")
					{
						TreeNode dnsNode = MakeDNSTreeNode(tcpHeader.Data, (int)tcpHeader.MessageLength);
						rootNode.Nodes.Add(dnsNode);
					}
					break;
				case Protocol.UDP:
					UDPHeader udpHeader = new UDPHeader(ipHeader.Data,			 //IPHeader.Data stores the data being 
																					//carried by the IP datagram
													 (int)ipHeader.MessageLength);//Length of the data field					
					TreeNode udpNode = MakeUDPTreeNode(udpHeader);
					rootNode.Nodes.Add(udpNode);
					//If the port is equal to 53 then the underlying protocol is DNS
					//Note: DNS can use either TCP or UDP thats why the check is done twice
					if (udpHeader.DestinationPort == "53" || udpHeader.SourcePort == "53")
					{
						TreeNode dnsNode = MakeDNSTreeNode(udpHeader.Data,
														 //Length of UDP header is always eight bytes so we subtract that out of the total 
														 //length to find the length of the data
														 Convert.ToInt32(udpHeader.Length) - 8); 
						rootNode.Nodes.Add(dnsNode);
					}
					break;
				case Protocol.Unknown:
					break;
			}
			AddTreeNode addTreeNode = new AddTreeNode(OnAddTreeNode);
			rootNode.Text = ipHeader.SourceAddress.ToString() + "-" +
				ipHeader.DestinationAddress.ToString();
			//Thread safe adding of the nodes
			treeView.Invoke(addTreeNode, new object[] {rootNode});
		}
		//Helper function which returns the information contained in the IP header as a
		//tree node
		private TreeNode MakeIPTreeNode(IPHeader ipHeader)
		{
			TreeNode ipNode = new TreeNode();
			ipNode.Text = "IP";			
			ipNode.Nodes.Add ("Ver: " + ipHeader.Version);
			ipNode.Nodes.Add ("Header Length: " + ipHeader.HeaderLength);
			ipNode.Nodes.Add ("Differntiated Services: " + ipHeader.DifferentiatedServices);
			ipNode.Nodes.Add("Total Length: " + ipHeader.TotalLength);
			ipNode.Nodes.Add("Identification: " + ipHeader.Identification);
			ipNode.Nodes.Add("Flags: " + ipHeader.Flags);
			ipNode.Nodes.Add("Fragmentation Offset: " + ipHeader.FragmentationOffset);
			ipNode.Nodes.Add("Time to live: " + ipHeader.TTL);
			switch (ipHeader.ProtocolType)
			{
				case Protocol.TCP:
					ipNode.Nodes.Add ("Protocol: " + "TCP");
					break;
				case Protocol.UDP:
					ipNode.Nodes.Add ("Protocol: " + "UDP");
					break;
				case Protocol.Unknown:
					ipNode.Nodes.Add ("Protocol: " + "Unknown");
					break;
			}
			ipNode.Nodes.Add("Checksum: " + ipHeader.Checksum);
			ipNode.Nodes.Add("Source: " + ipHeader.SourceAddress.ToString());
			ipNode.Nodes.Add("Destination: " + ipHeader.DestinationAddress.ToString());
			return ipNode;
		}
		//Helper function which returns the information contained in the TCP header as a
		//tree node
		private TreeNode MakeTCPTreeNode(TCPHeader tcpHeader)
		{
			TreeNode tcpNode = new TreeNode();
			tcpNode.Text = "TCP";
			tcpNode.Nodes.Add("Source Port: " + tcpHeader.SourcePort);
			tcpNode.Nodes.Add("Destination Port: " + tcpHeader.DestinationPort);
			tcpNode.Nodes.Add("Sequence Number: " + tcpHeader.SequenceNumber);
			if (tcpHeader.AcknowledgementNumber != "")
				tcpNode.Nodes.Add("Acknowledgement Number: " + tcpHeader.AcknowledgementNumber);
			tcpNode.Nodes.Add("Header Length: " + tcpHeader.HeaderLength);
			tcpNode.Nodes.Add("Flags: " + tcpHeader.Flags);
			tcpNode.Nodes.Add("Window Size: " + tcpHeader.WindowSize);
			tcpNode.Nodes.Add("Checksum: " + tcpHeader.Checksum);
			if (tcpHeader.UrgentPointer != "")
				tcpNode.Nodes.Add("Urgent Pointer: " + tcpHeader.UrgentPointer);
			return tcpNode;
		}
		//Helper function which returns the information contained in the UDP header as a
		//tree node
		private TreeNode MakeUDPTreeNode(UDPHeader udpHeader)
		{		 
			TreeNode udpNode = new TreeNode();
			udpNode.Text = "UDP";
			udpNode.Nodes.Add("Source Port: " + udpHeader.SourcePort);
			udpNode.Nodes.Add("Destination Port: " + udpHeader.DestinationPort);
			udpNode.Nodes.Add("Length: " + udpHeader.Length);
			udpNode.Nodes.Add("Checksum: " + udpHeader.Checksum);
			
			return udpNode;
		}
		//Helper function which returns the information contained in the DNS header as a
		//tree node
		private TreeNode MakeDNSTreeNode(byte[] byteData, int nLength)
		{
			DNSHeader dnsHeader = new DNSHeader(byteData, nLength);
			TreeNode dnsNode = new TreeNode();
			dnsNode.Text = "DNS";
			dnsNode.Nodes.Add("Identification: " + dnsHeader.Identification);
			dnsNode.Nodes.Add("Flags: " + dnsHeader.Flags);
			dnsNode.Nodes.Add("Questions: " + dnsHeader.TotalQuestions);
			dnsNode.Nodes.Add("Answer RRs: " + dnsHeader.TotalAnswerRRs);
			dnsNode.Nodes.Add("Authority RRs: " + dnsHeader.TotalAuthorityRRs);
			dnsNode.Nodes.Add("Additional RRs: " + dnsHeader.TotalAdditionalRRs);
			return dnsNode;
		}
		private void OnAddTreeNode(TreeNode node)
		{
			treeView.Nodes.Add(node);
		}
		private void SnifferForm_Load(object sender, EventArgs e)
		{
			string strIP = null;
			IPHostEntry HosyEntry = Dns.GetHostEntry((Dns.GetHostName()));
			if (HosyEntry.AddressList.Length > 0)
			{
				foreach (IPAddress ip in HosyEntry.AddressList)
				{
					strIP = ip.ToString();
					cmbInterfaces.Items.Add(strIP);
				}
			}			
		}
		private void SnifferForm_FormClosing(object sender, FormClosingEventArgs e)
		{
			if (bContinueCapturing)
			{
				mainSocket.Close();
			}
		}
	}
}
namespace Test
{
	using System.Windows.Forms;
	using System.ComponentModel;
	using System.Drawing;
	partial class snifferForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.treeView = new TreeView();
			this.btnStart = new Button();
			this.cmbInterfaces = new ComboBox();
			this.SuspendLayout();
			// 
			// treeView
			// 
			this.treeView.Anchor = ((AnchorStyles)((((AnchorStyles.Top | AnchorStyles.Bottom)
						| AnchorStyles.Left)
						| AnchorStyles.Right)));
			this.treeView.Location = new System.Drawing.Point(12, 12);
			this.treeView.Name = "treeView";
			this.treeView.Size = new System.Drawing.Size(396, 208);
			this.treeView.TabIndex = 0;
			// 
			// btnStart
			// 
			this.btnStart.Anchor = ((AnchorStyles)((AnchorStyles.Bottom | AnchorStyles.Left)));
			this.btnStart.Location = new Point(12, 227);
			this.btnStart.Name = "btnStart";
			this.btnStart.Size = new Size(91, 33);
			this.btnStart.TabIndex = 1;
			this.btnStart.Text = "&Start";
			this.btnStart.UseVisualStyleBackColor = true;
			this.btnStart.Click += new System.EventHandler(this.btnStart_Click);
			// 
			// cmbInterfaces
			// 
			this.cmbInterfaces.Anchor = ((AnchorStyles)(((AnchorStyles.Bottom | AnchorStyles.Left)
						| AnchorStyles.Right)));
			this.cmbInterfaces.DropDownStyle = ComboBoxStyle.DropDownList;
			this.cmbInterfaces.FormattingEnabled = true;
			this.cmbInterfaces.Location = new Point(128, 234);
			this.cmbInterfaces.Name = "cmbInterfaces";
			this.cmbInterfaces.Size = new Size(280, 21);
			this.cmbInterfaces.TabIndex = 2;
			// 
			// snifferForm
			// 
			this.AutoScaleDimensions = new SizeF(6F, 13F);
			this.AutoScaleMode = AutoScaleMode.Font;
			this.ClientSize = new Size(421, 266);
			this.Controls.Add(this.cmbInterfaces);
			this.Controls.Add(this.btnStart);
			this.Controls.Add(this.treeView);
			this.Name = "snifferForm";
			this.Text = "sniffer";
			this.FormClosing += new FormClosingEventHandler(this.SnifferForm_FormClosing);
			this.Load += new System.EventHandler(this.SnifferForm_Load);
			this.ResumeLayout(false);
		}
		#endregion
		private TreeView treeView;
		private Button btnStart;
		private ComboBox cmbInterfaces;
	}
}
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new snifferForm());
		}
	}
}
#T=SoapExtension GZIP
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Web.Services.Protocols;
	public class GZipSoapExtension : SoapExtension
	{
		private Stream _originalStream;
		private Stream _workStream;
		public override Stream ChainStream(Stream stream)
		{
			_originalStream = stream;
			_workStream = new MemoryStream();
			return _workStream;
		}
		public override object GetInitializer
									(
										LogicalMethodInfo methodInfo
										, SoapExtensionAttribute attribute
									)
		{
			return null;
		}
		public override object GetInitializer(Type WebServiceType)
		{
			return null;
		}
		public override void Initialize(object initializer)
		{
			//to do ...
		}
		public override void ProcessMessage(SoapMessage message)
		{
			switch (message.Stage)
			{
				case SoapMessageStage.BeforeSerialize :
					break;
				case SoapMessageStage.AfterSerialize :
					CompressStream();
					break;
				case SoapMessageStage.BeforeDeserialize :
					DecompressStream(); 
					break;
				case SoapMessageStage.AfterDeserialize :
					break;
				default :
					throw new Exception("invalid stage") ;
			}
		}
		public void CompressStream()
		{
			//压缩 响应
			Stream stream = CompressHelper.GZipCompress(_workStream);
			byte[] buffer = CompressHelper.ReadStreamToBytes(stream);
			_originalStream.Write(buffer, 0, buffer.Length);
		}
		public void DecompressStream()
		{
			//解压 请求
			byte[] bytes = CompressHelper.ReadStreamToBytes(_originalStream);
			bytes = CompressHelper.GZipDecompress(bytes);
			_workStream.Write(bytes, 0, bytes.Length);
			_workStream.Position = 0;
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public class GZipSoapExtensionAttribute : SoapExtensionAttribute
	{
		private int _priority;
		public override int Priority
		{
			get
			{
				return _priority;
			}
			set
			{
				_priority = value;
			}
		}
		public override Type ExtensionType
		{
			get
			{
				return typeof(GZipSoapExtension);
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Text;
	using System.IO;
	using System.IO.Compression;
	public class CompressHelper
	{
		public static byte[] ReadStreamToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
		public static byte[] GZipCompress(byte[] DATA)
		{
			MemoryStream ms = new MemoryStream();
			GZipStream stream = new GZipStream(ms, CompressionMode.Compress, true);
			stream.Write(DATA, 0, DATA.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			byte[] buffer = ReadStreamToBytes(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return buffer;
		}
		public static byte[] GZipDecompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream(data);
			GZipStream stream = new GZipStream(ms, CompressionMode.Decompress);
			byte[] buffer = ReadStreamToBytes(stream);
			ms.Close();
			ms.Dispose();
			ms = null;
			stream.Close();
			stream.Dispose();
			stream = null;
			return buffer;
		}
		public static Stream GZipCompress(Stream DATA)
		{
			byte[] buffer = ReadStreamToBytes(DATA);
			MemoryStream ms = new MemoryStream();
			GZipStream stream = new GZipStream(ms, CompressionMode.Compress, true);
			stream.Write(buffer, 0, buffer.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			if (ms.CanSeek)
			{
				ms.Position = 0;
			}
			return ms;
		}
		public static Stream GZipDecompress(Stream data)
		{
			byte[] buffer = ReadStreamToBytes(data);
			MemoryStream ms = new MemoryStream(buffer);
			GZipStream stream = new GZipStream(ms, CompressionMode.Decompress);
			if (stream.CanSeek)
			{
				stream.Position = 0;
			}
			return stream;
		}
		public static byte[] DeflateCompress(byte[] DATA)
		{
			MemoryStream ms = new MemoryStream();
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true);
			stream.Write(DATA, 0, DATA.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			byte[] buffer = ReadStreamToBytes(ms);
			ms.Close();
			ms.Dispose();
			ms = null;
			return buffer;
		}
		public static byte[] DeflateDecompress(byte[] data)
		{
			MemoryStream ms = new MemoryStream(data);
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Decompress);
			byte[] buffer = ReadStreamToBytes(stream);
			ms.Close();
			ms.Dispose();
			ms = null;
			stream.Close();
			stream.Dispose();
			stream = null;
			return buffer;
		}
		public static Stream DeflateCompress(Stream DATA)
		{
			byte[] buffer = ReadStreamToBytes(DATA);
			MemoryStream ms = new MemoryStream();
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true);
			stream.Write(buffer, 0, buffer.Length);
			stream.Close();
			stream.Dispose();
			stream = null;
			if (ms.CanSeek)
			{
				ms.Position = 0;
			}
			return ms;
		}
		public static Stream DeflateDecompress(Stream data)
		{
			byte[] buffer = ReadStreamToBytes(data);
			MemoryStream ms = new MemoryStream(buffer);
			DeflateStream stream = new DeflateStream(ms, CompressionMode.Decompress, true);
			if (stream.CanSeek)
			{
				stream.Position = 0;
			}
			return stream;
		}
	}
}
//==================================================================================================
// WebService.asmx
//<%@ WebService Language="c#" Class="Microshaoft.Service1Class" Debug="true"%>
namespace Microshaoft
{
	using System.Diagnostics;
	using System.Web;
	using System.Web.Services;
	using System.Collections.Generic;
	using System.Data;		[WebService(Namespace="http://www.microshaoft.com/")]
	public class Service1Class : WebService
	{
		[WebMethodAttribute]
		[Microshaoft.GZipSoapExtension()]
		public string HelloWorld(string x)
		{
			return string.Format("hello {0}", x);// + a;
		}
		[WebMethod]
		[Microshaoft.GZipSoapExtension()]
		public DataSet HelloWorld1(DataSet x)
		{
			x.Tables[0].Rows[0][1] += "\tserver";
			return x;//string.Format("hello {0}", x);// + a;
		}
	}
	public class aaResponse
	{
		public string Name;
		public int age;
		public byte[] data;
	}
	public class aaRequest
	{
		public string Name;
		public int age;
		
	}
}
//==================================================================================================
//Proxy Client
namespace ConsoleApplication
{
	using System;
	using System.Data;
	using Proxy;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Service1Class x = new Service1Class();
			string s = x.HelloWorld("于溪h");
			Console.WriteLine(s);
			DataSet d = x.HelloWorld1(CreateDataSet());
			string ss = d.Tables[0].Rows[0][1].ToString();
			Console.WriteLine(ss);
			Console.WriteLine(Environment.Version.ToString());
		}
		private static DataSet CreateDataSet()
		{
			DataSet dataSet = new DataSet();
			// Create two DataTable objects using a function.
			DataTable table1 = MakeTable("idTable1", "thing1");
			DataTable table2 = MakeTable("idTable2", "thing2");
			dataSet.Tables.Add(table1);
			dataSet.Tables.Add(table2);
			return dataSet;
			//Console.WriteLine(dataSet.Tables.Count)
		}
		private static DataTable MakeTable
							(
								string c1Name
								, string c2Name
							)
		{
			DataTable table= new DataTable();
			//' Add two DataColumns
			DataColumn column = new DataColumn(c1Name, typeof(int));
			table.Columns.Add(column);
			column = new DataColumn(c2Name, typeof(string));
			table.Columns.Add(column);
			table.Rows.Add(1,"aa");
			table.Rows.Add(2, "bb");
			return table;
		}
	}
}
namespace Proxy
{
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 此代码由工具生成。
	//	 运行时版本:2.0.50727.3053
	//
	//	 对此文件的更改可能会导致不正确的行为，并且如果
	//	 重新生成代码，这些更改将会丢失。
	// </auto-generated>
	//------------------------------------------------------------------------------
	using System;
	using System.ComponentModel;
	using System.Data;
	using System.Diagnostics;
	using System.Web.Services;
	using System.Web.Services.Protocols;
	using System.Xml.Serialization;
	// 
	// 此源代码由 wsdl 自动生成, Version=2.0.50727.42。
	// 

	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[System.Web.Services.WebServiceBindingAttribute(Name="Service1ClassSoap", Namespace="http://www.microshaoft.com/")]
	public partial class Service1Class : System.Web.Services.Protocols.SoapHttpClientProtocol {
		
		private System.Threading.SendOrPostCallback HelloWorldOperationCompleted;
		
		private System.Threading.SendOrPostCallback HelloWorld1OperationCompleted;
		
		/// <remarks/>
		public Service1Class() {
			this.Url = "http://test.v20.asp.net/SoapExtension/Noname1.asmx";
		}
		
		/// <remarks/>
		public event HelloWorldCompletedEventHandler HelloWorldCompleted;
		
		/// <remarks/>
		public event HelloWorld1CompletedEventHandler HelloWorld1Completed;
		
		/// <remarks/>
		[System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microshaoft.com/HelloWorld", RequestNamespace="http://www.microshaoft.com/", ResponseNamespace="http://www.microshaoft.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
		[Microshaoft.GZipSoapExtension()]
		public string HelloWorld(string x) {
			object[] results = this.Invoke("HelloWorld", new object[] {
						x});
			return ((string)(results[0]));
		}
		
		/// <remarks/>
		public System.IAsyncResult BeginHelloWorld(string x, System.AsyncCallback callback, object asyncState) {
			return this.BeginInvoke("HelloWorld", new object[] {
						x}, callback, asyncState);
		}
		
		/// <remarks/>
		public string EndHelloWorld(System.IAsyncResult asyncResult) {
			object[] results = this.EndInvoke(asyncResult);
			return ((string)(results[0]));
		}
		
		/// <remarks/>
		public void HelloWorldAsync(string x) {
			this.HelloWorldAsync(x, null);
		}
		
		/// <remarks/>
		public void HelloWorldAsync(string x, object userState) {
			if ((this.HelloWorldOperationCompleted == null)) {
				this.HelloWorldOperationCompleted = new System.Threading.SendOrPostCallback(this.OnHelloWorldOperationCompleted);
			}
			this.InvokeAsync("HelloWorld", new object[] {
						x}, this.HelloWorldOperationCompleted, userState);
		}
		
		private void OnHelloWorldOperationCompleted(object arg) {
			if ((this.HelloWorldCompleted != null)) {
				System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
				this.HelloWorldCompleted(this, new HelloWorldCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
			}
		}
		
		/// <remarks/>
		[System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microshaoft.com/HelloWorld1", RequestNamespace="http://www.microshaoft.com/", ResponseNamespace="http://www.microshaoft.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
		[Microshaoft.GZipSoapExtension()]
		public System.Data.DataSet HelloWorld1(System.Data.DataSet x) {
			object[] results = this.Invoke("HelloWorld1", new object[] {
						x});
			return ((System.Data.DataSet)(results[0]));
		}
		
		/// <remarks/>
		public System.IAsyncResult BeginHelloWorld1(System.Data.DataSet x, System.AsyncCallback callback, object asyncState) {
			return this.BeginInvoke("HelloWorld1", new object[] {
						x}, callback, asyncState);
		}
		
		/// <remarks/>
		public System.Data.DataSet EndHelloWorld1(System.IAsyncResult asyncResult) {
			object[] results = this.EndInvoke(asyncResult);
			return ((System.Data.DataSet)(results[0]));
		}
		
		/// <remarks/>
		public void HelloWorld1Async(System.Data.DataSet x) {
			this.HelloWorld1Async(x, null);
		}
		
		/// <remarks/>
		public void HelloWorld1Async(System.Data.DataSet x, object userState) {
			if ((this.HelloWorld1OperationCompleted == null)) {
				this.HelloWorld1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnHelloWorld1OperationCompleted);
			}
			this.InvokeAsync("HelloWorld1", new object[] {
						x}, this.HelloWorld1OperationCompleted, userState);
		}
		
		private void OnHelloWorld1OperationCompleted(object arg) {
			if ((this.HelloWorld1Completed != null)) {
				System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
				this.HelloWorld1Completed(this, new HelloWorld1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
			}
		}
		
		/// <remarks/>
		public new void CancelAsync(object userState) {
			base.CancelAsync(userState);
		}
	}
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
	public delegate void HelloWorldCompletedEventHandler(object sender, HelloWorldCompletedEventArgs e);
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	public partial class HelloWorldCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
		
		private object[] results;
		
		internal HelloWorldCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
				base(exception, cancelled, userState) {
			this.results = results;
		}
		
		/// <remarks/>
		public string Result {
			get {
				this.RaiseExceptionIfNecessary();
				return ((string)(this.results[0]));
			}
		}
	}
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
	public delegate void HelloWorld1CompletedEventHandler(object sender, HelloWorld1CompletedEventArgs e);
	/// <remarks/>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	public partial class HelloWorld1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
		
		private object[] results;
		
		internal HelloWorld1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
				base(exception, cancelled, userState) {
			this.results = results;
		}
		
		/// <remarks/>
		public System.Data.DataSet Result {
			get {
				this.RaiseExceptionIfNecessary();
				return ((System.Data.DataSet)(this.results[0]));
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Web.Services.Protocols;
	using System.Configuration;
	public class TraceSoapMessagesLoggerSoapExtension : SoapExtension
	{
		private Stream _originalStream;
		private Stream _workStream;
		private string _filePath;
		public override Stream ChainStream(Stream stream)
		{
			_originalStream = stream;
			_workStream = new MemoryStream();
			return _workStream;
		}
		public override object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute)
		{
			//return ((TraceExtensionAttribute)attribute).Filename;
			return null;
		}
		private static string _SoapMessagesLogPath = ConfigurationManager.AppSettings["SoapMessagesLogPath"];
		public override object GetInitializer(Type WebServiceType)
		{
			// Return a file name to log the trace information to, based on the
			// type.
			if (!_SoapMessagesLogPath.EndsWith(@"\"))
			{
				_SoapMessagesLogPath += @"\";
			}
			return _SoapMessagesLogPath + WebServiceType.FullName + ".{0}.{1}.log";
		}
		// Receive the file name stored by GetInitializer and store it in a
		// member variable for this specific instance.
		public override void Initialize(object initializer)
		{
			_filePath = (string) initializer;
		}
		public override void ProcessMessage(SoapMessage message)
		{
			switch (message.Stage)
			{
				case SoapMessageStage.BeforeSerialize:
					break;
				case SoapMessageStage.AfterSerialize:
					WriteStream();
					break;
				case SoapMessageStage.BeforeDeserialize:
					ReadStream();
					break;
				case SoapMessageStage.AfterDeserialize:
					break;
				default:
					throw new Exception("invalid stage");
			}
		}
		public void WriteStream()
		{
			_workStream.Position = 0;
			byte[] buffer = ReadStreamToBytes(_workStream);
			TextReader reader = new StreamReader(_workStream);
			string s = reader.ReadToEnd();
			WriteLog(s, "response", _filePath);
			_originalStream.Write(buffer, 0, buffer.Length);
		}
		public void ReadStream()
		{
			//解压 请求
			byte[] bytes = ReadStreamToBytes(_originalStream);
			TextReader reader = new StreamReader(_originalStream);
			string s = reader.ReadToEnd();
			WriteLog(s, "request", _filePath);
			_workStream.Write(bytes, 0, bytes.Length);
			_workStream.Position = 0;
		}
		private static void WriteLog(string data, string title, string filePath)
		{
			string path = Path.GetDirectoryName(filePath);
			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}
			string fileName = string.Format(filePath, title, DateTime.Now.ToString("yyyy-MM-dd.HH"));
			using (FileStream fs = new FileStream
										(
											fileName
											, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite
										 )
					)
			{
				StreamWriter w = new StreamWriter(fs);
				w.BaseStream.Seek(0, SeekOrigin.End);
				w.WriteLine(title + "Begin===========" + DateTime.Now);
				w.Flush();
				w.WriteLine(data);
				w.WriteLine(title + "End=============");
				w.Flush();
				w.Close();
			}
		}
		public static byte[] ReadStreamToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			MemoryStream ms = new MemoryStream();
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public class TraceSoapMessagesLoggerSoapExtensionAttribute : SoapExtensionAttribute
	{
		private int _priority;
		public override int Priority
		{
			get
			{
				return _priority;
			}
			set
			{
				_priority = value;
			}
		}
		public override Type ExtensionType
		{
			get
			{
				return typeof(TraceSoapMessagesLoggerSoapExtension);
			}
		}
	}
}
/*
<webServices>
	<protocols>
		<add name="protocol name"/>
		<remove name="protocol name"/>
		<clear/>
	</protocols>
	<serviceDescriptionFormatExtensionTypes> 
		<add type="type"/>
		<remove type="type"/>
		<clear/>
	</serviceDescriptionFormatExtensionTypes>
	<soapExtensionTypes>
		<add type="type" priority="number" group="0|1"/>
		<remove type="type"/>
		<clear/>
	</soapExtensionTypes>
	<soapExtensionReflectorTypes>
		<add type="type" priority="number" group="0|1"/>
		<remove type="type"/>
		<clear/>
	</soapExtensionReflectorTypes>
	<soapExtensionImporterTypes>
		<add type="type" priority="number" group="0|1"/>
		<remove type="type"/>
		<clear/>
	</soapExtensionImporterTypes>
	<wsdlHelpGenerator href="help generator file"/>
	<diagnostics suppressReturningExceptions="true|false" />
</webServices>
*/
#T=SoapExtension Trace Logger
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Web.Services.Protocols;
	using System.Configuration;
	public class TraceSoapMessagesLoggerSoapExtension : SoapExtension
	{
		private Stream _originalStream;
		private Stream _workStream;
		private string _filePath;
		public override Stream ChainStream(Stream stream)
		{
			_originalStream = stream;
			_workStream = new MemoryStream();
			return _workStream;
		}
		public override object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute)
		{
			//return ((TraceExtensionAttribute)attribute).Filename;
			return null;
		}
		private static string _SoapMessagesLogPath = ConfigurationManager.AppSettings["SoapMessagesLogPath"];
		public override object GetInitializer(Type WebServiceType)
		{
			// Return a file name to log the trace information to, based on the
			// type.
			if (!_SoapMessagesLogPath.EndsWith(@"\"))
			{
				_SoapMessagesLogPath += @"\";
			}
			return _SoapMessagesLogPath + WebServiceType.FullName + ".{0}.{1}.log";
		}
		// Receive the file name stored by GetInitializer and store it in a
		// member variable for this specific instance.
		public override void Initialize(object initializer)
		{
			_filePath = (string) initializer;
		}
		public override void ProcessMessage(SoapMessage message)
		{
			switch (message.Stage)
			{
				case SoapMessageStage.BeforeSerialize:
					break;
				case SoapMessageStage.AfterSerialize:
					WriteStream();
					break;
				case SoapMessageStage.BeforeDeserialize:
					ReadStream();
					break;
				case SoapMessageStage.AfterDeserialize:
					break;
				default:
					throw new Exception("invalid stage");
			}
		}
		public void WriteStream()
		{
			_workStream.Position = 0;
			byte[] buffer = ReadStreamToBytes(_workStream);
			TextReader reader = new StreamReader(_workStream);
			string s = reader.ReadToEnd();
			WriteLog(s, "response", _filePath);
			_originalStream.Write(buffer, 0, buffer.Length);
		}
		public void ReadStream()
		{
			//解压 请求
			byte[] bytes = ReadStreamToBytes(_originalStream);
			TextReader reader = new StreamReader(_originalStream);
			string s = reader.ReadToEnd();
			WriteLog(s, "request", _filePath);
			_workStream.Write(bytes, 0, bytes.Length);
			_workStream.Position = 0;
		}
		private static void WriteLog(string data, string title, string filePath)
		{
			string path = Path.GetDirectoryName(filePath);
			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}
			string fileName = string.Format(filePath, title, DateTime.Now.ToString("yyyy-MM-dd.HH"));
			using (FileStream fs = new FileStream
										(
											fileName
											, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite
										 )
					)
			{
				StreamWriter w = new StreamWriter(fs);
				w.BaseStream.Seek(0, SeekOrigin.End);
				w.WriteLine(title + "Begin===========" + DateTime.Now);
				w.Flush();
				w.WriteLine(data);
				w.WriteLine(title + "End=============");
				w.Flush();
				w.Close();
			}
		}
		public static byte[] ReadStreamToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			MemoryStream ms = new MemoryStream();
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public class TraceSoapMessagesLoggerSoapExtensionAttribute : SoapExtensionAttribute
	{
		private int _priority;
		public override int Priority
		{
			get
			{
				return _priority;
			}
			set
			{
				_priority = value;
			}
		}
		public override Type ExtensionType
		{
			get
			{
				return typeof(TraceSoapMessagesLoggerSoapExtension);
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Web.Services.Protocols;
	using System.Configuration;
	public class TraceSoapMessagesLoggerSoapExtension : SoapExtension
	{
		private Stream _originalStream;
		private Stream _workStream;
		private string _filePath;
		public override Stream ChainStream(Stream stream)
		{
			_originalStream = stream;
			_workStream = new MemoryStream();
			return _workStream;
		}
		public override object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute)
		{
			//return ((TraceExtensionAttribute)attribute).Filename;
			return null;
		}
		private static string _SoapMessagesLogPath = ConfigurationManager.AppSettings["SoapMessagesLogPath"];
		public override object GetInitializer(Type WebServiceType)
		{
			// Return a file name to log the trace information to, based on the
			// type.
			if (!_SoapMessagesLogPath.EndsWith(@"\"))
			{
				_SoapMessagesLogPath += @"\";
			}
			return _SoapMessagesLogPath + WebServiceType.FullName + ".{0}.{1}.log";
		}
		// Receive the file name stored by GetInitializer and store it in a
		// member variable for this specific instance.
		public override void Initialize(object initializer)
		{
			_filePath = (string) initializer;
		}
		public override void ProcessMessage(SoapMessage message)
		{
			switch (message.Stage)
			{
				case SoapMessageStage.BeforeSerialize:
					break;
				case SoapMessageStage.AfterSerialize:
					WriteStream();
					break;
				case SoapMessageStage.BeforeDeserialize:
					ReadStream();
					break;
				case SoapMessageStage.AfterDeserialize:
					break;
				default:
					throw new Exception("invalid stage");
			}
		}
		public void WriteStream()
		{
			_workStream.Position = 0;
			byte[] buffer = ReadStreamToBytes(_workStream);
			TextReader reader = new StreamReader(_workStream);
			string s = reader.ReadToEnd();
			WriteLog(s, "response", _filePath);
			_originalStream.Write(buffer, 0, buffer.Length);
		}
		public void ReadStream()
		{
			//解压 请求
			byte[] bytes = ReadStreamToBytes(_originalStream);
			TextReader reader = new StreamReader(_originalStream);
			string s = reader.ReadToEnd();
			WriteLog(s, "request", _filePath);
			_workStream.Write(bytes, 0, bytes.Length);
			_workStream.Position = 0;
		}
		private static void WriteLog(string data, string title, string filePath)
		{
			string path = Path.GetDirectoryName(filePath);
			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}
			string fileName = string.Format(filePath, title, DateTime.Now.ToString("yyyy-MM-dd.HH"));
			using (FileStream fs = new FileStream
										(
											fileName
											, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite
										 )
					)
			{
				StreamWriter w = new StreamWriter(fs);
				w.BaseStream.Seek(0, SeekOrigin.End);
				w.WriteLine(title + "Begin===========" + DateTime.Now);
				w.Flush();
				w.WriteLine(data);
				w.WriteLine(title + "End=============");
				w.Flush();
				w.Close();
			}
		}
		public static byte[] ReadStreamToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			MemoryStream ms = new MemoryStream();
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public class TraceSoapMessagesLoggerSoapExtensionAttribute : SoapExtensionAttribute
	{
		private int _priority;
		public override int Priority
		{
			get
			{
				return _priority;
			}
			set
			{
				_priority = value;
			}
		}
		public override Type ExtensionType
		{
			get
			{
				return typeof(TraceSoapMessagesLoggerSoapExtension);
			}
		}
	}
}
/*
<webServices>
	<protocols>
		<add name="protocol name"/>
		<remove name="protocol name"/>
		<clear/>
	</protocols>
	<serviceDescriptionFormatExtensionTypes> 
		<add type="type"/>
		<remove type="type"/>
		<clear/>
	</serviceDescriptionFormatExtensionTypes>
	<soapExtensionTypes>
		<add type="type" priority="number" group="0|1"/>
		<remove type="type"/>
		<clear/>
	</soapExtensionTypes>
	<soapExtensionReflectorTypes>
		<add type="type" priority="number" group="0|1"/>
		<remove type="type"/>
		<clear/>
	</soapExtensionReflectorTypes>
	<soapExtensionImporterTypes>
		<add type="type" priority="number" group="0|1"/>
		<remove type="type"/>
		<clear/>
	</soapExtensionImporterTypes>
	<wsdlHelpGenerator href="help generator file"/>
	<diagnostics suppressReturningExceptions="true|false" />
</webServices>
*/
#T=Socket AsyncQueue
namespace Test
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using Microshaoft;
	public class AsyncSocketAsyncQueueHandlerProxyServer
	{
		public static int Main(String[] args)
		{
			AsyncSocketAsyncQueueHandlerProxyServer x = new AsyncSocketAsyncQueueHandlerProxyServer();
			x.StartListening();
			return 0;
		}
		public void StartListening()
		{
			//IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress;
			IPAddress.TryParse("127.0.0.1", out ipAddress);
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 12021);
			Socket listener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Stream
										, ProtocolType.Tcp
									);
			listener.Bind(localEndPoint);
			Console.WriteLine("Listening ...");
			listener.Listen(10);
			int i = 0;
			while (true)
			{
				Socket proxySocket = listener.Accept();
				//socket.Blocking = true;
				Console.WriteLine("accept");
				Socket socket = new Socket
										(
											AddressFamily.InterNetwork
											, SocketType.Stream
											, ProtocolType.Tcp
										);
				socket.Blocking = true;
				socket.Connect("bbs.newsmth.net", 23); //连接
				UserToken token = new UserToken();
				token.userID = "handler";
				SocketAsyncDataHandler<UserToken> handler = new SocketAsyncDataHandler<UserToken>(socket, token);
				handler.ReceiveDataBufferLength = 1;
				handler.ID = 0;
				handler.StartReceiveData();
				UserToken token2 = new UserToken();
				token2.userID = "proxy";
				SocketAsyncDataHandler<UserToken> proxyHandler = new SocketAsyncDataHandler<UserToken>(proxySocket, token2);
				proxyHandler.ReceiveDataBufferLength = 1;
				proxyHandler.ID = i++;
				proxyHandler.StartReceiveData();
				ProxyHandlersPair<UserToken> pair = new ProxyHandlersPair<UserToken>(handler, proxyHandler);
				pair.DataReceivedProxy += new ProxyHandlersPair<UserToken>.DataReceivedProxyEventHandler(pair_DataReceivedProxy);
			}
		}
		void pair_DataReceivedProxy(SocketAsyncDataHandler<UserToken> source, byte[] data, SocketAsyncDataHandler<UserToken> destination)
		{
			string s = Encoding.GetEncoding("gbk").GetString(data);
			Console.WriteLine("[source: {0}],[destination: {1}],[data: {2}],[length: {3}]", source.Token.userID, destination.Token.userID, s, data.Length);
			destination.SendDataAsync(data);
		}
	}
	public class UserToken
	{
		public string userID;
	}
}
namespace Microshaoft
{
	using System;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	public class ProxyHandlersPair<T>
	{
		private SocketAsyncDataHandler<T> _proxyHandler;
		public SocketAsyncDataHandler<T> ProxyHandler
		{
			get
			{
				return _proxyHandler;
			}
		}
		private SocketAsyncDataHandler<T> _handler;
		public SocketAsyncDataHandler<T> Handler
		{
			get
			{
				return _handler;
			}
		}
		public delegate void DataReceivedProxyEventHandler
										(
											SocketAsyncDataHandler<T> source
											, byte[] data
											, SocketAsyncDataHandler<T> destination
										);
		public event DataReceivedProxyEventHandler DataReceivedProxy;
		public ProxyHandlersPair(SocketAsyncDataHandler<T> proxy, SocketAsyncDataHandler<T> handler)
		{
			_proxyHandler = proxy;
			_handler = handler;
			_handler.DataReceivedCompletedAsync += new SocketAsyncDataHandler<T>.DataReceivedCompletedAsyncEventHandler(handler_DataReceivedCompletedAsyncProcess);
			_proxyHandler.DataReceivedCompletedAsync += new SocketAsyncDataHandler<T>.DataReceivedCompletedAsyncEventHandler(proxyHandler_DataReceivedCompletedAsyncProcess);
		}
		public void proxyHandler_DataReceivedCompletedAsyncProcess(SocketAsyncDataHandler<T> sender, byte[] data)
		{
			if (DataReceivedProxy != null)
			{
				DataReceivedProxy(sender, data, _handler);
			}
		}
		public void handler_DataReceivedCompletedAsyncProcess(SocketAsyncDataHandler<T> sender, byte[] data)
		{
			if (DataReceivedProxy != null)
			{
				DataReceivedProxy(sender, data, _proxyHandler);
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	using System.Collections.Generic;
	public class SocketAsyncDataHandler<T>
	{
		private AsyncQueue<byte[]> _sendAsyncQueue;
		private Queue<byte[]> _receiveQueue;
		private T _token;
		public T Token
		{
			get
			{
				return _token;
			}
		}
		public SocketAsyncDataHandler(Socket socket, T token)
		{
			_sendAsyncQueue = new AsyncQueue<byte[]>();
			_sendAsyncQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(SendQueue_OnDequeue);
			//_sendAsyncQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_sendAsyncQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_sendAsyncQueue.MaxConcurrentThreadsCount = 1;
			_receiveQueue = new Queue<byte[]>();
			//_receiveQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(ReceiveQueue_OnDequeue);
			//_receiveQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			//_receiveQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_socket = socket;
			_token = token;
		}
		private byte[] _lastData = null;
		public int ReceiveData(byte[] buffer, int offset, int size)
		{
			int l = 0;
			if (_lastData != null)
			{
				if (_lastData.Length > 0)
				{
					l = _lastData.Length;
				}
			}
			int p = offset;
			int P = offset + size;

			int count = 0;
			if (l > 0)
			{
				count = (l >= size ? size : l);
				Buffer.BlockCopy(_lastData, 0, buffer, p, count);
				if (l == size)
				{
					_lastData = null;
				}
				else if (l < size)
				{
					_lastData = new byte[size - l];
					Buffer.BlockCopy(buffer, p, _lastData, 0, _lastData.Length);
				}
				p += count;
			}
			count = 0;
			byte[] data = null;
			while (p < P)
			{
				
				data = _receiveQueue.Dequeue();
				l = data.Length;
				int s = P - p;
				if (l > 0)
				{
					count = (l >= s ? s : l);
					Buffer.BlockCopy(data, 0, buffer, p, count);
					 p += count;
				}  
			}
			if (l > count)
			{
				_lastData = new byte[l - count];
				Buffer.BlockCopy(data, count, _lastData, 0, _lastData.Length);
			}
			return p;
		}

		void Queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		void Queue_OnQueueLog(string logMessage)
		{
			//			Console.WriteLine(logMessage);
		}
		void SendQueue_OnDequeue(byte[] element)
		{
			SendDataAsync(element);
		}
		public enum ExceptionHandleAction : int
		{
			Ignore
			,
			ReThrow
			,
			Abort
		}
		private Socket _socket;
		private int _id;
		public int ID
		{
			set
			{
				_id = value;
			}
			get
			{
				return _id;
			}
		}
		private int _receiveDataBufferLength = 1024;
		public int ReceiveDataBufferLength
		{
			set
			{
				_receiveDataBufferLength = value;
			}
		}
		public void SendData(byte[] data)
		{
			_socket.Send(data);
		}
		public void SendDataAsyncQueue(byte[] data)
		{
			_sendAsyncQueue.Enqueue(data);
		}
		public void SendDataAsync(byte[] data)
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.SetBuffer(data, 0, data.Length);
			_socket.SendAsync(e);
		}
		public delegate void DataReceivedCompletedAsyncEventHandler
												(
													SocketAsyncDataHandler<T> sender
													, byte[] data
												);
		public event DataReceivedCompletedAsyncEventHandler DataReceivedCompletedAsync;
		public delegate void ExceptionOccursEventHandler
												(
													SocketAsyncDataHandler<T> sender
													, Exception exception
													, ExceptionHandleAction action
												);
		public ExceptionOccursEventHandler ExceptionOccurs;
		public void StartReceiveData()
		{
			SocketAsyncEventArgs receive = new SocketAsyncEventArgs();
			receive.AcceptSocket = _socket;
			receive.Completed += new EventHandler<SocketAsyncEventArgs>(ReceivedData_Completed);
			byte[] buffer = new byte[_receiveDataBufferLength];
			receive.SetBuffer(buffer, 0, buffer.Length);
			_socket.ReceiveAsync(receive);
		}
		void ReceivedData_Completed(object sender, SocketAsyncEventArgs e)
		{
			int l = e.BytesTransferred;
			if (l > 0)
			{
				byte[] data = new byte[l];
				Buffer.BlockCopy(e.Buffer, 0, data, 0, data.Length);
				_receiveQueue.Enqueue(data);
			}
			_socket.ReceiveAsync(e);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		///		private long _EnqueueCount = 0; //入列计数器
		///		public long EnqueueCount
		///		{
		///			get
		///			{
		///				return _EnqueueCount;
		///			}
		///		}
		///		private long _DequeueCount = 0; //出列计数器
		///		public long DequeueCount
		///		{
		///			get
		///			{
		///				return _DequeueCount;
		///			}
		///		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				//Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				//Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					//Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}
#T=Socket/Stream Data Helper
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Net.Sockets;
	public static class SocketDataHelper
	{
		public static void ReadDataToFixedLengthBytes
								(
									Socket socket ,
									ref byte[] buffer
								)
		{
			int p = 0;
			int l = buffer.Length;
			while (p < l)
			{
				int r = socket.Receive
									(
										buffer
										, p
										, l - p
										, SocketFlags.None
									);
				p += r;
			}
		}
		public static byte[] ReadDataToFixedLengthBytes
									(
										int length ,
										Socket socket 
									)
		{
			int p = 0;
			byte[] data = new byte[length];
			while (p < length)
			{
				int r = socket.Receive
									(
										data
										, p
										, length - p
										, SocketFlags.None
									);
				p += r;
			}
			return data;
		}
		public static byte[] ReadDataToBytes
									(
										int length,
										Socket socket
									)
		{
			byte[] data = new byte[length];
			int r = 0;
			//SocketError error;
			r = socket.Receive
								(
									data
									, 0
									, length
									, SocketFlags.None
									//, out error
								);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref data, r);
			}
			else
			{
				data = null;
			}
			return data;
		}
		public static int ReadDataToBytes
								(
									Socket socket ,
									ref byte[] buffer
								)
		{
			int r = 0;
			//SocketError error;
			int l = buffer.Length;
			r = socket.Receive
							(
								buffer
								, 0
								, l
								, SocketFlags.None
								//, out error
							);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref buffer, r);
			}
			else
			{
				buffer = null;
			}
			return r;
		}
	}
	public static class StreamDataHelper
	{
		private static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=SocketAsyncDataHandler echo server 2012-08-12
//Client.cs
namespace Client
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	using Microshaoft;
	class Class1
	{
		static void Main1(string[] args)
		{
			var ipa = IPAddress.Parse("127.0.0.1");
			var socket = new Socket
								(
									AddressFamily.InterNetwork
									, SocketType.Stream
									, ProtocolType.Tcp
								);
			var ipep = new IPEndPoint(ipa, 18180);
			socket.Connect(ipep);
			var handler = new SocketAsyncDataHandler<string>
														(
															socket
															, 1
														);
			var sendEncoding = Encoding.Default;
			var receiveEncoding = Encoding.UTF8;
			receiveEncoding = Encoding.Default;
			var decoder = receiveEncoding.GetDecoder();
			handler.StartReceiveData
							(
								1024 * 8
								, (x, y, z) =>
								{
									var l = decoder.GetCharCount(y, 0, y.Length);
									var chars = new char[l];
									decoder.GetChars(y, 0, y.Length, chars, 0, false);
									var s = new string(chars);
									Console.Write(s);
									return true;
								}
							);
			string input = string.Empty;
			while ((input = Console.ReadLine()) != "q")
			{
				try
				{
					var buffer = sendEncoding.GetBytes(input);
					Array.ForEach
							(
								buffer
								, (x) =>
								{
									handler.SendDataSync(new[] { x });
									Thread.Sleep(100);
								}
							);
				}
				catch (Exception e)
				{
					Console.WriteLine(e.ToString());
				}
			}
		}
	}
}
//===========================================================================================
//Share.cs
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	public class SocketAsyncDataHandler<TContext>
	{
		private Socket _socket;
		public Socket WorkingSocket
		{
			get
			{
				return _socket;
			}
		}
		public int ReceiveDataBufferLength
		{
			get;
			private set;
		}
		public TContext Context
		{
			get;
			set;
		}
		public IPAddress RemoteIPAddress
		{
			get
			{
				return ((IPEndPoint)_socket.RemoteEndPoint).Address;
			}
		}
		public IPAddress LocalIPAddress
		{
			get
			{
				return ((IPEndPoint)_socket.LocalEndPoint).Address;
			}
		}
		public int SocketID
		{
			get;
			private set;
		}
		public SocketAsyncDataHandler
							(
								Socket socket
								, int socketID
							)
		{
			_socket = socket;
			_sendSocketAsyncEventArgs = new SocketAsyncEventArgs();
			SocketID = socketID;
		}
		private SocketAsyncEventArgs _sendSocketAsyncEventArgs;
		public int HeaderBytesLength
		{
			get;
			private set;
		}
		public int HeaderBytesOffset
		{
			get;
			private set;
		}
		public int HeaderBytesCount
		{
			get;
			private set;
		}
		private bool _isStartedReceiveData = false;
		private bool _isHeader = true;
		public bool StartReceiveWholeDataPackets
							(
								int receiveBufferLength
								, int headerBytesLength
								, int headerBytesOffset
								, int headerBytesCount
								, Func
									<
										SocketAsyncDataHandler<TContext>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onOneWholeDataPacketReceivedProcessFunc
								, Func
									<
										SocketAsyncDataHandler<TContext>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onDataPacketReceivedErrorProcessFunc = null
								, Action
									<
										SocketAsyncDataHandler<TContext>
										, bool
									> onAfterDestoryWorkingSocketProcessAction = null
							)
		{
			if (!_isStartedReceiveData)
			{
				HeaderBytesLength = headerBytesLength;
				HeaderBytesOffset = headerBytesOffset;
				HeaderBytesCount = headerBytesCount;
				var saeaReceive = new SocketAsyncEventArgs();
				int bodyLength = 0;
				saeaReceive.Completed += new EventHandler<SocketAsyncEventArgs>
								(
									(sender, e) =>
									{
										var socket = sender as Socket;
										if (e.BytesTransferred >= 0)
										{
											byte[] buffer = e.Buffer;
											int r = e.BytesTransferred;
											int p = e.Offset;
											int l = e.Count;
											if (r < l)
											{
												p += r;
												e.SetBuffer(p, l - r);
											}
											else if (r == l)
											{
												if (_isHeader)
												{
													byte[] data = new byte[headerBytesCount];
													Buffer.BlockCopy
																(
																	buffer
																	, HeaderBytesOffset
																	, data
																	, 0
																	, data.Length
																);
													byte[] intBytes = new byte[4];
													l = (intBytes.Length < HeaderBytesCount ? intBytes.Length : HeaderBytesCount);
													Buffer.BlockCopy
																(
																	data
																	, 0
																	, intBytes
																	, 0
																	, l
																);
													//Array.Reverse(intBytes);
													bodyLength = BitConverter.ToInt32(intBytes, 0);
													p += r;
													e.SetBuffer(p, bodyLength);
													Console.WriteLine(bodyLength);
													_isHeader = false;
												}
												else
												{
													byte[] data = new byte[bodyLength + HeaderBytesLength];
													bodyLength = 0;
													Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
													_isHeader = true;
													e.SetBuffer(0, HeaderBytesLength);
													if (onOneWholeDataPacketReceivedProcessFunc != null)
													{
														onOneWholeDataPacketReceivedProcessFunc
																						(
																							this
																							, data
																							, e
																						);
													}
												}
											}
											else
											{
												if (onDataPacketReceivedErrorProcessFunc != null)
												{
													byte[] data = new byte[p + r + HeaderBytesLength];
													Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
													bool b = onDataPacketReceivedErrorProcessFunc
																					(
																						this
																						, data
																						, e
																					);
													if (b)
													{
														bool i = DestoryWorkingSocket();
														if (onAfterDestoryWorkingSocketProcessAction != null)
														{
															onAfterDestoryWorkingSocketProcessAction(this, i);
														}
													}
													else
													{
														_isHeader = true;
														e.SetBuffer(0, HeaderBytesLength);
													}
												}
											}
										}
										try
										{
											socket.ReceiveAsync(e);
										}
										catch (Exception exception)
										{
											Console.WriteLine(exception.ToString());
											DestoryWorkingSocket();
										}
									}
								);
				ReceiveDataBufferLength = receiveBufferLength;
				saeaReceive.SetBuffer
								(
									new byte[ReceiveDataBufferLength]
									, 0
									, HeaderBytesLength
								);
				_socket.ReceiveAsync(saeaReceive);
				_isStartedReceiveData = true;
			}
			return _isStartedReceiveData;
		}
		public bool DestoryWorkingSocket()
		{
			bool r = false;
			try
			{
				if (_socket.Connected)
				{
					_socket.Disconnect(false);
				}
				_socket.Shutdown(SocketShutdown.Both);
				_socket.Close();
				_socket.Dispose();
				_socket = null;
				r = true;
			}
			catch (Exception e)
			{
				Console.WriteLine(e.ToString());
				//r = false;
			}
			return r;
		}
		public bool StartReceiveData
							(
								int receiveBufferLength
								, Func
									<
										SocketAsyncDataHandler<TContext>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onDataReceivedProcessFunc
							)
		{
			if (!_isStartedReceiveData)
			{
				var saeaReceive = new SocketAsyncEventArgs();
				saeaReceive.Completed += new EventHandler<SocketAsyncEventArgs>
												(
													(sender, e) =>
													{
														var socket = sender as Socket;
														int l = e.BytesTransferred;
														if (l > 0)
														{
															byte[] data = new byte[l];
															var buffer = e.Buffer;
															Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
															if (onDataReceivedProcessFunc != null)
															{
																onDataReceivedProcessFunc(this, data, e);
															}
														}
														try
														{
															socket.ReceiveAsync(e);
														}
														catch (Exception exception)
														{
															Console.WriteLine(exception.ToString());
														}
													}
												);
				ReceiveDataBufferLength = receiveBufferLength;
				saeaReceive.SetBuffer
								(
									new byte[ReceiveDataBufferLength]
									, 0
									, ReceiveDataBufferLength
								);
				_socket.ReceiveAsync(saeaReceive);
				_isStartedReceiveData = true;
			}
			return _isStartedReceiveData;
		}
		private object _sendSyncLockObject = new object();
		public int SendDataSync(byte[] data)
		{
			lock (_sendSyncLockObject)
			{
				return _socket.Send(data);
			}
		}
	}
}
//=======================================================================================================
//Server.cs
namespace Server
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using Microshaoft;
	class EchoServer<T>
	{
		//Socket _socketListener;
		private Action<SocketAsyncDataHandler<T>, byte[]> _onReceivedDataProcessAction;
		public EchoServer
					(
						IPEndPoint localPoint
						, Action
							<
								SocketAsyncDataHandler<T>
								, byte[]
							>
							onReceivedDataProcessAction
					)
		{
			_onReceivedDataProcessAction = onReceivedDataProcessAction;
			var listener = new Socket
							(
								localPoint.AddressFamily
								, SocketType.Stream
								, ProtocolType.Tcp
							);
			listener.Bind(localPoint);
			listener.Listen(5);
			AcceptSocketAsyc(listener);
		}
		private void AcceptSocketAsyc(Socket listener)
		{
			var acceptSocketAsyncEventArgs = new SocketAsyncEventArgs();
			acceptSocketAsyncEventArgs.Completed += acceptSocketAsyncEventArgs_AcceptOneCompleted;
			listener.AcceptAsync(acceptSocketAsyncEventArgs);
		}
		private int _socketID = 0;
		void acceptSocketAsyncEventArgs_AcceptOneCompleted(object sender, SocketAsyncEventArgs e)
		{
			e.Completed -= acceptSocketAsyncEventArgs_AcceptOneCompleted;
			var client = e.AcceptSocket;
			var listener = sender as Socket;
			AcceptSocketAsyc(listener);
			var handler = new SocketAsyncDataHandler<T>
														(
															client
															, _socketID++
														);
			handler.StartReceiveData
						(
							1024
							, (x, y, z) =>
							{
								//var s = Encoding.UTF8.GetString(y);
								////Console.WriteLine("SocketID: {1}{0}Length: {2}{0}Data: {2}", "\r\n", x.SocketID, y.Length ,s);
								//Console.Write(s);
								if (_onReceivedDataProcessAction != null)
								{
									_onReceivedDataProcessAction(x, y);
								}
								return true;
							}
						);
			//handler.StartReceiveWholeDataPackets
			//					(
			//						1024 * 1024
			//						, 2
			//						, 0
			//						, 2
			//						, (x, y, z) =>
			//						{
			//							var s = Encoding.UTF8.GetString(y);
			//							//Console.WriteLine("SocketID: {1}{0}Length: {2}{0}Data: {2}", "\r\n", x.SocketID, y.Length ,s);
			//							Console.Write(s);
			//							return true;
			//						}
			//					);
		}
	}
}
namespace Server
{
	using System;
	using System.Net;
	using System.Text;
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			IPAddress ipa;
			IPAddress.TryParse("127.0.0.1", out ipa);
			var receiveEncoding = Encoding.Default;
			var sendEncoding = Encoding.UTF8;
			sendEncoding = Encoding.Default;
			var decoder = receiveEncoding.GetDecoder();
			var es = new EchoServer<string>
							(
								new IPEndPoint(ipa, 18180)
								, (x, y) =>
								{
									var l = decoder.GetCharCount(y, 0, y.Length);
									var chars = new char[l];
									decoder.GetChars(y, 0, y.Length, chars, 0, false);
									var s = new string(chars);
									Console.Write(s);
									//s = string.Format("Echo: {0}{1}{0}", "\r\n", s);
									var buffer = sendEncoding.GetBytes(s);
									x.SendDataSync(buffer);
								}
							);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
	}
}

#T=SocketAsyncDataHandler LinkedList Buffer
namespace Test
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	using Microshaoft;
	public class AsyncSocketLinkedListHandlerEchoServer
	{
		public static void StartListening()
		{
			//IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress;
			IPAddress.TryParse("127.0.0.1", out ipAddress);
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 12021);
			Socket listener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Stream
										, ProtocolType.Tcp
									);
			listener.Bind(localEndPoint);
			Console.WriteLine("Listening ...");
			listener.Listen(10);
			int i = 0;
			while (true)
			{
				int id = i++;
				UserToken token = new UserToken();
				token.ConnectionID = id;
				Socket socket = listener.Accept();
				Console.WriteLine("accept");
				SocketAsyncDataHandler<UserToken> handler = new SocketAsyncDataHandler<UserToken>(socket, token);
				handler.ReceiveDataBufferLength = 1;
				handler.ID = id;
				handler.StartReceiveData();
				new Thread //only once per handler
						(
							delegate()
							{
								StartReadData(handler);
							}
						).Start();
			}
		}
		static void StartReadData(SocketAsyncDataHandler<UserToken> handler)
		{
			int L = 4;
			Console.WriteLine("input buffer length:");
			string s = Console.ReadLine();
			int l = 0;
			if (int.TryParse(s, out l))
			{
				if (l >= 0)
				{
					L = l;
				}
			}
			while (true)
			{
				byte[] buffer = new byte[L];
				int r = handler.ReadFixedLengthData(buffer, 5000, 100);
				string ss = string.Empty;
				if (r > 0)
				{
					if (r < L)
					{
						Array.Resize<byte>(ref buffer, r);
					}
					ss = Encoding.ASCII.GetString(buffer);
				}
				Console.WriteLine("{0}Buffer Length: [{1}]{0}Data Length: [{2}]{0}Buffer Data: [{3}]{0}Connection: [{4}]{0} ", "\n", L, r, ss, handler.ID);
			}
		}
		public static int Main(String[] args)
		{
			StartListening();
			return 0;
		}
	}
	public class UserToken
	{
		public string UserID;
		public int ConnectionID;
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Net.Sockets;
	using System.Collections.Generic;
	//using System.Collections.Concurrent;
	public class SocketAsyncDataHandler<T>
	{
		private LinkedList<byte[]> _receivedDataLinkedList = new LinkedList<byte[]>();
		public delegate void DataEventHandler(SocketAsyncDataHandler<T> sender, byte[] data);
		//public event DataEventHandler AsyncDataReceivedCompleted;
		private object _syncLockObject = new object();
		private T _token;
		public T Token
		{
			get
			{
				return _token;
			}
		}
		public SocketAsyncDataHandler(Socket socket, T token)
		{
			_socket = socket;
			_token = token;
		}
		public int ReadFixedLengthData
								(
									byte[] buffer
									, int waitDataTimeoutMilliseconds
									, int sleep
								)
		{
			int L = buffer.Length;
			int p = 0;
			DateTime begin = DateTime.Now;
			while (p < L)
			{
				if (_receivedDataLinkedList.Count <= 0 || _receivedDataLinkedList.First == null)
				{
					DateTime now = DateTime.Now;
					if (now.Subtract(begin).TotalMilliseconds < waitDataTimeoutMilliseconds)
					{
						Thread.Sleep(sleep);
						continue;
					}
					else
					{ 
						break;
					}
				}
				begin = DateTime.Now;
				int u = (L - p);
				byte[] data = _receivedDataLinkedList.First.Value;
				int l = data.Length;
				int size = (u > l ? l : u);
				if (u >= l)
				{
					lock (_syncLockObject)
					{
						_receivedDataLinkedList.RemoveFirst();
					}
				}
				Buffer.BlockCopy(data, 0, buffer, p, size);
				if (u < l)
				{
					byte[] tail = new byte[size];
					Buffer.BlockCopy(data, l - size, tail, 0, tail.Length);
					_receivedDataLinkedList.First.Value = tail;
				}
				p += size;
			}
			return p;
		}
		private Socket _socket;
		private int _id;
		public int ID
		{
			set
			{
				_id = value;
			}
			get
			{
				return _id;
			}
		}
		private int _receiveDataBufferLength = 1024;
		public int ReceiveDataBufferLength
		{
			set
			{
				_receiveDataBufferLength = value;
			}
		}
		public void SendData(byte[] data)
		{
			_socket.Send(data);
		}
		public void SendDataAsync(byte[] data)
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.SetBuffer(data, 0, data.Length);
			_socket.SendAsync(e);
		}
		public void StartReceiveData()
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.Completed += new EventHandler<SocketAsyncEventArgs>(ReceivedData_Completed);
			byte[] buffer = new byte[_receiveDataBufferLength];
			e.SetBuffer(buffer, 0, buffer.Length);
			_socket.ReceiveAsync(e); //first
		}
		private void ReceivedData_Completed(object sender, SocketAsyncEventArgs e)
		{
			int l = e.BytesTransferred;
			if (l > 0)
			{
				byte[] data = new byte[l];
				Buffer.BlockCopy(e.Buffer, 0, data, 0, data.Length);
				lock (_syncLockObject)
				{
					_receivedDataLinkedList.AddLast(data);
				}
			}
			_socket.ReceiveAsync(e);
		}
	}
}
//===============================================================================!!
#T=SocketAsyncEventArgs MSDN SAEA Buffer池化
namespace Microshaoft
{
	using System.Collections.Generic;
	using System.Net.Sockets;
	// This class creates a single large buffer which can be divided up 
	// and assigned to SocketAsyncEventArgs objects for use with each 
	// socket I/O operation.  
	// This enables bufffers to be easily reused and guards against 
	// fragmenting heap memory.
	// 
	// The operations exposed on the BufferManager class are not thread safe.
	class BufferManager
	{
		int m_numBytes;                 // the total number of bytes controlled by the buffer pool
		byte[] m_buffer;                // the underlying byte array maintained by the Buffer Manager
		Stack<int> m_freeIndexPool;     // 
		int m_currentIndex;
		int m_bufferSize;
		public BufferManager(int totalBytes, int bufferSize)
		{
			m_numBytes = totalBytes;
			m_currentIndex = 0;
			m_bufferSize = bufferSize;
			m_freeIndexPool = new Stack<int>();
		}
		// Allocates buffer space used by the buffer pool
		public void InitBuffer()
		{
			// create one big large buffer and divide that 
			// out to each SocketAsyncEventArg object
			m_buffer = new byte[m_numBytes];
		}
		// Assigns a buffer from the buffer pool to the 
		// specified SocketAsyncEventArgs object
		//
		// <returns>true if the buffer was successfully set, else false</returns>
		public bool SetBuffer(SocketAsyncEventArgs args)
		{
			if (m_freeIndexPool.Count > 0)
			{
				args.SetBuffer(m_buffer, m_freeIndexPool.Pop(), m_bufferSize);
			}
			else
			{
				if ((m_numBytes - m_bufferSize) < m_currentIndex)
				{
					return false;
				}
				args.SetBuffer(m_buffer, m_currentIndex, m_bufferSize);
				m_currentIndex += m_bufferSize;
			}
			return true;
		}
		// Removes the buffer from a SocketAsyncEventArg object.  
		// This frees the buffer back to the buffer pool
		public void FreeBuffer(SocketAsyncEventArgs args)
		{
			m_freeIndexPool.Push(args.Offset);
			args.SetBuffer(null, 0, 0);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Net.Sockets;
	// Represents a collection of reusable SocketAsyncEventArgs objects.  
	class SocketAsyncEventArgsPool
	{
		Stack<SocketAsyncEventArgs> m_pool;
		// Initializes the object pool to the specified size
		//
		// The "capacity" parameter is the maximum number of 
		// SocketAsyncEventArgs objects the pool can hold
		public SocketAsyncEventArgsPool(int capacity)
		{
			m_pool = new Stack<SocketAsyncEventArgs>(capacity);
		}
		// Add a SocketAsyncEventArg instance to the pool
		//
		//The "item" parameter is the SocketAsyncEventArgs instance 
		// to add to the pool
		public void Push(SocketAsyncEventArgs item)
		{
			if (item == null) { throw new ArgumentNullException("Items added to a SocketAsyncEventArgsPool cannot be null"); }
			lock (m_pool)
			{
				m_pool.Push(item);
			}
		}
		// Removes a SocketAsyncEventArgs instance from the pool
		// and returns the object removed from the pool
		public SocketAsyncEventArgs Pop()
		{
			lock (m_pool)
			{
				return m_pool.Pop();
			}
		}
		// The number of SocketAsyncEventArgs instances in the pool
		public int Count
		{
			get { return m_pool.Count; }
		}
	}
}
namespace Microshaoft
{
	using System.Net.Sockets;
	class AsyncUserToken
	{
		public Socket Socket;
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Net.Sockets;
	using System.Net;
	using System.Text;
	// Implements the connection logic for the socket server.  
	// After accepting a connection, all data read from the client 
	// is sent back to the client. The read and echo back to the client pattern 
	// is continued until the client disconnects.
	class Server
	{
		private int m_numConnections;   // the maximum number of connections the sample is designed to handle simultaneously 
		private int m_receiveBufferSize;// buffer size to use for each socket I/O operation 
		BufferManager m_bufferManager;  // represents a large reusable set of buffers for all socket operations
		const int opsToPreAlloc = 2;    // read, write (don't alloc buffer space for accepts)
		Socket listenSocket;            // the socket used to listen for incoming connection requests
		// pool of reusable SocketAsyncEventArgs objects for write, read and accept socket operations
		SocketAsyncEventArgsPool m_readWritePool;
		int m_totalBytesRead;           // counter of the total # bytes received by the server
		int m_numConnectedSockets;      // the total number of clients connected to the server 
		Semaphore m_maxNumberAcceptedClients;
		// Create an uninitialized server instance.  
		// To start the server listening for connection requests
		// call the Init method followed by Start method 
		//
		// <param name="numConnections">the maximum number of connections the sample is designed to handle simultaneously</param>
		// <param name="receiveBufferSize">buffer size to use for each socket I/O operation</param>
		public Server(int numConnections, int receiveBufferSize)
		{
			m_totalBytesRead = 0;
			m_numConnectedSockets = 0;
			m_numConnections = numConnections;
			m_receiveBufferSize = receiveBufferSize;
			// allocate buffers such that the maximum number of sockets can have one outstanding read and 
			//write posted to the socket simultaneously  
			m_bufferManager = new BufferManager(receiveBufferSize * numConnections * opsToPreAlloc,
				receiveBufferSize);
			m_readWritePool = new SocketAsyncEventArgsPool(numConnections);
			m_maxNumberAcceptedClients = new Semaphore(numConnections, numConnections);
		}
		// Initializes the server by preallocating reusable buffers and 
		// context objects.  These objects do not need to be preallocated 
		// or reused, but it is done this way to illustrate how the API can 
		// easily be used to create reusable objects to increase server performance.
		//
		public void Init()
		{
			// Allocates one large byte buffer which all I/O operations use a piece of.  This gaurds 
			// against memory fragmentation
			m_bufferManager.InitBuffer();
			// preallocate pool of SocketAsyncEventArgs objects
			SocketAsyncEventArgs readWriteEventArg;
			for (int i = 0; i < m_numConnections; i++)
			{
				//Pre-allocate a set of reusable SocketAsyncEventArgs
				readWriteEventArg = new SocketAsyncEventArgs();
				readWriteEventArg.Completed += new EventHandler<SocketAsyncEventArgs>(IO_Completed);
				readWriteEventArg.UserToken = new AsyncUserToken();
				
				// assign a byte buffer from the buffer pool to the SocketAsyncEventArg object
				m_bufferManager.SetBuffer(readWriteEventArg);
				// add SocketAsyncEventArg to the pool
				m_readWritePool.Push(readWriteEventArg);
			}
		}
		// Starts the server such that it is listening for 
		// incoming connection requests.    
		//
		// <param name="localEndPoint">The endpoint which the server will listening 
		// for connection requests on</param>
		public void Start(IPEndPoint localEndPoint)
		{
			// create the socket which listens for incoming connections
			listenSocket = new Socket(localEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
			listenSocket.Bind(localEndPoint);
			// start the server with a listen backlog of 100 connections
			listenSocket.Listen(100);
			// post accepts on the listening socket
			StartAccept(null);
			//Console.WriteLine("{0} connected sockets with one outstanding receive posted to each....press any key", m_outstandingReadCount);
			Console.WriteLine("Press any key to terminate the server process....");
			Console.ReadKey();
		}
		// Begins an operation to accept a connection request from the client 
		//
		// <param name="acceptEventArg">The context object to use when issuing 
		// the accept operation on the server's listening socket</param>
		public void StartAccept(SocketAsyncEventArgs acceptEventArg)
		{
			if (acceptEventArg == null)
			{
				acceptEventArg = new SocketAsyncEventArgs();
				acceptEventArg.Completed += new EventHandler<SocketAsyncEventArgs>(AcceptEventArg_Completed);
			}
			else
			{
				// socket must be cleared since the context object is being reused
				acceptEventArg.AcceptSocket = null;
			}
			m_maxNumberAcceptedClients.WaitOne();
			bool willRaiseEvent = listenSocket.AcceptAsync(acceptEventArg);
			if (!willRaiseEvent)
			{
				ProcessAccept(acceptEventArg);
			}
		}
		// This method is the callback method associated with Socket.AcceptAsync 
		// operations and is invoked when an accept operation is complete
		//
		void AcceptEventArg_Completed(object sender, SocketAsyncEventArgs e)
		{
			ProcessAccept(e);
		}
		private void ProcessAccept(SocketAsyncEventArgs e)
		{
			Interlocked.Increment(ref m_numConnectedSockets);
			Console.WriteLine("Client connection accepted. There are {0} clients connected to the server",
				m_numConnectedSockets);
			// Get the socket for the accepted client connection and put it into the 
			//ReadEventArg object user token
			SocketAsyncEventArgs readEventArgs = m_readWritePool.Pop();
			((AsyncUserToken)readEventArgs.UserToken).Socket = e.AcceptSocket;
			// As soon as the client is connected, post a receive to the connection
			bool willRaiseEvent = e.AcceptSocket.ReceiveAsync(readEventArgs);
			if (!willRaiseEvent)
			{
				ProcessReceive(readEventArgs);
			}
			// Accept the next connection request
			StartAccept(e);
		}
		// This method is called whenever a receive or send operation is completed on a socket 
		//
		// <param name="e">SocketAsyncEventArg associated with the completed receive operation</param>
		void IO_Completed(object sender, SocketAsyncEventArgs e)
		{
			// determine which type of operation just completed and call the associated handler
			switch (e.LastOperation)
			{
				case SocketAsyncOperation.Receive:
					ProcessReceive(e);
					break;
				case SocketAsyncOperation.Send:
					ProcessSend(e);
					break;
				default:
					throw new ArgumentException("The last operation completed on the socket was not a receive or send");
			}
		}
		// This method is invoked when an asynchronous receive operation completes. 
		// If the remote host closed the connection, then the socket is closed.  
		// If data was received then the data is echoed back to the client.
		//
		private void ProcessReceive(SocketAsyncEventArgs e)
		{
			// check if the remote host closed the connection
			AsyncUserToken token = (AsyncUserToken)e.UserToken;
			if (e.BytesTransferred > 0 && e.SocketError == SocketError.Success)
			{
				//increment the count of the total bytes receive by the server
				Interlocked.Add(ref m_totalBytesRead, e.BytesTransferred);
				Console.WriteLine("The server has read a total of {0} bytes", m_totalBytesRead);
				Int32 BytesToProcess = e.BytesTransferred;
				Byte[] bt = new Byte[BytesToProcess];
				Buffer.BlockCopy(e.Buffer, e.Offset, bt, 0, BytesToProcess);
				string strReceive = Encoding.Default.GetString(bt);
				Send(token.Socket, bt, 0, bt.Length, 1000);
				Thread.Sleep(1000);
				//echo the data received back to the client
				//e.SetBuffer(e.Offset, e.BytesTransferred);
				bool willRaiseEvent = token.Socket.SendAsync(e);
				if (!willRaiseEvent)
				{
					ProcessSend(e);
				}
			}
			else
			{
				CloseClientSocket(e);
			}
		}
		public static void Send(Socket socket, byte[] buffer, int offset, int size, int timeout)
		{
			socket.SendTimeout = 0;
			int startTickCount = Environment.TickCount;
			int sent = 0;  // how many bytes is already sent
			do
			{
				if (Environment.TickCount > startTickCount + timeout)
					//throw new Exception("Timeout.");
				try
				{
					sent += socket.Send(buffer, offset + sent, size - sent, SocketFlags.None);
				}
				catch (SocketException ex)
				{
					if (ex.SocketErrorCode == SocketError.WouldBlock ||
						ex.SocketErrorCode == SocketError.IOPending ||
						ex.SocketErrorCode == SocketError.NoBufferSpaceAvailable)
					{
						// socket buffer is probably full, wait and try again
						Thread.Sleep(30);
					}
					else
						throw ex;  // any serious error occurr
				}
			} while (sent < size);
		}
		// This method is invoked when an asynchronous send operation completes.  
		// The method issues another receive on the socket to read any additional 
		// data sent from the client
		//
		// <param name="e"></param>
		private void ProcessSend(SocketAsyncEventArgs e)
		{
			if (e.SocketError == SocketError.Success)
			{
				//e.SetBuffer(e.Offset, 10);
				// done echoing data back to the client
				AsyncUserToken token = (AsyncUserToken)e.UserToken;
				// read the next block of data send from the client
				bool willRaiseEvent = token.Socket.ReceiveAsync(e);
				if (!willRaiseEvent)
				{
					ProcessReceive(e);
				}
			}
			else
			{
				CloseClientSocket(e);
			}
		}
		private void CloseClientSocket(SocketAsyncEventArgs e)
		{
			AsyncUserToken token = e.UserToken as AsyncUserToken;
			// close the socket associated with the client
			try
			{
				token.Socket.Shutdown(SocketShutdown.Send);
			}
			// throws if client process has already closed
			catch (Exception) { }
			token.Socket.Close();
			// decrement the counter keeping track of the total number of clients connected to the server
			Interlocked.Decrement(ref m_numConnectedSockets);
			m_maxNumberAcceptedClients.Release();
			Console.WriteLine("A client has been disconnected from the server. There are {0} clients connected to the server", m_numConnectedSockets);
			// Free the SocketAsyncEventArg so they can be reused by another client
			m_readWritePool.Push(e);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Collections.Generic;
	using System.IO;
	class Program
	{
		static void Main(string[] args)
		{
			IPEndPoint iep = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 1333);
			Server objServer = new Server(1000, 10);
			objServer.Init();
			objServer.Start(iep);
		}
	}
}
#T=SocketAsyncQueueDataHandler Echo Server not OK
namespace Test
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	using Microshaoft;
	public class AsyncSocketAsyncDataQueueHandlerEchoServer
	{
		public static void StartListening()
		{
			//IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress;
			IPAddress.TryParse("127.0.0.1", out ipAddress);
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 12021);
			Socket listener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Stream
										, ProtocolType.Tcp
									);
			listener.Bind(localEndPoint);
			Console.WriteLine("Listening ...");
			listener.Listen(10);
			int i = 0;
			while (true)
			{
				int id = i++;
				UserToken token = new UserToken();
				token.ConnectionID = id;
				Socket socket = listener.Accept();
				Console.WriteLine("accept");
				SocketAsyncQueueDataHandler<UserToken> handler = new SocketAsyncQueueDataHandler<UserToken>(socket, token);
				handler.ReceiveDataBufferLength = 1;
				handler.ID = id;
				
				//handler.DataReceivedCompletedAsync += new SocketAsyncQueueDataHandler<UserToken>.DataReceivedCompletedAsyncEventHandler(DataReceived_CompletedAsync);
				handler.WaitingDataReceive += new SocketAsyncQueueDataHandler<UserToken>.WaitingDataReceiveEventHandler(handler_WaitingDataReceive);
				handler.StartReceiveData();

				
			}
		}

		static void handler_WaitingDataReceive(SocketAsyncQueueDataHandler<UserToken> sender)
		{
			while (true)
			{ 
				byte[] buffer = new byte[64];
				int offset = 0;
				int size = buffer.Length;
				int r = sender.ReceiveDataSync(buffer, offset, buffer.Length);
				string s = Encoding.GetEncoding("gb2312").GetString(buffer);
				Console.Write(s);
				//if (r == size)
				{
					sender.SendDataAsyncQueue(buffer);
				}
			}
		}


		public static int Main(String[] args)
		{
			StartListening();
			return 0;
		}
	}
	public class UserToken
	{
		public string UserID;
		public int ConnectionID;
	}
}
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	using System.Collections.Generic;
	public class SocketAsyncQueueDataHandler<T>
	{
		private AsyncQueue<byte[]> _sendAsyncQueue;
		private Queue<byte[]> _receiveQueue;
		private T _token;
		public T Token
		{
			get
			{
				return _token;
			}
		}
		public SocketAsyncQueueDataHandler(Socket socket, T token)
		{
			_sendAsyncQueue = new AsyncQueue<byte[]>();
			_sendAsyncQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(SendQueue_OnDequeue);
			//_sendAsyncQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_sendAsyncQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_sendAsyncQueue.MaxConcurrentThreadsCount = 1;
			_receiveQueue = new Queue<byte[]>();
			//_receiveQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(ReceiveQueue_OnDequeue);
			//_receiveQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			//_receiveQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_socket = socket;
			_token = token;
		}
		private byte[] _lastData = null;
		public int ReceiveDataSync(byte[] buffer, int offset, int size)
		{
			int l = 0;
			if (_lastData != null)
			{
				if (_lastData.Length > 0)
				{
					l = _lastData.Length;
				}
			}
			int p = offset;
			int P = offset + size;

			int count = 0;
			if (l > 0)
			{
				count = (l >= size ? size : l);
				Buffer.BlockCopy(_lastData, 0, buffer, p, count);
				if (l == size)
				{
					_lastData = null;
				}
				else if (l < size)
				{
					_lastData = new byte[size - l];
					Buffer.BlockCopy(buffer, p, _lastData, 0, _lastData.Length);
				}
				p += count;
			}
			count = 0;
			byte[] data = null;
			while (p < P)
			{
				if (_receiveQueue.Count > 0)
				{
					data = _receiveQueue.Dequeue();
					if (data != null)
					{
						l = data.Length;
						int s = P - p;
						if (l > 0)
						{
							count = (l >= s ? s : l);
							Buffer.BlockCopy(data, 0, buffer, p, count);
							p += count;
						}
					}
				}
			}
			if (l > count)
			{
				_lastData = new byte[l - count];
				Buffer.BlockCopy(data, count, _lastData, 0, _lastData.Length);
			}
			return p;
		}
		private void Queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		private void Queue_OnQueueLog(string logMessage)
		{
			//			Console.WriteLine(logMessage);
		}
		private void SendQueue_OnDequeue(byte[] element)
		{
			SendDataAsync(element);
		}
		public enum ExceptionHandleAction : int
		{
			Ignore
			,
			ReThrow
			,
			Abort
		}
		private Socket _socket;
		private int _id;
		public int ID
		{
			set
			{
				_id = value;
			}
			get
			{
				return _id;
			}
		}
		private int _receiveDataBufferLength = 1024;
		public int ReceiveDataBufferLength
		{
			set
			{
				_receiveDataBufferLength = value;
			}
		}
		public void SendData(byte[] data)
		{
			_socket.Send(data);
		}
		public void SendDataAsyncQueue(byte[] data)
		{
			_sendAsyncQueue.Enqueue(data);
		}
		private void SendDataAsync(byte[] data)
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.SetBuffer(data, 0, data.Length);
			_socket.SendAsync(e);
		}
		public delegate void WaitingDataReceiveEventHandler
												(
													SocketAsyncQueueDataHandler<T> sender

												);
		public event WaitingDataReceiveEventHandler WaitingDataReceive;
		public delegate void ExceptionOccursEventHandler
												(
													SocketAsyncQueueDataHandler<T> sender
													, Exception exception
													, ExceptionHandleAction action
												);
		public ExceptionOccursEventHandler ExceptionOccurs;
		private Thread _waitingDataReceiveThread = null;
		public void StartReceiveData()
		{
			if (WaitingDataReceive != null)
			{
				if (_waitingDataReceiveThread == null)
				{
					ThreadStart ts = new ThreadStart(WaitingDataReceiveProcess);
					_waitingDataReceiveThread = new Thread(ts);
					_waitingDataReceiveThread.Start();
				}
				
			}
			SocketAsyncEventArgs receive = new SocketAsyncEventArgs();
			receive.AcceptSocket = _socket;
			receive.Completed += new EventHandler<SocketAsyncEventArgs>(ReceivedData_Completed);
			byte[] buffer = new byte[_receiveDataBufferLength];
			receive.SetBuffer(buffer, 0, buffer.Length);
			_socket.ReceiveAsync(receive);
		}
		private void WaitingDataReceiveProcess()
		{
		   // while (true)
			{
				WaitingDataReceive(this);
			   // Thread.Sleep(100);
			}
		}
		private static object _SyncLockObject = new object();
		private void ReceivedData_Completed(object sender, SocketAsyncEventArgs e)
		{
			int l = e.BytesTransferred;
			if (l > 0)
			{
				byte[] data = new byte[l];
				Buffer.BlockCopy(e.Buffer, 0, data, 0, data.Length);
				lock (_SyncLockObject)
				{
					_receiveQueue.Enqueue(data);
				}
			}
			_socket.ReceiveAsync(e);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		///		private long _EnqueueCount = 0; //入列计数器
		///		public long EnqueueCount
		///		{
		///			get
		///			{
		///				return _EnqueueCount;
		///			}
		///		}
		///		private long _DequeueCount = 0; //出列计数器
		///		public long DequeueCount
		///		{
		///			get
		///			{
		///				return _DequeueCount;
		///			}
		///		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				//Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				//Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					//Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}
#T=SQL inject inspector
// /r:"C:\Program Files\Microsoft Visual Studio 10.0\VSTSDB\Deploy\Microsoft.Data.Schema.ScriptDom.dll";"C:\Program Files\Microsoft Visual Studio 10.0\VSTSDB\Deploy\Microsoft.Data.Schema.ScriptDom.Sql.dll"
namespace Microsoft.Security.Application.SecurityRuntimeEngine.PlugIns
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using Data.Schema.ScriptDom;
	using Data.Schema.ScriptDom.Sql;
	public class SqlInjectionInspector //: IRequestInspector, IConfigurablePlugIn
	{
		/// <summary>
		/// Returns a value indicating if the specified input could be a SQL injection attempt.
		/// </summary>
		/// <param name="input">The input to check.</param>
		/// <returns>True if the input is a possible SQL injection attempt, otherwise false</returns>
		private static bool IsSqlInjectible(string input)
		{
			return DetectCompleteSql(input) || DetectPartialSql(input) || DetectLogicInjection(input);
		}
		/// <summary>
		/// Detects logic short circuit attempts.
		/// </summary>
		/// <param name="input">The input to check.</param>
		/// <returns>True if a logic short circuit has been detected, otherwise false.</returns>
		private static bool DetectLogicInjection(string input)
		{
			// First determine whether there are two or more instances of single quotes.
			// This could potentially be SQL that attempts to change logic in a SQL query.
			int firstSingleQuoteIndex = input.IndexOf("'", StringComparison.Ordinal);
			// If there is no single quote in the input, then logic injection attack is unlikely.
			if (firstSingleQuoteIndex == -1)
			{
				return false;
			}
			int lastSingleQuoteIndex = input.LastIndexOf("'", StringComparison.Ordinal);
			// If there is only one single quote in the input, then logic injection attack is unlikely.
			if (firstSingleQuoteIndex == lastSingleQuoteIndex)
			{
				return false;
			}
			/* At this point, there is more than one single quote in the input.
			 * Strip out any quotes after the first instance and then pass it to the parser.
			 * For example, consider the query: select * from users where username=’ ” + param + “ ‘ “.
			 * 
			 * Input attack vectors:
			 * (a) someText' or username='alias
			 * (b) a' or 'a'='a
			 * 
			 * This function is designed to catch these types of attacks. */
			/* split the input into two sections. First variables contains everything from the
			 * start to the first occurrence (including) of the single quote.
			 * The second half contains everything after the first occurrence of the single quote. */
			string firstHalf = input.Substring(0, firstSingleQuoteIndex + 1);
			string secondHalf = input.Substring(firstSingleQuoteIndex + 1);
			/* Strip out any single quotes */
			secondHalf = secondHalf.Replace("'", string.Empty);
			string finalScrubbedInput = firstHalf + secondHalf;
			TSql100Parser parser = new TSql100Parser(false);
			IList<ParseError> errors;
			/* Try input with permutation. If input completes an invalid and partial SQL,
			 * then there is potential for an attack. This will capture cases where
			 * attackers attempt to escape out of valid SQL or modify logic. (i.e. OR 1=1)
			 */
			const string SqlCommandPrefix = "SELECT * FROM USERS WHERE ID='";
			string completeSql = SqlCommandPrefix + finalScrubbedInput;
			using (StringReader sr = new StringReader(completeSql))
			{
				parser.Parse(sr, out errors);
			}
			return errors == null || errors.Count <= 0;
		}
		/// <summary>
		/// Detects partial SQL command injection.
		/// </summary>
		/// <param name="input">The input to check.</param>
		/// <returns>True if a partial command has been detected, otherwise false.</returns>
		private static bool DetectPartialSql(string input)
		{
			// Only processing input greater than 2 characters
			if (input.Length < 3)
			{
				return false;
			}
			TSql100Parser parser = new TSql100Parser(false);
			IList<ParseError> errors;
			// Try input with permutation. If input completes an invalid and partial SQL,
			// then there is potential for an attack. This will capture cases where
			// attackers attempt to escape out of valid SQL or modify logic. (i.e. OR 1=1)
			const string StartSql = "SELECT * FROM USERS WHERE ID='";
			string completedSql = StartSql + input;
			using (StringReader sr = new StringReader(completedSql))
			{
				parser.Parse(sr, out errors);
			}
			return errors == null || errors.Count <= 0;
		}
		/// <summary>
		/// Detects a complete SQL command in the specified input.
		/// </summary>
		/// <param name="input">The input to check.</param>
		/// <returns>True if a logic short circuit has been detected, otherwise false.</returns>
		private static bool DetectCompleteSql(string input)
		{
			// Parser treats strings of length 1 or 2 as stored procedure calls. These will be skipped as they do not form complete SQL.
			input = input.Trim();
			string[] numberOfTokens = input.Split(' ');
			if (numberOfTokens.Length < 3)
			{
				return false;
			}
			// Try input in raw format. Detects complete SQL.
			using (StringReader sr = new StringReader(input))
			{
				TSql100Parser parser = new TSql100Parser(false);
				IList<ParseError> errors;
				parser.Parse(sr, out errors);
				return errors == null || errors.Count <= 0;
			}
		}
	}
}

#T=Sql Test Simple
namespace Microshaoft
{
	using System;
	using System.Data;
	using System.Data.SqlClient;
	class Program
	{
		static void Main()
		{
			using
				(
					SqlConnection connection = new SqlConnection
							(
								@"Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=TestDB;Data Source=cosdb01aohagls;ApplicationIntent=READONLY"
							)
				)
			{
				SqlDataAdapter adapter = new SqlDataAdapter("select @@ServerName as F1", connection);
				DataSet dataSet = new DataSet();
				adapter.Fill(dataSet,"T");
				DataTable table = dataSet.Tables[0];
				DataRowCollection rows = table.Rows;
				int i = 0;
				foreach (DataRow row in rows)
				{
					Console.Write("{1:0000}{0}", "\t", ++ i);
					foreach (DataColumn column in table.Columns)
					{
						Console.Write
								(
									"{1}{0}"
									, "\t"
									, row[column.ColumnName].ToString()
								);
					}
					Console.WriteLine();
					
				}
				connection.Close();
			}
		}
	}
}
#T=SqlBulkCopy
namespace Microsoft.Samples.SqlServer
{
	using System;
	using System.Data;
	using System.Data.SqlClient;

	class Program
	{
		public static void Main(string[] args)
		// Define and open a connection to the AdventureWorks 
		// database.
		{
			using
				(
					SqlConnection connection = new SqlConnection
													(
														GetConnectionString()
													)
				)
			{
				connection.Open();
				// Perform an initial count on the destination 
				// table.

				SqlCommand commandRowCount = new SqlCommand
													(
														"SELECT COUNT(*) FROM " 
														+ "dbo.BulkCopyDemoMatchingColumns;"
														, connection
													);
				long countStart = Convert.ToInt32
											(
												commandRowCount.ExecuteScalar()
											);
				Console.WriteLine("Starting row count = " + countStart);
				// Get data from the source table as a 
				// SqlDataReader.

				SqlCommand commandSourceData = new SqlCommand
													(
														"SELECT ProductID, Name, " +
														"ProductNumber " +
														"FROM Production.Product;"
														, connection
													);
				SqlDataReader reader =
					commandSourceData.ExecuteReader();
				// Set up the bulk copy object. 
				// Note that the column positions in the source
				// data reader match the column positions in 
				// the destination table so there is no need to
				// map columns.

				using (SqlBulkCopy bcp = 
					new SqlBulkCopy(connection))
				{
					bcp.DestinationTableName =
						"dbo.BulkCopyDemoMatchingColumns";
					// Write from the source to the 
					// destination.

					bcp.WriteToServer(reader);
				}
				// Perform a final count on the destination 
				// table to see how many rows were added.

				long countEnd = System.Convert.ToInt32(
					commandRowCount.ExecuteScalar());
				Console.WriteLine("Ending row count = " +
					countEnd);
				Console.WriteLine(countEnd - countStart +
					" rows were added.");
				Console.WriteLine("Press Enter to finish.");
				Console.ReadLine();
			}
		}

		// MARS is turned on in the connection string because this sample 
		// performs a bulk copy in the same database, using the same connection.
		// However, MARS is not required to use the SqlBulkCopy functionality.
		private static string GetConnectionString()
		// To avoid storing the connection string in your code, 
		// you can retrieve it from a configuration file. 
		{
			return "Data Source=(local);" +
				"Integrated Security=SSPI;" +
				"Initial Catalog=AdventureWorks;" +
				"MultipleActiveResultSets=True";
		 }
	}
}
#T=Ssl Stream Server/Client
namespace Examples.Server//.System.Net
{
	using System;
	using System.Collections;
	using System.Net;
	using System.Net.Sockets;
	using System.Net.Security;
	using System.Security.Authentication;
	using System.Text;
	using System.Security.Cryptography.X509Certificates;
	using System.IO;

	public sealed class SslTcpServer 
	{
		static X509Certificate serverCertificate = null;
		// The certificate parameter specifies the name of the file 
		// containing the machine certificate.
		public static void RunServer(string certificate) 
		{
			serverCertificate = X509Certificate.CreateFromCertFile(certificate);
			// Create a TCP/IP (IPv4) socket and listen for incoming connections.
			TcpListener listener = new TcpListener(IPAddress.Any, 8080);	
			listener.Start();
			while (true) 
			{
				Console.WriteLine("Waiting for a client to connect...");
				// Application blocks while waiting for an incoming connection.
				// Type CNTL-C to terminate the server.
				TcpClient client = listener.AcceptTcpClient();
				ProcessClient(client);
			}
		}
		static void ProcessClient (TcpClient client)
		{
			// A client has connected. Create the 
			// SslStream using the client's network stream.
			SslStream sslStream = new SslStream(
				client.GetStream(), false);
			// Authenticate the server but don't require the client to authenticate.
			try 
			{
				sslStream.AuthenticateAsServer(serverCertificate, 
					false, SslProtocols.Tls, true);
				// Display the properties and settings for the authenticated stream.
				DisplaySecurityLevel(sslStream);
				DisplaySecurityServices(sslStream);
				DisplayCertificateInformation(sslStream);
				DisplayStreamProperties(sslStream);

				// Set timeouts for the read and write to 5 seconds.
				sslStream.ReadTimeout = 5000;
				sslStream.WriteTimeout = 5000;
				// Read a message from the client.   
				Console.WriteLine("Waiting for client message...");
				string messageData = ReadMessage(sslStream);
				Console.WriteLine("Received: {0}", messageData);
				
				// Write a message to the client.
				byte[] message = Encoding.UTF8.GetBytes("Hello from the server.<EOF>");
				Console.WriteLine("Sending hello message.");
				sslStream.Write(message);
			}
			catch (AuthenticationException e)
			{
				Console.WriteLine("Exception: {0}", e.Message);
				if (e.InnerException != null)
				{
					Console.WriteLine("Inner exception: {0}", e.InnerException.Message);
				}
				Console.WriteLine ("Authentication failed - closing the connection.");
				sslStream.Close();
				client.Close();
				return;
			}
			finally
			{
				// The client stream will be closed with the sslStream
				// because we specified this behavior when creating
				// the sslStream.
				sslStream.Close();
				client.Close();
			}
		}
		static string ReadMessage(SslStream sslStream)
		{
			// Read the  message sent by the client.
			// The client signals the end of the message using the
			// "<EOF>" marker.
			byte [] buffer = new byte[2048];
			StringBuilder messageData = new StringBuilder();
			int bytes = -1;
			do
			{
				// Read the client's test message.
				bytes = sslStream.Read(buffer, 0, buffer.Length);
						
				// Use Decoder class to convert from bytes to UTF8
				// in case a character spans two buffers.
				Decoder decoder = Encoding.UTF8.GetDecoder();
				char[] chars = new char[decoder.GetCharCount(buffer,0,bytes)];
				decoder.GetChars(buffer, 0, bytes, chars,0);
				messageData.Append (chars);
				// Check for EOF or an empty message.
				if (messageData.ToString().IndexOf("<EOF>") != -1)
				{
					break;
				}
			} while (bytes !=0); 
			
			return messageData.ToString();
		}
		 static void DisplaySecurityLevel(SslStream stream)
		 {
			Console.WriteLine("Cipher: {0} strength {1}", stream.CipherAlgorithm, stream.CipherStrength);
			Console.WriteLine("Hash: {0} strength {1}", stream.HashAlgorithm, stream.HashStrength);
			Console.WriteLine("Key exchange: {0} strength {1}", stream.KeyExchangeAlgorithm, stream.KeyExchangeStrength);
			Console.WriteLine("Protocol: {0}", stream.SslProtocol);
		 }
		 static void DisplaySecurityServices(SslStream stream)
		 {
			Console.WriteLine("Is authenticated: {0} as server? {1}", stream.IsAuthenticated, stream.IsServer);
			Console.WriteLine("IsSigned: {0}", stream.IsSigned);
			Console.WriteLine("Is Encrypted: {0}", stream.IsEncrypted);
		 }
		 static void DisplayStreamProperties(SslStream stream)
		 {
			Console.WriteLine("Can read: {0}, write {1}", stream.CanRead, stream.CanWrite);
			Console.WriteLine("Can timeout: {0}", stream.CanTimeout);
		 }
		static void DisplayCertificateInformation(SslStream stream)
		{
			Console.WriteLine("Certificate revocation list checked: {0}", stream.CheckCertRevocationStatus);
				
			X509Certificate localCertificate = stream.LocalCertificate;
			if (stream.LocalCertificate != null)
			{
				Console.WriteLine("Local cert was issued to {0} and is valid from {1} until {2}.",
					localCertificate.Subject,
					localCertificate.GetEffectiveDateString(),
					localCertificate.GetExpirationDateString());
			 } else
			{
				Console.WriteLine("Local certificate is null.");
			}
			// Display the properties of the client's certificate.
			X509Certificate remoteCertificate = stream.RemoteCertificate;
			if (stream.RemoteCertificate != null)
			{
			Console.WriteLine("Remote cert was issued to {0} and is valid from {1} until {2}.",
				remoteCertificate.Subject,
				remoteCertificate.GetEffectiveDateString(),
				remoteCertificate.GetExpirationDateString());
			} else
			{
				Console.WriteLine("Remote certificate is null.");
			}
		}
		private static void DisplayUsage()
		{ 
			Console.WriteLine("To start the server specify:");
			Console.WriteLine("serverSync certificateFile.cer");
			Environment.Exit(1);
		}
		public static int Main(string[] args)
		{
			string certificate = null;
			if (args == null ||args.Length < 1 )
			{
				DisplayUsage();
			}
			certificate = args[0];
			SslTcpServer.RunServer (certificate);
			return 0;
		} 
	}
}



namespace Examples.Client//.System.Net
{
	using System;
	using System.Collections;
	using System.Net;
	using System.Net.Security;
	using System.Net.Sockets;
	using System.Security.Authentication;
	using System.Text;
	using System.Security.Cryptography.X509Certificates;
	using System.IO;

	public class SslTcpClient 
	{
		private static Hashtable certificateErrors = new Hashtable();
		// The following method is invoked by the RemoteCertificateValidationDelegate.
		public static bool ValidateServerCertificate(
			object sender,
			X509Certificate certificate,
			X509Chain chain,
			SslPolicyErrors sslPolicyErrors)
		{
		if (sslPolicyErrors == SslPolicyErrors.None)
				return true;

			Console.WriteLine("Certificate error: {0}", sslPolicyErrors);
			
			// Do not allow this client to communicate with unauthenticated servers.
			return false;
		}
		public static void RunClient(string machineName, string serverName)
		{
			// Create a TCP/IP client socket.
			// machineName is the host running the server application.
			TcpClient client = new TcpClient(machineName,443);
			Console.WriteLine("Client connected.");
			// Create an SSL stream that will close the client's stream.
			SslStream sslStream = new SslStream(
				client.GetStream(),
				false,
				new RemoteCertificateValidationCallback (ValidateServerCertificate),
				null
				);
			// The server name must match the name on the server certificate.
			try
			{
				sslStream.AuthenticateAsClient(serverName);
			}
			catch (AuthenticationException e)
			{
				Console.WriteLine("Exception: {0}", e.Message);
				if (e.InnerException != null)
				{
					Console.WriteLine("Inner exception: {0}", e.InnerException.Message);
				}
				Console.WriteLine ("Authentication failed - closing the connection.");
				client.Close();
				return;
			}
			// Encode a test message into a byte array.
			// Signal the end of the message using the "<EOF>".
			byte[] messsage = Encoding.UTF8.GetBytes("Hello from the client.<EOF>");
			// Send hello message to the server.
			sslStream.Write(messsage);
			sslStream.Flush();
			// Read message from the server.
			string serverMessage = ReadMessage(sslStream);
			Console.WriteLine("Server says: {0}", serverMessage);
			// Close the client connection.
			client.Close();
			Console.WriteLine("Client closed.");
		}
		static string ReadMessage(SslStream sslStream)
		{
			// Read the  message sent by the server.
			// The end of the message is signaled using the
			// "<EOF>" marker.
			byte [] buffer = new byte[2048];
			StringBuilder messageData = new StringBuilder();
			int bytes = -1;
			do
			{
				bytes = sslStream.Read(buffer, 0, buffer.Length);
						
				// Use Decoder class to convert from bytes to UTF8
				// in case a character spans two buffers.
				Decoder decoder = Encoding.UTF8.GetDecoder();
				char[] chars = new char[decoder.GetCharCount(buffer,0,bytes)];
				decoder.GetChars(buffer, 0, bytes, chars,0);
				messageData.Append (chars);
				// Check for EOF.
				if (messageData.ToString().IndexOf("<EOF>") != -1)
				{
					break;
				}
			} while (bytes != 0);
			
			return messageData.ToString();
		}
		private static void DisplayUsage()
		{
			Console.WriteLine("To start the client specify:");
			Console.WriteLine("clientSync machineName [serverName]");
			Environment.Exit(1);
		}
		public static int Main(string[] args)
		{
			string serverCertificateName = null;
			string machineName = null;
			if (args == null ||args.Length <1 )
			{
				DisplayUsage();
			}
			// User can specify the machine name and server name.
			// Server name must match the name on the server's certificate.
			machineName = args[0];
			if (args.Length <2 )
			{
				serverCertificateName = machineName;
			}
			else
			{
				serverCertificateName = args[1];
			}
			SslTcpClient.RunClient (machineName, serverCertificateName);
			return 0;
		}
	}
}

#T=stack 栈 遍历目录文件
namespace ConsoleApplication
{
	using System;
	using System.IO;
	using System.Collections.Generic;
	public class Class1
	{
		static void Main(string[] args)
		{
			int dirs = 0;
			int files = 0;
			string path = @"d:\myc#\";
			Stack<string> stack = new Stack<string>();
			stack.Push(path);
			while (stack.Count > 0)
			{
				//获取目录表
				DirectoryInfo parent = new DirectoryInfo(path);
				foreach (DirectoryInfo di in parent.GetDirectories())
				{
					string dir = string.Format(@"{0}{1}\", path, di.Name);
					stack.Push(dir);
					Console.WriteLine("dir: {0}", dir);
					dirs ++;
				}
				//出栈,获取文件信息
				if (stack.Count > 0)
				{
					path = stack.Pop();
					parent = new DirectoryInfo(path);
					//列出文件
					foreach (FileInfo fi in parent.GetFiles())
					{
						string file = string.Format(@"{0}{1}", path, fi.Name);
						Console.WriteLine("file: {0}", file);
						files ++;
					}
				}
			}
			Console.WriteLine("summary dirs: {0}, files: {1}", dirs, files);
		}
	}
}

#T=StackTraceHelper
namespace WebApplication1
{
	using System;
	using System.Web.UI;
	using Microshaoft;
	/// <summary>
	/// WebForm1 的摘要说明。
	/// </summary>
	public class ThrowPage : Page
	{
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			try
			{
				int i = 0;
				
				throw new Exception("aaa");
///				i = 3 / i;
///				i = int.Parse("aaa");

				ThrowPage x = new ThrowPage();
				x.Page_Load(null, null);
			}
			catch (Exception e)
			{
				
				PrintException(e);
				Console.WriteLine(StackTraceHelper.EnhancedStackTrace(e));
				Console.WriteLine("throw: ...");
				throw;
			}
		}
		static void PrintException(Exception e)
		{
			ConsoleColor color = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine("e.ToString:{0}{1}", "\n", e.ToString());
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine("e.StackTrace:{0}{1}", "\n", e.StackTrace);
			Console.ForegroundColor = color;
		}
		private void Page_Load(object sender, System.EventArgs e)
		{
			int i = 0;
			//Response.Write((3/i).ToString() + "<br>");





			//i = int.Parse("aaa");
			Test();
		}
		void Test()
		{
///			try
///			{
				int i = int.Parse("aaa");
				int j = 0;
				//Console.WriteLine(3/j);
				//throw new Exception("test");

///			}
///			catch (Exception e)
///			{
///				PrintException(e);
///				Console.WriteLine("throw: ...");
///				throw;
///			}
		
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Text;
	using System.Reflection;
	class StackTraceHelper
	{
		public static string EnhancedStackTrace(Exception ex)
		{
			return EnhancedStackTrace(new StackTrace(ex, true));
		}
		public static string EnhancedStackTrace(StackTrace st)
		{
			StringBuilder sb = new StringBuilder();
			sb.Append(Environment.NewLine);
			sb.Append("---- Stack Trace ----");
			sb.Append(Environment.NewLine);

			for (int i = 0; i < st.FrameCount; i++)
			{
				StackFrame sf = st.GetFrame(i);
				MemberInfo mi = sf.GetMethod();
				sb.Append(StackFrameToString(sf));
			} 
			sb.Append(Environment.NewLine); 
			
			return sb.ToString();
		}
		public static string StackFrameToString(StackFrame sf)
		{
			StringBuilder sb = new StringBuilder();
			int intParam; MemberInfo mi = sf.GetMethod(); 
			sb.Append("   "); 
			sb.Append(mi.DeclaringType.Namespace);
			sb.Append(".");
			sb.Append(mi.DeclaringType.Name); 
			sb.Append("."); 
			sb.Append(mi.Name);  
			// -- build method params           
			sb.Append("(");
			intParam = 0;
			foreach (ParameterInfo param in sf.GetMethod().GetParameters())
			{
				intParam += 1; 
				sb.Append(param.Name); 
				sb.Append(" As "); 
				sb.Append(param.ParameterType.Name);
			}
			sb.Append(")"); 
			sb.Append(Environment.NewLine);
			// -- if source code is available, append location info           
			sb.Append("       ");
			if (string.IsNullOrEmpty(sf.GetFileName()))
			{
				sb.Append("(unknown file)");               
				//-- native code offset is always available               
				sb.Append(": N ");
				sb.Append(String.Format("{0:#00000}", sf.GetNativeOffset()));
			}
			else
			{
				sb.Append(System.IO.Path.GetFileName(sf.GetFileName()));
				sb.Append(": line "); 
				sb.Append(String.Format("{0:#0000}", sf.GetFileLineNumber()));
				sb.Append(", col ");
				sb.Append(String.Format("{0:#00}", sf.GetFileColumnNumber()));
				if (sf.GetILOffset() != StackFrame.OFFSET_UNKNOWN)
				{
					sb.Append(", IL "); 
					sb.Append(String.Format("{0:#0000}", sf.GetILOffset()));
				}
			}
			sb.Append(Environment.NewLine); 
			return sb.ToString();
		}
	}

}

#T=StreamDataHelper
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=StringHelper
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine(StringHelper.IsValidString(null));
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}

}
namespace Microshaoft
{
	using System;
	public static class StringHelper
	{
		public static bool IsValidString(string text)
		{
			return (text != string.Empty && text != null && text.Trim().Length > 0);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Specialized;
	using System.Text;

	public static class HttpHelper
	{
		public static string GenerateFormHTML
								(
									NameValueCollection httpRequestFields
									, string formName
									, string httpMethod
									, string actionUrl
								)
		{
			StringBuilder sb = new StringBuilder();
			sb.Append(string.Format("<form name=\"{0}\" method=\"{1}\" action=\"{2}\"><br>", formName, httpMethod, actionUrl));
			foreach (string var in httpRequestFields.AllKeys)
			{
				string s = string.Format
									(
										"{0} <input type=\"text\" name=\"{0}\" value=\"{1}\" /><br>" 
										, var
										, httpRequestFields[var]
									);
				if (StringHelper.IsValidString(s))
				{
					sb.Append(s);
				}
			}
			sb.Append("<input type=\"submit\" />");
			sb.Append("</form>");
			//sb.Append(string.Format("<script type=\"text/javascript\">alert('asda');{0}.submit()</script>", formName));
			return sb.ToString();
		}
	}
}

#T=StringWalker
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------
// --------------------------------------------------------------------------
//  StringWalker class: this string encapsulates string operations in order
//  to provide easy methods that handle surrogates and combining characters
// --------------------------------------------------------------------------
namespace Microsoft.Samples.StringWalker
{
	using System;
	using System.Globalization;
	using System.Text;
	using System.Runtime.Serialization;
	[Serializable]
	public class StringWalkerException : Exception
	{
		public StringWalkerException()           : base() { }
		public StringWalkerException(String message) : base(message) { }
		public StringWalkerException(String message, Exception innerException) : base(message, innerException) { }
		protected StringWalkerException(SerializationInfo info, StreamingContext context) : base(info, context) { }
	}
	public class StringWalker
	{
		// private members
		private string myString = String.Empty;
		private int[] myIndex;
		private int myPos;
		// public property
		public int Length
		{
			get
			{
				return (null != myIndex) ? myIndex.Length : 0;
			}
		}
		// constructor
		public StringWalker(string input)
		{
			Initialize(input);
		}
		// ToString overriden method
		public override string ToString()
		{
			return myString;
		}
		// "easy" walking methods: GetFirst, GetNext, GetPrev, GetLast, Get
		// these are basically wrapper around the GetSubString method
		public bool GetFirst(out string input)
		{
			myPos = 0;
			return Get(myPos, out input);
		}
		public bool GetLast(out string input)
		{
			myPos = Length - 1;
			return Get(myPos, out input);
		}
		public bool GetNext(out string input)
		{
			return Get(++myPos, out input);
		}
		public bool GetPrevious(out string input)
		{
			return Get(--myPos, out input);
		}
		public bool Get(int index, out string input)
		{
			return (0 != GetSubString(index, 1, out input));
		}
		// GetSubString method
		public int GetSubString(int index, int count, out string input)
		{
			// check for index within bounds and non zero count
			if ((1 <= count) && (0 <= index) && (index < Length))
			{
				try
				{
					int lastindex = index + count;
					// if we are past the last char, then we get the string
					// up to the last char and return the actual count
					if (lastindex > (Length - 1))
					{
						input = myString.Substring(myIndex[index]);
						return Length - index;
					}
					else
					{
						input = myString.Substring(myIndex[index], myIndex[lastindex] - myIndex[index]);
						return count;
					}
				}
				catch // catch all and throw our exception
				{
					throw (new StringWalkerException());
				}
			}
			else
			{
				input = String.Empty;
				return 0;
			}
		}
		// Insert, Remove: both methods return true if the operation was succesful and false otherwise
		// Insert: inserts a string at the specified position
		public bool Insert(int index, string input)
		{
			if ((0 <= index) && (index <= Length))
			{
				try
				{
					if (index == Length)
						Initialize(myString.Insert(myString.Length, input));
					else
						Initialize(myString.Insert(myIndex[index], input));
					return true;
				}
				catch // catch all and throw our exception
				{
					throw (new StringWalkerException());
				}
			}
			return false;
		}
		// Remove: removes the specified number of text elements starting at the specified position
		public bool Remove(int index, int count)
		{
			if ((count > 0) && (0 <= index) && (index < Length))
			{
				try
				{
					int idxLast = index + count;
					int charcount = (idxLast < Length) ? myIndex[idxLast] - myIndex[index] : myString.Length - myIndex[index];
					Initialize(myString.Remove(myIndex[index], charcount));
					return true;
				}
				catch // catch all and throw our exception
				{
					throw (new StringWalkerException());
				}
			}
			return false;
		}
		// IndexOf: 
		public int IndexOf(string input, int index)
		{
			if ((0 <= index) && (index < Length))
			{
				try
				{
					// try and find the input string in the current string
					int position = myIndex[index];
					int foundAt = myString.IndexOf(input, position);
					// if the string is found, then we need to see if it
					// can be matched to a text element index.
					if (-1 != foundAt)
					{
						for (int i = 0; i < myIndex.Length; i++)
							if (myIndex[i] == foundAt)
								return i;
					}
				}
				catch // catch all and throw our exception
				{
					throw (new StringWalkerException());
				}
			}
			return -1;
		}
		// private initialization method
		private void Initialize(string input)
		{
			try
			{
				myPos = 0;
				myString = input;
				myIndex = StringInfo.ParseCombiningCharacters(myString);
			}
			catch (ArgumentNullException)
			{
				throw (new StringWalkerException());
			}
		}
	}
}

#T=Sync Framework FileSyncSample
//regsvr32 Synchronization2.dll
// D:\MyC#\SyncFx.FileSyncSample\a\ D:\MyC#\SyncFx.FileSyncSample\b\
// /r:Microsoft.Synchronization.Files.dll,Microsoft.Synchronization.dll

namespace Microshaoft
{
	// <copyright file="SyncMain.cs" company="Microsoft">
	//	 Copyright (c) Microsoft Corporation.  All rights reserved.
	// </copyright>
	// <summary>Sample code for using the MSF File Sync Provider</summary>

	using System;
	using System.IO;
	using Microsoft.Synchronization;
	using Microsoft.Synchronization.Files;

	public class FileSyncProviderSample
	{
		public static void Main(string[] args)
		{
			Console.WriteLine(args[1]);
			if (args.Length < 2 || 
				string.IsNullOrEmpty(args[0]) || string.IsNullOrEmpty(args[1]) ||
				!Directory.Exists(args[0]) || !Directory.Exists(args[1]))
			{
				Console.WriteLine(
				  "Usage: FileSyncSample [valid directory path 1] [valid directory path 2]");
				return;
			}

			string replica1RootPath = args[0];
			string replica2RootPath = args[1];

			try
			{
				// Set options for the sync operation
				FileSyncOptions options = FileSyncOptions.ExplicitDetectChanges |
						 FileSyncOptions.RecycleDeletedFiles | FileSyncOptions.RecyclePreviousFileOnUpdates | FileSyncOptions.RecycleConflictLoserFiles;

				FileSyncScopeFilter filter = new FileSyncScopeFilter();
				filter.FileNameExcludes.Add("*.lnk"); // Exclude all *.lnk files

				// Explicitly detect changes on both replicas upfront, to avoid two change 
				// detection passes for the two-way sync
				DetectChangesOnFileSystemReplica(
					replica1RootPath, filter, options);
				DetectChangesOnFileSystemReplica(
					replica2RootPath, filter, options);

				// Sync in both directions
				SyncFileSystemReplicasOneWay(replica1RootPath, replica2RootPath, null, options);
				SyncFileSystemReplicasOneWay(replica2RootPath, replica1RootPath, null, options);
			}
			catch (Exception e)
			{
				Console.WriteLine("\nException from File Sync Provider:\n" + e.ToString());
			}
		}

		public static void DetectChangesOnFileSystemReplica(
				string replicaRootPath,
				FileSyncScopeFilter filter, FileSyncOptions options)
		{
			FileSyncProvider provider = null;

			try
			{
				provider = new FileSyncProvider(replicaRootPath, filter, options);
				provider.DetectChanges();
			}
			finally
			{
				// Release resources
				if (provider != null)
					provider.Dispose(); 
			}
		}

		public static void SyncFileSystemReplicasOneWay(
				string sourceReplicaRootPath, string destinationReplicaRootPath,
				FileSyncScopeFilter filter, FileSyncOptions options)
		{
			FileSyncProvider sourceProvider = null;
			FileSyncProvider destinationProvider = null;

			try
			{
				sourceProvider = new FileSyncProvider(
					sourceReplicaRootPath, filter, options);
				destinationProvider = new FileSyncProvider(
					destinationReplicaRootPath, filter, options);

				destinationProvider.AppliedChange += 
					new EventHandler<AppliedChangeEventArgs>(OnAppliedChange);
				destinationProvider.SkippedChange += 
					new EventHandler<SkippedChangeEventArgs>(OnSkippedChange);

				SyncOrchestrator agent = new SyncOrchestrator();
				agent.LocalProvider = sourceProvider;
				agent.RemoteProvider = destinationProvider;
				agent.Direction = SyncDirectionOrder.Upload; // Sync source to destination

				Console.WriteLine("Synchronizing changes to replica: " + 
					destinationProvider.RootDirectoryPath);
				agent.Synchronize();
			}
			finally
			{
				// Release resources
				if (sourceProvider != null) sourceProvider.Dispose(); 
				if (destinationProvider != null) destinationProvider.Dispose();
			}
		}

		public static void OnAppliedChange(object sender, AppliedChangeEventArgs args)
		{
			switch(args.ChangeType)
			{
				case ChangeType.Create: 
				   Console.WriteLine("-- Applied CREATE for file " + args.NewFilePath); 
				   break;
				case ChangeType.Delete:
				   Console.WriteLine("-- Applied DELETE for file " + args.OldFilePath); 
				   break;
				case ChangeType.Update:
				   Console.WriteLine("-- Applied OVERWRITE for file " + args.OldFilePath); 
				   break;
				case ChangeType.Rename:
				   Console.WriteLine("-- Applied RENAME for file " + args.OldFilePath + 
									 " as " + args.NewFilePath); 
				   break;
			}
		}

		public static void OnSkippedChange(object sender, SkippedChangeEventArgs args)
		{
			Console.WriteLine("-- Skipped applying " + args.ChangeType.ToString().ToUpper() 
				  + " for " + (!string.IsNullOrEmpty(args.CurrentFilePath) ? 
								args.CurrentFilePath : args.NewFilePath) + " due to error");
				  
			if (args.Exception != null)
				Console.WriteLine("   [" + args.Exception.Message + "]");
		}
	}
}
#T=Sync Invoke Asyc Process Remoting 2012-04-06
//==========================================================================================================================
/*
csc /r:Share.dll Server.cs
*/
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections.Concurrent;
	using Microshaoft;
	public class SyncInvokeAsyncProcessor
	{
		private ConcurrentDictionary<string, SessionWithData<string, DateTime>> _sessions = new ConcurrentDictionary<string, SessionWithData<string, DateTime>>();
		public string SyncInvokeWaitFor(string sessionID, string completeCommand)
		{
			var sessionData = _sessions.GetOrAdd
											(
												sessionID
												, key =>
													{
														return new SessionWithData<string, DateTime>()
																			{
																				SessionID = sessionID
																				,
																				CompleteCommandWaits = new ConcurrentDictionary<string, ConcurrentBag<WaitWithData<DateTime>>>()
																			};
													}
											);
			var waits = sessionData.CompleteCommandWaits;
			var completeCommandWaits = waits.GetOrAdd
											(
												completeCommand
												, key =>
													{
														return new ConcurrentBag<WaitWithData<DateTime>>();
													}
											);
			var wwd = new WaitWithData<DateTime>()
												{
													Wait = new AutoResetEvent(false)
												};
			completeCommandWaits.Add(wwd);
			EventWaitHandle wait = wwd.Wait;
			wait.WaitOne();
			return wwd.Data.ToString("yyyy-MM-dd HH:mm:ss.fffff");
		}
		public void SendCommand(string sessionID, string commandText)
		{
			SessionWithData<string, DateTime> session;
			if (_sessions.TryGetValue(sessionID, out session))
			{
				ConcurrentBag<WaitWithData<DateTime>> waits;
				if (session.CompleteCommandWaits.TryGetValue(commandText, out waits))
				{
					while (!waits.IsEmpty)
					{
						WaitWithData<DateTime> wwd;
						if (waits.TryTake(out wwd))
						{
							wwd.Data = DateTime.Now;
							wwd.Wait.Set();
						};
					}
				}
			}
		}
	}
	public class SessionWithData<TSessionData, TConnectionData>
	{
		public string SessionID;
		public ConcurrentDictionary<string, ConcurrentBag<WaitWithData<TConnectionData>>> CompleteCommandWaits;
		public TSessionData Data;
	}
	public class WaitWithData<T>
	{
		public EventWaitHandle Wait;
		public T Data;
	}
}
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Security.Principal;
	using System.Configuration.Install;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using Microshaoft;
	using Microshaoft.Win32;
	using Microshaoft.RemotingObjects;
	public class ServiceHost : ServiceBase
	{
		public static readonly string serviceName = "RemotingSyncAsycInvokeService";
		private static SyncInvokeAsyncProcessor _processor;
		public static SyncInvokeAsyncProcessor Processor
		{
			get
			{
				return _processor;
			}
		}
		static void Main(string[] args)
		{
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
				}
				Console.Title = "Server"; //不能以服务运行
				Console.WriteLine("Console");
				service.OnStart(null);
				Console.ReadLine();
				return;
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			_processor = new SyncInvokeAsyncProcessor();
			RemotingHelper.StartRemoting<RemotingSyncInvokerAsyncHandler>
											(
												"SyncInvokeAsyncHandler"
												, 8080
												, WellKnownObjectMode.SingleCall
											);
			Console.WriteLine("Server . , Press Enter key to exit.");
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.RemotingObjects
{
	using System;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.RemotingObjects.Server;
	public class RemotingSyncInvokerAsyncHandler : MarshalByRefObject, IRemotingSyncInvokerAsyncHandler
	{
		public string SyncInvokeWaitFor(string user, string completeCommand)
		{
			return ServiceHost.Processor.SyncInvokeWaitFor(user, completeCommand);
		}
		public void SendCommand(string user, string command)
		{
			ServiceHost.Processor.SendCommand(user, command);
		}
	}
}
namespace Microshaoft.Win32
{
	using System;
	using System.Runtime.InteropServices;
	public static class NativeMethods
	{
		[
			DllImport
				(
					"kernel32.dll"
				)
		]
		public static extern bool AllocConsole();
		[
			DllImport
				(
					"kernel32.dll"
				)
		]
		public static extern bool FreeConsole();
	}
}
//==========================================================================================================================
//==========================================================================================================================
/*
csc /r:Share.dll Client.cs
*/
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.Title = "Client";
			Class1 a = new Class1();
			a.Run();
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		public void Run()
		{
			IRemotingSyncInvokerAsyncHandler _proxy = RemotingHelper.GetRemotingLocalClientProxyObject<IRemotingSyncInvokerAsyncHandler>("tcp://127.0.0.1:8080/SyncInvokeAsyncHandler");
			string s;
			while ((s = Console.ReadLine()) != "q")
			{
				string[] a = s.Split(' ');
				Console.WriteLine("BeginSyncWaitFor: {0} at {1} blocking ...", s, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
				string r = _proxy.SyncInvokeWaitFor(a[0], a[1]);
				Console.WriteLine(r);
				Console.WriteLine("EndSyncWaitFor: {0} at {1}", s, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
			}
		}
	}
}
//==========================================================================================================================
//==========================================================================================================================
/*
csc /t:library Share.cs
*/
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	public static class RemotingHelper
	{
		public static void StartRemoting
								(
									Type RemotingType
									, string Url
									, int Port
									, WellKnownObjectMode ServiceMode
								)
		{
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
			IDictionary ht = new Hashtable();
			ht["port"] = Port;
			TcpChannel tc = new TcpChannel(ht, null, provider);
			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, ServiceMode);
			Console.WriteLine("Remoting Object Started ...");
		}
		public static void StartRemoting<T>
								(
									string Url
									, int Port
									, WellKnownObjectMode Mode
								)
		{
			StartRemoting(typeof(T), Url, Port, Mode);
		}
		public static T GetRemotingLocalClientProxyObject<T>
			(
				string Url
			)
		{
			return (T) Activator.GetObject
									(
										typeof(T)
										, Url
									);
		}
	}
}
namespace Microshaoft.RemotingObjects.Share
{
	using System;
	public interface IRemotingSyncInvokerAsyncHandler
	{
		string SyncInvokeWaitFor(string user, string command);
		void SendCommand(string user, string command);
	}
}
//==========================================================================================================================
#T=Sync Remoting Invoke Async
/*
csc /t:library Share.cs
*/
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using System.Runtime.Serialization.Formatters;
	public static class RemotingHelper
	{
		public static void StartRemoting
								(
									Type RemotingType
									, string Url
									, int Port
									, WellKnownObjectMode ServiceMode
								)
		{
			BinaryServerFormatterSinkProvider provider = new BinaryServerFormatterSinkProvider();
			provider.TypeFilterLevel = TypeFilterLevel.Full;
			IDictionary ht = new Hashtable();
			ht["port"] = Port;
			TcpChannel tc = new TcpChannel(ht, null, provider);
			ChannelServices.RegisterChannel(tc, false);
			RemotingConfiguration.RegisterWellKnownServiceType(RemotingType, Url, ServiceMode);
			Console.WriteLine("Remoting Object Started ...");
		}
		public static void StartRemoting<T>
								(
									string Url
									, int Port
									, WellKnownObjectMode Mode
								)
		{
			StartRemoting(typeof(T), Url, Port, Mode);
		}
		public static T GetRemotingLocalClientProxyObject<T>
			(
				string Url
			)
		{
			return (T) Activator.GetObject
									(
										typeof(T)
										, Url
									);
		}
	}
}
namespace Microshaoft.RemotingObjects.Share
{
	using System;
	public interface IRemotingSyncInvokerAsyncHandler
	{
		void BeginSyncWaitFor(string user, string command);
		void SendCommand(string user, string command);
	}
}
/*
csc /r:Share.dll Server.cs
*/
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Runtime.InteropServices;
	public class SyncInvokerAsyncHandler<TSessionData, TAsyncHandleCommand>
	{
		public delegate void AsyncEventHandler
											(
												SyncInvokerAsyncHandler<TSessionData, TAsyncHandleCommand> sender
												, TAsyncHandleCommand command
											);
		public event AsyncEventHandler AsyncHandle;
		private bool _waiting = false;
		private AutoResetEvent _are;
		public SyncInvokerAsyncHandler(TSessionData session)
		{
			_sessionData = session;
		}
		public void CompleteAsyncHandle()
		{
			_waiting = false;
			_are.Set();
			if (AsyncHandle != null)
			{
				Delegate[] D = AsyncHandle.GetInvocationList();
				AsyncEventHandler handler = null;
				foreach (Delegate d in D)
				{
					handler = (AsyncEventHandler) d;
					AsyncHandle -= handler;
				}
			}
		}
		public void SendCommand(TAsyncHandleCommand command)
		{
			if (AsyncHandle != null)
			{
				AsyncHandle(this, command);
			}
		}
		private TSessionData _sessionData;
		public TSessionData SessionData
		{
			get
			{
				return _sessionData;
			}
		}
		public void SyncInvoke(TSessionData session)
		{
			_sessionData = session;
			_are = new AutoResetEvent(false);
			_waiting = true;
			Wait();
		}
		private void Wait()
		{
			while (_waiting)
			{
				Console.WriteLine("WaitOne ...");
				_are.WaitOne();
			}
		}
	}
}
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Runtime.InteropServices;
	using System.Collections.Generic;
	using Microshaoft;
	public class SyncInvokerAsyncHandlerProcessor
	{
		private Dictionary<string, SyncInvokerAsyncHandler<UserSessionData, AsyncHandleCommand>> _invokers = new Dictionary<string, SyncInvokerAsyncHandler<UserSessionData, AsyncHandleCommand>>();
		public void SyncInvoke(string sessionID, string completeCommand)
		{
			if (!_invokers.ContainsKey(sessionID))
			{
				UserSessionData session = new UserSessionData();
				session.SessionID = sessionID;
				session.CompleteCommand = completeCommand;
				SyncInvokerAsyncHandler<UserSessionData, AsyncHandleCommand> invoker = new SyncInvokerAsyncHandler<UserSessionData, AsyncHandleCommand>(session);
				invoker.AsyncHandle += new SyncInvokerAsyncHandler<UserSessionData, AsyncHandleCommand>.AsyncEventHandler(Invokers_AsyncHandle);
				_invokers.Add(session.SessionID, invoker);
				invoker.SyncInvoke(session);
			}
		}
		public void SendCommand(string sessionID, string commandText)
		{
			if (_invokers.ContainsKey(sessionID))
			{
				AsyncHandleCommand command = new AsyncHandleCommand();
				command.CommandText = commandText;
				SyncInvokerAsyncHandler<UserSessionData, AsyncHandleCommand> invoker = _invokers[sessionID];
				invoker.SendCommand(command);
			}
		}
		void Invokers_AsyncHandle(SyncInvokerAsyncHandler<UserSessionData, AsyncHandleCommand> sender, AsyncHandleCommand command)
		{
			if (sender.SessionData.CompleteCommand == command.CommandText)
			{
				sender.CompleteAsyncHandle();
				_invokers.Remove(sender.SessionData.SessionID);
			}
		}
	}
	public class UserSessionData
	{
		public string SessionID;
		public string CompleteCommand;
	}
	//[StructLayout(LayoutKind.Sequential)]
	public class AsyncHandleCommand
	{
		public string CommandText;
	}
}
namespace Microshaoft.RemotingObjects.Server
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Security.Principal;
	using System.Configuration.Install;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Tcp;
	using Microshaoft;
	using Microshaoft.Win32;
	using Microshaoft.RemotingObjects;
	public class ServiceHost : ServiceBase
	{
		public static readonly string serviceName = "RemotingSyncAsycInvokeService";
		private static SyncInvokerAsyncHandlerProcessor _processor;
		public static SyncInvokerAsyncHandlerProcessor Processor
		{
			get
			{
				return _processor;
			}
		}
		static void Main(string[] args)
		{
			ServiceHost service = new ServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
				}
				Console.Title = "Server"; //不能以服务运行
				Console.WriteLine("Console");
				service.OnStart(null);
				Console.ReadLine();
				return;
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public ServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = ServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			_processor = new SyncInvokerAsyncHandlerProcessor();
			RemotingHelper.StartRemoting<RemotingSyncInvokerAsyncHandler>
											(
												"SyncInvokeAsyncHandler"
												, 8080
												, WellKnownObjectMode.SingleCall
											);
			Console.WriteLine("Server . , Press Enter key to exit.");
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = ServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.RemotingObjects
{
	using System;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	using Microshaoft.RemotingObjects.Server;
	public class RemotingSyncInvokerAsyncHandler : MarshalByRefObject, IRemotingSyncInvokerAsyncHandler
	{
		public void BeginSyncWaitFor(string user, string completeCommand)
		{
			ServiceHost.Processor.SyncInvoke(user, completeCommand);
		}
		public void SendCommand(string user, string command)
		{
			ServiceHost.Processor.SendCommand(user, command);
		}
	}
}
namespace Microshaoft.Win32
{
	using System;
	using System.Runtime.InteropServices;
	public static class NativeMethods
	{
		[
			DllImport
				(
					"kernel32.dll"
				)
		]
		public static extern bool AllocConsole();
		[
			DllImport
				(
					"kernel32.dll"
				)
		]
		public static extern bool FreeConsole();
	}
}
/*
csc /r:Share.dll Client.cs
*/
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.Title = "Client";
			Class1 a = new Class1();
			a.Run();
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		public void Run()
		{
			IRemotingSyncInvokerAsyncHandler _proxy = RemotingHelper.GetRemotingLocalClientProxyObject<IRemotingSyncInvokerAsyncHandler>("tcp://127.0.0.1:8080/SyncInvokeAsyncHandler");
			string s;
			while ((s = Console.ReadLine()) != "q")
			{
				string[] a = s.Split(' ');
				Console.WriteLine("BeginSyncWaitFor: {0} at {1} blocking ...", s, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
				_proxy.BeginSyncWaitFor(a[0], a[1]);
				Console.WriteLine("EndSyncWaitFor: {0} at {1}", s, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
			}
		}
	}
}
/*
csc /r:Share.dll ControlerClient.cs
*/
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using Microshaoft;
	using Microshaoft.RemotingObjects.Share;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.Title = "Controler Client";
			Class1 a = new Class1();
			a.Run();
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		public void Run()
		{
			IRemotingSyncInvokerAsyncHandler _proxy = RemotingHelper.GetRemotingLocalClientProxyObject<IRemotingSyncInvokerAsyncHandler>("tcp://127.0.0.1:8080/SyncInvokeAsyncHandler");
			string s;
			while ((s = Console.ReadLine()) != "q")
			{
				string[] a = s.Split(' ');
				_proxy.SendCommand(a[0], a[1]);
				Console.WriteLine("SendCommand end: [{0}] at {1}", s, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
			}
		}
	}
}
#T=Task multi-threads pool
//http://www.cnblogs.com/Alexander-Lee/archive/2009/10/31/1593647.html
//亚历山大同志
namespace TaskPoolTest
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Threading;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			TaskPool pool = new TaskPool();
			for (int i = 0; i < 50; i++)
			{
				pool.AddTaskItem
						(
							x =>
								{
									for (int j = 0; j < 5; j++)
									{
										Thread.Sleep(10);
										Console.WriteLine("Thread " + (int) x + " print " + j);
									}
								},
							i
						);
			}
			Console.ReadKey();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Threading;
	public class TaskPool : IDisposable
	{
		private int max = 25; //最大线程数
		private int min = 4;  //最小线程数
		private int increment = 2; //当活动线程不足的时候新增线程的增量
		private Dictionary<string, Task> publicpool; //所有的线程
		private Queue<Task> freequeue;  //空闲线程队列
		private Dictionary<string, Task> working;   //正在工作的线程
		private Queue<Waititem> waitlist;  //等待执行工作队列
		//设置最大线程数
		public void Setmaxthread(int Value)
		{
			lock (this)
			{
				max = Value;
			}
		}
		//设置最小线程数
		public void Setminthread(int Value)
		{
			lock (this)
			{
				min = Value;
			}
		}
		//设置增量
		public void Setincrement(int Value)
		{
			lock (this)
			{
				increment = Value;
			}
		}
		//初始化线程池
		public TaskPool()
		{
			publicpool = new Dictionary<string, Task>();
			working = new Dictionary<string, Task>();
			freequeue = new Queue<Task>();
			waitlist = new Queue<Waititem>();
			Task t = null;
			//先创建最小线程数的线程
			for (int i = 0; i < min; i++)
			{
				t = new Task();
				//注册线程完成时触发的事件
				t.WorkComplete += new Action<Task>(t_WorkComplete);
				//加入到所有线程的字典中
				publicpool.Add(t.Key, t);
				//因为还没加入具体的工作委托就先放入空闲队列
				freequeue.Enqueue(t);
			}
		}
		//线程执行完毕后的触发事件
		void t_WorkComplete(Task obj)
		{
			lock (this)
			{
				//首先因为工作执行完了，所以从正在工作字典里删除
				working.Remove(obj.Key);
				//检查是否有等待执行的操作，如果有等待的优先执行等待的任务
				if (waitlist.Count > 0)
				{
					//先要注销当前的线程，将其从线程字典删除
					publicpool.Remove(obj.Key);
					obj.Close();
					//从等待任务队列提取一个任务
					Waititem item = waitlist.Dequeue();
					Task nt = null;
					//如果有空闲的线程，就是用空闲的线程来处理
					if (freequeue.Count > 0)
					{
						nt = freequeue.Dequeue();
					}
					else
					{
						//如果没有空闲的线程就再新创建一个线程来执行
						nt = new Task();
						publicpool.Add(nt.Key, nt);
						nt.WorkComplete += new Action<Task>(t_WorkComplete);
					}
					//设置线程的执行委托对象和上下文对象
					nt.taskWorkItem = item.Works;
					nt.contextdata = item.Context;
					//添加到工作字典中
					working.Add(nt.Key, nt);
					//唤醒线程开始执行
					nt.Active();
				}
				else
				{
					//如果没有等待执行的操作就回收多余的工作线程
					if (freequeue.Count > min)
					{
						//当空闲线程超过最小线程数就回收多余的这一个
						publicpool.Remove(obj.Key);
						obj.Close();
					}
					else
					{
						//如果没超过就把线程从工作字典放入空闲队列
						obj.contextdata = null;
						freequeue.Enqueue(obj);
					}
				}
			}
		}
		//添加工作委托的方法
		public void AddTaskItem(WaitCallback TaskItem, object Context)
		{
			lock (this)
			{
				Task t = null;
				int len = publicpool.Values.Count;
				//如果线程没有到达最大值
				if (len < max)
				{
					//如果空闲列表非空
					if (freequeue.Count > 0)
					{
						//从空闲队列pop一个线程
						t = freequeue.Dequeue();
						//加入工作字典
						working.Add(t.Key, t);
						//设置执行委托
						t.taskWorkItem = TaskItem;
						//设置状态对象
						t.contextdata = Context;
						//唤醒线程开始执行
						t.Active();
						return;
					}
					else
					{
						//如果没有空闲队列了，就根据增量创建线程
						for (int i = 0; i < increment; i++)
						{
							//判断线程的总量不能超过max
							if ((len + i) <= max)
							{
								t = new Task();
								//设置完成响应事件
								t.WorkComplete += new Action<Task>(t_WorkComplete);
								//加入线程字典
								publicpool.Add(t.Key, t);
								//加入空闲队列
								freequeue.Enqueue(t);
							}
							else
							{
								break;
							}
						}
						//从空闲队列提出出来设置后开始执行
						t = freequeue.Dequeue();
						working.Add(t.Key, t);
						t.taskWorkItem = TaskItem;
						t.contextdata = Context;
						t.Active();
						return;
					}
				}
				else
				{
					//如果线程达到max就把任务加入等待队列
					waitlist.Enqueue(new Waititem() { Context = Context, Works = TaskItem });
				}
			}
		}
		//回收资源
		public void Dispose()
		{
			//throw new NotImplementedException();
			foreach (Task t in publicpool.Values)
			{
				//关闭所有的线程
				using (t)
				{
					t.Close();
				}
			}
			publicpool.Clear();
			working.Clear();
			waitlist.Clear();
			freequeue.Clear();
		}
		//存储等待队列的类
		class Waititem
		{
			public WaitCallback Works
			{
				get;
				set;
			}
			public object Context
			{
				get;
				set;
			}
		}
		}
		//线程包装器类
		class Task : IDisposable
		{
			private AutoResetEvent locks; //线程锁
			private Thread T;  //线程对象
			public WaitCallback taskWorkItem; //线程体委托
			private bool working;  //线程是否工作
			public object contextdata
			{
				get;
				set;
			}
			public event Action<Task> WorkComplete;  //线程完成一次操作的事件
			//用于字典的Key
			public string Key
			{
			get;
			set;
			}
			//初始化包装器
			public Task()
			{
				//设置线程一进入就阻塞
				locks = new AutoResetEvent(false);
				Key = Guid.NewGuid().ToString();
				//初始化线程对象
				T = new Thread(Work);
				T.IsBackground = true;
				working = true;
				contextdata = new object();
				//开启线程
				T.Start();
			}
			//唤醒线程
			public void Active()
			{
				locks.Set();
			}
			//设置执行委托和状态对象
			public void SetWorkItem(WaitCallback action, object context)
			{
				taskWorkItem = action;
				contextdata = context;
			}
			//线程体包装方法
			private void Work()
			{
				while (working)
				{
					//阻塞线程
					locks.WaitOne();
					taskWorkItem(contextdata);
					//完成一次执行，触发事件
					WorkComplete(this);
				}
			}
			//关闭线程
			public void Close()
			{
				working = false;
			}
			//回收资源
			public void Dispose()
			{
				//throw new NotImplementedException();
			try
			{
				T.Abort();
			}
			catch
			{
			}
		}
	}
}
#T=telnet proxy AsyncSocket SocketAsyncEventArgs AsyncQueue
namespace Test
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using Microshaoft;
	public class AsyncSocketAsyncQueueHandlerProxyServer
	{
		public static int Main(String[] args)
		{
			AsyncSocketAsyncQueueHandlerProxyServer x = new AsyncSocketAsyncQueueHandlerProxyServer();
			x.StartListening();
			return 0;
		}
		public void StartListening()
		{
			//IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress;
			IPAddress.TryParse("127.0.0.1", out ipAddress);
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 12021);
			Socket listener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Stream
										, ProtocolType.Tcp
									);
			listener.Bind(localEndPoint);
			Console.WriteLine("Listening ...");
			listener.Listen(10);
			int i = 0;
			while (true)
			{
				Socket proxySocket = listener.Accept();
				//socket.Blocking = true;
				Console.WriteLine("accept");
				Socket socket = new Socket
										(
											AddressFamily.InterNetwork
											, SocketType.Stream
											, ProtocolType.Tcp
										);
				socket.Blocking = true;
				socket.Connect("bbs.newsmth.net", 23); //连接
				UserToken token = new UserToken();
				token.userID = "handler";
				SocketAsyncDataHandler<UserToken> handler = new SocketAsyncDataHandler<UserToken>(socket, token);
				handler.ReceiveDataBufferLength = 1;
				handler.ID = 0;
				handler.StartReceiveData();
				UserToken token2 = new UserToken();
				token2.userID = "proxy";
				SocketAsyncDataHandler<UserToken> proxyHandler = new SocketAsyncDataHandler<UserToken>(proxySocket, token2);
				proxyHandler.ReceiveDataBufferLength = 1;
				proxyHandler.ID = i++;
				proxyHandler.StartReceiveData();
				ProxyHandlersPair<UserToken> pair = new ProxyHandlersPair<UserToken>(handler, proxyHandler);
				pair.DataReceivedProxy += new ProxyHandlersPair<UserToken>.DataReceivedProxyEventHandler(pair_DataReceivedProxy);
			}
		}
		void pair_DataReceivedProxy(SocketAsyncDataHandler<UserToken> source, byte[] data, SocketAsyncDataHandler<UserToken> destination)
		{
			string s = Encoding.GetEncoding("gbk").GetString(data);
			Console.WriteLine("[source: {0}],[destination: {1}],[data: {2}],[length: {3}]", source.Token.userID, destination.Token.userID, s, data.Length);
			destination.SendDataAsync(data);
		}
	}
	public class UserToken
	{
		public string userID;
	}
}
namespace Microshaoft
{
	using System;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	public class ProxyHandlersPair<T>
	{
		private SocketAsyncDataHandler<T> _proxyHandler;
		public SocketAsyncDataHandler<T> ProxyHandler
		{
			get
			{
				return _proxyHandler;
			}
		}
		private SocketAsyncDataHandler<T> _handler;
		public SocketAsyncDataHandler<T> Handler
		{
			get
			{
				return _handler;
			}
		}
		public delegate void DataReceivedProxyEventHandler
										(
											SocketAsyncDataHandler<T> source
											, byte[] data
											, SocketAsyncDataHandler<T> destination
										);
		public event DataReceivedProxyEventHandler DataReceivedProxy;
		public ProxyHandlersPair(SocketAsyncDataHandler<T> proxy, SocketAsyncDataHandler<T> handler)
		{
			_proxyHandler = proxy;
			_handler = handler;
			_handler.DataReceivedCompletedAsync += new SocketAsyncDataHandler<T>.DataReceivedCompletedAsyncEventHandler(handler_DataReceivedCompletedAsyncProcess);
			_proxyHandler.DataReceivedCompletedAsync += new SocketAsyncDataHandler<T>.DataReceivedCompletedAsyncEventHandler(proxyHandler_DataReceivedCompletedAsyncProcess);
		}
		public void proxyHandler_DataReceivedCompletedAsyncProcess(SocketAsyncDataHandler<T> sender, byte[] data)
		{
			if (DataReceivedProxy != null)
			{
				DataReceivedProxy(sender, data, _handler);
			}
		}
		public void handler_DataReceivedCompletedAsyncProcess(SocketAsyncDataHandler<T> sender, byte[] data)
		{
			if (DataReceivedProxy != null)
			{
				DataReceivedProxy(sender, data, _proxyHandler);
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.IO;
	using System.Threading;
	public class SocketAsyncDataHandler<T>
	{
		private AsyncQueue<byte[]> _sendQueue;
		private AsyncQueue<byte[]> _receiveQueue;
		private T _token;
		public T Token
		{
			get
			{
				return _token;
			}
		}
		public SocketAsyncDataHandler(Socket socket, T token)
		{
			_sendQueue = new AsyncQueue<byte[]>();
			_sendQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(SendQueue_OnDequeue);
			//_sendQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_sendQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_sendQueue.MaxConcurrentThreadsCount = 1;
			_receiveQueue = new AsyncQueue<byte[]>();
			_receiveQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(ReceiveQueue_OnDequeue);
			//_receiveQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_receiveQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_socket = socket;
			_token = token;
		}
		void Queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		void Queue_OnQueueLog(string logMessage)
		{
			//			Console.WriteLine(logMessage);
		}
		void SendQueue_OnDequeue(byte[] element)
		{
			SendDataAsync(element);
		}
		void ReceiveQueue_OnDequeue(byte[] element)
		{
			if (DataReceivedCompletedAsync != null)
			{
				DataReceivedCompletedAsync(this, element);
			}
		}
		public enum ExceptionHandleAction : int
		{
			Ignore
			,
			ReThrow
			,
			Abort
		}
		private Socket _socket;
		private int _id;
		public int ID
		{
			set
			{
				_id = value;
			}
			get
			{
				return _id;
			}
		}
		private int _receiveDataBufferLength = 1024;
		public int ReceiveDataBufferLength
		{
			set
			{
				_receiveDataBufferLength = value;
			}
		}
		public void SendData(byte[] data)
		{
			_socket.Send(data);
		}
		public void SendDataAsyncQueue(byte[] data)
		{
			_sendQueue.Enqueue(data);
		}
		public void SendDataAsync(byte[] data)
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.SetBuffer(data, 0, data.Length);
			_socket.SendAsync(e);
		}
		public delegate void DataReceivedCompletedAsyncEventHandler
												(
													SocketAsyncDataHandler<T> sender
													, byte[] data
												);
		public event DataReceivedCompletedAsyncEventHandler DataReceivedCompletedAsync;
		public delegate void ExceptionOccursEventHandler
												(
													SocketAsyncDataHandler<T> sender
													, Exception exception
													, ExceptionHandleAction action
												);
		public ExceptionOccursEventHandler ExceptionOccurs;
		public void StartReceiveData()
		{
			SocketAsyncEventArgs receive = new SocketAsyncEventArgs();
			receive.AcceptSocket = _socket;
			receive.Completed += new EventHandler<SocketAsyncEventArgs>(ReceivedData_Completed);
			byte[] buffer = new byte[_receiveDataBufferLength];
			receive.SetBuffer(buffer, 0, buffer.Length);
			_socket.ReceiveAsync(receive);
		}
		void ReceivedData_Completed(object sender, SocketAsyncEventArgs e)
		{
			int l = e.BytesTransferred;
			if (l > 0)
			{
				byte[] data = new byte[l];
				Buffer.BlockCopy(e.Buffer, 0, data, 0, data.Length);
				_receiveQueue.Enqueue(data);
			}
			_socket.ReceiveAsync(e);
		}
	 }
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
///		private long _EnqueueCount = 0; //入列计数器
///		public long EnqueueCount
///		{
///			get
///			{
///				return _EnqueueCount;
///			}
///		}
///		private long _DequeueCount = 0; //出列计数器
///		public long DequeueCount
///		{
///			get
///			{
///				return _DequeueCount;
///			}
///		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				//Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				//Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					//Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}
#T=telnet proxy server SocketAsyncDataHandler LinkedList Buffer
namespace Test
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using Microshaoft;
	public class AsyncSocketAsyncQueueHandlerProxyServer
	{
		public static int Main(String[] args)
		{
			AsyncSocketAsyncQueueHandlerProxyServer x = new AsyncSocketAsyncQueueHandlerProxyServer();
			x.StartListening();
			return 0;
		}
		public void StartListening()
		{
			//IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress;
			IPAddress.TryParse("127.0.0.1", out ipAddress);
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 12021);
			Socket listener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Stream
										, ProtocolType.Tcp
									);
			listener.Bind(localEndPoint);
			Console.WriteLine("Listening ...");
			listener.Listen(10);
			int i = 0;
			while (true)
			{
				Socket proxySocket = listener.Accept();
				//socket.Blocking = true;
				Console.WriteLine("accept");
				Socket socket = new Socket
										(
											AddressFamily.InterNetwork
											, SocketType.Stream
											, ProtocolType.Tcp
										);
				socket.Blocking = true;
				socket.Connect("bbs.newsmth.net", 23); //连接
				UserToken token = new UserToken();
				token.userID = "handler";
				SocketAsyncDataHandler<UserToken> handler = new SocketAsyncDataHandler<UserToken>(socket, token);
				handler.ReceiveDataBufferLength = 1;
				handler.ID = 0;
				handler.StartReceiveData();
				UserToken token2 = new UserToken();
				token2.userID = "proxy";
				SocketAsyncDataHandler<UserToken> proxyHandler = new SocketAsyncDataHandler<UserToken>(proxySocket, token2);
				proxyHandler.ReceiveDataBufferLength = 1;
				proxyHandler.ID = i++;
				proxyHandler.StartReceiveData();
				ProxyHandlersPair<UserToken> pair = new ProxyHandlersPair<UserToken>(handler, proxyHandler);
				pair.DataReceivedProxy += new ProxyHandlersPair<UserToken>.DataReceivedProxyEventHandler(pair_DataReceivedProxy);
			}
		}
		void pair_DataReceivedProxy(SocketAsyncDataHandler<UserToken> source, byte[] data, SocketAsyncDataHandler<UserToken> destination)
		{
			string s = Encoding.GetEncoding("gbk").GetString(data);
			Console.WriteLine("[source: {0}],[destination: {1}],[data: {2}],[length: {3}]", source.Token.userID, destination.Token.userID, s, data.Length);
			destination.SendDataAsync(data);
		}
	}
	public class UserToken
	{
		public string userID;
	}
}
namespace Microshaoft
{
	using System;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	public class ProxyHandlersPair<T>
	{
		private SocketAsyncDataHandler<T> _proxyHandler;
		public SocketAsyncDataHandler<T> ProxyHandler
		{
			get
			{
				return _proxyHandler;
			}
		}
		private SocketAsyncDataHandler<T> _handler;
		public SocketAsyncDataHandler<T> Handler
		{
			get
			{
				return _handler;
			}
		}
		public delegate void DataReceivedProxyEventHandler
										(
											SocketAsyncDataHandler<T> source
											, byte[] data
											, SocketAsyncDataHandler<T> destination
										);
		public event DataReceivedProxyEventHandler DataReceivedProxy;
		public ProxyHandlersPair(SocketAsyncDataHandler<T> proxy, SocketAsyncDataHandler<T> handler)
		{
			_proxyHandler = proxy;
			_handler = handler;
			new Thread
						(
							delegate()
							{
								StartProxyReceivedData();
							}
						).Start();

			new Thread
						(
							delegate()
							{
								StartReceivedData();
							}
						).Start();
		}
		private void StartProxyReceivedData()
		{
			while (true)
			{
				
				int l = 1024;
				
				byte[] buffer = new byte[l];
				int r = _proxyHandler.ReadData(buffer);
				if (r <= 0)
				{
					Thread.Sleep(100);
					continue;
				}
				if (r < l)
				{
					Array.Resize<byte>(ref buffer, r);
				}
				if (DataReceivedProxy != null)
				{
					DataReceivedProxy(_proxyHandler, buffer, _handler);
				}
			}
		}
		private void StartReceivedData()
		{
			while (true)
			{
				
				int l = 1024;
				
				byte[] buffer = new byte[l];
				int r = _handler.ReadData(buffer);
				if (r <= 0)
				{
					Thread.Sleep(100);
					continue;
				}
				if (r < l)
				{
					Array.Resize<byte>(ref buffer, r);
				}
				if (DataReceivedProxy != null)
				{
					DataReceivedProxy(_handler, buffer, _proxyHandler);
				}
			}
		}
		public void handler_DataReceivedCompletedAsyncProcess(SocketAsyncDataHandler<T> sender, byte[] data)
		{
			if (DataReceivedProxy != null)
			{
				DataReceivedProxy(sender, data, _proxyHandler);
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Net.Sockets;
	using System.Collections.Generic;
	public class SocketAsyncDataHandler<T>
	{
		private LinkedList<byte[]> _receivedDataLinkedList = new LinkedList<byte[]>();
		public delegate void DataEventHandler(SocketAsyncDataHandler<T> sender, byte[] data);
		public event DataEventHandler AsyncDataReceivedCompleted;
		private object _syncLockObject = new object();
		private T _token;
		public T Token
		{
			get
			{
				return _token;
			}
		}
		public SocketAsyncDataHandler(Socket socket, T token)
		{
			_socket = socket;
			_token = token;
		}
		public int ReadData(byte[] buffer)
		{
			int l = buffer.Length;
			int p = 0;
			while (p < l)
			{
				if (_receivedDataLinkedList.Count <= 0)
				{
					break;
				}
				if (_receivedDataLinkedList.First == null)
				{
					break;
				}
				byte[] data = _receivedDataLinkedList.First.Value;
				int size = ((l - p) > data.Length ? data.Length : (l - p));
				if ((l - p) >= data.Length)
				{
					lock (_syncLockObject)
					{
						_receivedDataLinkedList.RemoveFirst();
					}
				}
				Buffer.BlockCopy(data, 0, buffer, p, size);
				if ((l - p) < data.Length)
				{
					byte[] newData = new byte[size];
					Buffer.BlockCopy(data, data.Length - size, newData, 0, newData.Length);
					_receivedDataLinkedList.First.Value = newData;
				}
				p += size;
			}
			return p;
		}
		private Socket _socket;
		private int _id;
		public int ID
		{
			set
			{
				_id = value;
			}
			get
			{
				return _id;
			}
		}
		private int _receiveDataBufferLength = 1024;
		public int ReceiveDataBufferLength
		{
			set
			{
				_receiveDataBufferLength = value;
			}
		}
		public void SendData(byte[] data)
		{
			_socket.Send(data);
		}
		public void SendDataAsync(byte[] data)
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.SetBuffer(data, 0, data.Length);
			_socket.SendAsync(e);
		}
		public void StartReceiveData()
		{
			SocketAsyncEventArgs e = new SocketAsyncEventArgs();
			e.AcceptSocket = _socket;
			e.Completed += new EventHandler<SocketAsyncEventArgs>(ReceivedData_Completed);
			byte[] buffer = new byte[_receiveDataBufferLength];
			e.SetBuffer(buffer, 0, buffer.Length);
			_socket.ReceiveAsync(e);
		}
		private void ReceivedData_Completed(object sender, SocketAsyncEventArgs e)
		{
			int l = e.BytesTransferred;
			if (l > 0)
			{
				byte[] data = new byte[l];
				Buffer.BlockCopy(e.Buffer, 0, data, 0, data.Length);
				lock (_syncLockObject)
				{
					_receivedDataLinkedList.AddLast(data);
				}
				if (AsyncDataReceivedCompleted != null)
				{
					AsyncDataReceivedCompleted(this, data);
				}
			}
			_socket.ReceiveAsync(e);
		}
	}
}

#T=telnet proxy SyncSocketAsyncQueue
namespace Test
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using Microshaoft;
	public class SyncSocketAsyncQueueHandlerProxyServer
	{
		public static int Main(String[] args)
		{
			SyncSocketAsyncQueueHandlerProxyServer x = new SyncSocketAsyncQueueHandlerProxyServer();
			x.StartListening();
			return 0;
		}
		public void StartListening()
		{
			//IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
			IPAddress ipAddress;
			IPAddress.TryParse("127.0.0.1", out ipAddress);
			IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 12021);
			Socket listener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Stream
										, ProtocolType.Tcp
									);
			listener.Bind(localEndPoint);
			Console.WriteLine("Listening ...");
			listener.Listen(10);
			int i = 0;
			while (true)
			{
				Socket proxySocket = listener.Accept();
				//socket.Blocking = true;
				Console.WriteLine("accept");
				Socket socket = new Socket
										(
											AddressFamily.InterNetwork
											, SocketType.Stream
											, ProtocolType.Tcp
										);
				socket.Blocking = true;
				socket.Connect("bbs.newsmth.net", 23); //连接
				UserToken token = new UserToken();
				token.userID = "handler";
				SocketDataHandler<UserToken> handler = new SocketDataHandler<UserToken>(socket, token);
				handler.ReceiveDataBufferLength = 1;
				handler.ID = 0;
				handler.StartReceiveData();
				UserToken token2 = new UserToken();
				token2.userID = "proxy";
				SocketDataHandler<UserToken> proxyHandler = new SocketDataHandler<UserToken>(proxySocket, token2);
				proxyHandler.ReceiveDataBufferLength = 1;
				proxyHandler.ID = i++;
				proxyHandler.StartReceiveData();
				ProxyHandlersPair<UserToken> pair = new ProxyHandlersPair<UserToken>(handler, proxyHandler);
				pair.DataReceivedProxy += new ProxyHandlersPair<UserToken>.DataReceivedProxyEventHandler(pair_DataReceivedProxy);
			}
		}
		void pair_DataReceivedProxy(SocketDataHandler<UserToken> source, byte[] data, SocketDataHandler<UserToken> destination)
		{
			string s = Encoding.GetEncoding("gbk").GetString(data);
			Console.WriteLine("[source: {0}],[destination: {1}],[data: {2}],[length: {3}]", source.Token.userID, destination.Token.userID, s, data.Length);
			destination.SendDataAsyncQueue(data);
		}
	}
	public class UserToken
	{
		public string userID;
	}
}
namespace Microshaoft
{
	using System;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	public class ProxyHandlersPair<T>
	{
		private SocketDataHandler<T> _proxyHandler;
		public SocketDataHandler<T> ProxyHandler
		{
			get
			{
				return _proxyHandler;
			}
		}
		private SocketDataHandler<T> _handler;
		public SocketDataHandler<T> Handler
		{
			get
			{
				return _handler;
			}
		}
		public delegate void DataReceivedProxyEventHandler
										(
											SocketDataHandler<T> source
											, byte[] data
											, SocketDataHandler<T> destination
										);
		public event DataReceivedProxyEventHandler DataReceivedProxy;
		public ProxyHandlersPair(SocketDataHandler<T> proxy, SocketDataHandler<T> handler)
		{
			_proxyHandler = proxy;
			_handler = handler;
			_handler.DataReceivedAsync += new SocketDataHandler<T>.DataReceivedEventHandler(handler_DataReceivedAsyncProcess);
			_proxyHandler.DataReceivedAsync += new SocketDataHandler<T>.DataReceivedEventHandler(proxyHandler_DataReceivedAsyncProcess);
		}
		public void proxyHandler_DataReceivedAsyncProcess(SocketDataHandler<T> sender, byte[] data)
		{
			if (DataReceivedProxy != null)
			{
				DataReceivedProxy(sender, data, _handler);
			}
		}
		public void handler_DataReceivedAsyncProcess(SocketDataHandler<T> sender, byte[] data)
		{
			if (DataReceivedProxy != null)
			{
				DataReceivedProxy(sender, data, _proxyHandler);
			}
		}
	}
	public class SocketDataHandler<T>
	{
		private AsyncQueue<byte[]> _sendQueue;
		private AsyncQueue<byte[]> _receiveQueue;
		private T _token;
		public T Token
		{
			get
			{
				return _token;
			}
		}
		public SocketDataHandler(Socket socket, T token)
		{
			_sendQueue = new AsyncQueue<byte[]>();
			_sendQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(SendQueue_OnDequeue);
			//_sendQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_sendQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_sendQueue.MaxConcurrentThreadsCount = 1;
			_receiveQueue = new AsyncQueue<byte[]>();
			_receiveQueue.OnDequeue += new AsyncQueue<byte[]>.QueueEventHandler(ReceiveQueue_OnDequeue);
			//_receiveQueue.OnQueueLog += new AsyncQueue<byte[]>.QueueLogEventHandler(Queue_OnQueueLog);
			_receiveQueue.OnException += new AsyncQueue<byte[]>.ExceptionEventHandler(Queue_OnException);
			_socket = socket;
			_token = token;
		}
		void Queue_OnException(Exception e)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(e.Message);
			Console.ResetColor();
		}
		void Queue_OnQueueLog(string logMessage)
		{
//			Console.WriteLine(logMessage);
		}
		void SendQueue_OnDequeue(byte[] element)
		{
			_socket.Send(element);
		}
		void ReceiveQueue_OnDequeue(byte[] element)
		{
			if (DataReceivedAsync != null)
			{
				DataReceivedAsync(this, element);
			}
		}
		public enum ExceptionHandleAction : int
		{
			Ignore
			,
			ReThrow
			,
			Abort
		}
		private Thread _thread;
		private Socket _socket;
		private int _id;
		public int ID
		{
			set
			{
				_id = value;
			}
			get
			{
				return _id;
			}
		}
		private int _receiveDataReceiveDataBufferLength = 1024;
		public int ReceiveDataBufferLength
		{
			set
			{
				_receiveDataReceiveDataBufferLength = value;
			}
		}
		public void SendDataAsyncQueue(byte[] data)
		{
			_sendQueue.Enqueue(data);
		}
		public void SendData(byte[] data)
		{
			_socket.Send(data);
		}
		public delegate void DataReceivedEventHandler
												(
													SocketDataHandler<T> sender
													, byte[] data
												);
		public event DataReceivedEventHandler DataReceived;
		public event DataReceivedEventHandler DataReceivedAsync;
		public delegate void ExceptionOccursEventHandler
												(
													SocketDataHandler<T> sender
													, Exception exception
													, ExceptionHandleAction action
												);
		public ExceptionOccursEventHandler ExceptionOccurs;
		public void StartReceiveData()
		{
			ThreadStart ts = new ThreadStart(RecieveDataThreadProcess);
			_thread = new Thread(ts);
			_thread.Start();
		}
		private void RecieveDataThreadProcess()
		{
			while (true)
			{
				byte[] buffer = null;
				try
				{
					buffer = SocketDataHelper.ReadDataToBytes(_receiveDataReceiveDataBufferLength, _socket);
				}
				catch (Exception e)
				{
					if (ExceptionOccurs != null)
					{
						ExceptionHandleAction a = ExceptionHandleAction.Ignore;
						ExceptionOccurs(this, e, a);
						if (a == ExceptionHandleAction.ReThrow)
						{
							throw;
						}
						else if (a == ExceptionHandleAction.Abort)
						{
							break;
						}
					}
				}
				if (buffer != null)
				{
					if (buffer.Length > 0)
					{
						_receiveQueue.Enqueue(buffer);
						if (DataReceived != null)
						{
							DataReceived(this, buffer);
						}
					}
				}
				Thread.Sleep(100);
			}
		}
	}
	public static class SocketDataHelper
	{
		public static void ReadDataToFixedLengthBytes
								(
									Socket socket,
									ref byte[] buffer
								)
		{
			int p = 0;
			int l = buffer.Length;
			while (p < l)
			{
				int r = socket.Receive
									(
										buffer
										, p
										, l - p
										, SocketFlags.None
									);
				p += r;
			}
		}
		public static byte[] ReadDataToFixedLengthBytes
									(
										int length,
										Socket socket
									)
		{
			int p = 0;
			byte[] data = new byte[length];
			while (p < length)
			{
				int r = socket.Receive
									(
										data
										, p
										, length - p
										, SocketFlags.None
									);
				p += r;
			}
			return data;
		}
		public static byte[] ReadDataToBytes
									(
										int length,
										Socket socket
									)
		{
			byte[] data = new byte[length];
			int r = 0;
			//SocketError error;
			r = socket.Receive
								(
									data
									, 0
									, length
									, SocketFlags.None
									//, out error
								);
			//if (error != SocketError.Success)
			//{
			//	Console.WriteLine("socket error: {0}", Enum.GetName(typeof(SocketError), error));
			//	Thread.Sleep(100);
			//}
			if (r > 0)
			{
				Array.Resize<byte>(ref data, r);
			}
			else
			{
				data = null;
			}
			return data;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Collections.Generic;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		public event QueueLogEventHandler OnQueueLog;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
		private Queue<T> _queue = new Queue<T>();
		private static object _SyncLockObject = new object();
		private int _concurrentThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private volatile bool _queueRuning = false;
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
///		private long _EnqueueCount = 0; //入列计数器
///		public long EnqueueCount
///		{
///			get
///			{
///				return _EnqueueCount;
///			}
///		}
///		private long _DequeueCount = 0; //出列计数器
///		public long DequeueCount
///		{
///			get
///			{
///				return _DequeueCount;
///			}
///		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (!_queueRuning)
			{
				_queueRuning = true;
				lock (_SyncLockObject)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public int ConcurrentThreadsCount
		{
			get
			{
				return _concurrentThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
									, "Queue Runing Start ..."
									, _concurrentThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
								)
					);
			}
			while (_queue.Count > 0) //Microshaoft 死循环
			{
				T element = null;
				int threadID = -1;
				lock (_SyncLockObject)
				{
					if (_concurrentThreadsCount < _maxConcurrentThreadsCount)
					{
						if (_queue.Count > 0)
						{
							Interlocked.Increment(ref _concurrentThreadsCount);
							threadID = _concurrentThreadsCount;
							if (_concurrentThreadsCount >= _maxConcurrentThreadsCount)
							{
								if (OnQueueLog != null)
								{
									OnQueueLog
										(
											string.Format
													(
														"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
														, "Threads is Full!"
														, _concurrentThreadsCount
														, _queue.Count
														, Thread.CurrentThread.Name
													)
										);
								}
							}
							if (OnQueueLog != null)
							{
								OnQueueLog
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
													, "Threads ++ !"
													, _concurrentThreadsCount
													, _queue.Count
													, Thread.CurrentThread.Name
												)
									);
							}
							element = _queue.Dequeue();
						}
					}
				}
				if (element != null)
				{
					//Microshaoft ThreadPool.QueueUserWorkelement(new WaitCallback(OnDequeueThreadProcess), element);
					ThreadProcessState tps = new ThreadProcessState();
					tps.element = element;
					tps.Sender = this;
					Thread t = new Thread(new ThreadStart(tps.ThreadProcess));
					t.Name = string.Format("ConcurrentThread[{0}]", threadID);
					t.Start();
				}
			}
			_queueRuning = false;
			if (OnQueueLog != null)
			{
				OnQueueLog
					(
						string.Format
							(
								"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
								, "Queue Runing Stopped!"
								, _concurrentThreadsCount
								, _queue.Count
								, Thread.CurrentThread.Name
							)
					);
			}
		}
		public void Enqueue(T element)
		{
			try
			{
				lock (_SyncLockObject) //还算并发吗?
				{
					_queue.Enqueue(element);
				}
				//Interlocked.Increment(ref _EnqueueCount);
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			if (!_queueRuning)
			{
				QueueRun();
			}
		}
		private void OnDequeueThreadProcess(T element)
		{
			try
			{
				if (OnDequeue != null)
				{
					OnDequeue(element);
				}
				//Interlocked.Increment(ref _DequeueCount);
				DequeueProcess();
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				Interlocked.Decrement(ref _concurrentThreadsCount);
				if (_concurrentThreadsCount == 0)
				{
					if (OnQueueLog != null)
					{
						OnQueueLog
							(
								string.Format
										(
											"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
											, "All Threads Finished!"
											, _concurrentThreadsCount
											, _queue.Count
											, Thread.CurrentThread.Name
										)
							);
					}
				}
				if (OnQueueLog != null)
				{
					OnQueueLog
						(
							string.Format
									(
										"{0} Threads Count {1},Queue Count {2},Current Thread: {3}"
										, "Threads -- !"
										, _concurrentThreadsCount
										, _queue.Count
										, Thread.CurrentThread.Name
									)
						);
				}
			}
		}
		private void DequeueProcess()
		{
			while (_queue.Count > 0)
			{
				T element = null;
				lock (_SyncLockObject)
				{
					if (_queue.Count > 0)
					{
						element = _queue.Dequeue();
					}
				}
				if (element != null)
				{
					if (OnDequeue != null)
					{
						OnDequeue(element);
					}
					//Interlocked.Increment(ref _DequeueCount);
				}
			}
		}
		private class ThreadProcessState
		{
			private AsyncQueue<T> _sender;
			public AsyncQueue<T> Sender
			{
				get
				{
					return _sender;
				}
				set
				{
					_sender = value;
				}
			}
			private T _element;
			public T element
			{
				get
				{
					return _element;
				}
				set
				{
					_element = value;
				}
			}
			public void ThreadProcess()
			{
				_sender.OnDequeueThreadProcess(_element);
			}
		}
	}
}
#T=Thread
		System.Threading.Thread x = new System.Threading.Thread(new System.Threading.ThreadStart(DoWait)).Start(); //监视线程: 显示滚动计数器
		//以下是耗时的主程序
		System.Threading.Thread.Sleep(5 * 1000); //主程序耗时 5 秒

ThreadPool.QueueUserWorkItem(new WaitCallback(ThreadProc));
#T=Thread.Join IsThreadPoolThread
namespace Microshaoft
{
	using System;
	using System.Threading;
	class IsThreadPool
	{
		static void Main()
		{
			Test1();
			Test2();
		}
		static void Test1()
		{
			AutoResetEvent autoResetEvent = new AutoResetEvent(false);
			Thread regularThread = new Thread
											(
												new ThreadStart
													(
														() =>
														{
															Thread.Sleep(2 * 1000);
															Console.WriteLine
																	(
																		"ThreadOne, executing ThreadMethod, " +
																		"is {0}from the thread pool."
																		, Thread.CurrentThread.IsThreadPoolThread ? "" : "not "
																	);
														}
													)
											);
			regularThread.Start();
			ThreadPool.QueueUserWorkItem
							(
								new WaitCallback
									(
										(x) =>
										{
											Thread.Sleep(3 * 1000);
											Console.WriteLine("ThreadTwo, executing WorkMethod, " +
												"is {0}from the thread pool.",
												Thread.CurrentThread.IsThreadPoolThread ? "" : "not ");
											// Signal that this thread is finished.
											autoResetEvent.Set();
										}
									)
							);
			// Wait for background thread to end.
			autoResetEvent.WaitOne();
			Console.WriteLine("autoEvent.WaitOne(); ok");
			// Wait for foreground thread to end.
			regularThread.Join();
			Console.WriteLine("regularThread.Join(); ok");
			Console.ReadLine();
		}
		static void Test2()
		{
			AutoResetEvent autoEvent = new AutoResetEvent(false);
			Thread regularThread = 
				new Thread(new ThreadStart(ThreadMethod));
			regularThread.Start();
			ThreadPool.QueueUserWorkItem(new WaitCallback(WorkMethod), 
				autoEvent);
			// Wait for background thread to end.
			autoEvent.WaitOne();
			Console.WriteLine("autoEvent.WaitOne(); ok");
			// Wait for foreground thread to end.
			regularThread.Join();
			Console.WriteLine("regularThread.Join(); ok");
		}
		static void ThreadMethod()
		{
			
			Thread.Sleep(2*1000);
			Console.WriteLine
					(
						"ThreadOne, executing ThreadMethod, " +
						"is {0}from the thread pool."
						, Thread.CurrentThread.IsThreadPoolThread ? "" : "not "
					);
		}
		static void WorkMethod(object stateInfo)
		{
			Thread.Sleep(3*1000);
			Console.WriteLine("ThreadTwo, executing WorkMethod, " +
				"is {0}from the thread pool.", 
				Thread.CurrentThread.IsThreadPoolThread ? "" : "not ");
			// Signal that this thread is finished.
			((AutoResetEvent)stateInfo).Set();
		}
	}
}
#T=Thread.Join/Abort
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Threading;

	public class JoiningThread
	{
		static void Main()
		{
			Test1();
			Test2();
		}
		static Thread SecondThread;
		static Thread FirstThread;

		static void First()
		{
			for (int i = 1; i <= 250; i++)
			{
				Console.Write(i + " ");
			}
		}

		static void Second()
		{
			FirstThread.Join();
			for (int i = 251; i <= 500; i++)
			{
				Console.Write(i + " ");
			}
		}

		public static void Test1()
		{
			var i = 0;
			var thread1 = new Thread
								(
									new ThreadStart
												(
													() =>
													{
														for (; i <= 10; i++)
														{
															Console.WriteLine
																		(
																			"{0} @ Thread: {1} "
																			, i
																			, Thread.CurrentThread.ManagedThreadId
																		);
														}
														//Thread.CurrentThread.Abort();
													}
												)
								);
			thread1.Start();
			new Thread
					(
						new ThreadStart
									(
										() =>
										{
											thread1.Join();
											for (; i <= 20; i++)
											{
												Console.WriteLine
															(
																"{0} @ Thread: {1} "
																, i
																, Thread.CurrentThread.ManagedThreadId
															);
											}
										}
									)
					).Start();
			Console.ReadLine();
		}
		public static void Test2()
		{
			FirstThread = new Thread(new ThreadStart(First));
			SecondThread = new Thread(new ThreadStart(Second));

			FirstThread.Start();
			SecondThread.Start();

			Console.ReadLine();
		}
	}
}
#T=Threading Monitor
namespace CSThreadingMonitor
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Threading;
	class Program
	{
		static void Main(string[] args)
		{
			// Result initialized to say there is no error
			int result = 0;   
			Cell cell = new Cell();

			CellProd prod = new CellProd(cell, 20);  // Use cell for storage, 
			// produce 20 items
			CellCons cons = new CellCons(cell, 20);  // Use cell for storage, 
			// consume 20 items

			Thread producer = new Thread(new ThreadStart(prod.ThreadRun));
			Thread consumer = new Thread(new ThreadStart(cons.ThreadRun));
			// Threads producer and consumer have been created, 
			// but not started at this point.

			try
			{
				producer.Start();
				consumer.Start();

				producer.Join();
				// Run both until done.
				consumer.Join();
				// threads producer and consumer have finished at this point.
			}
			catch (ThreadStateException e)
			{
				Console.WriteLine(e);  // Display text of exception
				result = 1;			// Result says there was an error
			}
			catch (ThreadInterruptedException e)
			{
				Console.WriteLine(e);  
				// This exception means that the thread
				// was interrupted during a Wait
				result = 1;			
				// Result says there was an error
			}
			// Even though Main returns void, this provides a return code to 
			// the parent process.
			Environment.ExitCode = result;

		}
	}

	public class CellProd
	{
		Cell cell;		 // Field to hold cell object to be used
		int quantity = 1;  // Field for how many items to produce in cell

		public CellProd(Cell box, int request)
		{
			cell = box;		  // Pass in what cell object to be used
			quantity = request;  // Pass in how many items to produce in cell
		}
		public void ThreadRun()
		{
			for (int looper = 1; looper <= quantity; looper++)
				cell.WriteToCell(looper);  // "producing"
		}
	}

	public class CellCons
	{
		Cell cell;		 // Field to hold cell object to be used
		int quantity = 1;  // Field for how many items to consume from cell

		public CellCons(Cell box, int request)
		{
			cell = box;		  // Pass in what cell object to be used
			quantity = request;  // Pass in how many items to consume from cell
		}
		public void ThreadRun()
		{
			int valReturned;
			for (int looper = 1; looper <= quantity; looper++)
				// Consume the result by placing it in valReturned.
				valReturned = cell.ReadFromCell();
		}
	}

	public class Cell
	{
		int cellContents;		 // Cell contents
		bool readerFlag = false;  // State flag
		public int ReadFromCell()
		{
			lock (this)   // Enter synchronization block
			{
				if (!readerFlag)
				{			// Wait until Cell.WriteToCell is done producing
					try
					{
						// Waits for the Monitor.Pulse in WriteToCell
						Monitor.Wait(this);
					}
					catch (SynchronizationLockException e)
					{
						Console.WriteLine(e);
					}
					catch (ThreadInterruptedException e)
					{
						Console.WriteLine(e);
					}
				}
				Console.WriteLine("Consume: {0}", cellContents);
				readerFlag = false;	// Reset the state flag to say consuming
				// is done.
				Monitor.Pulse(this);   // Pulse tells Cell.WriteToCell that
				// Cell.ReadFromCell is done.
			}   // Exit synchronization block
			return cellContents;
		}

		public void WriteToCell(int n)
		{
			lock (this)  // Enter synchronization block
			{
				if (readerFlag)
				{	  // Wait until Cell.ReadFromCell is done consuming.
					try
					{
						Monitor.Wait(this);   // Wait for the Monitor.Pulse in
						// ReadFromCell
					}
					catch (SynchronizationLockException e)
					{
						Console.WriteLine(e);
					}
					catch (ThreadInterruptedException e)
					{
						Console.WriteLine(e);
					}
				}
				cellContents = n;
				Console.WriteLine("Produce: {0}", cellContents);
				readerFlag = true;	// Reset the state flag to say producing
				// is done
				Monitor.Pulse(this);  // Pulse tells Cell.ReadFromCell that 
				// Cell.WriteToCell is done.
			}   // Exit synchronization block
		}
	}
}

#T=ThreadLocal
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	class ThreadLocalDemo
	{
		// Demonstrates:
		//	  ThreadLocal(T) constructor
		//	  ThreadLocal(T).Value
		//	  One usage of ThreadLocal(T)
		static void Main()
		{
			// Thread-Local variable that yields a name for a thread
			ThreadLocal<string> ThreadName = new ThreadLocal<string>
				(
					() =>
					{
						return "Thread" + Thread.CurrentThread.ManagedThreadId;
					}
				);
			// Action that prints out ThreadName for the current thread
			Action action = 
				() =>
				{
					// If ThreadName.IsValueCreated is true, it means that we are not the
					// first action to run on this thread.
					bool repeat = ThreadName.IsValueCreated;
					Console.WriteLine("ThreadName = {0} {1}", ThreadName.Value, repeat ? "(repeat)" : "");
				};
			// Launch eight of them.  On 4 cores or less, you should see some repeat ThreadNames
			Parallel.Invoke
						(
							action
							, action
							, action
							, action
							, action
							, action
							, action
							, action
							, action
							, action
							, action
							, action
							, action
							, action
							, action
						);
			// Dispose when you are done
			ThreadName.Dispose();
		}
	}
}
#T=throw Exception StackTraceHelper
namespace WebApplication1
{
	using System;
	using System.Diagnostics;
	//using System.Web.UI;
	using Microshaoft;
	/// <summary>
	/// WebForm1 的摘要说明。
	/// </summary>
	public class ThrowPage //: Page
	{
		static void Main(string[] args)
		{
			Trace.Assert(1 != 1);
			TryCatchFinallyProcessHelper
				.TryProcessCatchFinally
					(
						true
						, () =>
						{
							Test(null);
						}
						, false
						, (x) =>
						{
							Console.WriteLine("TryProcessCatchFinally");
							//PrintException(x);
							PrintException(x);
							return false;
						}
						, null
					);
			Console.ReadLine();

		}
		static void Test(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			try
			{
				int i = 0;
				//throw;
				throw new Exception("aaa");
				///				i = 3 / i;
				///				i = int.Parse("aaa");

				ThrowPage x = new ThrowPage();
				x.Page_Load(null, null);
			}
			catch (Exception e)
			{
				Console.WriteLine("Catch");
				PrintException(e);
				Console.WriteLine(StackTraceHelper.EnhancedStackTrace(e));
				///Console.WriteLine("throw: ...");
				//throw;
				///Console.WriteLine("throw e: ...");
				///throw e;
				Console.WriteLine("throw new e: ...");
				var ne = new Exception("rethrow ", e);
				PrintException(ne);
				throw ne;
			}
		}
		static void PrintException(Exception e)
		{
			ConsoleColor color = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine("print e.ToString:【{0}{1}】", "\n", e.ToString());
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine("print e.StackTrace:【{0}{1}】", "\n", e.StackTrace);
			Console.ForegroundColor = color;
		}
		private void Page_Load(object sender, System.EventArgs e)
		{
			int i = 0;
			//Response.Write((3/i).ToString() + "<br>");





			//i = int.Parse("aaa");
			Test();
		}
		void Test()
		{
			///			try
			///			{
			int i = int.Parse("aaa");
			int j = 0;
			//Console.WriteLine(3/j);
			//throw new Exception("test");

			///			}
			///			catch (Exception e)
			///			{
			///				PrintException(e);
			///				Console.WriteLine("throw: ...");
			///				throw;
			///			}

		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Text;
	using System.Reflection;
	class StackTraceHelper
	{
		public static string EnhancedStackTrace(Exception ex)
		{
			return EnhancedStackTrace(new StackTrace(ex, true));
		}
		public static string EnhancedStackTrace(StackTrace st)
		{
			StringBuilder sb = new StringBuilder();
			sb.Append(Environment.NewLine);
			sb.Append("---- Stack Trace ----");
			sb.Append(Environment.NewLine);

			for (int i = 0; i < st.FrameCount; i++)
			{
				StackFrame sf = st.GetFrame(i);
				MemberInfo mi = sf.GetMethod();
				sb.Append(StackFrameToString(sf));
			}
			sb.Append(Environment.NewLine);

			return sb.ToString();
		}
		public static string StackFrameToString(StackFrame sf)
		{
			StringBuilder sb = new StringBuilder();
			int intParam; MemberInfo mi = sf.GetMethod();
			sb.Append("   ");
			sb.Append(mi.DeclaringType.Namespace);
			sb.Append(".");
			sb.Append(mi.DeclaringType.Name);
			sb.Append(".");
			sb.Append(mi.Name);
			// -- build method params		   
			sb.Append("(");
			intParam = 0;
			foreach (ParameterInfo param in sf.GetMethod().GetParameters())
			{
				intParam += 1;
				sb.Append(param.Name);
				sb.Append(" As ");
				sb.Append(param.ParameterType.Name);
			}
			sb.Append(")");
			sb.Append(Environment.NewLine);
			// -- if source code is available, append location info		   
			sb.Append("	   ");
			if (string.IsNullOrEmpty(sf.GetFileName()))
			{
				sb.Append("(unknown file)");
				//-- native code offset is always available			   
				sb.Append(": N ");
				sb.Append(String.Format("{0:#00000}", sf.GetNativeOffset()));
			}
			else
			{
				sb.Append(System.IO.Path.GetFileName(sf.GetFileName()));
				sb.Append(": line ");
				sb.Append(String.Format("{0:#0000}", sf.GetFileLineNumber()));
				sb.Append(", col ");
				sb.Append(String.Format("{0:#00}", sf.GetFileColumnNumber()));
				if (sf.GetILOffset() != StackFrame.OFFSET_UNKNOWN)
				{
					sb.Append(", IL ");
					sb.Append(String.Format("{0:#0000}", sf.GetILOffset()));
				}
			}
			sb.Append(Environment.NewLine);
			return sb.ToString();
		}
	}

}


namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Reflection;
	using System.Threading.Tasks;
	public static class TryCatchFinallyProcessHelper
	{
		public static async Task<T> TryProcessCatchFinallyAsync<T>
									(
										bool needTry
										, Func<Task<T>> onTryProcessFunc
										, bool reThrowException = false
										, Func<Exception, bool> onCaughtExceptionProcessFunc = null
										, Action<bool, Exception> onFinallyProcessAction = null
									)
		{
			T r = default(T);
			//if (onTryProcessAction != null)
			{
				if (needTry)
				{
					Exception exception = null;
					var caughtException = false;
					try
					{
						r = await onTryProcessFunc();
						return r;
					}
					catch (Exception e)
					{
						caughtException = true;
						exception = e;
						var currentCalleeMethod = MethodInfo.GetCurrentMethod();
						var currentCalleeType = currentCalleeMethod.DeclaringType;
						StackTrace stackTrace = new StackTrace();
						StackFrame stackFrame = stackTrace.GetFrame(1);
						var callerMethod = stackFrame.GetMethod();
						var callerType = callerMethod.DeclaringType;
						var frame = (stackTrace.FrameCount > 1 ? stackTrace.FrameCount - 1 : 1);
						stackFrame = stackTrace.GetFrame(frame);
						var originalCallerMethod = stackFrame.GetMethod();
						var originalCallerType = originalCallerMethod.DeclaringType;
						var innerExceptionMessage = string.Format
								(
									"Rethrow caught [{1}] Exception{0} at Callee Method: [{2}]{0} at Caller Method: [{3}]{0} at Original Caller Method: [{4}]"
									, "\r\n\t"
									, e.Message
									, string.Format("{1}{0}{2}", "::", currentCalleeType, currentCalleeMethod)
									, string.Format("{1}{0}{2}", "::", callerType, callerMethod)
									, string.Format("{1}{0}{2}", "::", originalCallerType, originalCallerMethod)
								);
						Console.WriteLine(innerExceptionMessage);
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrowException = onCaughtExceptionProcessFunc(e);
						}
						if (reThrowException)
						{
							throw
								new Exception
										(
											innerExceptionMessage
											, e
										);
						}
						return r;
					}
					finally
					{
						if (onFinallyProcessAction != null)
						{
							onFinallyProcessAction(caughtException, exception);
						}
					}
				}
				else
				{
					return await onTryProcessFunc();
				}
			}
		}
		public static void TryProcessCatchFinally
									(
										bool needTry
										, Action onTryProcessAction
										, bool reThrowException = false
										, Func<Exception, bool> onCaughtExceptionProcessFunc = null
										, Action<bool, Exception> onFinallyProcessAction = null
									)
		{
			if (onTryProcessAction != null)
			{
				if (needTry)
				{
					Exception exception = null;
					var caughtException = false;
					try
					{
						onTryProcessAction();
					}
					catch (Exception e)
					{
						caughtException = true;
						exception = e;
						var currentCalleeMethod = MethodInfo.GetCurrentMethod();
						var currentCalleeType = currentCalleeMethod.DeclaringType;
						StackTrace stackTrace = new StackTrace(e, true);
						StackFrame stackFrame = stackTrace.GetFrame(1);
						var callerMethod = stackFrame.GetMethod();
						var callerType = callerMethod.DeclaringType;
						var frame = (stackTrace.FrameCount > 1 ? stackTrace.FrameCount - 1 : 1);
						stackFrame = stackTrace.GetFrame(frame);
						var originalCallerMethod = stackFrame.GetMethod();
						var originalCallerType = originalCallerMethod.DeclaringType;
						var innerExceptionMessage = string.Format
								(
									"Rethrow caught [{1}] Exception{0} at Callee Method: [{2}]{0} at Caller Method: [{3}]{0} at Original Caller Method: [{4}]"
									, "\r\n\t"
									, e.Message
									, string.Format("{1}{0}{2}", "::", currentCalleeType, currentCalleeMethod)
									, string.Format("{1}{0}{2}", "::", callerType, callerMethod)
									, string.Format("{1}{0}{2}", "::", originalCallerType, originalCallerMethod)
								);
						//Console.WriteLine(innerExceptionMessage);
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrowException = onCaughtExceptionProcessFunc(e);
						}
						if (reThrowException)
						{
							throw
								new Exception
										(
											innerExceptionMessage
											, e
										);
						}
					}
					finally
					{
						//Console.WriteLine("Finally");
						if (onFinallyProcessAction != null)
						{
							onFinallyProcessAction(caughtException, exception);
						}
					}
				}
				else
				{
					onTryProcessAction();
				}
			}
		}
	}
}

#T=Tokens String Spliter
//Copyright (C) Microsoft Corporation.  All rights reserved.
// tokens2.cs
using System;
using System.Collections;
public class Tokens: IEnumerable
{
	private string[] elements;
	Tokens(string source, char[] delimiters)
	{
		elements = source.Split(delimiters);
	}
	// IEnumerable Interface Implementation:
	public TokenEnumerator GetEnumerator() // non-IEnumerable version
	{
		return new TokenEnumerator(this);
	}
	IEnumerator IEnumerable.GetEnumerator() // IEnumerable version
	{
		return (IEnumerator) new TokenEnumerator(this);
	}
	// Inner class implements IEnumerator interface:
	public class TokenEnumerator: IEnumerator
	{
		private int position = -1;
		private Tokens t;
		public TokenEnumerator(Tokens t)
		{
			this.t = t;
		}
		public bool MoveNext()
		{
			if (position < t.elements.Length - 1)
			{
			position++;
			return true;
			}
			else
			{
			return false;
			}
		}
		public void Reset()
		{
			position = -1;
		}
		public string Current // non-IEnumerator version: type-safe
		{
			get
			{
			return t.elements[position];
			}
		}
		object IEnumerator.Current // IEnumerator version: returns object
		{
			get
			{
			return t.elements[position];
			}
		}
	}
	// Test Tokens, TokenEnumerator
	static void Main()
	{
		Tokens f = new Tokens("This is a well-done program.", 
			new char [] {' ','-'});
		foreach (string item in f) // try changing string to int
		{
			Console.WriteLine(item);
		}
	}
}

#T=Tree 级联勾选  ASP.NET
<%@ Page Language="C#"%>

<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
  <title></title>
  <script type="text/javascript">
    var nextInput = null;
    var nextID = null;
    var preInput = null;
    var preID = null;
    var uncheckParent = false;
    var pId;

    function checkIt(o) {
      preInput = nextInput = o.checked;
      nextID = o.id;
      preID = o.getAttribute("parentId");
      uncheckParent = false;
      checkStart(o)
    }

    function checkStart(o) {
      checkChild(o)
      checkParent(o)
    }

    function checkChild(o) {
      obj = o;
      if (obj.nodeType == 1 && obj.tagName == "INPUT" && obj.type == "checkbox") {
        if (obj.getAttribute("id").substr(0, nextID.length) == nextID)
          obj.checked = nextInput        
      }
      obj = obj.nextSibling;
      if (obj == null) return;
      checkChild(obj);
    }

    function checkParent(o) {
      pId = o.getAttribute("parentId");
      obj = o.previousSibling;
      while (obj && obj.nodeType != 1 && obj.tagName != "INPUT" && obj.type != "checkbox") {
        obj = obj.previousSibling;
        if (obj == null) return;
      }
      if (obj == null) return;
      if (obj.getAttribute("id") == preID) {          
        preID = obj.getAttribute("parentId");
        obj.checked = preInput
        if (uncheckParent) obj.checked = false;

      }
      //判断是否要取消父节点选择
      chs = document.getElementById("tree").getElementsByTagName("INPUT");
      for (i = 0; i < chs.length; i++) {
        if (chs[i].getAttribute("parentId") == pId) {
          if (chs[i].checked == false) {
            uncheckParent = true;
            break;
          }
        }
      }
      checkParent(obj);
    }
  </script>
</head>
<body>
  <form id="form1" runat="server">
  <div id="tree">
  <input type="checkbox" id="1" onclick="checkIt(this)" parentId="0" />1<br />
  &nbsp;&nbsp;<input type="checkbox" id="11" onclick="checkIt(this)" parentId="1" />11<br />
  &nbsp;&nbsp;<input type="checkbox" id="12" onclick="checkIt(this)" parentId="1" />12<br />
  &nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" id="121" onclick="checkIt(this)" parentId="12" />121<br />
  &nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" id="122" onclick="checkIt(this)" parentId="12" />122<br />
  &nbsp;&nbsp;<input type="checkbox" id="13" onclick="checkIt(this)" parentId="1" />13<br />
  &nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" id="131" onclick="checkIt(this)" parentId="13" />131<br />
  &nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" id="132" onclick="checkIt(this)" parentId="13" />132<br />
  <input type="checkbox" id="2" onclick="checkIt(this)" parentId="0" />2<br />
  &nbsp;&nbsp;<input type="checkbox" id="21" onclick="checkIt(this)" parentId="2" />21<br />
  <input type="checkbox" id="3" onclick="checkIt(this)" parentId="0" />3<br />
  </div>
  </form>
</body>
</html>

#T=TreeViewEx
// playyuer@Microshaoft.com invent
//一个 TreeView 的派生类: TreeViewEx 实现 NodeShowToolTip、NodeDoubleClick 事件
//1.实现了 NodeShowToolTip 事件,结合键盘 Ctrl 键显示及设置 ToolTipText
//2.实现了 NodeDoubleClick 事件,可在调用中只响应"叶子"节点
//3.点击 TreeView 空白处不选中任何节点
//Class1.cs
namespace WindowsApplication1
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using Microshaoft;
	public class Form1 : Form
	{
		private Button button1;
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private Container components = null;
		public Form1()
		{
			//
			// Windows 窗体设计器支持所必需的
			//
			InitializeComponent();
			//
			// TODO: 在 InitializeComponent 调用后添加任何构造函数代码
			//
		}
		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if (disposing)
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}
		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要使用代码编辑器修改
		/// 此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new Button();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new Point(96, 112);
			this.button1.Name = "button1";
			this.button1.Size = new Size(88, 32);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.Click += new EventHandler(this.button1_Click);
			// 
			// Form1
			// 
			this.AutoScaleBaseSize = new Size(6, 14);
			this.ClientSize = new Size(292, 273);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new EventHandler(this.Form1_Load);
			this.ResumeLayout(false);
		}
		#endregion
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new Form1());
		}
		private TreeViewEx treeViewEx1;
		private void Form1_Load(object sender, EventArgs e)
		{
			treeViewEx1 = new TreeViewEx();
			this.Controls.Add(treeViewEx1);
			treeViewEx1.HideSelection=false;
			treeViewEx1.NodeDoubleClick +=new TreeViewExEventHandler(treeViewEx1_NodeDoubleClick);
			treeViewEx1.NodeShowToolTip += new TreeViewExEventHandler(this.treeViewEx1_NodeShowToolTip);
			treeViewEx1.Nodes.AddRange
								(
									new TreeNode[]
											{
												new TreeNode
														(
															"Root"
															, new TreeNode[]
																	{
																		new TreeNode("a")
																		, new TreeNode("b")
																	}
														)
												, new TreeNode
														(
															"Root1"
															, new TreeNode[]
															{
																new TreeNode("a1")
																, new TreeNode("b1")
															}
														)
											}
								);
		}
		public void treeViewEx1_NodeShowToolTip (object sender,TreeViewExEventArgs e)
		{
			e.NodeToolTip.SetToolTip (this.treeViewEx1,"[" + e.Node.Text + "]{" );
		}
		private void treeViewEx1_NodeDoubleClick(object sender, TreeViewExEventArgs e)
		{
			if (e.SelectedNode.GetNodeCount(true)==0)
			{
				MessageBox.Show(e.SelectedNode.Text);
			}
		}
		private void button1_Click(object sender, EventArgs e)
		{
		
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	public class TreeViewEx : TreeView
	{
		public event TreeViewExEventHandler NodeDoubleClick;
		public event TreeViewExEventHandler NodeShowToolTip;
		private void OnNodeDoubleClick(TreeNode xx)
		{
			if (NodeDoubleClick != null)
			{
				NodeDoubleClick(this,new TreeViewExEventArgs(xx));
			}
		}
		private void OnNodeShowToolTip(TreeNode xx, ToolTip yy)
		{
			if (NodeShowToolTip != null)
			{
				if ((xx != null) && (toolTip !=null))
				{
					NodeShowToolTip(this,new TreeViewExEventArgs(xx,toolTip));
				}
			}
		}
		protected override void OnDoubleClick(EventArgs e)
		{
			if (SelectedNode != null)
				OnNodeDoubleClick(SelectedNode);
			base.OnDoubleClick(e);
		}
		private ToolTip toolTip;
		public TreeViewEx()
		{
			toolTip = new ToolTip();
			toolTip.InitialDelay = 300;
			toolTip.ReshowDelay = 0;
		}
		protected override void OnClick (EventArgs e)
		{
			if (GetNodeAt(TreeView.MousePosition.X,TreeView.MousePosition.Y) == null)
			{
				SelectedNode = null;
			}
			base.OnClick(e);
		}
		protected override void OnMouseDown (MouseEventArgs e)
		{
			if (GetNodeAt(e.X,e.Y) == null)
			{
				SelectedNode = null;
			}
			base.OnMouseDown(e);
		}
		private TreeNode LastTreeNode;
		protected override void OnMouseMove (MouseEventArgs e)
		{
			Cursor = Cursors.Default ;
			TreeNode treeNode;
			treeNode = GetNodeAt(e.X,e.Y) ;
			if (treeNode != null)
			{
				if( (Control.ModifierKeys & Keys.Control) != 0)
				{
					Cursor = Cursors.Hand ;
					if(treeNode != LastTreeNode | LastTreeNode ==null )
					{
						LastTreeNode = treeNode;
						toolTip.Active = false;
						OnNodeShowToolTip(treeNode,toolTip);
						toolTip.Active = true;
					}
				}
				else
				{
					Cursor = Cursors.Default ;
					toolTip.Active = false;
				}
			}
			else
			{
				Cursor = Cursors.Default ;
				toolTip.Active = false;
			}
			base.OnMouseMove(e);
		}
	}
	public delegate void TreeViewExEventHandler(object sender,TreeViewExEventArgs e);
	public class TreeViewExEventArgs : EventArgs
	{
		public TreeViewExEventArgs(TreeNode SelectedNode)
		{
			m_SelectedNode = SelectedNode;
		}
		public TreeViewExEventArgs(TreeNode Node,ToolTip NodeToolTip)
		{
			m_NodeToolTip = NodeToolTip;
			m_Node = Node;
		}
		public TreeViewExEventArgs(TreeNode Node,string ToolTipText)
		{
			m_ToolTipText = ToolTipText;
		}
		private string m_ToolTipText;
		private ToolTip m_NodeToolTip;
		private TreeNode m_SelectedNode;
		private TreeNode m_Node;
		public TreeNode SelectedNode
		{
			get
			{
				return m_SelectedNode;
			}
		}
		public string ToolTipText
		{
			get
			{
				return ToolTipText;
			}
			set
			{
				m_ToolTipText = value;
			}
		}
		public TreeNode Node
		{
			get
			{
				return m_Node;
			}
		}
		public ToolTip NodeToolTip
		{
			get
			{
				return m_NodeToolTip;
			}
		}
	}
	public class TreeNodeEx : TreeNode
	{
		public int GetLevel()
		{
			int i = 0;
			TreeNode xx =Parent;
			while ((xx = xx.Parent) != null)
			{
				i++;
			}
			return i;
		}
	}
}
#T=TryCatchFinallyProcessHelper/using
namespace Test
{
	using Microshaoft;
	using System;
	using System.Threading.Tasks;
	class Program
	{
		static void Main(string[] args)
		{
			//string s = await Download("http://msdn.microsoft.com");
			using (var foo = new Foo())
			{
				try
				{
					throw new Exception();
					int i = 0;
					int r = GetNumber(3);
					//i /= i;
					//throw new DivideByZeroException();
				}
				catch (Exception e)
				{
					Console.WriteLine(e.ToString());
				}
				TryCatchFinallyProcessHelper.TryProcessCatchFinally
					(
						true
						//false
						, () =>
						{
							throw new Exception();
							int ii = 0;
							//int rr = GetNumber(3);
							ii /= ii;
							//throw new DivideByZeroException();
						}
						, false
						, (x) =>
						{
							Console.WriteLine(x.ToString());
							//throw new Exception("ReThrow Exception OnCaught", x);
							return true;
						}
						, (x, y) =>
						{
							if (x)
							{
								Console.WriteLine("=======================finally: " + x.ToString());
							}
						}
					);
			}
			Console.ReadLine();
		}
		static int GetNumber(int index)
		{
			int[] nums = { 300, 600, 900 };
			//if (index >= nums.Length)
			//{
			//	throw new IndexOutOfRangeException();
			//}
			int r = nums[index];
			return r;
		}
		public static async Task<string> DownloadAsync(string url)
		{
			return
				await
					TryCatchFinallyProcessHelper
						.TryProcessCatchFinallyAsync
							(
								true
								, async
									() =>
								{
									//var httpClient = new HttpClient();
									Task<string> task = null; //= httpClient.GetStringAsync(url);
									string s = await task;
									//int exampleInt = contents.Length; 
									return s;
								}
							);
		}
	}
}
namespace Microshaoft
{
	using System;
	class Foo : IDisposable
	{
		public void Dispose()
		{
			//Console.ReadLine();
			Console.WriteLine("Disposing");
			//throw new NotImplementedException();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Reflection;
	using System.Threading.Tasks;
	public static class TryCatchFinallyProcessHelper
	{
		public static async Task<T> TryProcessCatchFinallyAsync<T>
									(
										bool needTry
										, Func<Task<T>> onTryProcessFunc
										, bool reThrowException = false
										, Func<Exception, bool> onCaughtExceptionProcessFunc = null
										, Action<bool, Exception> onFinallyProcessAction = null
									)
		{
			T r = default(T);
			//if (onTryProcessAction != null)
			{
				if (needTry)
				{
					Exception exception = null;
					var caughtException = false;
					try
					{
						r = await onTryProcessFunc();
						return r;
					}
					catch (Exception e)
					{
						caughtException = true;
						exception = e;
						var currentCalleeMethod = MethodInfo.GetCurrentMethod();
						var currentCalleeType = currentCalleeMethod.DeclaringType;
						StackTrace stackTrace = new StackTrace();
						StackFrame stackFrame = stackTrace.GetFrame(1);
						var callerMethod = stackFrame.GetMethod();
						var callerType = callerMethod.DeclaringType;
						var frame = (stackTrace.FrameCount > 1 ? stackTrace.FrameCount - 1 : 1);
						stackFrame = stackTrace.GetFrame(frame);
						var originalCallerMethod = stackFrame.GetMethod();
						var originalCallerType = originalCallerMethod.DeclaringType;
						var innerExceptionMessage = string.Format
								(
									"Rethrow caught [{1}] Exception{0} at Callee Method: [{2}]{0} at Caller Method: [{3}]{0} at Original Caller Method: [{4}]"
									, "\r\n\t"
									, e.Message
									, string.Format("{1}{0}{2}", "::", currentCalleeType, currentCalleeMethod)
									, string.Format("{1}{0}{2}", "::", callerType, callerMethod)
									, string.Format("{1}{0}{2}", "::", originalCallerType, originalCallerMethod)
								);
						Console.WriteLine(innerExceptionMessage);
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrowException = onCaughtExceptionProcessFunc(e);
						}
						if (reThrowException)
						{
							throw
								new Exception
										(
											innerExceptionMessage
											, e
										);
						}
						return r;
					}
					finally
					{
						if (onFinallyProcessAction != null)
						{
							onFinallyProcessAction(caughtException, exception);
						}
					}
				}
				else
				{
					return await onTryProcessFunc();
				}
			}
		}
		public static void TryProcessCatchFinally
									(
										bool needTry
										, Action onTryProcessAction
										, bool reThrowException = false
										, Func<Exception, bool> onCaughtExceptionProcessFunc = null
										, Action<bool, Exception> onFinallyProcessAction = null
									)
		{
			if (onTryProcessAction != null)
			{
				if (needTry)
				{
					Exception exception = null;
					var caughtException = false;
					try
					{
						onTryProcessAction();
					}
					catch (Exception e)
					{
						caughtException = true;
						exception = e;
						var currentCalleeMethod = MethodInfo.GetCurrentMethod();
						var currentCalleeType = currentCalleeMethod.DeclaringType;
						StackTrace stackTrace = new StackTrace(e, true);
						StackFrame stackFrame = stackTrace.GetFrame(1);
						var callerMethod = stackFrame.GetMethod();
						var callerType = callerMethod.DeclaringType;
						var frame = (stackTrace.FrameCount > 1 ? stackTrace.FrameCount - 1 : 1);
						stackFrame = stackTrace.GetFrame(frame);
						var originalCallerMethod = stackFrame.GetMethod();
						var originalCallerType = originalCallerMethod.DeclaringType;
						var innerExceptionMessage = string.Format
								(
									"Rethrow caught [{1}] Exception{0} at Callee Method: [{2}]{0} at Caller Method: [{3}]{0} at Original Caller Method: [{4}]"
									, "\r\n\t"
									, e.Message
									, string.Format("{1}{0}{2}", "::", currentCalleeType, currentCalleeMethod)
									, string.Format("{1}{0}{2}", "::", callerType, callerMethod)
									, string.Format("{1}{0}{2}", "::", originalCallerType, originalCallerMethod)
								);
						//Console.WriteLine(innerExceptionMessage);
						if (onCaughtExceptionProcessFunc != null)
						{
							reThrowException = onCaughtExceptionProcessFunc(e);
						}
						if (reThrowException)
						{
							throw
								new Exception
										(
											innerExceptionMessage
											, e
										);
						}
					}
					finally
					{
						//Console.WriteLine("Finally");
						if (onFinallyProcessAction != null)
						{
							onFinallyProcessAction(caughtException, exception);
						}
					}
				}
				else
				{
					onTryProcessAction();
				}
			}
		}
	}
}

#T=TSqlParser SqlScriptGenerator
// /r:"C:\Program Files\Microsoft Visual Studio 10.0\VSTSDB\Deploy\Microsoft.Data.Schema.ScriptDom.dll";"C:\Program Files\Microsoft Visual Studio 10.0\VSTSDB\Deploy\Microsoft.Data.Schema.ScriptDom.Sql.dll"
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using Microsoft.Data.Schema.ScriptDom;
	using Microsoft.Data.Schema.ScriptDom.Sql;
	public class Class1
	{
		static void Main(string[] args)
		{
			//SqlScriptGeneratorOptions options = new SqlScriptGeneratorOptions();
			//options.SqlVersion = SqlVersion.Sql100;
			//options.KeywordCasing = KeywordCasing.Uppercase;
			//Sql100ScriptGenerator scriptGenerator = new Sql100ScriptGenerator(options);
			SqlScriptGenerator scriptGenerator = new Sql100ScriptGenerator();
			TSqlParser parser = new TSql100Parser(false);
			IList<ParseError> errors;
			string sql =
@"
					--SELECT * FROM [from] WHERE ID='1'
					select a.id,MAX(a.name),a.Name
					from sysobjects aa
					left join syscomments b
					on a.id = b.id
					where a.xtype = 'p'
					and b.[text] like '% exec%'
					group by a.id
";
			using (StringReader reader = new StringReader(sql))
			{
				IScriptFragment fragment = parser.Parse(reader, out errors);
				if (errors != null && errors.Count > 0)
				{
					foreach(ParseError pe in errors)
					{
						Console.WriteLine(pe.Message);
					}
				}
				else
				{
					string script;
					scriptGenerator.GenerateScript(fragment, out script);
					Console.WriteLine(script);
				}
			}
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}

#T=UAC elevation
namespace CSUac
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new MainForm());
		}
	}
}
namespace CSUac
{
/************************************* Module Header **************************************\
* Module Name:	MainForm.cs
* Project:		CSUac
* Copyright ? 2009 Microsoft Corporation. and 
* Copyright ? 2009 Coder24.com.
* 
* The C# Security example demonstrates how to perform User Account Control (UAC) security 
* elevation in Windows Forms application.
* 
* Note:
* This application and code example does [NOT] work correct in Windows XP or earlier, 
* It works in Windows Vista and later operating systems.
* 
* This source is subject to the Microsoft Public License.
* See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
* All other rights reserved.
* 
* History:
* * 4/30/2009 9:25 PM Fisnik Hasani Created
\******************************************************************************************/
^#region Using directives
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Diagnostics;
using System.Security.Principal;
using System.Runtime.InteropServices;
^#endregion
	public partial class MainForm : Form
	{
		public MainForm()
		{
			InitializeComponent();
			// Here we check if the user is Administrator or basic user. 
			if (!IsAdmin())
			{
				// If account isn't administrator, then change the buttons flatstyle to 
				// 'system' and call the 'SendMessage' function, to add UAC shield icon. 
				this.btnElevate.FlatStyle = FlatStyle.System;
				SendMessage(btnElevate.Handle, Shield, 0, 0xFFFFFFFF);
			}
			else
			{
				// If account is administrator, then disable the button control. 
				this.btnElevate.Enabled = false;  
			}
		}
		// We import this dll, to get access to the UAC shield icon. 
		[DllImport("user32")]
		public static extern UInt32 SendMessage
			(IntPtr hWnd, UInt32 msg, UInt32 wParam, UInt32 lParam);
		internal const int Normal = 0x1600; // Normal button.
		internal const int Shield = 0x160C; // UAC shield will be added to the button.
		
		bool IsAdmin()
		{
			WindowsIdentity id = WindowsIdentity.GetCurrent();
			WindowsPrincipal principal = new WindowsPrincipal(id);
			return principal.IsInRole(WindowsBuiltInRole.Administrator);
		}
		bool IsUser()
		{
			WindowsIdentity id = WindowsIdentity.GetCurrent();
			WindowsPrincipal principal = new WindowsPrincipal(id);
			return principal.IsInRole(WindowsBuiltInRole.User);
		}
		void NTAUTHORITY()
		{
			ProcessStartInfo proc = new ProcessStartInfo();
			proc.UseShellExecute = true;
			proc.WorkingDirectory = Environment.CurrentDirectory;
			proc.FileName = Application.ExecutablePath;
			// Here we decide the action to take when we restart our application. 
			proc.Verb = "runas"; 
			try
			{
				Process.Start(proc);
			}
			catch
			{
				return;
			}
			Application.Exit();
		}
		private void btnElevate_Click(object sender, EventArgs e)
		{
			if (IsAdmin())
			{
				// Don't need any security permission, or full granted rights for action.
			}
			else if (IsUser())
			{
				NTAUTHORITY();
			}
		}
	}
}
namespace CSUac
{
	partial class MainForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.btnElevate = new System.Windows.Forms.Button();
			this.label1 = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// btnElevate
			// 
			this.btnElevate.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft;
			this.btnElevate.Location = new System.Drawing.Point(62, 40);
			this.btnElevate.Name = "btnElevate";
			this.btnElevate.Size = new System.Drawing.Size(174, 24);
			this.btnElevate.TabIndex = 0;
			this.btnElevate.Text = "Elevate UAC";
			this.btnElevate.UseVisualStyleBackColor = true;
			this.btnElevate.Click += new System.EventHandler(this.btnElevate_Click);
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(13, 13);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(253, 13);
			this.label1.TabIndex = 1;
			this.label1.Text = "Demostrating User Account Control (UAC) elevation:";
			// 
			// MainForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(301, 87);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.btnElevate);
			this.Name = "MainForm";
			this.Text = "UAC Elevated Sample";
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		#endregion
		private System.Windows.Forms.Button btnElevate;
		private System.Windows.Forms.Label label1;
	}
}
#T=UAC Helper
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine(UacHelper.IsProcessElevated ? "Run as administrator" : "Not run as administrator");
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	using System.Security.Principal;
	using Microsoft.Win32;
	public static class UacHelper
	{
		private const string uacRegistryKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System";
		private const string uacRegistryValue = "EnableLUA";
		private static uint STANDARD_RIGHTS_READ = 0x00020000;
		private static uint TOKEN_QUERY = 0x0008;
		private static uint TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY);
		[DllImport("advapi32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);
		[DllImport("advapi32.dll", SetLastError = true)]
		public static extern bool GetTokenInformation(IntPtr TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, IntPtr TokenInformation, uint TokenInformationLength, out uint ReturnLength);
		public enum TOKEN_INFORMATION_CLASS
		{
			TokenUser = 1,
			TokenGroups,
			TokenPrivileges,
			TokenOwner,
			TokenPrimaryGroup,
			TokenDefaultDacl,
			TokenSource,
			TokenType,
			TokenImpersonationLevel,
			TokenStatistics,
			TokenRestrictedSids,
			TokenSessionId,
			TokenGroupsAndPrivileges,
			TokenSessionReference,
			TokenSandBoxInert,
			TokenAuditPolicy,
			TokenOrigin,
			TokenElevationType,
			TokenLinkedToken,
			TokenElevation,
			TokenHasRestrictions,
			TokenAccessInformation,
			TokenVirtualizationAllowed,
			TokenVirtualizationEnabled,
			TokenIntegrityLevel,
			TokenUIAccess,
			TokenMandatoryPolicy,
			TokenLogonSid,
			MaxTokenInfoClass
		}
		public enum TOKEN_ELEVATION_TYPE
		{
			TokenElevationTypeDefault = 1,
			TokenElevationTypeFull,
			TokenElevationTypeLimited
		}
		public static bool IsUacEnabled
		{
			get
			{
				var uacKey = Registry.LocalMachine.OpenSubKey(uacRegistryKey, false);
				var result = uacKey.GetValue(uacRegistryValue).Equals(1);
				return result;
			}
		}
		public static bool IsProcessElevated
		{
			get
			{
				if (IsUacEnabled)
				{
					IntPtr tokenHandle;
					if (!OpenProcessToken(Process.GetCurrentProcess().Handle, TOKEN_READ, out tokenHandle))
					{
						throw new ApplicationException("Could not get process token.  Win32 Error Code: " + Marshal.GetLastWin32Error());
					}
					var elevationResult = TOKEN_ELEVATION_TYPE.TokenElevationTypeDefault;
					var elevationResultSize = Marshal.SizeOf((int)elevationResult);
					uint returnedSize = 0;
					var elevationTypePtr = Marshal.AllocHGlobal(elevationResultSize);
					var success = GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenElevationType, elevationTypePtr, (uint)elevationResultSize, out returnedSize);
					if (success)
					{
						elevationResult = (TOKEN_ELEVATION_TYPE)Marshal.ReadInt32(elevationTypePtr);
						var isProcessAdmin = elevationResult == TOKEN_ELEVATION_TYPE.TokenElevationTypeFull;
						return isProcessAdmin;
					}
					throw new ApplicationException("Unable to determine the current elevation.");
				}
				var identity = WindowsIdentity.GetCurrent();
				var principal = new WindowsPrincipal(identity);
				var result = principal.IsInRole(WindowsBuiltInRole.Administrator);
				return result;
			}
		}
	}
}
#T=UDP
namespace Test
{
	using System;
	using System.Text;
	using System.Net;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Net.Sockets;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			//byte[] data = new byte[1024];
			string[] a = args[0].Split(new char[] { ':' });
			string ip = a[0];
			int port = int.Parse(a[1]);
			IPEndPoint ipepLocal = new IPEndPoint(IPAddress.Parse(ip), port);
			a = args[1].Split(new char[] { ':' });
			ip = a[0];
			port = int.Parse(a[1]);
			IPEndPoint ipepRemote = new IPEndPoint(IPAddress.Parse(ip), port);
			Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
			//socket.RemoteEndPoint = ipep2;
			SocketAsyncDataHandler<string> handler = new SocketAsyncDataHandler<string>(socket, 1, 1024 * 64);
			socket.Bind(ipepLocal);
			Console.WriteLine("This is a Server, host name is {0}", Dns.GetHostName());
			handler.OnSyncDataPackReceived += new SocketAsyncDataHandler<string>.DataPackReceivedEventHandler(handler_OnSyncDataPackReceived);
			handler.StartReceiveData(4, 0, 4);
			string s = string.Empty;
			while ((s = Console.ReadLine().ToLower()) != "q")
			{
				var buff = Encoding.UTF8.GetBytes(s);
				var l = buff.Length;
				var buf = BitConverter.GetBytes(l);
				Array.Reverse(buf);
				var buffer = new byte[handler.HeaderBytesLength + l];
				int p = 0;
				p += handler.HeaderBytesOffset;
				Buffer.BlockCopy(buf, 0, buffer, p, handler.HeaderBytesCount);
				p += handler.HeaderBytesCount;
				Buffer.BlockCopy(buff, 0, buffer, p, l);
				Parallel.For
						(
							0
							, 100
							, new ParallelOptions()
							{
								MaxDegreeOfParallelism = Environment.ProcessorCount
								//, TaskScheduler = null
							}
							, i =>
							{
								handler.SendDataToSync(buffer, ipepRemote);
							}
						);
			}
		}
		private static int _recieveCount = 0;
		static void handler_OnSyncDataPackReceived(SocketAsyncDataHandler<string> sender, byte[] data)
		{
			string s = Encoding.UTF8.GetString(data, sender.HeaderBytesLength, data.Length - sender.HeaderBytesLength);
			Console.WriteLine(s);
			Interlocked.Increment(ref _recieveCount);
			Console.WriteLine(_recieveCount);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	//using System.Threading;
	public class SocketAsyncDataHandler<T>
	{
		private Socket _socket;
		public Socket WorkingSocket
		{
			get
			{
				return _socket;
			}
		}
		public int ReceiveBufferLength
		{
			get;
			private set;
		}
		public T ConnectionToken
		{
			get;
			set;
		}
		public delegate void DataPackReceivedEventHandler(SocketAsyncDataHandler<T> sender, byte[] data);
		public event DataPackReceivedEventHandler OnSyncDataPackReceived;
		public IPAddress RemoteIPAddress
		{
			get
			{
				return ((IPEndPoint)_socket.RemoteEndPoint).Address;
			}
		}
		public IPAddress LocalIPAddress
		{
			get
			{
				return ((IPEndPoint)_socket.LocalEndPoint).Address;
			}
		}
		public int SocketID
		{
			get;
			private set;
		}
		private bool _isUdp = false;
		public SocketAsyncDataHandler
							(
								Socket socket
								, int socketID
								, int receiveBufferLength
							)
		{
			_socket = socket;
			_isUdp = (_socket.ProtocolType == ProtocolType.Udp);
			ReceiveBufferLength = receiveBufferLength;
			_sendSocketAsyncEventArgs = new SocketAsyncEventArgs();
			SocketID = socketID;
			var buffer = new byte[ReceiveBufferLength];
			_sendSocketAsyncEventArgs.SetBuffer(buffer, _sendSocketAsyncEventArgsBufferOffset, buffer.Length);
			_sendSocketAsyncEventArgs.Completed += send_OnCompleted;
		}
		void send_OnCompleted(object sender, SocketAsyncEventArgs e)
		{
			if (true)
			{
			}
		}
		private bool _isSendingAsync = false;
		private SocketAsyncEventArgs _sendSocketAsyncEventArgs;
		private int _sendSocketAsyncEventArgsBufferOffset = 0;
		private bool SendDataAsync(byte[] data)
		{
			//lock (_sendSyncLockObject)
			{
				var r = false;
				var offset = _sendSocketAsyncEventArgs.Offset;
				var count = data.Length;
				byte[] buffer = _sendSocketAsyncEventArgs.Buffer;
				if (offset + count <= buffer.Length)
				{
					Buffer.BlockCopy(data, 0, buffer, _sendSocketAsyncEventArgsBufferOffset, data.Length);
					if (!_isSendingAsync)
					{
						_socket.SendAsync(_sendSocketAsyncEventArgs);
					}
				}
				return r;
			}
		}
		public int HeaderBytesLength
		{
			get;
			private set;
		}
		public int HeaderBytesOffset
		{
			get;
			private set;
		}
		public int HeaderBytesCount
		{
			get;
			private set;
		}
		private bool _isStartedReceiveData = false;
		public void StartReceiveData
							(
								int headerBytesLength
								, int headerBytesOffset
								, int headerBytesCount
								//, EndPoint remoteEndPoint = null
							)
		{
			if (!_isStartedReceiveData)
			{
				HeaderBytesLength = headerBytesLength;
				HeaderBytesOffset = headerBytesOffset;
				HeaderBytesCount = headerBytesCount;
				var saeaReceive = new SocketAsyncEventArgs();
				saeaReceive.Completed += receive_OnCompleted;
				var buffer = new byte[ReceiveBufferLength];
				if (_isUdp)
				{
					saeaReceive.SetBuffer(buffer, 0, buffer.Length);
					saeaReceive.RemoteEndPoint = _socket.LocalEndPoint;
					_socket.ReceiveFromAsync(saeaReceive);
				}
				else
				{
					saeaReceive.SetBuffer(buffer, 0, HeaderBytesLength);
					_socket.ReceiveAsync(saeaReceive);
				}
				_isStartedReceiveData = true;
			}
		}
		private bool _isHeader = true;
		private void receive_OnCompleted(object sender, SocketAsyncEventArgs e)
		{
			var socket = sender as Socket;
			if (e.BytesTransferred >= 0)
			{
				byte[] buffer = e.Buffer;
				int r = e.BytesTransferred;
				if (_isUdp)
				{
					byte[] data = new byte[r];
					Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
					if (OnSyncDataPackReceived != null)
					{
						OnSyncDataPackReceived(this, data);
					}
				}
				else
				{
					int p = e.Offset;
					int l = e.Count;
					if (r < l)
					{
						p += r;
						e.SetBuffer(p, l - p);
					}
					else if (r == l)
					{
						if (_isHeader)
						{
							byte[] data = new byte[l];
							Buffer.BlockCopy
										(
											buffer
											, HeaderBytesOffset
											, data
											, 0
											, HeaderBytesCount
										);
							//Console.WriteLine(CryptographyHelper.BytesArrayToHexString(data));
							byte[] bytes = new byte[4];
							l = (bytes.Length < HeaderBytesCount ? bytes.Length : HeaderBytesCount);
							Buffer.BlockCopy
											(
												data
												, 0
												, bytes
												, 0
												, l
											);
							Array.Reverse(bytes);
							int i = BitConverter.ToInt32(bytes, 0);
							p += r;
							e.SetBuffer(p, i);
							_isHeader = false;
						}
						else
						{
							byte[] data = new byte[l + HeaderBytesLength];
							Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
							_isHeader = true;
							e.SetBuffer(0, HeaderBytesLength);
							if (OnSyncDataPackReceived != null)
							{
								OnSyncDataPackReceived(this, data);
							}
						}
					}
					else
					{
						Console.WriteLine("err");
					}
				}
			}
			try
			{
				if (_isUdp)
				{
					socket.ReceiveFromAsync(e);
				}
				else
				{
					socket.ReceiveAsync(e);
				}
			}
			catch (Exception exception)
			{
				Console.WriteLine(exception.ToString());
			}
		}
		private object _sendSyncLockObject = new object();
		public void SendDataToSync(byte[] data, EndPoint remoteEndPoint)
		{
			lock (_sendSyncLockObject)
			{
				_socket.SendTo(data, remoteEndPoint);
			}
		}
		public void SendDataSync(byte[] data)
		{
			lock (_sendSyncLockObject)
			{
				_socket.Send(data);
			}
		}
		//private void SendAsyncQueue_OnDequeue(byte[] element)
		//{
		//	SendDataSync(element);
		//}
		//private void ReceivedQueue_OnDequeue(byte[] element)
		//{
		//	if (OnAsyncQueueDataPackReceived != null)
		//	{
		//		OnAsyncQueueDataPackReceived(this, element);
		//	}
		//}
	}
}
#T=Udp SocketAsyncDataHandler<string>
namespace Test
{
	using Microshaoft;
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	using System.Threading.Tasks;
	class Program
	{
		static BufferManager _bufferManager;
		static SocketAsyncEventArgsPool _socketAsyncEventArgsPool;
		static void Main(string[] args)
		{
			args = new string[]
						{
							"127.0.0.1:10080"
							, "127.0.0.1:10081"
						};
			_bufferManager = new BufferManager
									(
										64 * 1024 * 1024
										, 64 * 1024
									);
			_bufferManager.InitBuffer();
			_socketAsyncEventArgsPool = new SocketAsyncEventArgsPool(100);
			var performanceCountersCategoryName = "Microshaoft EasyPerformanceCounters Category";
			EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
				.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, "Hander1::Sended"
								);
			EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
				.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, "Hander2::Sended"
								);
			EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
				.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, "Hander1::Received"
								);
			EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
				.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, "Hander2::Received"
								);
			Console.WriteLine(@"Press any key to Send! Press ""q"" to release resource");
			string s = string.Empty;
			while ((s = Console.ReadLine().ToLower()) != "q")
			{
				Run(args);
			}
		}
		static void Run(string[] args)
		{
			var performanceCountersCategoryName = "Microshaoft EasyPerformanceCounters Category";
			var enableCounters = MultiPerformanceCountersTypeFlags.ProcessCounter
									| MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
									| MultiPerformanceCountersTypeFlags.ProcessedCounter
									| MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter
									| MultiPerformanceCountersTypeFlags.ProcessingCounter;
			var sendEncoding = Encoding.Default;
			var receiveEncoding = Encoding.Default;
			//byte[] data = new byte[1024];
			string[] a = args[0].Split(new char[] { ':' });
			string ip = a[0];
			int port = int.Parse(a[1]);
			IPEndPoint ipep1 = new IPEndPoint(IPAddress.Parse(ip), port);
			Console.WriteLine("ipep1 {0}", ipep1.ToString());
			a = args[1].Split(new char[] { ':' });
			ip = a[0];
			port = int.Parse(a[1]);
			IPEndPoint ipep2 = new IPEndPoint(IPAddress.Parse(ip), port);
			Console.WriteLine("ipep2 {0}", ipep2.ToString());
			var remoteAnyIPEP = new IPEndPoint(IPAddress.Any, 0);
			Socket socket1 = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
			socket1.Bind(ipep1);
			SocketAsyncDataHandler<string> handler1 = new SocketAsyncDataHandler<string>(socket1, 1);
			var receiveSocketAsyncEventArgs1 = _socketAsyncEventArgsPool.Pop();
			_bufferManager.SetBuffer(receiveSocketAsyncEventArgs1);
			handler1.StartReceiveDataFrom
						(
							remoteAnyIPEP
							, receiveSocketAsyncEventArgs1
							, (x, y, z) =>
							{
								Console.WriteLine("次数: {0}", x.ReceivedCount);
								Console.WriteLine("字节: {0}", y.Length);
								EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
									.CountPerformance
										(
											enableCounters
											, performanceCountersCategoryName
											, "Hander1::Received"
											, null
											, () =>
											{
												var ss = receiveEncoding.GetString(y);
												//Console.Write(s);
												Console.WriteLine
															(
																"from {0} , to {1}, data {2}"
																, x.WorkingSocket.LocalEndPoint
																, z.RemoteEndPoint
																, ss
															);
											}
											, null
											, null
											, null
										);
								return false;
							}
							, (x, y, z) =>
							{
								Console.WriteLine(z.ToString());
								return true;
							}
						);
			Socket socket2 = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
			socket2.Bind(ipep2);
			SocketAsyncDataHandler<string> handler2 = new SocketAsyncDataHandler<string>(socket2, 2);
			var receiveSocketAsyncEventArgs2 = _socketAsyncEventArgsPool.Pop();
			_bufferManager.SetBuffer(receiveSocketAsyncEventArgs2);
			handler2.StartReceiveDataFrom
							(
								remoteAnyIPEP
								, receiveSocketAsyncEventArgs2
								, (x, y, z) =>
								{
									Console.WriteLine("次数: {0}", x.ReceivedCount);
									Console.WriteLine("字节: {0}", y.Length);
									EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
										.CountPerformance
											(
												enableCounters
												, performanceCountersCategoryName
												, "Hander2::Received"
												, null
												, () =>
												{
													var ss = receiveEncoding.GetString(y);
													//Console.Write(s);
													Console.WriteLine
																(
																	"from {0} , to {1}, data {2}"
																	, x.WorkingSocket.LocalEndPoint
																	, z.RemoteEndPoint
																	, ss
																);
												}
												, null
												, null
												, null
											);
									return false;
								}
								, (x, y, z) =>
								{
									Console.WriteLine(z.ToString());
									return true;
								}
							);
			string s = string.Empty;
			Console.WriteLine("Send ...");
			while ((s = Console.ReadLine().ToLower()) != "q")
			{
				var buffer = sendEncoding.GetBytes(s);
				Parallel.For
						(
							0
							, 1000
							, new ParallelOptions()
							{
								MaxDegreeOfParallelism = 1// Environment.ProcessorCount
								//, TaskScheduler = null
							}
							, i =>
							{
								Thread.Sleep(5);
								EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
									.CountPerformance
										(
											enableCounters
											, performanceCountersCategoryName
											, "Hander1::Sended"
											, null
											, () =>
											{
												handler1.SendDataToSync(buffer, ipep2);
											}
											, null
											, null
											, null
										);
								EasyPerformanceCountersHelper<CommonPerformanceCountersContainer>
									.CountPerformance
										(
											enableCounters
											, performanceCountersCategoryName
											, "Hander2::Sended"
											, null
											, () =>
											{
												handler2.SendDataToSync(buffer, ipep1);
											}
											, null
											, null
											, null
										);
							}
						);
			}
			var e = handler1.ReceiveSocketAsyncEventArgs;
			//_bufferManager.FreeBuffer(e);
			_socketAsyncEventArgsPool.Push(e);
			e = handler2.ReceiveSocketAsyncEventArgs;
			//_bufferManager.FreeBuffer(e);
			_socketAsyncEventArgsPool.Push(e);
			handler1.DestoryWorkingSocket();
			handler2.DestoryWorkingSocket();
			Console.WriteLine("Send quit");
		}
		//private static int _recieveCount = 0;
	}
}
namespace Microshaoft
{
	using System.Collections.Concurrent;
	using System.Net.Sockets;
	// Represents a collection of reusable SocketAsyncEventArgs objects.
	public class SocketAsyncEventArgsPool
	{
		private ConcurrentStack<SocketAsyncEventArgs> _pool;
		public SocketAsyncEventArgsPool(int count)
		{
			_pool = new ConcurrentStack<SocketAsyncEventArgs>();
			for (var i = 0; i < count; i++)
			{
				_pool.Push(new SocketAsyncEventArgs());
			}
		}
		// Add a SocketAsyncEventArg instance to the pool
		//
		//The "item" parameter is the SocketAsyncEventArgs instance
		// to add to the pool
		public void Push(SocketAsyncEventArgs socketAsyncEventArgs)
		{
			_pool.Push(socketAsyncEventArgs);
		}
		// Removes a SocketAsyncEventArgs instance from the pool
		// and returns the object removed from the pool
		public SocketAsyncEventArgs Pop()
		{
			SocketAsyncEventArgs socketAsyncEventArgs = null;
			if
				(
					_pool.IsEmpty
					|| !_pool.TryPop(out socketAsyncEventArgs)
				)
			{
				socketAsyncEventArgs = new SocketAsyncEventArgs();
			}
			return socketAsyncEventArgs;
		}
		// The number of SocketAsyncEventArgs instances in the pool
		public int Count
		{
			get
			{
				return _pool.Count;
			}
		}
	}
}
namespace Microshaoft
{
	using System.Collections.Concurrent;
	using System.Net.Sockets;
	public class BufferManager
	{
		// This class creates a single large buffer which can be divided up
		// and assigned to SocketAsyncEventArgs objects for use with each
		// socket I/O operation.
		// This enables buffers to be easily reused and guards against
		// fragmenting heap memory.
		//
		//This buffer is a byte array which the Windows TCP buffer can copy its data to.
		// the total number of bytes controlled by the buffer pool
		int _totalBytesInBufferBlock;
		// Byte array maintained by the Buffer Manager.
		byte[] _bufferBlock;
		ConcurrentStack<int> _freeIndexPool;
		int _currentIndex;
		int _bufferBytesAllocatedForEachSaea;
		public BufferManager(int totalBytes, int totalBufferBytesInEachSaeaObject)
		{
			_totalBytesInBufferBlock = totalBytes;
			_currentIndex = 0;
			_bufferBytesAllocatedForEachSaea = totalBufferBytesInEachSaeaObject;
			_freeIndexPool = new ConcurrentStack<int>();
		}
		// Allocates buffer space used by the buffer pool
		public void InitBuffer()
		{
			// Create one large buffer block.
			_bufferBlock = new byte[_totalBytesInBufferBlock];
		}
		// Divide that one large buffer block out to each SocketAsyncEventArg object.
		// Assign a buffer space from the buffer block to the
		// specified SocketAsyncEventArgs object.
		//
		// returns true if the buffer was successfully set, else false
		public bool SetBuffer(SocketAsyncEventArgs args)
		{
			int index = -1;
			if (_freeIndexPool.TryPop(out index))
			{
				//This if-statement is only true if you have called the FreeBuffer
				//method previously, which would put an offset for a buffer space
				//back into this stack.
				args.SetBuffer(_bufferBlock, index, _bufferBytesAllocatedForEachSaea);
			}
			else
			{
				//Inside this else-statement is the code that is used to set the
				//buffer for each SAEA object when the pool of SAEA objects is built
				//in the Init method.
				if ((_totalBytesInBufferBlock - _bufferBytesAllocatedForEachSaea) < _currentIndex)
				{
					return false;
				}
				args.SetBuffer(_bufferBlock, _currentIndex, _bufferBytesAllocatedForEachSaea);
				_currentIndex += _bufferBytesAllocatedForEachSaea;
			}
			return true;
		}
		// Removes the buffer from a SocketAsyncEventArg object.   This frees the
		// buffer back to the buffer pool. Try NOT to use the FreeBuffer method,
		// unless you need to destroy the SAEA object, or maybe in the case
		// of some exception handling. Instead, on the server
		// keep the same buffer space assigned to one SAEA object for the duration of
		// this app's running.
		private void FreeBuffer(SocketAsyncEventArgs args)
		{
			_freeIndexPool.Push(args.Offset);
			args.SetBuffer(null, 0, 0);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Threading;
	public class SocketAsyncDataHandler<T>
	{
		private Socket _socket;
		public Socket WorkingSocket
		{
			get
			{
				return _socket;
			}
		}
		//public int ReceiveDataBufferLength
		//{
		//	get;
		//	private set;
		//}
		public T ConnectionToken
		{
			get;
			set;
		}
		public IPAddress RemoteIPAddress
		{
			get
			{
				return ((IPEndPoint) _socket.RemoteEndPoint).Address;
			}
		}
		public IPAddress LocalIPAddress
		{
			get
			{
				return ((IPEndPoint) _socket.LocalEndPoint).Address;
			}
		}
		public int SocketID
		{
			get;
			private set;
		}
		public SocketAsyncDataHandler
							(
								Socket socket
								, int socketID
							)
		{
			_socket = socket;
			_isUdp = (_socket.ProtocolType == ProtocolType.Udp);
			_sendSocketAsyncEventArgs = new SocketAsyncEventArgs();
			SocketID = socketID;
		}
		private SocketAsyncEventArgs _sendSocketAsyncEventArgs;
		public int HeaderBytesLength
		{
			get;
			private set;
		}
		public int HeaderBytesOffset
		{
			get;
			private set;
		}
		private long _receivedCount = 0;
		public long ReceivedCount
		{
			get
			{
				return _receivedCount;
			}
		}
		public int HeaderBytesCount
		{
			get;
			private set;
		}
		public SocketAsyncEventArgs ReceiveSocketAsyncEventArgs
		{
			get;
			private set;
		}
		private bool _isStartedReceiveData = false;
		private bool _isHeader = true;
		public bool StartReceiveWholeDataPackets
							(
								int headerBytesLength
								, int headerBytesOffset
								, int headerBytesCount
								, Func<SocketAsyncEventArgs> getReceiveSocketAsyncEventArgsProcessFunc
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onOneWholeDataPacketReceivedProcessFunc
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onReceivedDataPacketErrorProcessFunc = null
								, Func
									<
										SocketAsyncDataHandler<T>
										, SocketAsyncEventArgs
										, Exception
										, bool
									> onCaughtExceptionProcessFunc = null
							)
		{
			return
				StartReceiveWholeDataPackets
					(
						headerBytesLength
						, headerBytesOffset
						, headerBytesCount
						, getReceiveSocketAsyncEventArgsProcessFunc()
						, onOneWholeDataPacketReceivedProcessFunc
						, onReceivedDataPacketErrorProcessFunc
						, onCaughtExceptionProcessFunc
					);
		}
		public bool StartReceiveWholeDataPackets
							(
								int headerBytesLength
								, int headerBytesOffset
								, int headerBytesCount
								, SocketAsyncEventArgs receiveSocketAsyncEventArgs
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onOneWholeDataPacketReceivedProcessFunc
								, Func
									<
										SocketAsyncDataHandler<T>
										, byte[]
										, SocketAsyncEventArgs
										, bool
									> onReceivedDataPacketErrorProcessFunc = null
								, Func
									<
										SocketAsyncDataHandler<T>
										, SocketAsyncEventArgs
										, Exception
										, bool
									> onCaughtExceptionProcessFunc = null
							)
		{
			if (!_isStartedReceiveData)
			{
				HeaderBytesLength = headerBytesLength;
				HeaderBytesOffset = headerBytesOffset;
				HeaderBytesCount = headerBytesCount;
				int bodyLength = 0;
				ReceiveSocketAsyncEventArgs = receiveSocketAsyncEventArgs;
				ReceiveSocketAsyncEventArgs.Completed += new EventHandler<SocketAsyncEventArgs>
								(
									(sender, e) =>
									{
										var socket = sender as Socket;
										if (e.BytesTransferred >= 0)
										{
											byte[] buffer = e.Buffer;
											int r = e.BytesTransferred;
											int p = e.Offset;
											int l = e.Count;
											if (r < l)
											{
												p += r;
												e.SetBuffer(p, l - r);
											}
											else if (r == l)
											{
												if (_isHeader)
												{
													byte[] data = new byte[headerBytesCount];
													Buffer.BlockCopy
																(
																	buffer
																	, HeaderBytesOffset
																	, data
																	, 0
																	, data.Length
																);
													byte[] intBytes = new byte[4];
													l = (intBytes.Length < HeaderBytesCount ? intBytes.Length : HeaderBytesCount);
													Buffer.BlockCopy
																(
																	data
																	, 0
																	, intBytes
																	, 0
																	, l
																);
													//Array.Reverse(intBytes);
													bodyLength = BitConverter.ToInt32(intBytes, 0);
													p += r;
													e.SetBuffer(p, bodyLength);
													Console.WriteLine(bodyLength);
													_isHeader = false;
												}
												else
												{
													byte[] data = new byte[bodyLength + HeaderBytesLength];
													bodyLength = 0;
													Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
													_isHeader = true;
													e.SetBuffer(0, HeaderBytesLength);
													if (onOneWholeDataPacketReceivedProcessFunc != null)
													{
														onOneWholeDataPacketReceivedProcessFunc
															(
																this
																, data
																, e
															);
													}
												}
											}
											else
											{
												if (onReceivedDataPacketErrorProcessFunc != null)
												{
													byte[] data = new byte[p + r + HeaderBytesLength];
													Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
													bool b = onReceivedDataPacketErrorProcessFunc
																(
																	this
																	, data
																	, e
																);
													if (b)
													{
														bool i = DestoryWorkingSocket();
													}
													else
													{
														_isHeader = true;
														e.SetBuffer(0, HeaderBytesLength);
													}
												}
											}
										}
										if (!_isWorkingSocketDestoryed)
										{
											try
											{
												socket.ReceiveAsync(e);
											}
											catch (Exception exception)
											{
												var r = false;
												if (onCaughtExceptionProcessFunc != null)
												{
													r = onCaughtExceptionProcessFunc
																(
																	this
																	, e
																	, exception
																);
												}
												if (r)
												{
													DestoryWorkingSocket();
												}
											}
										}
									}
								);
				_socket.ReceiveAsync(ReceiveSocketAsyncEventArgs);
				_isStartedReceiveData = true;
			}
			return _isStartedReceiveData;
		}
		private bool _isUdp = false;
		public bool IsUdp
		{
			get
			{
				return _isUdp;
			}
		}
		private bool _isWorkingSocketDestoryed = false;
		public bool DestoryWorkingSocket()
		{
			//bool r = false;
			try
			{
				if (_socket.Connected)
				{
					_socket.Disconnect(false);
				}
				_socket.Shutdown(SocketShutdown.Both);
				_socket.Close();
				_socket.Dispose();
				_socket = null;
				_isWorkingSocketDestoryed = true;
			}
			catch (Exception e)
			{
				Console.WriteLine(e.ToString());
				//r = false;
			}
			return _isWorkingSocketDestoryed;
		}
		public bool StartReceiveDataFrom
			(
				EndPoint remoteEndPoint
				, Func<SocketAsyncEventArgs> getReceiveSocketAsyncEventArgsProcessFunc
				, Func
					<
						SocketAsyncDataHandler<T>
						, byte[]
						, SocketAsyncEventArgs
						, bool
					> onDataReceivedProcessFunc
				, Func
					<
						SocketAsyncDataHandler<T>
						, SocketAsyncEventArgs
						, Exception
						, bool
					> onCaughtExceptionProcessFunc = null
			)
		{
			return
				StartReceiveDataFrom
					(
						remoteEndPoint
						, getReceiveSocketAsyncEventArgsProcessFunc()
						, onDataReceivedProcessFunc
						, onCaughtExceptionProcessFunc
					);
		}
		public bool StartReceiveDataFrom
					(
						EndPoint remoteEndPoint
						, SocketAsyncEventArgs receiveSocketAsyncEventArgs
						, Func
							<
								SocketAsyncDataHandler<T>
								, byte[]
								, SocketAsyncEventArgs
								, bool
							> onDataReceivedProcessFunc
						, Func
							<
								SocketAsyncDataHandler<T>
								, SocketAsyncEventArgs
								, Exception
								, bool
							> onCaughtExceptionProcessFunc = null
					)
		{
			if (!_isStartedReceiveData)
			{
				ReceiveSocketAsyncEventArgs = receiveSocketAsyncEventArgs;
				ReceiveSocketAsyncEventArgs.RemoteEndPoint = remoteEndPoint;
				ReceiveSocketAsyncEventArgs.Completed += new EventHandler<SocketAsyncEventArgs>
												(
													(sender, e) =>
													{
														Interlocked.Increment(ref _receivedCount);
														var socket = sender as Socket;
														int l = e.BytesTransferred;
														//Console.WriteLine(l);
														if (l > 0)
														{
															byte[] data = new byte[l];
															var buffer = e.Buffer;
															Buffer.BlockCopy(buffer, 0, data, 0, data.Length);
															if (onDataReceivedProcessFunc != null)
															{
																onDataReceivedProcessFunc(this, data, e);
																//Console.WriteLine(_receivedCount);
															}
														}
														if (!_isWorkingSocketDestoryed)
														{
															try
															{
																socket.ReceiveFromAsync(ReceiveSocketAsyncEventArgs);
															}
															catch (Exception exception)
															{
																//Console.WriteLine(exception.ToString());
																var r = false;
																if (onCaughtExceptionProcessFunc != null)
																{
																	r = onCaughtExceptionProcessFunc(this, ReceiveSocketAsyncEventArgs, exception);
																}
																if (r)
																{
																	DestoryWorkingSocket();
																}
															}
														}
													}
												);
				_socket.ReceiveFromAsync(ReceiveSocketAsyncEventArgs);
				_isStartedReceiveData = true;
			}
			return _isStartedReceiveData;
		}
		private object _sendSyncLockObject = new object();
		public int SendDataSync(byte[] data)
		{
			var r = -1;
			if (!_isUdp)
			{
				lock (_sendSyncLockObject)
				{
					r = _socket.Send(data);
				}
			}
			return r;
		}
		public int SendDataSyncWithRetry
				(
					byte[] data
					, int retry = 3
					, int sleepSeconds = 1
				)
		{
			//增加就地重试机制
			int r = -1;
			int i = 0;

			while (i < retry)
			{
				r = -1;
				//lock (_sendSyncLockObject)
				{
					try
					{
						if (_socket != null)
						{
							r = SendDataSync(data);
						}
					}
					catch (Exception e)
					{
						Console.WriteLine(e.ToString());
					}
				}
				i++;
				if (r > 0 || i == retry)
				{
					break;
				}
				else
				{
					Thread.Sleep(sleepSeconds * 1000);
				}
			}
			return r;
		}
		public int SendDataToSync(byte[] data, EndPoint remoteEndPoint)
		{
			var r = -1;
			if (_isUdp)
			{
				lock (_sendSyncLockObject)
				{
					r = _socket.SendTo(data, remoteEndPoint);
				}
			}
			return r;
		}
		public int SendDataToSyncWithRetry
						(
							byte[] data
							, EndPoint remoteEndPoint
							, int retry = 3
							, int sleepSeconds = 1
						)
		{
			//增加就地重试机制
			int r = -1;
			int i = 0;
			while (i < retry)
			{
				r = -1;
				lock (_sendSyncLockObject)
				{
					try
					{
						if (_socket != null)
						{
							r = _socket.SendTo(data, remoteEndPoint);
						}
					}
					catch (Exception e)
					{
						Console.WriteLine(e.ToString());
					}
				}
				i++;
				if (r > 0 || i == retry)
				{
					break;
				}
				else
				{
					Thread.Sleep(sleepSeconds * 1000);
				}
			}
			return r;
		}
	}
}

#T=Udp 并发 Sleep 测试
namespace UdpSender
{
	using Microshaoft;
	using System;
	using System.Diagnostics;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	using System.Threading.Tasks;
	class Program
	{
		static void Main(string[] args)
		{
			Console.Title = "sender";
			var sendEncoding = Encoding.Default;
			var data = new byte[256];
			string ip = "127.0.0.1";
			IPEndPoint ipepLocal = new IPEndPoint(IPAddress.Parse(ip), 0);
			IPEndPoint ipepRemote = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 10444);
			Socket socket1 = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
			SocketAsyncDataHandler<string> handler1 = new SocketAsyncDataHandler<string>(socket1, 1);
			var stopwatch = new Stopwatch();
			var sleep = 1;
			string input = string.Empty;
			while ("q" != (input =Console.ReadLine()))
			{
				stopwatch.Start();
				Parallel.For
					(
						0
						, 10000
						, new ParallelOptions() {  MaxDegreeOfParallelism = 32 }
						, (x) =>
							{
								handler1.SendDataToSync(data, ipepRemote);
								if (sleep > 0)
								{
									Thread.Sleep(sleep);
								}
							}
					);
				stopwatch.Stop();
				Console.WriteLine("Elapsed in Seconds: {0}", stopwatch.ElapsedMilliseconds / 1000);
				stopwatch.Reset();
			}
			Console.ReadLine();
		}
	}
}
namespace UdpReceiver
{
	using Microshaoft;
	using System;
	using System.Net;
	using System.Net.Sockets;
	using System.Text;
	using System.Threading;
	class Program
	{
		static void Main1(string[] args)
		{
			Console.Title = "receiver";
			var receiveEncoding = Encoding.Default;
			IPAddress ipAddress;
			IPAddress.TryParse
							(
								"127.0.0.1"
								, out ipAddress
							);
			IPEndPoint localEndPoint = new IPEndPoint
												(
													ipAddress
													, 10444
												);
			Socket udpListener = new Socket
									(
										AddressFamily.InterNetwork
										, SocketType.Dgram
										, ProtocolType.Udp
									);
			udpListener.Bind(localEndPoint);
			//var id = Interlocked.Increment(ref _i);
			var udpListenerHandler = new SocketAsyncDataHandler<int>(udpListener, 1);
			var remoteAnyIPEP = new IPEndPoint(IPAddress.Any, 0);
			var receiveSocketAsyncEventArgs = new SocketAsyncEventArgs();
				var buffer = new byte
								[
									(1024)
								];
				receiveSocketAsyncEventArgs
					.SetBuffer
						(
							buffer
							, 0
							, buffer.Length
						);
			int i = 0;
			udpListenerHandler
				.StartReceiveDataFrom
					(
						remoteAnyIPEP
						, receiveSocketAsyncEventArgs
						, (x, y, z, w) =>
						{
							var r = Interlocked.Increment(ref i);
							//Console.WriteLine(r);
							return false;
						}
						, (x, y, z) =>
						{
							return false;
						}
					);
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine()))
			{
				Console.WriteLine("count {0}", i);
			}
		}
	}
}

#T=Unlock/Lock desktop Detect UsersDesktopStatus
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	using System.Threading;

	public class UsersDesktopStatus
	{
		private const uint DESKTOP_READOBJECTS = 0x0001;
		private const uint DESKTOP_WRITEOBJECTS = 0x0080;
		private const uint DESKTOP_SWITCHDESKTOP = 0x0100;
		private const uint AccessUnlocked = DESKTOP_READOBJECTS
											| DESKTOP_WRITEOBJECTS
											| DESKTOP_SWITCHDESKTOP;

		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern IntPtr OpenDesktop(string lpszDesktop, int dwFlags,
				bool fInherit, uint dwDesiredAccess);

		[DllImport("user32.dll")]
		private static extern bool SwitchDesktop(IntPtr hDesktop);

		public delegate void WindowsDesktopEventHandler(bool DesktopIsLocked);
		public event WindowsDesktopEventHandler UsersDesktopLockStatusChanged;

		private Timer _timer;

		public UsersDesktopStatus(int CheckIntervals)
		{
			_timer = new Timer(new TimerCallback(CheckStatus), null, 0, CheckIntervals);

		}
		private bool _lastIsLocked = false;
		private void CheckStatus(Object state)
		{
			//Console.WriteLine(Desktop.IsNotLocked() == true ? "unlock": "locked");

			if (_lastIsLocked != IsLocked())
			{
				_lastIsLocked = IsLocked();
				if (UsersDesktopLockStatusChanged != null)
				{
					UsersDesktopLockStatusChanged(_lastIsLocked);
				}
			}

		}
		private bool IsLocked()
		{
			IntPtr hdt = OpenDesktop("Default", 0, false, AccessUnlocked);
			return !SwitchDesktop(hdt);
		}
	}
}

namespace Test
{
	using System;
	using System.Threading;
	using System.Windows.Forms;

	using Microshaoft;

	class Class1
	{
		//public static UsersDesktopStatus desk;
		public static void Main()
		{
			UsersDesktopStatus desk = new UsersDesktopStatus(500); //
			desk.UsersDesktopLockStatusChanged += new UsersDesktopStatus.WindowsDesktopEventHandler(OnUsersDesktopLockStatusChanged);
			Console.ReadLine();

		}
		static void OnUsersDesktopLockStatusChanged(bool IsLocked)
		{
			Console.WriteLine(IsLocked ? "Locked" : "Unlocked");
			Console.WriteLine("Screen Width: {0}", Screen.PrimaryScreen.WorkingArea.Width);
		}

	}
}
#T=Unsafe FastCopy
//Copyright (C) Microsoft Corporation.  All rights reserved.

// fastcopy.cs
// compile with: /unsafe
using System;

class Test
{
	// The unsafe keyword allows pointers to be used within
	// the following method:
	static unsafe void Copy(byte[] src, int srcIndex,
		byte[] dst, int dstIndex, int count)
	{
		if (src == null || srcIndex < 0 ||
			dst == null || dstIndex < 0 || count < 0)
		{
			throw new ArgumentException();
		}
		int srcLen = src.Length;
		int dstLen = dst.Length;
		if (srcLen - srcIndex < count ||
			dstLen - dstIndex < count)
		{
			throw new ArgumentException();
		}


		// The following fixed statement pins the location of
		// the src and dst objects in memory so that they will
		// not be moved by garbage collection.		
		fixed (byte* pSrc = src, pDst = dst)
		{
			byte* ps = pSrc;
			byte* pd = pDst;

			// Loop over the count in blocks of 4 bytes, copying an
			// integer (4 bytes) at a time:
			for (int n = 0; n < count / 4; n++)
			{
				*((int*)pd) = *((int*)ps);
				pd += 4;
				ps += 4;
			}

			// Complete the copy by moving any bytes that weren't
			// moved in blocks of 4:
			for (int n = 0; n < count % 4; n++)
			{
				*pd = *ps;
				pd++;
				ps++;
			}
		}
	}


	static void Main(string[] args)
	{
		byte[] a = new byte[100];
		byte[] b = new byte[100];
		for (int i = 0; i < 100; ++i)
			a[i] = (byte)i;
		Copy(a, 0, b, 0, 100);
		Console.WriteLine("The first 10 elements are:");
		for (int i = 0; i < 10; ++i)
			Console.Write(b[i] + " ");
		Console.WriteLine("\n");
	}
}


#T=upload.aspx HtmlInputFile HttpPostedFile
<%@ Page Language="C#" %>
	<%@ Import Namespace="System.Data" %>
	<%@ Import Namespace="System.Data.SqlClient" %>
	<%@ Import Namespace="System.Security.Principal" %>
	<%@ Import Namespace="System.IO" %>
<script runat="server">
	protected void Page_Load(object sender, EventArgs ea) 
	{
		UploadProcess();
	}
	void UploadProcess()
	{
		if (File1.PostedFile != null)
		{
			try
			{
				HttpPostedFile uploadFile = File1.PostedFile;
				string fileName = Path.GetFileName(uploadFile.FileName);
				uploadFile.SaveAs(@"D:\Uploads\" + fileName);
				Span1.InnerHtml = "Upload Successful!";
			}
			catch (Exception ex)
			{
				Span1.InnerHtml = "Error saving file <b>C:\\" +
				File1.Value + "</b><br>" + ex.ToString();
			}
		}
	}
</script>
<html>
<head>
</head>
<body>
	<form runat="server" enctype="multipart/form-data">
		Select a file to upload:<br />
		<input type="file" id="File1" runat="Server" />
		<p>

		<p>
		<span id="Span1" runat="Server" />
		<input type="submit" />
	</form>
</body>
</html>
#T=USB Drive Detect
namespace ConsoleApplication
{
	using System;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			DriveDetector x = new DriveDetector();
			x.DeviceArrived += new DriveDetector.DriveDetectorEventHandler(x_DeviceArrived);
			x.DeviceRemoved += new DriveDetector.DriveDetectorEventHandler(x_DeviceRemoved);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			Console.ReadLine();
		}
		static void x_DeviceRemoved(DriveDetector sender, DriveDetectorEventArgs e)
		{
			Console.WriteLine("DeviceRemoved {0}", e.Drive);
		}
		static void x_DeviceArrived(DriveDetector sender, DriveDetectorEventArgs e)
		{
			Console.WriteLine("DeviceArrived {0}", e.Drive);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Windows.Forms;				// required for Message
	using System.Runtime.InteropServices;	// required for Marshal
	using System.IO;
	using Microsoft.Win32.SafeHandles;
	using System.Threading;
	public class DriveDetectorEventArgs : EventArgs
	{
		public DriveDetectorEventArgs()
		{
			Cancel = false;
			Drive = "";
			HookQueryRemove = false;
		}
		public bool Cancel;
		public string Drive;
		public bool HookQueryRemove;
	}
	public class DriveDetector : IDisposable
	{
		public event DriveDetectorEventHandler DeviceArrived;
		public event DriveDetectorEventHandler DeviceRemoved;
		public event DriveDetectorEventHandler QueryRemove;
		public delegate void DriveDetectorEventHandler(DriveDetector sender, DriveDetectorEventArgs e);
		private WindowsMessagesListener _listener;// = new WindowsMessagesListener();
		private IntPtr _DirHandle = IntPtr.Zero;
		private FileStream _FileOnFlash = null;
		private string _FileToOpen;
		private IntPtr _DeviceNotifyHandle;
		private IntPtr _hWnd;
		private string _CurrentDrive;
		private Thread _thread;
		private class WindowsMessagesListener : Form//NativeWindow
		{
			public delegate void WndProcEventHandler(ref Message m, bool cancel);
			public event WndProcEventHandler BeforeBaseWndProc;
			public event WndProcEventHandler AfterBaseWndProc;
			protected override void WndProc(ref Message m)
			{
				bool b = false;
				if (BeforeBaseWndProc != null)
				{
					BeforeBaseWndProc(ref m, b);
				}
				if (!b)
				{
					base.WndProc(ref m);
					if (AfterBaseWndProc != null)
					{
						AfterBaseWndProc(ref m, b);
					}
				}
			}
		}
		public DriveDetector()
		{
			Init(null);
		}
		public DriveDetector(string FileToOpen)
		{
			Init(FileToOpen);
		}
		private void Init(string fileToOpen)
		{
			_thread = new Thread(new ThreadStart(Run)); //监视线程: 显示滚动计数器
			_thread.Start();
			_FileToOpen = fileToOpen;
			_FileOnFlash = null;
			_DeviceNotifyHandle = IntPtr.Zero;
			_DirHandle = IntPtr.Zero;   // handle to the root directory of the flash drive which we open 
			_CurrentDrive = "";
		}
		private void Run()
		{
			_listener = new WindowsMessagesListener();
			_hWnd = _listener.Handle;
			_listener.AfterBaseWndProc += new WindowsMessagesListener.WndProcEventHandler(_listener_AfterBaseWndProc);
			Application.Run();
		}
		void _listener_AfterBaseWndProc(ref Message m, bool canceledBaseWndProc)
		{
			int devType;
			char c;
			if (m.Msg == Win32Native.WM_DEVICECHANGE)
			{
				// WM_DEVICECHANGE can have several meanings depending on the WParam value...
				switch (m.WParam.ToInt32())
				{
					//
					// New device has just arrived
					//
					case Win32Native.DBT_DEVICEARRIVAL :
						devType = Marshal.ReadInt32(m.LParam, 4);
						if (devType == Win32Native.DBT_DEVTYP_VOLUME)
						{
							DEV_BROADCAST_VOLUME vol;
							vol = (DEV_BROADCAST_VOLUME)
								Marshal.PtrToStructure(m.LParam, typeof(DEV_BROADCAST_VOLUME));
							// Get the drive letter 
							c = DriveMaskToLetter(vol.dbcv_unitmask);
							//
							// Call the client event handler
							//
							// We should create copy of the event before testing it and
							// calling the delegate - if any
							DriveDetectorEventHandler tempDeviceArrived = DeviceArrived;
							if (tempDeviceArrived != null)
							{
								DriveDetectorEventArgs e = new DriveDetectorEventArgs();
								e.Drive = c + ":\\";
								tempDeviceArrived(this, e);
								// Register for query remove if requested
								if (e.HookQueryRemove)
								{
									// If something is already hooked, unhook it now
									if (_DeviceNotifyHandle != IntPtr.Zero)
									{
										RegisterForDeviceChange(false, null);
									}
									RegisterQuery(c + ":\\");
								}
							}	// if  has event handler
						}
						break;
					//
					// Device is about to be removed
					// Any application can cancel the removal
					//
					case Win32Native.DBT_DEVICEQUERYREMOVE :
						devType = Marshal.ReadInt32(m.LParam, 4);
						if (devType == Win32Native.DBT_DEVTYP_HANDLE)
						{
							// TODO: we could get the handle for which this message is sent 
							// from vol.dbch_handle and compare it against a list of handles for 
							// which we have registered the query remove message (?)												
							//DEV_BROADCAST_HANDLE vol;
							//vol = (DEV_BROADCAST_HANDLE)
							//   Marshal.PtrToStructure(_.LParam, typeof(DEV_BROADCAST_HANDLE));
							// if ( vol.dbch_handle ....
							//
							// Call the event handler in client
							//
							DriveDetectorEventHandler tempQuery = QueryRemove;
							if (tempQuery != null)
							{
								DriveDetectorEventArgs e = new DriveDetectorEventArgs();
								e.Drive = _CurrentDrive;		// drive which is hooked
								tempQuery(this, e);
								// If the client wants to cancel, let Windows know
								if (e.Cancel)
								{
									m.Result = (IntPtr)Win32Native.BROADCAST_QUERY_DENY;
								}
								else
								{
									// Change 28.10.2007: Unregister the notification, this will
									// close the handle to file or root directory also. 
									// We have to close it anyway to allow the removal so
									// even if some other app cancels the removal we would not know about it...
									RegisterForDeviceChange(false, null);   // will also close the mFileOnFlash
								}
							}
						}
						break;
					//
					// Device has been removed
					//
					case Win32Native.DBT_DEVICEREMOVECOMPLETE :
						devType = Marshal.ReadInt32(m.LParam, 4);
						if (devType == Win32Native.DBT_DEVTYP_VOLUME)
						{
							devType = Marshal.ReadInt32(m.LParam, 4);
							if (devType == Win32Native.DBT_DEVTYP_VOLUME)
							{
								DEV_BROADCAST_VOLUME vol;
								vol = (DEV_BROADCAST_VOLUME)
									Marshal.PtrToStructure(m.LParam, typeof(DEV_BROADCAST_VOLUME));
								c = DriveMaskToLetter(vol.dbcv_unitmask);
								//
								// Call the client event handler
								//
								DriveDetectorEventHandler tempDeviceRemoved = DeviceRemoved;
								if (tempDeviceRemoved != null)
								{
									DriveDetectorEventArgs e = new DriveDetectorEventArgs();
									e.Drive = c + ":\\";
									tempDeviceRemoved(this, e);
								}
								// TODO: we could unregister the notify handle here if we knew it is the
								// right drive which has been just removed
								//RegisterForDeviceChange(false, null);
							}
						}
						break;
				}
			}
		}
		public bool IsQueryHooked
		{
			get
			{
				if (_DeviceNotifyHandle == IntPtr.Zero)
				{
					return false;
				}
				else
				{
					return true;
				}
			}
		}
		public string HookedDrive
		{
			get
			{
				return _CurrentDrive;
			}
		}
		public FileStream OpenedFile
		{
			get
			{
				return _FileOnFlash;
			}
		}
		public bool EnableQueryRemove(string fileOnDrive)
		{
			if (fileOnDrive == null || fileOnDrive.Length == 0)
			{
				throw new ArgumentException("Drive path must be supplied to register for Query remove.");
			}
			if (fileOnDrive.Length == 2 && fileOnDrive[1] == ':')
			{
				fileOnDrive += '\\';		// append "\\" if only drive letter with ":" was passed in.
			}
			if (_DeviceNotifyHandle != IntPtr.Zero)
			{
				// Unregister first...
				RegisterForDeviceChange(false, null);
			}
			if (Path.GetFileName(fileOnDrive).Length == 0 || !File.Exists(fileOnDrive))
			{
				_FileToOpen = null;	// use root directory...
			}
			else
			{
				_FileToOpen = fileOnDrive;
			}
			RegisterQuery(Path.GetPathRoot(fileOnDrive));
			if (_DeviceNotifyHandle == IntPtr.Zero)
			{
				return false;   // failed to register
			}
			return true;
		}
		public void DisableQueryRemove()
		{
			if (_DeviceNotifyHandle != IntPtr.Zero)
			{
				RegisterForDeviceChange(false, null);
			}
		}
		public void Dispose()
		{
			RegisterForDeviceChange(false, null);
		}
		private void RegisterQuery(string drive)
		{
			bool register = true;
			if (!String.IsNullOrEmpty(_FileToOpen))
			{
				// Make sure the path in mFileToOpen contains valid drive
				// If there is a drive letter in the path, it may be different from the  actual
				// letter assigned to the drive now. We will cut it off and merge the actual drive 
				// with the rest of the path.
				if (_FileToOpen.Contains(":"))
				{
					string tmp = _FileToOpen.Substring(3);
					string root = Path.GetPathRoot(drive);
					_FileToOpen = Path.Combine(root, tmp);
				}
				else
				{
					_FileToOpen = Path.Combine(drive, _FileToOpen);
				}
			}
			try
			{
				//mFileOnFlash = new FileStream(_FileToOpen, FileMode.Open);
				// Change 28.10.2007 - Open the root directory 
				if (_FileToOpen == null)  // open root directory
				{
					_FileOnFlash = null;
				}
				else
				{
					_FileOnFlash = new FileStream(_FileToOpen, FileMode.Open);
				}
			}
			catch (Exception)
			{
				// just do not register if the file could not be opened
				register = false;
			}
			if (register)
			{
				//RegisterForDeviceChange(true, mFileOnFlash.SafeFileHandle);
				//mCurrentDrive = drive;
				// Change 28.10.2007 - Open the root directory 
				if (_FileOnFlash == null)
				{
					RegisterForDeviceChange(drive);
				}
				else
				{
					// old version
					RegisterForDeviceChange(true,_FileOnFlash.SafeFileHandle);
				}
				_CurrentDrive = drive;
			}
		}
		private void RegisterForDeviceChange(string dirPath)
		{
			IntPtr handle = Win32Native.OpenDirectory(dirPath);
			if (handle == IntPtr.Zero)
			{
				_DeviceNotifyHandle = IntPtr.Zero;
				return;
			}
			else
				_DirHandle = handle;	// save handle for closing it when unregistering
			// Register for handle
			DEV_BROADCAST_HANDLE data = new DEV_BROADCAST_HANDLE();
			data.dbch_devicetype = Win32Native.DBT_DEVTYP_HANDLE;
			data.dbch_reserved = 0;
			data.dbch_nameoffset = 0;
			//data.dbch_data = null;
			//data.dbch_eventguid = 0;
			data.dbch_handle = handle;
			data.dbch_hdevnotify = (IntPtr)0;
			int size = Marshal.SizeOf(data);
			data.dbch_size = size;
			IntPtr buffer = Marshal.AllocHGlobal(size);
			Marshal.StructureToPtr(data, buffer, true);
			_DeviceNotifyHandle = Win32Native.RegisterDeviceNotification(_hWnd, buffer, 0);
		}
		private void RegisterForDeviceChange(bool register, SafeFileHandle fileHandle)
		{
			if (register)
			{
				// Register for handle
				DEV_BROADCAST_HANDLE data = new DEV_BROADCAST_HANDLE();
				data.dbch_devicetype = Win32Native.DBT_DEVTYP_HANDLE;
				data.dbch_reserved = 0;
				data.dbch_nameoffset = 0;
				//data.dbch_data = null;
				//data.dbch_eventguid = 0;
				data.dbch_handle = fileHandle.DangerousGetHandle(); //Marshal. fileHandle; 
				data.dbch_hdevnotify = (IntPtr)0;
				int size = Marshal.SizeOf(data);
				data.dbch_size = size;
				IntPtr buffer = Marshal.AllocHGlobal(size);
				Marshal.StructureToPtr(data, buffer, true);
				_DeviceNotifyHandle = Win32Native.RegisterDeviceNotification(_hWnd, buffer, 0);
			}
			else
			{
				// close the directory handle
				if (_DirHandle != IntPtr.Zero)
				{
					Win32Native.CloseDirectoryHandle(_DirHandle);
					//	string er = Marshal.GetLastWin32Error().ToString();
				}
				// unregister
				if (_DeviceNotifyHandle != IntPtr.Zero)
				{
					Win32Native.UnregisterDeviceNotification(_DeviceNotifyHandle);
				}
				_DeviceNotifyHandle = IntPtr.Zero;
				_DirHandle = IntPtr.Zero;
				_CurrentDrive = "";
				if (_FileOnFlash != null)
				{
					_FileOnFlash.Close();
					_FileOnFlash = null;
				}
			}
		}
		private static char DriveMaskToLetter(int mask)
		{
			char c;
			string drives = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
			// 1 = A
			// 2 = B
			// 4 = C...
			int i = 0;
			int p = mask / 2;
			while (p != 0)
			{
				p = p / 2;
				i ++;
			}
			if (i < drives.Length)
			{
				c = drives[i];
			}
			else
			{
				c = '?';
			}
			return c;
		}
		private class Win32Native
		{
			// Win32 constants
			public const int DBT_DEVTYP_DEVICEINTERFACE = 5;
			public const int DBT_DEVTYP_HANDLE = 6;
			public const int BROADCAST_QUERY_DENY = 0x424D5144;
			public const int WM_DEVICECHANGE = 0x0219;
			public const int DBT_DEVICEARRIVAL = 0x8000; // system detected a new device
			public const int DBT_DEVICEQUERYREMOVE = 0x8001;   // Preparing to remove (any program can disable the removal)
			public const int DBT_DEVICEREMOVECOMPLETE = 0x8004; // removed 
			public const int DBT_DEVTYP_VOLUME = 0x00000002; // drive type is logical volume
			//   HDEVNOTIFY RegisterDeviceNotification(HANDLE hRecipient,LPVOID NotificationFilter,DWORD Flags);
			[DllImport("user32.dll", CharSet = CharSet.Auto)]
			public static extern IntPtr RegisterDeviceNotification(IntPtr hRecipient, IntPtr NotificationFilter, uint Flags);
			[DllImport("user32.dll", CharSet = CharSet.Auto)]
			public static extern uint UnregisterDeviceNotification(IntPtr hHandle);
			//
			// CreateFile  - MSDN
			const uint GENERIC_READ = 0x80000000;
			const uint OPEN_EXISTING = 3;
			const uint FILE_SHARE_READ = 0x00000001;
			const uint FILE_SHARE_WRITE = 0x00000002;
			const uint FILE_ATTRIBUTE_NORMAL = 128;
			const uint FILE_FLAG_BACKUP_SEMANTICS = 0x02000000;
			static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
			// should be "static extern unsafe"
			[DllImport("kernel32", SetLastError = true)]
			static extern IntPtr CreateFile
										(
											string FileName,					// file name
											uint DesiredAccess,				// access mode
											uint ShareMode,					// share mode
											uint SecurityAttributes,			// Security Attributes
											uint CreationDisposition,		  // how to create
											uint FlagsAndAttributes,			// file attributes
											int hTemplateFile				  // handle to template file
										);
			[DllImport("kernel32", SetLastError = true)]
			static extern bool CloseHandle
										(
											IntPtr hObject   // handle to object
										);
			static public IntPtr OpenDirectory(string dirPath)
			{
				// open the existing file for reading		 
				IntPtr handle = CreateFile
										(
											dirPath,
											GENERIC_READ,
											FILE_SHARE_READ | FILE_SHARE_WRITE,
											0,
											OPEN_EXISTING,
											FILE_FLAG_BACKUP_SEMANTICS | FILE_ATTRIBUTE_NORMAL,
											0
										);
				if (handle == INVALID_HANDLE_VALUE)
				{
					return IntPtr.Zero;
				}
				else
				{
					return handle;
				}
			}
			public static bool CloseDirectoryHandle(IntPtr handle)
			{
				return CloseHandle(handle);
			}
		}
		// Structure with information for RegisterDeviceNotification.
		[StructLayout(LayoutKind.Sequential)]
		public struct DEV_BROADCAST_HANDLE
		{
			public int dbch_size;
			public int dbch_devicetype;
			public int dbch_reserved;
			public IntPtr dbch_handle;
			public IntPtr dbch_hdevnotify;
			public Guid dbch_eventguid;
			public long dbch_nameoffset;
			//public byte[] dbch_data[1]; // = new byte[1];
			public byte dbch_data;
			public byte dbch_data1;
		}
		// Struct for parameters of the WM_DEVICECHANGE message
		[StructLayout(LayoutKind.Sequential)]
		public struct DEV_BROADCAST_VOLUME
		{
			public int dbcv_size;
			public int dbcv_devicetype;
			public int dbcv_reserved;
			public int dbcv_unitmask;
		}
	}
}

#T=USB Drive Detect Service
namespace WindowsService1
{
	using System;
	using System.IO;
	using System.Runtime.InteropServices;
	
	using System.ServiceProcess;
	using System.ComponentModel;
	using System.Security.Principal;
	using System.Configuration.Install;
	using System.Text;
	//以下就是比普通应用程序多出的 ProjectInstaller
	[RunInstallerAttribute(true)]
	public class ProjectInstaller: Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = Service1.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
	public partial class Service1 : ServiceBase
	{
		public static readonly string serviceName = "USB detect Service1";
		public static void Main(string[] args)
		{
			Service1 x = new Service1();
			int l = 0;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0) //有参数时以 console 方式运行
			{
				Console.WriteLine("Run as Console");
				x.OnStart(null);
				Console.ReadLine();
			}
			else
			//intallutil 成服务后
			//即: 无参数时,以 Service 方式运行
			{
				Console.WriteLine("Run as Service");
				ServiceBase.Run(x);
			}
		}
		public Service1()
		{
			CanPauseAndContinue = true;
			ServiceName = Service1.serviceName;
		}
		#region Fields
		private FileSystemWatcher fileSystemWatcher;
		private IntPtr deviceNotifyHandle;
		private IntPtr directoryHandle;
		private Win32.ServiceControlHandlerEx myCallback;
		#endregion
		#region USB Detection
		private int ServiceControlHandler(int control, int eventType, IntPtr eventData, IntPtr context)
		{
			if (control == Win32.SERVICE_CONTROL_STOP || control == Win32.SERVICE_CONTROL_SHUTDOWN)
			{
				UnregisterHandles();
				Win32.UnregisterDeviceNotification(this.ServiceHandle);
				base.Stop();
			}
			else if (control == Win32.SERVICE_CONTROL_DEVICEEVENT)
			{
				switch (eventType)
				{
					case Win32.DBT_DEVICEARRIVAL:
						Win32.DEV_BROADCAST_HDR hdr;
						hdr = (Win32.DEV_BROADCAST_HDR)
							Marshal.PtrToStructure(eventData, typeof(Win32.DEV_BROADCAST_HDR));
						if (hdr.dbcc_devicetype == Win32.DBT_DEVTYP_DEVICEINTERFACE)
						{
							Win32.DEV_BROADCAST_DEVICEINTERFACE deviceInterface;
							deviceInterface = (Win32.DEV_BROADCAST_DEVICEINTERFACE)
								Marshal.PtrToStructure(eventData, typeof(Win32.DEV_BROADCAST_DEVICEINTERFACE));
							string name = new string(deviceInterface.dbcc_name);
							name = name.Substring(0, name.IndexOf('\0')) + "\\";
							StringBuilder stringBuilder = new StringBuilder();
							Win32.GetVolumeNameForVolumeMountPoint(name, stringBuilder, 100);
							uint stringReturnLength = 0;
							string driveLetter = "";
							Win32.GetVolumePathNamesForVolumeNameW(stringBuilder.ToString(), driveLetter, (uint)driveLetter.Length, ref stringReturnLength);
							if (stringReturnLength == 0)
							{
								// TODO handle error
							}
							driveLetter = new string(new char[stringReturnLength]);
							if (!Win32.GetVolumePathNamesForVolumeNameW(stringBuilder.ToString(), driveLetter, stringReturnLength, ref stringReturnLength))
							{
								// TODO handle error
							}
							RegisterForHandle(driveLetter[0]);
							fileSystemWatcher.Path = driveLetter[0] + ":\\";
							fileSystemWatcher.EnableRaisingEvents = true;
						}
						break;
					case Win32.DBT_DEVICEQUERYREMOVE:
						UnregisterHandles();
						fileSystemWatcher.EnableRaisingEvents = false;
						break;
				}
			}
			return 0;
		}
		private void UnregisterHandles()
		{
			if (directoryHandle != IntPtr.Zero)
			{
				Win32.CloseHandle(directoryHandle);
				directoryHandle = IntPtr.Zero;
			}
			if (deviceNotifyHandle != IntPtr.Zero)
			{
				Win32.UnregisterDeviceNotification(deviceNotifyHandle);
				deviceNotifyHandle = IntPtr.Zero;
			}
		}
		private void RegisterForHandle(char c)
		{
			Win32.DEV_BROADCAST_HANDLE deviceHandle = new Win32.DEV_BROADCAST_HANDLE();
			int size = Marshal.SizeOf(deviceHandle);
			deviceHandle.dbch_size = size;
			deviceHandle.dbch_devicetype = Win32.DBT_DEVTYP_HANDLE;
			directoryHandle = CreateFileHandle(c + ":\\");
			deviceHandle.dbch_handle = directoryHandle;
			IntPtr buffer = Marshal.AllocHGlobal(size);
			Marshal.StructureToPtr(deviceHandle, buffer, true);
			deviceNotifyHandle = Win32.RegisterDeviceNotification(this.ServiceHandle, buffer, Win32.DEVICE_NOTIFY_SERVICE_HANDLE);
			if (deviceNotifyHandle == IntPtr.Zero)
			{
				// TODO handle error
			}
		}
		private void RegisterDeviceNotification()
		{
			myCallback = new Win32.ServiceControlHandlerEx(ServiceControlHandler);
			Win32.RegisterServiceCtrlHandlerEx(this.ServiceName, myCallback, IntPtr.Zero);
			if (this.ServiceHandle == IntPtr.Zero)
			{
				// TODO handle error
			}
			Win32.DEV_BROADCAST_DEVICEINTERFACE deviceInterface = new Win32.DEV_BROADCAST_DEVICEINTERFACE();
			int size = Marshal.SizeOf(deviceInterface);
			deviceInterface.dbcc_size = size;
			deviceInterface.dbcc_devicetype = Win32.DBT_DEVTYP_DEVICEINTERFACE;
			IntPtr buffer = default(IntPtr);
			buffer = Marshal.AllocHGlobal(size);
			Marshal.StructureToPtr(deviceInterface, buffer, true);
			IntPtr r = default(IntPtr);
			r = Win32.RegisterDeviceNotification(this.ServiceHandle, buffer, Win32.DEVICE_NOTIFY_SERVICE_HANDLE | Win32.DEVICE_NOTIFY_ALL_INTERFACE_CLASSES);
			if (r == IntPtr.Zero)
			{
				// TODO handle error
				Console.WriteLine("RegisterDeviceNotification error");
			}
		}
		#endregion
		#region Events
		void fileSystemWatcher_Created(object sender, System.IO.FileSystemEventArgs e)
		{
			// TODO handle event
			Console.WriteLine("fileSystemWatcher_Created");
		}
		void fileSystemWatcher_Renamed(object sender, System.IO.RenamedEventArgs e)
		{
			// TODO handle event
			Console.WriteLine("fileSystemWatcher_Renamed");
		}
		void fileSystemWatcher_Changed(object sender, System.IO.FileSystemEventArgs e)
		{
			// TODO handle event
			Console.WriteLine("fileSystemWatcher_Changed");
		}
		void fileSystemWatcher_Deleted(object sender, System.IO.FileSystemEventArgs e)
		{
			// TODO handle event
			Console.WriteLine("fileSystemWatcher_Deleted");
		}
		#endregion
		#region Private Helper Methods
		public static IntPtr CreateFileHandle(string driveLetter)
		{
			// open the existing file for reading		  
			IntPtr handle = Win32.CreateFile(
				  driveLetter,
				  Win32.GENERIC_READ,
				  Win32.FILE_SHARE_READ | Win32.FILE_SHARE_WRITE,
				  0,
				  Win32.OPEN_EXISTING,
				  Win32.FILE_FLAG_BACKUP_SEMANTICS | Win32.FILE_ATTRIBUTE_NORMAL,
				  0);
			if (handle == Win32.INVALID_HANDLE_VALUE)
			{
				return IntPtr.Zero;
			}
			else
			{
				return handle;
			}
		}
		#endregion
		#region ServiceBase Implementation
		protected override void OnStart(string[] args)
		{
			base.OnStart(args);
			RegisterDeviceNotification();
			fileSystemWatcher = new FileSystemWatcher();
			fileSystemWatcher.Created += new System.IO.FileSystemEventHandler(fileSystemWatcher_Created);
			fileSystemWatcher.Deleted += new System.IO.FileSystemEventHandler(fileSystemWatcher_Deleted);
			fileSystemWatcher.Changed += new System.IO.FileSystemEventHandler(fileSystemWatcher_Changed);
			fileSystemWatcher.Renamed += new System.IO.RenamedEventHandler(fileSystemWatcher_Renamed);
		}
		#endregion
	}
	public class Win32
	{
		public const int DEVICE_NOTIFY_SERVICE_HANDLE = 1;
		public const int DEVICE_NOTIFY_ALL_INTERFACE_CLASSES = 4;
		public const int SERVICE_CONTROL_STOP = 1;
		public const int SERVICE_CONTROL_DEVICEEVENT = 11;
		public const int SERVICE_CONTROL_SHUTDOWN = 5;
		public const uint GENERIC_READ = 0x80000000;
		public const uint OPEN_EXISTING = 3;
		public const uint FILE_SHARE_READ = 1;
		public const uint FILE_SHARE_WRITE = 2;
		public const uint FILE_SHARE_DELETE = 4;
		public const uint FILE_ATTRIBUTE_NORMAL = 128;
		public const uint FILE_FLAG_BACKUP_SEMANTICS = 0x02000000;
		public static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
		public const int DBT_DEVTYP_DEVICEINTERFACE = 5;
		public const int DBT_DEVTYP_HANDLE = 6;
		public const int DBT_DEVICEARRIVAL = 0x8000;
		public const int DBT_DEVICEQUERYREMOVE = 0x8001;
		public const int DBT_DEVICEREMOVECOMPLETE = 0x8004;
		public const int WM_DEVICECHANGE = 0x219;
		public delegate int ServiceControlHandlerEx(int control, int eventType, IntPtr eventData, IntPtr context);
		[DllImport("advapi32.dll", SetLastError = true)]
		public static extern IntPtr RegisterServiceCtrlHandlerEx(string lpServiceName, ServiceControlHandlerEx cbex, IntPtr context);
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetVolumePathNamesForVolumeNameW(
				[MarshalAs(UnmanagedType.LPWStr)]
					string lpszVolumeName,
				[MarshalAs(UnmanagedType.LPWStr)]
					string lpszVolumePathNames,
				uint cchBuferLength,
				ref UInt32 lpcchReturnLength);
		[DllImport("kernel32.dll")]
		public static extern bool GetVolumeNameForVolumeMountPoint(string
		   lpszVolumeMountPoint, [Out] StringBuilder lpszVolumeName,
		   uint cchBufferLength);
		[DllImport("user32.dll", SetLastError = true)]
		public static extern IntPtr RegisterDeviceNotification(IntPtr IntPtr, IntPtr NotificationFilter, Int32 Flags);
		[DllImport("user32.dll", CharSet = CharSet.Auto)]
		public static extern uint UnregisterDeviceNotification(IntPtr hHandle);
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr CreateFile(
			  string FileName,					// file name
			  uint DesiredAccess,				 // access mode
			  uint ShareMode,					 // share mode
			  uint SecurityAttributes,			// Security Attributes
			  uint CreationDisposition,		   // how to create
			  uint FlagsAndAttributes,			// file attributes
			  int hTemplateFile				   // handle to template file
			  );
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool CloseHandle(IntPtr hObject);
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct DEV_BROADCAST_DEVICEINTERFACE
		{
			public int dbcc_size;
			public int dbcc_devicetype;
			public int dbcc_reserved;
			[MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst = 16)]
			public byte[] dbcc_classguid;
			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
			public char[] dbcc_name;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct DEV_BROADCAST_HDR
		{
			public int dbcc_size;
			public int dbcc_devicetype;
			public int dbcc_reserved;
		}
		[StructLayout(LayoutKind.Sequential)]
		public struct DEV_BROADCAST_HANDLE
		{
			public int dbch_size;
			public int dbch_devicetype;
			public int dbch_reserved;
			public IntPtr dbch_handle;
			public IntPtr dbch_hdevnotify;
			public Guid dbch_eventguid;
			public long dbch_nameoffset;
			public byte dbch_data;
			public byte dbch_data1;
		}
	}
}

#T=UserTokenHelper
namespace TestApplication
{

	using System;
	using Microshaoft.Util;

	using Microshaoft.Portal.Util;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main()
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//

			string key = CryptoHelper.GenerateTripleDESHexStringKey();
			string iv = CryptoHelper.GenerateTripleDESHexStringIV();
			
			Console.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.s"));
			string UserToken = TokenHelper.GenerateUserToken
			(
				key
				, iv
				, "cqctc001@Microshaoft.com"
				, "04000000002"
				, "cqctc001"
				, 5 //5秒钟后过期

				, ""
				, "00"
				, "00"
			);
			Console.WriteLine(UserToken);
			//等5秒后回车后,该Token 过期
			Console.ReadLine();
			string originalUserTokenText = TokenHelper.DecryptUserToken
				(
					key
					, iv
					, UserToken
				);

			UserInfo u ;
			bool b = TokenHelper.IsValidUserToken
				(
					key
					, iv
					, UserToken
					, out originalUserTokenText
					, out u
				);
			Console.WriteLine("Token 是否有效: {0}", b);
			Console.WriteLine(originalUserTokenText);

			if (b)
			{
				Console.WriteLine(u.UserID);
			}


			Console.ReadLine();
		}
	}
}

namespace Microshaoft.Portal.Util
{
	using System;
	using System.Collections.Specialized;
	using System.Text;
	using Microshaoft.Util;


	public class UserInfo
	{
		public UserInfo(NameValueCollection collection)
		{
			_UserID = collection["UserID"];
		}
		private string _UserID;
		public string UserID
		{
			get
			{
				return _UserID;
			}
		}

	}

	public class TokenHelper
	{
		/// <summary>
		/// 校验userToken
		/// </summary>
		/// <param name="TripleDESHexStringKey"></param>
		/// <param name="TripleDESHexStringIV"></param>
		/// <param name="userToken"></param>
		/// <param name="originalUserTokenText"></param>
		/// <returns></returns>
		public static bool IsValidUserToken
				(
					string TripleDESHexStringKey
					, string TripleDESHexStringIV
					, string userTokenText
					, out string originalUserTokenText
					, out UserInfo user
				)
		{
			originalUserTokenText = DecryptUserToken
				(
					TripleDESHexStringKey
					, TripleDESHexStringIV
					, userTokenText
				);
			string[] A = originalUserTokenText.Split('$');
			int l = A.Length;
			NameValueCollection nvc = new NameValueCollection();

			for (int i = 0; i < l - 1; i++)
			{
				string[] a = A[i].Split('=');
				nvc.Add(a[0], a[1]);
			}

			DateTime dt;

			if (DateTime.TryParse(nvc["ExpireTime"], out dt))
			{
				if (dt < DateTime.Now)
				{
					//过期
					user = null;
					return false;
				}
			}
			else
			{
				user = null;
				return false;
			}

			//以下仅对摘要信息进行了校验
			string originalDigest = string.Format
				(
					"{1}{0}{2}"
					, ""
					, nvc["UserID"]	//UserID
					, nvc["UserAccount"]	//UserAccount
				);
			string digest = Convert.ToBase64String(CryptoHelper.ComputeSHA1(originalDigest));
			if (digest != A[l - 1])
			{
				user = null;
				return false;
			}
			user = new UserInfo(nvc);
			return true;
			
		}
		

		/// <summary>
		/// 解密userToken
		/// </summary>
		/// <param name="TripleDESHexStringKey"></param>
		/// <param name="TripleDESHexStringIV"></param>
		/// <param name="userToken"></param>
		/// <returns></returns>
		public static string DecryptUserToken
				(
					string TripleDESHexStringKey
					, string TripleDESHexStringIV
					, string userToken
				)
		{


				byte[] buffer = CryptoHelper.DecryptTripleDES
									(
										userToken
										, CryptoHelper.HexStringToBytesArray(TripleDESHexStringKey)
										, CryptoHelper.HexStringToBytesArray(TripleDESHexStringIV)
									);
				buffer = GZipHelper.Decompress(buffer);
			
			return

				Encoding.UTF8.GetString
					(
						buffer
					);

		}
		/// <summary>
		/// 生成userToken
		/// </summary>
		/// <param name="TripleDESHexStringKey"></param>
		/// <param name="TripleDESHexStringIV"></param>
		/// <param name="userAccount"></param>
		/// <param name="userID"></param>
		/// <param name="nickName"></param>
		/// <param name="expireTime"></param>
		/// <param name="secretID"></param>
		/// <param name="authType"></param>
		/// <param name="paymentAuthType"></param>
		/// <returns></returns>
		public static string GenerateUserToken
			(
				string TripleDESHexStringKey
				, string TripleDESHexStringIV
				, string userAccount			//用户的帐号
				, string userID					//用户的唯一标识
				, string nickName				//用户昵称
				, int expireTimeInSeconds		//失效时间
				, string secretID				//系统之间共享密钥的ID
				, string authType				//登陆认证的类型，
				, string paymentAuthType		//支付认证类型
			)
		{
			//string originalUserTokenText  =  "UserAccount" "=" value";""UserID" "=" value ";" "ExpireTime" "=" value";""NickName" "=" value";""AuthType" "=" value";""PaymentAuthType" "=" value"
			string originalUserTokenText = string.Format
				(
					//UserToken 的字段、格式
					"UserAccount={1}{0}UserID={2}{0}NickName={3}{0}ExpireTime={4}{0}AuthType={5}{0}PaymentAuthType={6}"
					, "$" //Token 字段分割符
					, userAccount
					, userID
					, nickName
					, DateTime.Now.AddSeconds(expireTimeInSeconds).ToString("yyyy-MM-dd HH:mm:ss.s")

					, authType
					, paymentAuthType
				);
			string originalDigest = string.Format
				(
					"{1}{0}{2}"
					, ""
					, userID
					, userAccount
				);
			string digest = Convert.ToBase64String(CryptoHelper.ComputeSHA1(originalDigest));
			//usertoken = Base64(3DES(originalUserTokenText + "$" + Digest))

			originalUserTokenText = string.Format
				(
					"{1}{0}{2}"
					, "$"
					, originalUserTokenText
					, digest
				);

			byte[] buffer = Encoding.UTF8.GetBytes
									(
										originalUserTokenText
									);

			//Console.WriteLine(buffer.Length);
			buffer = GZipHelper.Compress(buffer);
			//Console.WriteLine(buffer.Length);

			string userToken;

			//Console.WriteLine(userToken);
			userToken = Convert.ToBase64String
				(
					CryptoHelper.EncryptTripleDES
						(
							//originalUserTokenText
							//, Encoding.UTF8
							buffer
							, CryptoHelper.HexStringToBytesArray(TripleDESHexStringKey)
							, CryptoHelper.HexStringToBytesArray(TripleDESHexStringIV)
						)
				);

			return userToken;
		}

	}
}

namespace Microshaoft.Util
{

	using System;
	using System.Security.Cryptography;
	using System.Text;
	using System.IO;
	using System.IO.Compression;




	/// <summary>
	/// Crypto 的摘要说明。
	/// </summary>
	public class GZipHelper
	{
		public static byte[] Compress(byte[] data)
		{
			MemoryStream ms = new MemoryStream();
			GZipStream gzs = new GZipStream(ms, CompressionMode.Compress, true);
			gzs.Write(data, 0, data.Length);
			gzs.Close();
			long l = ms.Length;
			ms.Position = 0;
			byte[] buffer = new byte[l];
			ms.Read(buffer, 0, (int) l);
			ms.Close();
			ms = null;
			return buffer;
		}
		public static byte[] Decompress(byte[] data)
		{
			MemoryStream ms1 = new MemoryStream(data);
			MemoryStream ms2  = new MemoryStream();
			GZipStream gzs = new GZipStream(ms1, CompressionMode.Decompress);
			byte[] buffer = new byte[128];
			int l = buffer.Length;
			int r = 0;
			while (true)
			{
				r = gzs.Read(buffer, 0, l);
				if (r > 0)
				{
					ms2.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			ms1.Close();
			ms1 = null;
			ms2.Position = 0;
			l = (int) ms2.Length;
			buffer = new byte[l];
			ms2.Read(buffer, 0, (int) l);
			ms2.Close();
			ms2 = null;
			return buffer;
		}
	}

	public class CryptoHelper
	{
		public static byte[] DecryptTripleDES
			(
				byte[] data
				, byte[] Key
				, byte[] IV
			)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
		}

		public static byte[] DecryptTripleDES
			(
				string text
				, string Base64Key
				, string Base64IV
			)
		{
			return DecryptTripleDES
				(
					Convert.FromBase64String(text)
					, Convert.FromBase64String(Base64Key)
					, Convert.FromBase64String(Base64IV)
				);

		}

		public static byte[] DecryptTripleDES
			(
				string text
				, byte[] Key
				, byte[] IV
			)
		{
			return DecryptTripleDES
				(
					Convert.FromBase64String(text)
					, Key
					, IV
				);
		}

		public static string DecryptTripleDES
			(
				string text
				, string Base64Key
				, string Base64IV
				, Encoding e //原文的encoding
			)
		{
			return e.GetString
				(
					DecryptTripleDES
						(
							text
							, Base64Key
							, Base64IV
						)
				);
		}

		public static string DecryptTripleDES
			(
				string text
				, byte[] Key
				, byte[] IV
				, Encoding e //原文的encoding
			)
		{
			return e.GetString
				(
					DecryptTripleDES
						(
							text
							, Key
							, IV
						)
				);
		}

		public static string GenerateTripleDESHexStringKey()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateKey();
			return BytesArrayToHexString(des.Key);
		}
		public static string GenerateTripleDESHexStringIV()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateIV();
			return BytesArrayToHexString(des.IV);
		}

		public static byte[] EncryptTripleDES
			(
				byte[] data
				, byte[] Key
				, byte[] IV
			)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
		}

		public static byte[] EncryptTripleDES
			(
				string text
				, Encoding e
				, byte[] Key
				, byte[] IV
			)
		{
			return EncryptTripleDES
				(
					e.GetBytes(text)
					, Key
					, IV
				);

		}

		public static byte[] EncryptTripleDES
			(
				string text
				, Encoding e
				, string Base64Key
				, string Base64IV
			)
		{
			return EncryptTripleDES
				(
					text
					, e
					, Convert.FromBase64String(Base64Key)
					, Convert.FromBase64String(Base64IV)
				);
		}


		public static byte[] ComputeSHA1(byte[] data)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(data);
		}

		public static byte[] ComputeSHA1(string text, Encoding e)
		{
			return ComputeSHA1(e.GetBytes(text));
		}

		public static byte[] ComputeSHA1(string text)
		{
			return ComputeSHA1(text, Encoding.UTF8);
		}
		public static byte[] ComputeMD5(byte[] data)
		{
			return new MD5CryptoServiceProvider().ComputeHash(data, 0, data.Length);
		}
		public static byte[] ComputeMD5(string text, Encoding e)
		{
			return ComputeMD5(e.GetBytes(text));
		}
		public static byte[] ComputeMD5(string text)
		{
			return ComputeMD5(text, Encoding.UTF8);
		}

		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}
#T=Verify Code 图形验证码
//VerifyCodePlaceHolder.aspx.cs
namespace Microshaoft.Web
{
	using System;
	using System.Configuration;
	using System.Web;
	using System.Web.UI;
	using Microshaoft;
	public class VerifyCodePlaceHolder : Page
	{
		public static string _UrlPrefix = ConfigurationManager.AppSettings["UrlPrefix"];
		private static string _TripleDESKey = ConfigurationManager.AppSettings["TripleDESKey"];
		private static string _TripleDESIV = ConfigurationManager.AppSettings["TripleDESIV"];
		public int _W = IntegerHelper.Int32Parse(ConfigurationManager.AppSettings["DefaultWidth"]);
		public int _H = IntegerHelper.Int32Parse(ConfigurationManager.AppSettings["DefaultHeight"]);
		public int _L = IntegerHelper.Int32Parse(ConfigurationManager.AppSettings["DefaultTextLength"]);
		public string _RequestRSAPublicKey;
		public string _ImgID = "ID_" + Guid.NewGuid().ToString().Replace("-", "_");
		public string _DivID = "ID_" + Guid.NewGuid().ToString().Replace("-", "_");
		public string _DivObjVar = "var_" + Guid.NewGuid().ToString().Replace("-", "_");
		public string _DivChildrenNodesObjVar = "var_" + Guid.NewGuid().ToString().Replace("-", "_");
		public string _DivChildNodeObjVar = "var_" + Guid.NewGuid().ToString().Replace("-", "_");
		public string _iVar = "var_" + Guid.NewGuid().ToString().Replace("-", "_");
		public string _FunctionName = "function_" + Guid.NewGuid().ToString().Replace("-", "_");
		public string _CallbackName;
		public string _RefreshCallName;
		public string _RSASignMode;
		public string _ScriptObjVar = "var_" + Guid.NewGuid().ToString().Replace("-", "_");
		protected void Page_Load(object sender, EventArgs e)
		{
			if (!_UrlPrefix.EndsWith("/"))
			{
				_UrlPrefix += "/";
			}
			//AntiXss
			_CallbackName = HttpUtility.HtmlEncode(Request.QueryString["callback"]);
			_RefreshCallName = HttpUtility.HtmlEncode(Request.QueryString["refresh"]);
			_RequestRSAPublicKey = HttpUtility.HtmlEncode(Request.QueryString["rsa"]);
			_RSASignMode = HttpUtility.HtmlEncode(Request.QueryString["sign"]);
			string s = Request.QueryString["w"];
			if (StringHelper.IsValidString(s))
			{
				_W = IntegerHelper.Int32Parse(s);
			}
			s = Request.QueryString["h"];
			if (StringHelper.IsValidString(s))
			{
				_H = IntegerHelper.Int32Parse(s);
			}
			s = Request.QueryString["l"];
			if (StringHelper.IsValidString(s))
			{
				_L = IntegerHelper.Int32Parse(s);
			}
		}
	}
}
//CodeGenerator.aspx.cs
namespace Microshaoft.Web
{
	using System;
	using System.Configuration;
	using System.Text;
	using System.Web;
	using System.Web.UI;
	using System.Security.Cryptography;
	using Microshaoft;
	public class CodeGenerator : Page
	{
		public static string _UrlPrefix = ConfigurationManager.AppSettings["UrlPrefix"];
		private static string _TripleDESKey = ConfigurationManager.AppSettings["TripleDESKey"];
		private static string _TripleDESIV = ConfigurationManager.AppSettings["TripleDESIV"];
		public int _W = IntegerHelper.Int32Parse(ConfigurationManager.AppSettings["DefaultWidth"]);
		public int _H = IntegerHelper.Int32Parse(ConfigurationManager.AppSettings["DefaultHeight"]);
		public int _L = IntegerHelper.Int32Parse(ConfigurationManager.AppSettings["DefaultTextLength"]);
		public string _RequestRSAPublicKey;
		public string _RSASignMode;
		public string _ResponseRSAPublicKey;
		public string _ResponseRSASignature;
		public string _ImgID;
		public string _ImgObjVar = "var_" + Guid.NewGuid().ToString().Replace("-", "_");
		public string _CallbackName;
		public string _OrignalVerifyCode;
		public string _EncryptedVerifyCode;
		public string _TripleDESEncryptedVerifyCode;
		public string _EncryptedMode;
		protected void Page_Load(object sender, EventArgs e)
		{
			if (!_UrlPrefix.EndsWith("/"))
			{
				_UrlPrefix += "/";
			}
			//AntiXss
			_ImgID = HttpUtility.HtmlEncode(Request.QueryString["imgid"]);
			_CallbackName = HttpUtility.HtmlEncode(Request.QueryString["callback"]);
			_RequestRSAPublicKey = Request.QueryString["rsa"];
			_RSASignMode = Request.QueryString["sign"];
			if (!StringHelper.IsValidString(_RSASignMode))
			{
				_RSASignMode = "";
			}
			string s = Request.QueryString["w"];
			if (StringHelper.IsValidString(s))
			{
				_W = IntegerHelper.Int32Parse(s);
			}
			s = Request.QueryString["h"];
			if (StringHelper.IsValidString(s))
			{
				_H = IntegerHelper.Int32Parse(s);
			}
			s = Request.QueryString["l"];
			if (StringHelper.IsValidString(s))
			{
				_L = IntegerHelper.Int32Parse(s);
			}
			s = RandomHelper.GenerateText
									(
										new char[]
												{
													'j', 'k', 'm', 'n', 'p',
													'2', '3', '4',
													'A', 'C', 'D', 'E', 'F',
													//'G',
													'H' , 'J',
													'a', 'c', 'd',
													//'e',
													'f', 'g', 'h', 'i',
													'5', '6', '7',
													'K', 'L', 'M', 'N', 'P','R', 'S', 'T', 'W', 'X',
													's',
													//'t',
													'w', 'x'
												},
										_L
									);
			_OrignalVerifyCode = string.Format
											(
												"{1}{0}{2}",
												"\t",
												s,
												DateTime.Now.ToString("yyyyMMddHHmmss")
											);
			byte[] buffer = Encoding.ASCII.GetBytes(_OrignalVerifyCode);
			byte[] bytes = CryptoHelper.TripleDESEncrypt
											(
												buffer,
												CryptoHelper.HexStringToBytesArray(_TripleDESKey),
												CryptoHelper.HexStringToBytesArray(_TripleDESIV)
											);
			_TripleDESEncryptedVerifyCode = CryptoHelper.BytesArrayToHexString(bytes);
			if (StringHelper.IsValidString(_RequestRSAPublicKey))
			{
				bytes = CryptoHelper.HexStringToBytesArray(_RequestRSAPublicKey);
				_RequestRSAPublicKey = Encoding.ASCII.GetString(bytes);
				bytes = CryptoHelper.RSAEncrypt(buffer, _RequestRSAPublicKey, true);
				_EncryptedVerifyCode = CryptoHelper.BytesArrayToHexString(bytes);
				_EncryptedMode = "RSA";
			}
			else
			{
				_EncryptedVerifyCode = _TripleDESEncryptedVerifyCode;
				_EncryptedMode = "3DES";
			}

			if (_RSASignMode.ToLower() == "md5")
			{
				RSACryptoServiceProvider x = new RSACryptoServiceProvider();
				//rsa privateKey
				string key = x.ToXmlString(true);
				//signature rsa md5
				bytes = CryptoHelper.RSASignMD5(buffer, key);
				_ResponseRSASignature = CryptoHelper.BytesArrayToHexString(bytes);
				//rsa publicKey
				_ResponseRSASignature = CryptoHelper.BytesArrayToHexString(bytes);
				//rsa publicKey
				key = x.ToXmlString(false);
				bytes = Encoding.ASCII.GetBytes(key);
				_ResponseRSAPublicKey = CryptoHelper.BytesArrayToHexString(bytes);
			}
			else if (_RSASignMode.ToLower() == "sha1")
			{
				RSACryptoServiceProvider x = new RSACryptoServiceProvider();
				//rsa privateKey
				string key = x.ToXmlString(true);
				//signature rsa sha1
				bytes = CryptoHelper.RSASignSHA1(buffer, key);
				_ResponseRSASignature = CryptoHelper.BytesArrayToHexString(bytes);
				//rsa publicKey
				key = x.ToXmlString(false);
				bytes = Encoding.ASCII.GetBytes(key);
				_ResponseRSAPublicKey = CryptoHelper.BytesArrayToHexString(bytes);
			}
		}
	}
}
//CodeImage.aspx.cs
namespace Microshaoft.Web
{
	using System;
	using System.Configuration;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.IO;
	using System.Text;
	using System.Web.UI;
	using Microshaoft;
	public class CodeImage : Page
	{
		private static string _TripleDESKey = ConfigurationManager.AppSettings["TripleDESKey"];
		private static string _TripleDESIV = ConfigurationManager.AppSettings["TripleDESIV"];
		public int _W = IntegerHelper.Int32Parse(ConfigurationManager.AppSettings["DefaultWidth"]);
		public int _H = IntegerHelper.Int32Parse(ConfigurationManager.AppSettings["DefaultHeight"]);
		protected void Page_Load(object sender, EventArgs e)
		{
			string text = Request.QueryString["text"];
			byte[] buffer = CryptoHelper.TripleDESDecrypt
											(
												CryptoHelper.HexStringToBytesArray(text),
												CryptoHelper.HexStringToBytesArray(_TripleDESKey),
												CryptoHelper.HexStringToBytesArray(_TripleDESIV)
											);
			//buffer = CryptoHelper.ComputeMD5(buffer);
			text = Encoding.ASCII.GetString(buffer);
			string[] a = text.Split(new char[] {'\t' });
			text = a[0];
			
			string s = Request.QueryString["w"];
			if (StringHelper.IsValidString(s))
			{
				_W = IntegerHelper.Int32Parse(s);
			}
			s = Request.QueryString["h"];
			if (StringHelper.IsValidString(s))
			{
				_H = IntegerHelper.Int32Parse(s);
			}
			Bitmap bmp = GraphicsHelper.DrawGraphicsString
											(
												text,
												new Color[]
														{
															//Color.Tomato,
															//Color.OrangeRed,
															//Color.Olive,
															//Color.Gold,
															//Color.GreenYellow,
															Color.Black,
															Color.Red,
															Color.Green,
															Color.Blue,
															//Color.LawnGreen,
															//Color.Lime,
															//Color.MediumSpringGreen,
															//Color.Aqua,
															//Color.RoyalBlue,
															//Color.MediumBlue,
															//Color.BlueViolet,
															//Color.MediumOrchid,
															//Color.Fuchsia,
															//Color.DeepPink,
															//Color.HotPink
														},
												new Color[]
														{
															Color.Tomato,
															Color.OrangeRed,
															Color.Olive,
															Color.Gold,
															Color.GreenYellow,
															//Color.Black,
															//Color.Red,
															//Color.Green,
															//Color.Blue,
															Color.LawnGreen,
															Color.Lime,
															Color.MediumSpringGreen,
															Color.Aqua,
															Color.RoyalBlue,
															Color.MediumBlue,
															Color.BlueViolet,
															Color.MediumOrchid,
															Color.Fuchsia,
															Color.DeepPink,
															Color.HotPink
														},
												new string[]
														{
															"Times New Roman",
															"Courier New",
															"MS Mincho",
															"Book Antiqua",
															"Gungsuh",
															"PMingLiU"
														},
												_W,
												_H
											);
			MemoryStream ms = new MemoryStream();
			bmp.Save(ms, ImageFormat.Png);
			Response.ClearContent();
			//Response.ContentType = "image/Png";
			Response.BinaryWrite(ms.ToArray());
			bmp.Dispose();
			bmp = null;
			Response.End();
		}
	}
}
//CryptoHelper.cs
namespace Microshaoft
{
	using System;
	using System.Security.Cryptography;
	using System.Text;
	using System.IO;
	class Class1
	{
		static void Main()
		{
			//RSA
			string privateKey = "<RSAKeyValue><Modulus>tvWiOBhMJy8t0aZ7futbIm7IPrrTCH4fwl/4ut360k5syBFVW/WyN50j1aUJmnsp1pPXjt6uGfGNVVOxB9Hku7ppg/pNb2xHGau1Yw4EBTpmyR0jq0YjhluxDQkzQzqWZZwiZRluJ5MMT/WDgn90aeD/adNlir/ZWsKegpW/Kbc=</Modulus><Exponent>AQAB</Exponent><P>84e89A2DhAXiUW9VhKteDoPSFsqM8KvFAyM8irWV5xqrvOzBebEbmm79pdCeoimuSmIWcQydBCDghkxK3jXObw==</P><Q>wFPq8G5yJZGKQTo6NwFXrEptqByJWMdi5GZZNpAn3z0FB7AV+5WSRZCQlB9wWlk7HEnJX2Fb2q0aIU5XBYh9OQ==</Q><DP>Cg8aQ+5m90YS8hAqNR+q8+iH/f8B0VMXASkscAJOHcyhOV2CJFenbzqUaYvzcXlNRK9GhAbkWW5ON93g3crVKw==</DP><DQ>Lf9j/yDLGAUY5cTBS4p8p24dj8lTZ/I3ypxX1d7gSlnTrCUG/Oam1xBeI67pNhKFOpzDFpa4WzJvP2v3EBG2sQ==</DQ><InverseQ>dW2nGb+ynRYFEZFNkcolorILLuJEvsEAd6VD77YQNidQJlHgSFLlrx1m29Ws7rqY6nK+nez+JivzIjCcmn5hWuTQ==</InverseQ><D>a1z1VqmbdpsO7iod6jq+fhQ4WedUE3W/uVaMJUxB9cujtjvFtXMWo+AIuURhwE9qG8siAWrXC85du6ajCg23hRp3gKElDaibYp6B+/4j0jj0EBhGwL8P2D2dMzf4QAoZChI3AwlDSP0zDTS/sFc01Mnz39ch5G8FN95ihiaur6E=</D></RSAKeyValue>";//x.ToXmlString(true);
			Console.WriteLine(privateKey);
			string publicKey = "3C5253414B657956616C75653E3C4D6F64756C75733E747657694F42684D4A79387430615A3766757462496D37495072725443483466776C2F3475743336306B357379424656572F57794E35306A3161554A6D6E7370317050586A7436754766474E56564F784239486B75377070672F704E6232784847617531597734454254706D7952306A7130596A686C757844516B7A517A71575A5A77695A526C754A354D4D542F5744676E39306165442F61644E6C69722F5A57734B656770572F4B62633D3C2F4D6F64756C75733E3C4578706F6E656E743E415141423C2F4578706F6E656E743E3C2F5253414B657956616C75653E";//x.ToXmlString(false);
			byte[] buffer = CryptoHelper.HexStringToBytesArray(publicKey);
			string s = Encoding.ASCII.GetString(buffer);
			Console.WriteLine("{0}", s);
			s = "B156066E1E68A04904CDDA222914C1E864F15C92A88AA907F75AAEB8BF0FAD365AB704C1F5DC40F3159E18D84E9128313448E1D19A2D5AB900F674EA10EA046868385EEAED75DE5D248302BAE3347674BB9F36BDC1F671B667D552CEA9644388DB750432A106B0CFB14DAE7657E188714ACAC2AA9C2C60160DAF17D7D861E404";
			s = "76880CC465DDCBB13D65CDB8738AD51B19553D031E0F34D3DB8860D18A744EC227526078371A27DFFD0A19F2F414145C3F69BE98AA5D9F8B332C12679C5263732096F27A15E0A730D7E0EB5E42607E530A951F31814406A03C688E62A1C52336A18C3A0C3131992CC39150BB2F92D30563EB7CFE52AEA82ED57DA867A936D05F";
			byte[] encryptedData = CryptoHelper.HexStringToBytesArray(s);
			byte[] data = CryptoHelper.RSADecrypt(encryptedData, privateKey, true);
			s = Encoding.ASCII.GetString(data);
			Console.WriteLine("Decrypted plaintext: {0}", s);
			//RSA
			UTF8Encoding e = new UTF8Encoding();
			//byte[]
			data = e.GetBytes("测试@microshaoft.com");
			//byte[] encryptedData;
			//byte[] decryptedData;
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			privateKey = x.ToXmlString(true);
			Console.WriteLine("RSA Private Key: {0}", privateKey);
			publicKey = x.ToXmlString(false);
			Console.WriteLine("RSA Public Key: {0}", publicKey);
			//公钥加密
			encryptedData = CryptoHelper.RSAEncrypt(data, publicKey, false);
			//私钥解密
			data = CryptoHelper.RSADecrypt(encryptedData, privateKey, false);
			Console.WriteLine("RSA Decrypted plaintext: {0}", e.GetString(data));
			//私钥签名
			byte[] signature = CryptoHelper.RSASignSHA1(data, privateKey);
			//公钥验签
			Console.WriteLine(CryptoHelper.RSAVerifySHA1(data, publicKey, signature));
			//TripleDES
			string key = "000111222333444555666777888999aaabbbcccdddeeefff";//48
			string iv = "0123456789abcdef";//16
			data = e.GetBytes("测试@microshaoft.com");
			data = CryptoHelper.TripleDESEncrypt
											(
												data,
												CryptoHelper.HexStringToBytesArray(key),
												CryptoHelper.HexStringToBytesArray(iv)
											);
			data = CryptoHelper.TripleDESDecrypt
											(
												data,
												CryptoHelper.HexStringToBytesArray(key),
												CryptoHelper.HexStringToBytesArray(iv)
											);
			Console.WriteLine("3DES Decrypted plaintext: {0}", e.GetString(data));
			Console.WriteLine(Environment.Version.ToString());
		}
	}
	public class CryptoHelper
	{
		static public byte[] RSASignSHA1
			(
				byte[] data
				, string privateKey
			)
		{
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			x.FromXmlString(privateKey);
			return x.SignHash
						(
							ComputeSHA1(data)
							, "SHA1"
						);
		}
		public static bool RSAVerifySHA1
								(
									byte[] data
									, string publicKey
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.VerifyHash
								(
									ComputeSHA1(data)
									, "SHA1"
									, signature
								);
		}
		public static byte[] RSASignMD5
			(
				byte[] data
				, string privateKey
			)
		{
			RSACryptoServiceProvider x = new RSACryptoServiceProvider();
			x.FromXmlString(privateKey);
			return x.SignHash
						(
							ComputeMD5(data)
							, "MD5"
						);
		}
		public static bool RSAVerifyMD5
								(
									byte[] data
									, string publicKey
									, byte[] signature
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.VerifyHash
								(
									ComputeMD5(data)
									, "MD5"
									, signature
								);
		}
		public static byte[] RSAEncrypt
								(
									byte[] data
									, string publicKey
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(publicKey);
			return provider.Encrypt(data, DoOAEPPadding);
		}
		public static byte[] RSADecrypt
								(
									byte[] data
									, string privateKey
									, bool DoOAEPPadding
								)
		{
			RSACryptoServiceProvider provider = new RSACryptoServiceProvider();
			provider.FromXmlString(privateKey);
			return provider.Decrypt(data, DoOAEPPadding);
		}
		public static byte[] TripleDESDecrypt
			(
				byte[] data
				, byte[] Key
				, byte[] IV
			)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
		}
		public static byte[] TripleDESDecrypt
			(
				string text
				, string Base64Key
				, string Base64IV
			)
		{
			return TripleDESDecrypt
				(
					Convert.FromBase64String(text)
					, Convert.FromBase64String(Base64Key)
					, Convert.FromBase64String(Base64IV)
				);
		}
		public static byte[] TripleDESDecrypt
			(
				string text
				, byte[] Key
				, byte[] IV
			)
		{
			return TripleDESDecrypt
				(
					Convert.FromBase64String(text)
					, Key
					, IV
				);
		}
		public static string TripleDESDecrypt
			(
				string text
				, string Base64Key
				, string Base64IV
				, Encoding e //原文的encoding
			)
		{
			return e.GetString
				(
					TripleDESDecrypt
						(
							text
							, Base64Key
							, Base64IV
						)
				);
		}
		public static string TripleDESDecrypt
			(
				string text
				, byte[] Key
				, byte[] IV
				, Encoding e //原文的encoding
			)
		{
			return e.GetString
				(
					TripleDESDecrypt
						(
							text
							, Key
							, IV
						)
				);
		}
		public static string GenerateTripleDESHexStringKey()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateKey();
			return BytesArrayToHexString(des.Key);
		}
		public static string GenerateTripleDESHexStringIV()
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.GenerateIV();
			return BytesArrayToHexString(des.IV);
		}
		public static byte[] TripleDESEncrypt
			(
				byte[] data
				, byte[] Key
				, byte[] IV
			)
		{
			TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
			des.Key = Key;
			des.IV = IV;
			return des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
		}
		public static byte[] TripleDESEncrypt
			(
				string text
				, Encoding e
				, byte[] Key
				, byte[] IV
			)
		{
			return TripleDESEncrypt
				(
					e.GetBytes(text)
					, Key
					, IV
				);
		}
		public static byte[] TripleDESEncrypt
			(
				string text
				, Encoding e
				, string Base64Key
				, string Base64IV
			)
		{
			return TripleDESEncrypt
				(
					text
					, e
					, Convert.FromBase64String(Base64Key)
					, Convert.FromBase64String(Base64IV)
				);
		}
		public static byte[] ComputeSHA1(byte[] data)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(data);
		}
		public static byte[] ComputeSHA1(string text, Encoding e)
		{
			return ComputeSHA1(e.GetBytes(text));
		}
		public static byte[] ComputeSHA1(string text)
		{
			return ComputeSHA1(text, Encoding.UTF8);
		}
		public static byte[] ComputeSHA1(Stream stream)
		{
			return new SHA1CryptoServiceProvider().ComputeHash(stream);
		}
		public static byte[] ComputeMD5(byte[] data)
		{
			return new MD5CryptoServiceProvider().ComputeHash(data, 0, data.Length);
		}
		public static byte[] ComputeMD5(string text, Encoding e)
		{
			return ComputeMD5(e.GetBytes(text));
		}
		public static byte[] ComputeMD5(string text)
		{
			return ComputeMD5(text, Encoding.UTF8);
		}
		public static byte[] ComputeMD5(Stream stream)
		{
			return new MD5CryptoServiceProvider().ComputeHash(stream);
		}
		public static string BytesArrayToHexString(byte[] data)
		{
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static byte[] HexStringToBytesArray(string text)
		{
			text = text.Replace(" ", "");
			int l = text.Length;
			byte[] buffer = new byte[l / 2];
			for (int i = 0; i < l; i += 2)
			{
				buffer[i / 2] = Convert.ToByte(text.Substring(i, 2), 16);
			}
			return buffer;
		}
	}
}
//GraphicsHelper.cs
namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.Drawing.Imaging;
	public class GraphicsHelper
	{
		public static Bitmap DrawGraphicsString
			(
				string text
				, Color[] foregroundColors
				, Color[] backgroundColors
				, string[] font
				, int width
				, int height
			)
		{
			Bitmap bmp = new Bitmap(width, height);
			Graphics g = Graphics.FromImage(bmp);
			g.Clear(Color.White);
			Random random = new Random();
			//画噪线
			for (int i = 0; i < 10; i++)
			{
				int x1 = random.Next(bmp.Width);
				int y1 = random.Next(bmp.Height);
				int x2 = random.Next(bmp.Width);
				int y2 = random.Next(bmp.Height);
				Color color = backgroundColors[random.Next(backgroundColors.Length)];
				g.DrawLine(new Pen(color), x1, y1, x2, y2);
			}
			//画噪点
			for (int i = 0; i < 100; i++)
			{
				int x = random.Next(bmp.Width);
				int y = random.Next(bmp.Height);
				Color color = backgroundColors[random.Next(backgroundColors.Length)];
				bmp.SetPixel(x, y, color);
			}
			//画边框
			Color col = backgroundColors[random.Next(foregroundColors.Length)];
			g.DrawLine
					(
						new Pen
								(
									backgroundColors[random.Next(foregroundColors.Length)],
									4
								),
						0,
						0,
						bmp.Width - 1,
						0
					);
			g.DrawLine
					(
						new Pen
								(
									backgroundColors[random.Next(foregroundColors.Length)],
									4
								),
						0,
						0,
						0,
						bmp.Height - 1
					);
			g.DrawLine
					(
						new Pen
								(
									backgroundColors[random.Next(foregroundColors.Length)],
									2
								),
						bmp.Width - 1,
						0,
						bmp.Width - 1,
						bmp.Height - 1
					);
			g.DrawLine
					(
						new Pen
								(
									backgroundColors[random.Next(foregroundColors.Length)],
									2
								),
						0,
						bmp.Height - 1,
						bmp.Width - 1,
						bmp.Height - 1
					);
			//画验证码字符串
			for (int i = 0; i < text.Length; i++)
			{
				FontStyle fs = FontStyle.Bold;
				if (random.Next(99) % 2 == 0)
				{
					fs |= FontStyle.Italic;
				}
				Font fnt = new Font
								(
									font[random.Next(font.Length)],
									18,
									fs
								);
				Color color = foregroundColors[random.Next(foregroundColors.Length)];
				g.DrawString(text[i].ToString(), fnt, new SolidBrush(color), (float) i * 20 + 10, (float) 2);
			}
			g.Dispose();
			g = null;
			return bmp;
		}
	}
}
//IntegerHelper.cs
namespace Microshaoft
{
	using System;
	public static class IntegerHelper
	{
		public static int Int32Parse(string text)
		{
			int i = int.TryParse
							(
								text
								, out i
							) ? i : int.MinValue;
			return i;
		}
		public static uint UInt32Parse(string text)
		{
			uint i = uint.TryParse
							(
								text
								, out i
							) ? i : uint.MaxValue;
			return i;
		}
		public static short Int16Parse(string text)
		{
			short i = short.TryParse
							(
								text
								, out i
							) ? i : short.MinValue;
			return i;
		}
		public static ushort UInt16Parse(string text)
		{
			ushort i = ushort.TryParse
							(
								text
								, out i
							) ? i : ushort.MaxValue;
			return i;
		}
		public static long Int64Parse(string text)
		{
			long i = long.TryParse
							(
								text
								, out i
							) ? i : long.MinValue;
			return i;
		}
		public static ulong UInt64Parse(string text)
		{
			ulong i = ulong.TryParse
							(
								text
								, out i
							) ? i : ulong.MaxValue;
			return i;
		}
	}
}
//StringHelper.cs
namespace Microshaoft
{
	using System;
	public static class StringHelper
	{
		public static bool IsValidString(string text)
		{
			return
				(
					text != null &&
					text != string.Empty &&
					text.Trim() != "" &&
					text.Trim().Length > 0
				);
		}
	}
}
//RandomHelper.cs
namespace Microshaoft
{
	using System;
	class RandomHelper
	{
		public static string GenerateText
								(
									char[] characters
									, int length
								)
		{
			Random random = new Random();
			string s = "";
			//生成验证码字符串
			for (int i = 0; i < length; i++)
			{
				s += characters[random.Next(characters.Length)];
			}
			return s;
		}
	}
}

#T=Version Compare 比较运算符重载
namespace Test
{
	using System;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.WriteLine("第一个\".\"和第二个\".\"之间的数字按小数比较,其他按整数比较");
			StringVersion v1 = new StringVersion("021.0390.0010");
			StringVersion v2 = new StringVersion("3.039000.10");
			Console.WriteLine("版本: [{0}][{1}] ", v1.ToString(), v2.ToString());
			Console.WriteLine("GetHashCode: [{0}][{1}] ", v1.GetHashCode(), v2.GetHashCode());
			Console.WriteLine("Equals , {0} ", v1.Equals(v2));
			Console.WriteLine("== , {0} ", v1 == v2);
			Console.WriteLine("!= , {0} ", v1 != v2);
			Console.WriteLine("> , {0} ", v1 > v2);
			Console.WriteLine("< , {0} ", v1 < v2);
			Console.WriteLine(">= , {0} ", v1 >= v2);
			Console.WriteLine("<= , {0} ", v1 <= v2);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	public class StringVersion
	{
		private string[] _versions;
		private string _version;
		protected string[] Versions
		{
			get
			{
				return _versions;
			}
		}
		public StringVersion(string version)
		{
			_version = version;
			char[] c = new char[]{'.'};
			_versions = version.Split(c);
		}
		public override string ToString()
		{
			return _version;
		}
		public override bool Equals(object o)
		{
			StringVersion x = this;
			StringVersion y = o as StringVersion;
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd != yd)
					{
						return false;
					}
				}
				else
				{
					if (xi != yi)
					{
						return false;
					}
				}
			}
			return true;
		}
		public override int GetHashCode()
		{
			string[] a = new string[_versions.Length];
			Array.Copy(_versions, 0, a, 0, a.Length);
			for(int i = 0; i < _versions.Length; i ++)
			{
				if (i == 1)
				{
					a[i] = _versions[i].TrimEnd('0');
				}
				else
				{
					a[i] = _versions[i].TrimStart('0');
				}
			}
			string s = string.Join(".", a);
			return s.GetHashCode();
		}
		public static bool operator == (StringVersion x, StringVersion y)
		{
			return x.Equals(y);
		}
		public static bool operator != (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd != yd)
					{
						return true;
					}
				}
				else
				{
					if (xi != yi)
					{
						return true;
					}
				}
			}
			return false;
		}
		public static bool operator > (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd > yd)
					{
						return true;
					}
					else if (xd < yd)
					{
						return false;
					}
				}
				else
				{
					if (xi > yi)
					{
						return true;
					}
					else if (xi < yi)
					{
						return false;
					}
				}
			}
			return false;
		}
		public static bool operator < (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd < yd)
					{
						return true;
					}
					else if (xd > yd)
					{
						return false;
					}
				}
				else
				{
					if (xi < yi)
					{
						return true;
					}
					else if (xi > yi)
					{
						return false;
					}
				}
			}
			return false;
		}
		public static bool operator >= (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			bool equal = true;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd > yd)
					{
						return true;
					}
					else if (xd < yd)
					{
						return false;
					}
					equal = equal && (xd == yd);
				}
				else
				{
					if (xi > yi)
					{
						return true;
					}
					else if (xi < yi)
					{
						return false;
					}
					equal = equal && (xi == yi);
				}
			}
			return equal;
		}
		public static bool operator <= (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			bool equal = true;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd < yd)
					{
						return true;
					}
					else if (xd > yd)
					{
						return false;
					}
					equal = equal && (xd == yd);
				}
				else
				{
					if (xi < yi)
					{
						return true;
					}
					else if (xi > yi)
					{
						return false;
					}
					equal = equal && (xi == yi);
				}
			}
			return equal;
		}
	}
}

#T=ViewState和DataTable动态录入数据的例子
<%@ Page Language="C#" EnableViewState="true" %>

<%@ Import Namespace="System.Data" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script runat="server">
  private DataTable stoveTable = null;
  protected void Page_Load(object sender, EventArgs e)
  {
    if (!Page.IsPostBack)
    {
      //创建 EmptyDataTemplate
      this.GridView_list.DataBind();
    }
  }

  protected void GridView_list_RowDataBound(object sender, GridViewRowEventArgs e)
  {
    if (e.Row.RowType == DataControlRowType.DataRow)
    {
      String usage = DataBinder.Eval(e.Row.DataItem, "usage").ToString();
      String steelKind = DataBinder.Eval(e.Row.DataItem, "steelKind").ToString();
      String castingTon = DataBinder.Eval(e.Row.DataItem, "castingTon").ToString();
      DropDownList x1 = e.Row.FindControl("x1") as DropDownList;
      DropDownList x2 = e.Row.FindControl("x2") as DropDownList;
      TextBox x3 = e.Row.FindControl("x3") as TextBox;
      x3.Text = castingTon;
      ListItem xx1 = x1.Items.FindByValue(usage);
      if (xx1 != null) xx1.Selected = true;
      ListItem xx2 = x2.Items.FindByValue(steelKind);
      if (xx2 != null) xx2.Selected = true;
    }
  }

  protected void LinkButton1_Click(object sender, EventArgs e)
  {
    DropDownList x1, x2;
    TextBox x3;
    if (GridView_list.Rows.Count == 0)
    {
      x1 = GridView_list.Controls[0].Controls[0].FindControl("x1") as DropDownList;
      x2 = GridView_list.Controls[0].Controls[0].FindControl("x2") as DropDownList;
      x3 = GridView_list.Controls[0].Controls[0].FindControl("x3") as TextBox;
    }
    else
    {
      GridViewRow r = GridView_list.FooterRow;
      x1 = r.FindControl("x1") as DropDownList;
      x2 = r.FindControl("x2") as DropDownList;
      x3 = r.FindControl("x3") as TextBox;
    }
    if (ViewState["dt"] == null)
    {
      stoveTable = new DataTable();
      stoveTable.Columns.Add("usage", typeof(string));
      stoveTable.Columns.Add("steelKind", typeof(string));
      stoveTable.Columns.Add("castingTon", typeof(string));
    }
    else
    {
      stoveTable = (DataTable)ViewState["dt"];
    }
    DataRow newRow = stoveTable.NewRow();
    newRow["usage"] = x1.SelectedValue;
    newRow["steelKind"] = x2.SelectedValue;
    newRow["castingTon"] = x3.Text;
    stoveTable.Rows.Add(newRow);

    ViewState["dt"] = stoveTable;
    this.GridView_list.DataSource = stoveTable;
    this.GridView_list.DataBind();

  }
  protected void LinkButton2_Click(object sender, EventArgs e)
  {
    if (ViewState["dt"] == null)
    {
      return;
    }
    stoveTable = (DataTable)ViewState["dt"];
    if (stoveTable.Rows.Count < 1) return;
    stoveTable.Rows.RemoveAt(stoveTable.Rows.Count - 1);
    ViewState["dt"] = stoveTable;
    this.GridView_list.DataSource = stoveTable;
    this.GridView_list.DataBind();
  }

  protected void x1_SelectedIndexChanged(object sender, EventArgs e)
  {
    DropDownList x1 = sender as DropDownList;
    GridViewRow r = x1.Parent.Parent as GridViewRow;
    if (ViewState["dt"] == null)
    {
      Response.Write("Error");
      return;
    }
    stoveTable = (DataTable)ViewState["dt"];
    stoveTable.Rows[r.RowIndex]["usage"] = x1.SelectedValue;
    ViewState["dt"] = stoveTable;
    this.GridView_list.DataSource = stoveTable;
    this.GridView_list.DataBind();
  }

  protected void x2_SelectedIndexChanged(object sender, EventArgs e)
  {
    DropDownList x2 = sender as DropDownList;
    GridViewRow r = x2.Parent.Parent as GridViewRow;
    if (ViewState["dt"] == null)
    {
      Response.Write("Error");
      return;
    }
    stoveTable = (DataTable)ViewState["dt"];
    stoveTable.Rows[r.RowIndex]["steelKind"] = x2.SelectedValue;
    ViewState["dt"] = stoveTable;
    this.GridView_list.DataSource = stoveTable;
    this.GridView_list.DataBind();
  }

  protected void x3_TextChanged(object sender, EventArgs e)
  {

    TextBox x3 = sender as TextBox;
    GridViewRow r = x3.Parent.Parent as GridViewRow;
    if (ViewState["dt"] == null)
    {
      Response.Write("Error");
      return;
    }
    stoveTable = (DataTable)ViewState["dt"];
    stoveTable.Rows[r.RowIndex]["castingTon"] = x3.Text;
    ViewState["dt"] = stoveTable;
    this.GridView_list.DataSource = stoveTable;
    this.GridView_list.DataBind();
  }
</script>
<html xmlns="http://www.w3.org/1999/xhtml">
<head id="Head1" runat="server">
  <title></title>
</head>
<body>
  <form id="form1" runat="server">
  <asp:GridView ID="GridView_list" runat="server" ShowFooter="true" AutoGenerateColumns="false"
    OnRowDataBound="GridView_list_RowDataBound">
    <EmptyDataTemplate>
      <table style="border-collapse: collapse; width: 100%" cellspacing="0" rules="all"
        border="1">
        <tr>
          <th scope="col">
            选择1
          </th>
          <th scope="col">
            选择2
          </th>
          <th scope="col">
            输入文字
          </th>
        </tr>
        <tr><td>
          <asp:DropDownList ID="x1" runat="server">
            <asp:ListItem>L0</asp:ListItem>
            <asp:ListItem>L1</asp:ListItem>
            <asp:ListItem>L2</asp:ListItem>
            <asp:ListItem>L3</asp:ListItem>
          </asp:DropDownList>
        </td><td>
          <asp:DropDownList ID="x2" runat="server">
            <asp:ListItem>10#</asp:ListItem>
            <asp:ListItem>20#</asp:ListItem>
            <asp:ListItem>30#</asp:ListItem>
            <asp:ListItem>40#</asp:ListItem>
          </asp:DropDownList>
        </td><td>
          <asp:TextBox ID="x3" runat="server"></asp:TextBox>
        </td></tr>
      </table>
    </EmptyDataTemplate>
    <Columns>
      <asp:TemplateField HeaderText="选择1">
        <ItemTemplate>
          <asp:DropDownList ID="x1" runat="server" AutoPostBack="true" OnSelectedIndexChanged="x1_SelectedIndexChanged">
            <asp:ListItem>L0</asp:ListItem>
            <asp:ListItem>L1</asp:ListItem>
            <asp:ListItem>L2</asp:ListItem>
            <asp:ListItem>L3</asp:ListItem>
          </asp:DropDownList>
        </ItemTemplate>
        <FooterTemplate>
          <asp:DropDownList ID="x1" runat="server">
            <asp:ListItem>L0</asp:ListItem>
            <asp:ListItem>L1</asp:ListItem>
            <asp:ListItem>L2</asp:ListItem>
            <asp:ListItem>L3</asp:ListItem>
          </asp:DropDownList>
        </FooterTemplate>
      </asp:TemplateField>
      <asp:TemplateField HeaderText="选择2">
        <ItemTemplate>
          <asp:DropDownList ID="x2" runat="server" AutoPostBack="true" OnSelectedIndexChanged="x2_SelectedIndexChanged">
            <asp:ListItem>10#</asp:ListItem>
            <asp:ListItem>20#</asp:ListItem>
            <asp:ListItem>30#</asp:ListItem>
            <asp:ListItem>40#</asp:ListItem>
          </asp:DropDownList>
        </ItemTemplate>
        <FooterTemplate>
          <asp:DropDownList ID="x2" runat="server">
            <asp:ListItem>10#</asp:ListItem>
            <asp:ListItem>20#</asp:ListItem>
            <asp:ListItem>30#</asp:ListItem>
            <asp:ListItem>40#</asp:ListItem>
          </asp:DropDownList>
        </FooterTemplate>
      </asp:TemplateField>
      <asp:TemplateField HeaderText="输入文字">
        <ItemTemplate>
          <asp:TextBox ID="x3" runat="server" AutoPostBack="true" OnTextChanged="x3_TextChanged"></asp:TextBox>
        </ItemTemplate>
        <FooterTemplate>
          <asp:TextBox ID="x3" runat="server"></asp:TextBox>
        </FooterTemplate>
      </asp:TemplateField>
    </Columns>
  </asp:GridView>
  <asp:LinkButton ID="LinkButton1" runat="server" Text="添加内容" OnClick="LinkButton1_Click"></asp:LinkButton>
  <asp:LinkButton ID="LinkButton2" runat="server" Text="删除内容" OnClick="LinkButton2_Click"></asp:LinkButton>
  </form>
</body>
</html>
==============================
<%@ Page Language="C#" AutoEventWireup="true" EnableViewState="true" %>
<%@ Import Namespace="System.Data" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<script runat="server">
  private DataTable dataTable = null;
  protected void Page_Load(object sender, EventArgs e)
  {
    if (!Page.IsPostBack)
    {
      this.Bind(true);
    }
  }

  private DataTable GetDataTable()
  {
    if (ViewState["dt"] == null)
    {
      dataTable = new DataTable();
      dataTable.Columns.Add("usage", typeof(String));
      dataTable.Columns.Add("steelKind", typeof(String));
      dataTable.Columns.Add("castingTon", typeof(String));
      return dataTable;
    }
    else
    {
      return ViewState["dt"] as DataTable;
    }
  }

  private void Bind(bool AddBlankRow)
  {
    dataTable = GetDataTable();
    if (AddBlankRow) dataTable.Rows.Add(dataTable.NewRow());
    this.GridView1.DataSource = dataTable;
    this.GridView1.DataBind();
  }
  protected void GridView1_RowDataBound(object sender, GridViewRowEventArgs e)
  {
    if (e.Row.RowType == DataControlRowType.DataRow)
    {
      DropDownList x1 = e.Row.FindControl("x1") as DropDownList;
      DropDownList x2 = e.Row.FindControl("x2") as DropDownList;
      TextBox x3 = e.Row.FindControl("x3") as TextBox;

      String usage = DataBinder.Eval(e.Row.DataItem, "usage").ToString();
      String steelKind = DataBinder.Eval(e.Row.DataItem, "steelKind").ToString();
      String castingTon = DataBinder.Eval(e.Row.DataItem, "castingTon").ToString();

      x3.Text = castingTon;
      ListItem xx1 = x1.Items.FindByValue(usage);
      if (xx1 != null) xx1.Selected = true;
      ListItem xx2 = x2.Items.FindByValue(steelKind);
      if (xx2 != null) xx2.Selected = true;
    }
  }

  protected void LinkButton1_Click(object sender, EventArgs e)
  {
    //总是取最后的一行
    GridViewRow row = GridView1.Rows[GridView1.Rows.Count - 1];
    DropDownList x1 = row.FindControl("x1") as DropDownList;
    DropDownList x2 = row.FindControl("x2") as DropDownList;
    TextBox x3 = row.FindControl("x3") as TextBox;

    dataTable = this.GetDataTable();
    DataRow newRow = dataTable.NewRow();
    if (dataTable.Rows.Count > 0)
    {
      newRow = dataTable.Rows[dataTable.Rows.Count - 1];
    }

    newRow["usage"] = x1.SelectedValue;
    newRow["steelKind"] = x2.SelectedValue;
    newRow["castingTon"] = x3.Text;
    if (dataTable.Rows.Count == 0)
    {
      dataTable.Rows.Add(newRow);
    }

    ViewState["dt"] = dataTable;
    this.Bind(true);

  }
  protected void LinkButton2_Click(object sender, EventArgs e)
  {
    dataTable = this.GetDataTable();
    if (dataTable.Rows.Count < 1) return;
    dataTable.Rows.RemoveAt(dataTable.Rows.Count - 1);
    ViewState["dt"] = dataTable;
    this.Bind(false);
  }

  protected void x1_SelectedIndexChanged(object sender, EventArgs e)
  {
    DropDownList x1 = sender as DropDownList;
    GridViewRow r = x1.Parent.Parent as GridViewRow;
    dataTable = this.GetDataTable();
    dataTable.Rows[r.RowIndex]["usage"] = x1.SelectedValue;
    ViewState["dt"] = dataTable;
    this.Bind(false);
  }

  protected void x2_SelectedIndexChanged(object sender, EventArgs e)
  {
    DropDownList x2 = sender as DropDownList;
    GridViewRow r = x2.Parent.Parent as GridViewRow;
    dataTable = this.GetDataTable();
    dataTable.Rows[r.RowIndex]["steelKind"] = x2.SelectedValue;
    ViewState["dt"] = dataTable;
    this.Bind(false);
  }

  protected void x3_TextChanged(object sender, EventArgs e)
  {
    TextBox x3 = sender as TextBox;
    GridViewRow r = x3.Parent.Parent as GridViewRow;
    dataTable = this.GetDataTable();
    dataTable.Rows[r.RowIndex]["castingTon"] = x3.Text;
    ViewState["dt"] = dataTable;
    this.Bind(false);
  }

  protected void GridView1_RowCreated(object sender, GridViewRowEventArgs e)
  {
    if (e.Row.RowType == DataControlRowType.DataRow)
    {
      if (e.Row.RowIndex < this.GetDataTable().Rows.Count - 1)
      {
        DropDownList x1 = e.Row.FindControl("x1") as DropDownList;
        DropDownList x2 = e.Row.FindControl("x2") as DropDownList;
        TextBox x3 = e.Row.FindControl("x3") as TextBox;
        x1.AutoPostBack = x2.AutoPostBack = x3.AutoPostBack = true;
        x1.SelectedIndexChanged += new EventHandler(x1_SelectedIndexChanged);
        x2.SelectedIndexChanged += new EventHandler(x2_SelectedIndexChanged);
        x3.TextChanged += new EventHandler(x3_TextChanged);
      }
    }
  }
</script>
<html xmlns="http://www.w3.org/1999/xhtml">
<head id="Head1" runat="server">
  <title></title>
</head>
<body>
  <form id="form1" runat="server">
  <asp:GridView ID="GridView1" runat="server" AutoGenerateColumns="false" OnRowDataBound="GridView1_RowDataBound"
    OnRowCreated="GridView1_RowCreated">
    <Columns>
      <asp:TemplateField HeaderText="选择1">
        <ItemTemplate>
          <asp:DropDownList ID="x1" runat="server">
            <asp:ListItem>L0</asp:ListItem>
            <asp:ListItem>L1</asp:ListItem>
            <asp:ListItem>L2</asp:ListItem>
            <asp:ListItem>L3</asp:ListItem>
          </asp:DropDownList>
        </ItemTemplate>
      </asp:TemplateField>
      <asp:TemplateField HeaderText="选择2">
        <ItemTemplate>
          <asp:DropDownList ID="x2" runat="server">
            <asp:ListItem>10#</asp:ListItem>
            <asp:ListItem>20#</asp:ListItem>
            <asp:ListItem>30#</asp:ListItem>
            <asp:ListItem>40#</asp:ListItem>
          </asp:DropDownList>
        </ItemTemplate>
      </asp:TemplateField>
      <asp:TemplateField HeaderText="输入文字">
        <ItemTemplate>
          <asp:TextBox ID="x3" runat="server"></asp:TextBox>
        </ItemTemplate>
      </asp:TemplateField>
    </Columns>
  </asp:GridView>
  <asp:LinkButton ID="LinkButton1" runat="server" Text="添加内容" OnClick="LinkButton1_Click"></asp:LinkButton>
  <asp:LinkButton ID="LinkButton2" runat="server" Text="删除内容" OnClick="LinkButton2_Click"></asp:LinkButton>
  </form>
</body>
</html>

#T=virtual,override,new,sealed 
//virtual,override,new,sealed 
public class P
{
	public P()
	{
		//
		// TODO: Add constructor logic here
		//
	}
	public virtual string Ma() 
	{
		return "Ma in P";
	}
	//no virtural same like sealed
	public  string Mb() 
	{
		return "Mb in P";
	}
}

public class C1 :P
{
	public C1() 
	{
	}
	public string Ma() 
	{
		return "Ma in C1";
	}
	//parent not defined virtual, not inheriteable
	//public string Mb() 
	//{
	//	return "Mb in C1";
	//}
	public new string Mb()
	{
		return "Mb in C1";
	}

}

public class C2 : P
{
	public C2()
	{
	}
	public override string Ma()
	{
		return "Ma in C2";
	}
	//will bring error
	//public override string Mb()
	//{
	//	return "Mb in C2";
	//}
	public new string Mb()
	{
		return "Mb in C2";
	}


}

public class C3 : P
{
	public C3()
	{
	}
	public new  string Ma()
	{
		return "Ma in C3";
	}
	public new virtual string Mb()
	{
		return "Mb in C3";
	}

}

public class CC1 : C1 
{
	public CC1() { }
	//same as sealed new
	//public sealed new Ma(){}
	public string Ma() 
	{
		return "Ma in CC1"; 
	}
}

public class CC2 : C2
{
	public CC2() { }
	public override string Ma()
	{
		return "Ma in CC1";
	}
}
public class CC3 : C3
{
	public CC3() { }
	////error
	//public override string Ma()
	//{
	//	return "Ma in CC3";
	//}
	
	public override string Mb()
	{
		return "Mb in CC3";
	}
}
#T=volatile join 创建和阻塞 当前线程 等待Thread线程结束 同步
namespace Microshaoft
{
	using System;
	using System.Threading;

	public class Worker
	{
		// This method will be called when the thread is started.
		public void DoWork()
		{
			while (!_shouldStop)
			{
				Console.WriteLine("worker thread: working...");
			}
			Console.WriteLine("worker thread: terminating gracefully.");
		}
		public void RequestStop()
		{
			_shouldStop = true;
		}
		// Volatile is used as hint to the compiler that this data
		// member will be accessed by multiple threads.
		private volatile bool _shouldStop;
	}

	public class WorkerThreadExample
	{
		static void Main()
		{
			// Create the thread object. This does not start the thread.
			Worker workerObject = new Worker();
			Thread workerThread = new Thread(workerObject.DoWork);

			// Start the worker thread.
			workerThread.Start();
			Console.WriteLine("main thread: Starting worker thread...");

			// Loop until worker thread activates.
			while (!workerThread.IsAlive);

			// Put the main thread to sleep for 1 millisecond to
			// allow the worker thread to do some work:
			Thread.Sleep(1);

			// Request that the worker thread stop itself:
			workerObject.RequestStop();

			// Use the Join method to block the current thread 
			// until the object's thread terminates.
			workerThread.Join();
			Console.WriteLine("main thread: Worker thread has terminated.");
		}
	}
}
#T=WaitHandle Wake AsycProcessor
namespace Microshaoft
{
	using System;
	using System.Threading;
	public class WakeProcessor<TData>
	{
		private delegate void ProcessCaller(AutoResetEvent wait, TData data);
		public delegate void WaitEventHandler(WakeProcessor<TData> sender, TData data);
		public event WaitEventHandler OnWaitOneTimeout;
		public event WaitEventHandler OnWaitOneWake;
		public event WaitEventHandler OnWaitComplete;
		private int _waitOneTimeoutSeconds = 0;
		private int _waitTimeoutMinutes = 0;
		public WakeProcessor
						(
							AutoResetEvent waitHandle
							, int waitOneTimeoutSeconds
							, int waitTimeoutMinutes
							, TData data
						)
		{
			BeginWaiting
					(
						waitHandle
						, waitOneTimeoutSeconds
						, waitTimeoutMinutes
						, data
					);
		}
		public void BeginWaiting
							(
								AutoResetEvent waitHandle
								, int waitOneTimeoutSeconds
								, int waitTimeoutMinutes
								, TData data
							)
		{
			_waitOneTimeoutSeconds = waitOneTimeoutSeconds;
			_waitTimeoutMinutes = waitTimeoutMinutes;
			ProcessCaller handler = new ProcessCaller(Process);
			//AsyncCallback callback = new AsyncCallback(ProcessedCallback);
			//IAsyncResult result =
			handler.BeginInvoke(waitHandle, data , null, null);
		}

		private void Process(AutoResetEvent wait, TData data)
		{
			DateTime beginTime = DateTime.Now;
			while (DateTime.Now.Subtract(beginTime).TotalSeconds <= _waitTimeoutMinutes * 60)
			{
				bool r = wait.WaitOne(_waitOneTimeoutSeconds * 1000);
				if (r)
				{
					if (OnWaitOneWake != null)
					{
						OnWaitOneWake(this, data);
					}
				}
				else
				{
					if (OnWaitOneTimeout != null)
					{
						OnWaitOneTimeout(this, data);
					}
				}
				//if (r)
				//{
				//	break;
				//}
			}
			//if (!r)
			{
				if (OnWaitComplete != null)
				{
					OnWaitComplete(this, data);
				}
			}
		}
		private void ProcessedCallback(IAsyncResult result)
		{
		}
	}
}
#T=waiting Processed Cancelable ShowDialog
namespace ConsoleApplication
{
	using System;
	using System.Threading;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine()))
			{
				Test();
			}
		}
		static void Test()
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			var r = TaskProcesserHelper.WaitingProcessedCancelableShowDialog
					(
						null
						, (x) =>
						{
							x.Text = "Test";
							x.ShowInTaskbar = false;
						}
						, () =>
						{
							Thread.Sleep(5 * 1000);
						}
						, () =>
						{
							Console.WriteLine("Finished");
						}
						, (x) =>
						{
							Console.WriteLine
									(
										x
									);
						}
					).ToString();
			Console.WriteLine(r);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Windows.Forms;
	public static class TaskProcesserHelper
	{
		public static DialogResult WaitingProcessedCancelableShowDialog
							(
								IWin32Window owner
								, Action<WaitingProcessedCancelableDialog> onDialogInitializeProcessAction
								, Action onProcessAction
								, Action onProcessedAction
								, Action<Exception> onCaughtExceptionProcessAction
							)
		{
			var form = new WaitingProcessedCancelableDialog();
			onDialogInitializeProcessAction(form);
			return
					form.ShowDialog
							(
								owner
								, () =>
								{
									Thread.Sleep(10);
									onProcessAction();
								}
								, () =>
								{
									onProcessedAction();
									try
									{
										if
											(
												form.IsHandleCreated
												&& !form.IsDisposed
											)
										{
											form.Invoke
													(
														new Action
															(
																() =>
																{
																	try
																	{
																		if
																			(
																				form.IsHandleCreated
																				&& !form.IsDisposed
																			)
																		{
																			form.Close();
																		}
																	}
																	catch (Exception e)
																	{
																		onCaughtExceptionProcessAction(e);
																	}
																	
																}
															)
													);
										}
									}
									catch (Exception e)
									{
										onCaughtExceptionProcessAction(e);
									}
								}
								, (x) =>
								{
									onCaughtExceptionProcessAction(x);
								}
							);
		}
		public static int WaitingProcessedCancelable
							(
								 Func<AutoResetEvent> onGetWaitingFunc
								, Action onProcessAction
								, Action onProcessedAction
								, Action<Exception> onCaughtExceptionProcessAction
							)
		{
			int r = 1; //Cancel
			var wait = onGetWaitingFunc();
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										try
										{
											onProcessAction();
											r = 0;
											onProcessedAction();
										}
										catch (Exception e)
										{
											r = -1;
											onCaughtExceptionProcessAction(e);
										}
										finally
										{
											wait.Set();
										}
									}
								)
					).Start();
			wait.WaitOne();
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.ComponentModel;
	using System.Threading;
	using System.Windows.Forms;
	public class WaitingProcessedCancelableDialog : Form
	{
		private IContainer components = null;
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		private void InitializeComponent()
		{
			button1 = new Button();
			SuspendLayout();
			//
			// button1
			//
			button1.DialogResult = DialogResult.Cancel;
			button1.Location = new Point(98, 158);
			button1.Name = "button1";
			button1.Size = new Size(75, 23);
			button1.TabIndex = 0;
			button1.Text = "取消(&C)";
			button1.UseVisualStyleBackColor = true;
			//
			// Form1
			//
			AutoScaleDimensions = new SizeF(8F, 16F);
			AutoScaleMode = AutoScaleMode.Font;
			CancelButton = button1;
			ClientSize = new Size(282, 253);
			ControlBox = false;
			Controls.Add(button1);
			///Name = "Form1";
			///Text = "Form1";
			ResumeLayout(false);
		}
		private Button button1;
		public Button CancelWaitButton
		{
			get
			{
				return button1;
			}
		}
		public WaitingProcessedCancelableDialog()
		{
			InitializeComponent();
			button1.Click += button1_Click;
		}
		void button1_Click(object sender, EventArgs e)
		{
			_wait.Set();
			button1.Click -= button1_Click;
			Close();
		}
		private object _objectLocker = new object();
		private AutoResetEvent _wait = new AutoResetEvent(false);
		private DialogResult _dialogResult = DialogResult.None;
		public DialogResult ShowDialog
								(
									IWin32Window owner
									, Action onBackgroundProcessAction
									, Action onBackgroundProcessedAction
									, Action<Exception> onCaughtExceptionProcessAction
								)
		{
			new Thread
				(
					new ThreadStart
						(
							() =>
							{
								int r = TaskProcesserHelper.WaitingProcessedCancelable
														(
															() => _wait
															, () =>
															{
																//Thread.Sleep(10 * 10);
																onBackgroundProcessAction();
															}
															, () =>
															{
																onBackgroundProcessedAction();
															}
															, (x) =>
															{
																onCaughtExceptionProcessAction(x);
															}
														);
								switch (r)
								{
									case 1 :	//Cancel
										_dialogResult = DialogResult.Cancel;
										break;
									case 0 :
										_dialogResult = DialogResult.OK;
										//Close();
///										try
///										{
///											if
///												(
///													IsHandleCreated
///													&& !IsDisposed
///												)
///											{
///												Invoke
///														(
///															new Action
///																(
///																	() =>
///																	{
///																		if
///																			(
///																				IsHandleCreated
///																				&& !IsDisposed
///																			)
///																		{
///																			try
///																			{
///																				Close();
///																			}
///																			catch (Exception e)
///																			{
///																				onCaughtExceptionProcessAction(e);
///																			}
///																		}
///																	}
///																)
///														);
///											}
///										}
///										catch (Exception e)
///										{
///											onCaughtExceptionProcessAction(e);
///										}
										break;
									case -1 :
										_dialogResult = DialogResult.Abort;
										break;
								}
							}
						)
				).Start();
			base.ShowDialog(owner);
			return _dialogResult;
		}
	}
}

#T=waiting Processed Cancelable ShowDialog 2013-11-02
namespace Test
{
	using System;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new MainForm());
		}
	}
}
namespace Test
{
	using System;
	using System.Threading;
	using System.Windows.Forms;
	using Microshaoft;
	partial class MainForm
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(119, 74);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(75, 23);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// MainForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(282, 253);
			this.Controls.Add(this.button1);
			this.Name = "MainForm";
			this.Text = "MainForm";
			this.ResumeLayout(false);
		}
		#endregion
		private System.Windows.Forms.Button button1;
	}
	public partial class MainForm : Form
	{
		public MainForm()
		{
			InitializeComponent();
		}
		private void button1_Click(object sender, EventArgs e)
		{
			var r = TaskProcesserHelper.ProcessWaitingShowDialog40
									(
										this
										, new ProcessWaitingCancelableDialog()
										, () =>
										{
											Thread.Sleep(5 * 1000);
											//throw new Exception();
										}
										, () =>
										{
											Console.WriteLine("Finished");
										}
										, (x) =>
										{
											Console.WriteLine("Caught Exception: {0}", x);
										}
									);
			Console.WriteLine(r);
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Windows.Forms;
	public static class TaskProcesserHelper
	{
		public static int ProcessWaitingShowDialog
					(
						IWin32Window ownerWindow
						, Func<Form> onWaitingDialogFactoryFunc
						, Action onProcessAction = null
						, Action onProcessedAction = null
						, Action<Exception> onCaughtExceptionProcessAction = null
					)
		{
			var dialogForm = onWaitingDialogFactoryFunc();
			return
				ProcessWaitingShowDialog
							(
								ownerWindow
								, dialogForm
								, onProcessAction = null
								, onProcessedAction = null
								, onCaughtExceptionProcessAction = null
							);
		}
		public static int ProcessWaitingShowDialog40
							(
								IWin32Window ownerWindow
								, Form dialogForm
								, Action onProcessAction = null
								, Action onProcessedAction = null
								, Action<Exception> onCaughtExceptionProcessAction = null
							)
		{
			var r = 1;
			Task<DialogResult> task1 = Task.Factory.StartNew<DialogResult>
							(
								() => 
								{
									return dialogForm.ShowDialog();
								}
							);
			Task task2 = Task.Factory.StartNew
									(
										() =>
											{
												try
												{
													//
													onProcessAction();
													r = 0;
												}
												catch (Exception e)
												{
													r = -1;
													if (onCaughtExceptionProcessAction != null)
													{
														onCaughtExceptionProcessAction(e);
													}
												}
												finally
												{
													TrySafeInvokeFormClose
														(
															dialogForm
															, onCaughtExceptionProcessAction
														);
												}
												try
												{
													onProcessedAction();
												}
												catch (Exception e)
												{
													//r = -1;
													onCaughtExceptionProcessAction(e);
												}
												finally
												{
													TrySafeInvokeFormClose(dialogForm, onCaughtExceptionProcessAction);
												}
											}
										
									);
			Task.WaitAny(task1, task2);
			//DialogResult dialogResult = await task;
			return r;
		}
		public static int ProcessWaitingShowDialog
							(
								IWin32Window ownerWindow
								, Form dialogForm
								, Action onProcessAction = null
								, Action onProcessedAction = null
								, Action<Exception> onCaughtExceptionProcessAction = null
							)
		{
			//var wait = new AutoResetEvent(false);
			int r = 1;
			if (onProcessAction != null)
			{
				new Thread
						(
							new ThreadStart
								(
									() =>
									{
										//wait.WaitOne();
										Thread.Sleep(10);
										try
										{
											//
											onProcessAction();
											r = 0;
										}
										catch (Exception e)
										{
											r = -1;
											if (onCaughtExceptionProcessAction != null)
											{
												onCaughtExceptionProcessAction(e);
											}
										}
										finally
										{
											TrySafeInvokeFormClose
												(
													dialogForm
													, onCaughtExceptionProcessAction
												);
										}
										try
										{
											onProcessedAction();
										}
										catch (Exception e)
										{
											//r = -1;
											onCaughtExceptionProcessAction(e);
										}
										finally
										{
											TrySafeInvokeFormClose(dialogForm, onCaughtExceptionProcessAction);
										}
									}
								)
						).Start();
				//wait.Set();
				if (r != 0)
				{
					dialogForm.ShowDialog(ownerWindow);
				}
			}
			return r;
		}
		private static bool TrySafeInvokeFormClose
								(
									Form dialogForm
									, Action<Exception> onCaughtExceptionProcessAction
								)
		{
			bool r = false;
			try
			{
				if
				(
					dialogForm.IsHandleCreated
					&& !dialogForm.IsDisposed
				)
				{
					dialogForm.Invoke
							(
								new Action
									(
										() =>
										{
											//try
											{
												if
												(
													dialogForm.IsHandleCreated
													&& !dialogForm.IsDisposed
												)
												{
													dialogForm.Close();
												}
												//throw new Exception("理论上不应该被外侧 try catch 捕获?!?!?!?!?!");
											}
											///											catch (Exception e)
											///											{
											///												r = false;
											///												if (onCaughtExceptionProcessAction != null)
											///												{
											///													onCaughtExceptionProcessAction(e);
											///												}
											///											}
										}
									)
							);
					Thread.Sleep(10);
				}
				r = true;
			}
			catch (Exception e)
			{
				r = false;
				if (onCaughtExceptionProcessAction != null)
				{
					onCaughtExceptionProcessAction(e);
				}
			}
			return r;
		}
		public static int ProcessWaitingCancelable
							(
								Func<AutoResetEvent> onWaitFactoryFunc
								, Action onProcessAction
								, Action onProcessedAction
								, Action<Exception> onCaughtExceptionProcessAction
							)
		{
			var wait = onWaitFactoryFunc();
			return
				ProcessWaitingCancelable
							(
								wait
								, onProcessAction
								, onProcessedAction
								, onCaughtExceptionProcessAction
							);
		}
		public static int ProcessWaitingCancelable
							(
								AutoResetEvent wait
								, Action onProcessAction
								, Action onProcessedAction
								, Action<Exception> onCaughtExceptionProcessAction
							)
		{
			int r = 1; //Cancel
			new Thread
					(
						new ThreadStart
								(
									() =>
									{
										try
										{
											onProcessAction();
											r = 0;
											onProcessedAction();
										}
										catch (Exception e)
										{
											r = -1;
											onCaughtExceptionProcessAction(e);
										}
										finally
										{
											wait.Set();
										}
									}
								)
					).Start();
			wait.WaitOne();
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.ComponentModel;
	using System.Threading;
	using System.Windows.Forms;
	public class ProcessWaitingCancelableDialog : Form
	{
		private IContainer components = null;
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		private void InitializeComponent()
		{
			button1 = new Button();
			SuspendLayout();
			//
			// button1
			//
			button1.DialogResult = DialogResult.Cancel;
			button1.Location = new Point(98, 158);
			button1.Name = "button1";
			button1.Size = new Size(75, 23);
			button1.TabIndex = 0;
			button1.Text = "取消(&C)";
			button1.UseVisualStyleBackColor = true;
			//
			// MainForm
			//
			AutoScaleDimensions = new SizeF(8F, 16F);
			AutoScaleMode = AutoScaleMode.Font;
			CancelButton = button1;
			ClientSize = new Size(282, 253);
			ControlBox = false;
			Controls.Add(button1);
			///Name = "MainForm";
			///Text = "MainForm";
			ResumeLayout(false);
		}
		private Button button1;
		public Button CancelWaitButton
		{
			get
			{
				return button1;
			}
		}
		public ProcessWaitingCancelableDialog()
		{
			InitializeComponent();
			button1.Click += button1_Click;
		}
		void button1_Click(object sender, EventArgs e)
		{
			button1.Click -= button1_Click;
			Close();
		}
	}
}

#T=watermark text
namespace ConsoleApplication
{
	using System;
	using System.IO;
	using System.Drawing.Text;
	using System.Drawing;
	using System.Drawing.Drawing2D;
	using System.Drawing.Imaging;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			string text = "神马都是浮云";
			int l = text.Length;
			float rotate = 10.0F;
			int alpha = 100;
			Color c = Color.Yellow;
			Font font = new Font("宋体", 50);
			using (Image img = Image.FromFile(@"C:\Users\xiyueyu\Desktop\搓麻的女人2.jpg"))
			{
				using (Graphics g = Graphics.FromImage(img))
				{
					g.SmoothingMode = SmoothingMode.AntiAlias;
					g.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
					int w = img.Width;
					int h = img.Height;
					Rectangle rectangle = new Rectangle(0, 0, w, h);
					StringFormat format = new StringFormat(StringFormatFlags.NoClip);
					format.Alignment = StringAlignment.Center;
					format.LineAlignment = StringAlignment.Center;
					SolidBrush brush = new SolidBrush(Color.FromArgb(alpha, c));
					g.RotateTransform(rotate);
					g.DrawString(text, font, brush, (RectangleF) rectangle, format);
					img.Save(@"c:\aaa.jpg", ImageFormat.Jpeg);
					MemoryStream ms = new MemoryStream();
					img.Save(ms, ImageFormat.Png);
				}
			}
			//to do
			//Response.ContentType = "image/jpg";
			//Response.BinaryWrite(ms.ToArray());
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}

#T=WCF BasicHttpBinding
namespace SimpleWcfServiceClient
{
	using System;
	using System.ServiceModel;
	using System.Windows.Forms;
	class ClientProgram
	{
		static void Main(string[] args)
		{
			string input;
			int a, b;
			Console.WriteLine("请输入两个整数，以逗号隔开！");
			input =Console.ReadLine();
			a = int.Parse(input.Split(',')[0]);
			b = int.Parse(input.Split(',')[1]);
			BasicHttpBinding binding = new BasicHttpBinding();
			ChannelFactory<ISimpleWcfService> factory = new ChannelFactory<ISimpleWcfService>(binding, new EndpointAddress("http://localhost:8001/OperationService"));
			ISimpleWcfService proxy = factory.CreateChannel();
			int result = proxy.Add(a,b);
			Console.WriteLine(string.Format("经过WCF服务计算，{0}加{1}原来等于{2}.",a,b, result));
			Console.ReadLine();
		}
		[ServiceContract]
		public interface ISimpleWcfService
		{
			[OperationContract]
			int Add(int a,int b);
		}
	}
}
namespace SimpleWcfServiceClient
{
	using System;
	using System.ServiceModel;
	using System.Windows.Forms;
	class ClientProgram
	{
		static void Main(string[] args)
		{
			string input;
			int a, b;
			Console.WriteLine("请输入两个整数，以逗号隔开！");
			input =Console.ReadLine();
			a = int.Parse(input.Split(',')[0]);
			b = int.Parse(input.Split(',')[1]);
			BasicHttpBinding binding = new BasicHttpBinding();
			ChannelFactory<ISimpleWcfService> factory = new ChannelFactory<ISimpleWcfService>(binding, new EndpointAddress("http://localhost:8001/OperationService"));
			ISimpleWcfService proxy = factory.CreateChannel();
			int result = proxy.Add(a,b);
			Console.WriteLine(string.Format("经过WCF服务计算，{0}加{1}原来等于{2}.",a,b, result));
			Console.ReadLine();
		}
		[ServiceContract]
		public interface ISimpleWcfService
		{
			[OperationContract]
			int Add(int a,int b);
		}
	}
}
#T=WCF Client 通用优雅调用 避免using
//IUserService就是WCF的ServiceContract，是客户端自动生成的代理类
WcfClient.UseService((IUserService userService) => (userService.GetUser(userId)));


public class WcfClient
{


    public static TReturn UseService<TChannel, TReturn>(Func<TChannel, TReturn> func)
    {
        var chanFactory = new ChannelFactory<TChannel>("*");
        TChannel channel = chanFactory.CreateChannel();
        TReturn result = func(channel);
        try
        {
            ((IClientChannel)channel).Close();
        }
        catch
        {
            ((IClientChannel)channel).Abort();
        }
        return result;
    }
}
#T=WCF MSMQ
// WCF.MSMQ.Message.Sender.(WCF.to.MSMQ).cs
namespace WCF.MSMQ.MessageSender.Host
{
	using System;
	using System.Transactions;
	using System.ServiceModel.MsmqIntegration;
	using System.ServiceModel;
	using Contracts.Entitys;
	using Contracts.Operations;
	using Contracts.Operations.ClientsProxys;
	class Program
	{
		static void Main(string[] args)
		{
			Console.Title = "Sender";
			// Create the purchase order
			PurchaseOrder po = new PurchaseOrder();
			po.customerId = "somecustomer.com";
			po.poNumber = Guid.NewGuid().ToString();
			PurchaseOrderLineItem lineItem1 = new PurchaseOrderLineItem();
			lineItem1.productId = "Blue Widget";
			lineItem1.quantity = 54;
			lineItem1.unitCost = 29.99F;
			PurchaseOrderLineItem lineItem2 = new PurchaseOrderLineItem();
			lineItem2.productId = "Red Widget";
			lineItem2.quantity = 890;
			lineItem2.unitCost = 45.89F;
			po.orderLineItems = new PurchaseOrderLineItem[2];
			po.orderLineItems[0] = lineItem1;
			po.orderLineItems[1] = lineItem2;
			string queueAddress = @"msmq.formatname:DIRECT=OS:.\private$\Orders";
			MsmqIntegrationBinding binding = new MsmqIntegrationBinding();
			binding.Security.Transport.MsmqAuthenticationMode = MsmqAuthenticationMode.None;
			binding.Security.Mode = MsmqIntegrationSecurityMode.None;
			EndpointAddress address = new EndpointAddress(queueAddress);
			ChannelFactory<IOrderProcessor> factory = new ChannelFactory<IOrderProcessor>(binding, new EndpointAddress(queueAddress));
			IOrderProcessor proxy = factory.CreateChannel();
			OrderProcessorClient client = new OrderProcessorClient(binding, address);

			int count = 1;
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine().ToLower()))
			{
				for (int i = 0; i < 1000 ; i++)
				{
					po.count = count++;
					MsmqMessage<PurchaseOrder> ordermsg = new MsmqMessage<PurchaseOrder>(po);
					using (TransactionScope scope = new TransactionScope(TransactionScopeOption.Required))
					{
						client.SubmitPurchaseOrder(ordermsg);
						scope.Complete();
					}
				}
				Console.WriteLine("WCF to MSMQ:");
				Console.WriteLine("Order has been submitted:{0}", po);
			}
			//Closing the client gracefully closes the connection and cleans up resources
			client.Close();
			Console.WriteLine();
			Console.WriteLine("Press <ENTER> to terminate client.");
			Console.ReadLine();
		}
	}
}
namespace Contracts.Operations.ClientsProxys
{
	using System.ServiceModel;
	using System.ServiceModel.Channels;
	using System.ServiceModel.MsmqIntegration;
	using Contracts.Entitys;
	public partial class OrderProcessorClient : ClientBase<IOrderProcessor>, IOrderProcessor
	{
///		public OrderProcessorClient()
///		{
///		}
///
///		public OrderProcessorClient(string configurationName)
///			:
///				base(configurationName)
///		{
///		}
		public OrderProcessorClient(Binding binding, EndpointAddress address)
			:
				base(binding, address)
		{
		}
		public void SubmitPurchaseOrder(MsmqMessage<PurchaseOrder> msg)
		{
			base.Channel.SubmitPurchaseOrder(msg);
		}
	}
}
//=================================================================================================================
// WCF.MSMQ.Message.Receiver.(MSMQ.to.WCF).cs
namespace WCF.MSMQ.MessageReceiver.Host
{
	using System;
	using System.ServiceModel;
	using System.ServiceModel.MsmqIntegration;
	using System.Messaging;
	using Contracts.Operations;
	using Contracts.Entitys;
	public class OrderProcessorService : IOrderProcessor
	{
		[OperationBehavior(TransactionScopeRequired = true, TransactionAutoComplete = true)]
		public void SubmitPurchaseOrder(MsmqMessage<PurchaseOrder> ordermsg)
		{
			PurchaseOrder po = ordermsg.Body;
			Random statusIndexer = new Random();
			po.Status = (OrderStates)statusIndexer.Next(3);
			Console.WriteLine("Processing {0} ", po);
		}
		// Host the service within this EXE console application.
		public static void Main()
		{
			// Get MSMQ queue name from app settings in configuration
			Console.Title = "Receiver";
			string queueName = @".\private$\Orders";//ConfigurationManager.AppSettings["orderQueueName"];
			// Create the transacted MSMQ queue if necessary.
			if (!MessageQueue.Exists(queueName))
			{
				MessageQueue.Create(queueName, true);
			}
			// Create a ServiceHost for the OrderProcessorService type.
			using (ServiceHost serviceHost = new ServiceHost(typeof(OrderProcessorService)))
			{
				string queueAddress = @"msmq.formatname:DIRECT=OS:.\private$\Orders";
				MsmqIntegrationBinding binding = new MsmqIntegrationBinding();
				binding.Security.Transport.MsmqAuthenticationMode = MsmqAuthenticationMode.None;
				binding.Security.Mode = MsmqIntegrationSecurityMode.None;
				serviceHost.AddServiceEndpoint(typeof(IOrderProcessor), binding, queueAddress);
				serviceHost.Open();
				// The service can now be accessed.
				Console.WriteLine("The MSMQ to WCF service is ready.");
				Console.WriteLine("Press <ENTER> to terminate service.");
				Console.ReadLine();
			}
		}
	}
}
//=================================================================================================================
// Contracts.Share.cs
namespace Contracts.Operations
{
	using System.ServiceModel;
	using System.ServiceModel.MsmqIntegration;
	using Contracts.Entitys;
	// Define a service contract. 
	[ServiceContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
	[ServiceKnownType(typeof(PurchaseOrder))]
	public interface IOrderProcessor
	{
		[OperationContract(IsOneWay = true, Action = "*")]
		void SubmitPurchaseOrder(MsmqMessage<PurchaseOrder> msg);
	}
}
namespace Contracts.Entitys
{
	using System;
	using System.Text;
	// Define the Purchase Order Line Item
	[Serializable]
	public class PurchaseOrderLineItem
	{
		public string productId;
		public float unitCost;
		public int quantity;
		public override string ToString()
		{
			string displayString = "Order LineItem: " + quantity + " of " + productId + " @unit price: $" + unitCost + "\n";
			return displayString;
		}
		public float TotalCost
		{
			get { return unitCost * quantity; }
		}
	}
	public enum OrderStates
	{
		Pending,
		Processed,
		Shipped
	}
	// Define Purchase Order
	[Serializable]
	public class PurchaseOrder
	{
	public static string[] orderStates = { "Pending", "Processed", "Shipped" };
		public int count;
		public string poNumber;
		public string customerId;
		public PurchaseOrderLineItem[] orderLineItems;
		public OrderStates orderStatus;
		public float TotalCost
		{
			get
			{
				float totalCost = 0;
				foreach (PurchaseOrderLineItem lineItem in orderLineItems)
					totalCost += lineItem.TotalCost;
				return totalCost;
			}
		}
		public OrderStates Status
		{
			get
			{
				return orderStatus;
			}
			set
			{
				orderStatus = value;
			}
		}
		public override string ToString()
		{
			StringBuilder strbuf = new StringBuilder("Purchase Order: " + poNumber + "\n");
			strbuf.Append("\tCustomer: " + customerId + "\n");
			strbuf.Append("\tOrderDetails\n");
			foreach (PurchaseOrderLineItem lineItem in orderLineItems)
			{
				strbuf.Append("\t\t" + lineItem.ToString());
			}
			strbuf.Append("\tTotal cost of this order: $" + TotalCost + "\n");
			strbuf.Append("\tOrder status: " + Status + "\n");
			strbuf.Append("\tOrder count: " + count + "\n");
			return strbuf.ToString();
		}
	}
}
#T=WCF Service Console CCF
// Server.cs
namespace WCF.Services
{
	using System;
	using System.ServiceModel;
	using Contracts.Operations;
	// Service class which implements the service contract.
	// Added code to write output to the console window
	public class CalculatorService : ICalculator
	{
		public double Add(double n1, double n2)
		{
			double result = n1 + n2;
			Console.WriteLine("Received Add({0},{1})", n1, n2);
			Console.WriteLine("Return: {0}", result);
			return result;
		}
		public double Subtract(double n1, double n2)
		{
			double result = n1 - n2;
			Console.WriteLine("Received Subtract({0},{1})", n1, n2);
			Console.WriteLine("Return: {0}", result);
			return result;
		}
		public double Multiply(double n1, double n2)
		{
			double result = n1 * n2;
			Console.WriteLine("Received Multiply({0},{1})", n1, n2);
			Console.WriteLine("Return: {0}", result);
			return result;
		}
		public double Divide(double n1, double n2)
		{
			double result = n1 / n2;

			Console.WriteLine("Received Divide({0},{1})", n1, n2);
			Console.WriteLine("Return: {0}", result);
			return result;
		}
		// Host the service within this EXE console application.
		public static void Main()
		{
			// Create a ServiceHost for the CalculatorService type.
			using (ServiceHost serviceHost = new ServiceHost(typeof(CalculatorService)))
			{
				// Open the ServiceHost to create listeners and start listening for messages.
				string address = @"net.tcp://192.168.1.200:9000/servicemodelsamples/service";
				NetTcpBinding binding = new NetTcpBinding();
				//binding.Security.Transport.MsmqAuthenticationMode = MsmqAuthenticationMode.None;
				//binding.Security.Mode = MsmqIntegrationSecurityMode.None;
				serviceHost.AddServiceEndpoint(typeof(ICalculator), binding, address);
				serviceHost.Open();
				// The service can now be accessed.
				Console.WriteLine("The service is ready.");
				Console.WriteLine("Press <ENTER> to terminate service.");
				Console.WriteLine();
				Console.ReadLine();
			}
		}
	}
}
//========================================================================================================
// Client.cs
namespace WCF.Clients.Proxys
{
	// "D:\Microsoft.SDKs\Windows\v7.1\Bin\NETFX 4.0 Tools\SvcUtil.exe" Share.dll
	// "D:\Microsoft.SDKs\Windows\v7.1\Bin\NETFX 4.0 Tools\SvcUtil.exe" *.wsdl *.xsd
		//------------------------------------------------------------------------------
	// <auto-generated>
	//	 此代码由工具生成。
	//	 运行时版本:4.0.30319.1
	//
	//	 对此文件的更改可能会导致不正确的行为，并且如果
	//	 重新生成代码，这些更改将会丢失。
	// </auto-generated>
	//------------------------------------------------------------------------------
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	[System.ServiceModel.ServiceContractAttribute(ConfigurationName="ICalculator")]
	public interface ICalculator
	{
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/ICalculator/Add", ReplyAction="http://tempuri.org/ICalculator/AddResponse")]
		double Add(double n1, double n2);
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/ICalculator/Subtract", ReplyAction="http://tempuri.org/ICalculator/SubtractResponse")]
		double Subtract(double n1, double n2);
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/ICalculator/Multiply", ReplyAction="http://tempuri.org/ICalculator/MultiplyResponse")]
		double Multiply(double n1, double n2);
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/ICalculator/Divide", ReplyAction="http://tempuri.org/ICalculator/DivideResponse")]
		double Divide(double n1, double n2);
	}
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	public interface ICalculatorChannel : ICalculator, System.ServiceModel.IClientChannel
	{
	}
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	public partial class CalculatorClient : System.ServiceModel.ClientBase<ICalculator>, ICalculator
	{
		public CalculatorClient()
		{
		}
		public CalculatorClient(string endpointConfigurationName) : 
				base(endpointConfigurationName)
		{
		}
		public CalculatorClient(string endpointConfigurationName, string remoteAddress) : 
				base(endpointConfigurationName, remoteAddress)
		{
		}
		public CalculatorClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
				base(endpointConfigurationName, remoteAddress)
		{
		}
		public CalculatorClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
				base(binding, remoteAddress)
		{
		}
		public double Add(double n1, double n2)
		{
			return base.Channel.Add(n1, n2);
		}
		public double Subtract(double n1, double n2)
		{
			return base.Channel.Subtract(n1, n2);
		}
		public double Multiply(double n1, double n2)
		{
			return base.Channel.Multiply(n1, n2);
		}
		public double Divide(double n1, double n2)
		{
			return base.Channel.Divide(n1, n2);
		}
	}
}
namespace WCF.Clients.Host
{
	using System;
	using System.ServiceModel;
	using WCF.Clients.Proxys;
	class Client
	{
		static void Main()
		{
			// Create a client
			string address = @"net.tcp://192.168.1.200:9000/servicemodelsamples/service";
			NetTcpBinding binding = new NetTcpBinding();
			CalculatorClient client = new CalculatorClient(binding, new EndpointAddress(address));
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine().ToLower()))
			{
				// Call the Add service operation.
				double value1 = 100.00D;
				double value2 = 15.99D;
				double result = client.Add(value1, value2);
				Console.WriteLine("Add({0},{1}) = {2}", value1, value2, result);
				// Call the Subtract service operation.
				value1 = 145.00D;
				value2 = 76.54D;
				result = client.Subtract(value1, value2);
				Console.WriteLine("Subtract({0},{1}) = {2}", value1, value2, result);
				// Call the Multiply service operation.
				value1 = 9.00D;
				value2 = 81.25D;
				result = client.Multiply(value1, value2);
				Console.WriteLine("Multiply({0},{1}) = {2}", value1, value2, result);
				// Call the Divide service operation.
				value1 = 22.00D;
				value2 = 7.00D;
				result = client.Divide(value1, value2);
				Console.WriteLine("Divide({0},{1}) = {2}", value1, value2, result);
				//Closing the client gracefully closes the connection and cleans up resources
			}
			client.Close();
			Console.WriteLine();
			Console.WriteLine("Press <ENTER> to terminate client.");
			Console.ReadLine();
		}
	}
}
//=============================================================================================================
// Share.cs
namespace Contracts.Operations
{
	using System.ServiceModel;
	// Define a service contract.
	[ServiceContract]
	public interface ICalculator
	{
		[OperationContract]
		double Add(double n1, double n2);
		[OperationContract]
		double Subtract(double n1, double n2);
		[OperationContract]
		double Multiply(double n1, double n2);
		[OperationContract]
		double Divide(double n1, double n2);
	}
}
//====================================================================================
#T=WCF simple Service config 
namespace ConsoleApplication
{
	using Microshaoft.WCF.Services;
	using System;
	using System.ServiceModel;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			Run();
			Console.ReadLine();
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
		static void Run()
		{
			var serviceHost = new ServiceHost(typeof(Service1));
			serviceHost.Open();
		}
	}
}
namespace Microshaoft.WCF.Contracts
{
	using System.Runtime.Serialization;
	using System.ServiceModel;
	// NOTE: You can use the "Rename" command on the "Refactor" menu to change the interface name "IService1" in both code and config file together.
	[ServiceContract]
	public interface IService1
	{
		[OperationContract]
		string GetData(int value);
		[OperationContract]
		CompositeType GetDataUsingDataContract(CompositeType composite);
		// TODO: Add your service operations here
	}
	// Use a data contract as illustrated in the sample below to add composite types to service operations.
	// You can add XSD files into the project. After building the project, you can directly use the data types defined there, with the namespace "WcfServiceLibrary3.ContractType".
	[DataContract]
	public class CompositeType
	{
		bool boolValue = true;
		string stringValue = "Hello ";
		[DataMember]
		public bool BoolValue
		{
			get { return boolValue; }
			set { boolValue = value; }
		}
		[DataMember]
		public string StringValue
		{
			get { return stringValue; }
			set { stringValue = value; }
		}
	}
}
namespace Microshaoft.WCF.Services
{
	using Microshaoft.WCF.Contracts;
	using System;
	// NOTE: You can use the "Rename" command on the "Refactor" menu to change the class name "Service1" in both code and config file together.
	public class Service1 : IService1
	{
		public string GetData(int value)
		{
			return string.Format("You entered: {0}", value);
		}
		public CompositeType GetDataUsingDataContract(CompositeType composite)
		{
			if (composite == null)
			{
				throw new ArgumentNullException("composite");
			}
			if (composite.BoolValue)
			{
				composite.StringValue += "Suffix";
			}
			return composite;
		}
	}
}
// exe.config
/*
<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<system.serviceModel>
		<behaviors>
			<serviceBehaviors>
				<behavior name="newBehavior01">
					<serviceMetadata httpGetEnabled="true"/>
				</behavior>
			</serviceBehaviors>
		</behaviors>
		<bindings>
			<basicHttpBinding>
				<binding name="newBinding01" receiveTimeout="00:15:00" />
			</basicHttpBinding>
			<mexHttpBinding>
				<binding name="newBinding02" />
			</mexHttpBinding>
		</bindings>
		<services>
			<service name="Microshaoft.WCF.Services.Service1" behaviorConfiguration="newBehavior01">
				<host>
					<baseAddresses>
						<add baseAddress="http://localhost:8090/Services" />
					</baseAddresses>
				</host>
				<endpoint
					address="service1"
					binding="basicHttpBinding"
					bindingConfiguration="newBinding01"
					contract="Microshaoft.WCF.Contracts.IService1"
				/>
				<endpoint
					address="mex"
					binding="mexHttpBinding"
					bindingConfiguration="newBinding02"
					contract="IMetadataExchange"
				/>
			</service>
		</services>
	</system.serviceModel>
</configuration>
*/
#T=WCF TCP
// Server.cs
namespace WCF.Services
{
	using System;
	using System.ServiceModel;
	using Contracts.Operations;
	// Service class which implements the service contract.
	// Added code to write output to the console window
	public class CalculatorService : ICalculator
	{
		public double Add(double n1, double n2)
		{
			double result = n1 + n2;
			Console.WriteLine("Received Add({0},{1})", n1, n2);
			Console.WriteLine("Return: {0}", result);
			return result;
		}
		public double Subtract(double n1, double n2)
		{
			double result = n1 - n2;
			Console.WriteLine("Received Subtract({0},{1})", n1, n2);
			Console.WriteLine("Return: {0}", result);
			return result;
		}
		public double Multiply(double n1, double n2)
		{
			double result = n1 * n2;
			Console.WriteLine("Received Multiply({0},{1})", n1, n2);
			Console.WriteLine("Return: {0}", result);
			return result;
		}
		public double Divide(double n1, double n2)
		{
			double result = n1 / n2;

			Console.WriteLine("Received Divide({0},{1})", n1, n2);
			Console.WriteLine("Return: {0}", result);
			return result;
		}
		// Host the service within this EXE console application.
		public static void Main()
		{
			// Create a ServiceHost for the CalculatorService type.
			using (ServiceHost serviceHost = new ServiceHost(typeof(CalculatorService)))
			{
				// Open the ServiceHost to create listeners and start listening for messages.
				string address = @"net.tcp://192.168.1.200:9000/servicemodelsamples/service";
				NetTcpBinding binding = new NetTcpBinding();
				//binding.Security.Transport.MsmqAuthenticationMode = MsmqAuthenticationMode.None;
				//binding.Security.Mode = MsmqIntegrationSecurityMode.None;
				serviceHost.AddServiceEndpoint(typeof(ICalculator), binding, address);
				serviceHost.Open();
				// The service can now be accessed.
				Console.WriteLine("The service is ready.");
				Console.WriteLine("Press <ENTER> to terminate service.");
				Console.WriteLine();
				Console.ReadLine();
			}
		}
	}
}
//========================================================================================================
// Client.cs
namespace WCF.Clients.Proxys
{
	// "D:\Microsoft.SDKs\Windows\v7.1\Bin\NETFX 4.0 Tools\SvcUtil.exe" Share.dll
	// "D:\Microsoft.SDKs\Windows\v7.1\Bin\NETFX 4.0 Tools\SvcUtil.exe" *.wsdl *.xsd
		//------------------------------------------------------------------------------
	// <auto-generated>
	//	 此代码由工具生成。
	//	 运行时版本:4.0.30319.1
	//
	//	 对此文件的更改可能会导致不正确的行为，并且如果
	//	 重新生成代码，这些更改将会丢失。
	// </auto-generated>
	//------------------------------------------------------------------------------
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	[System.ServiceModel.ServiceContractAttribute(ConfigurationName="ICalculator")]
	public interface ICalculator
	{
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/ICalculator/Add", ReplyAction="http://tempuri.org/ICalculator/AddResponse")]
		double Add(double n1, double n2);
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/ICalculator/Subtract", ReplyAction="http://tempuri.org/ICalculator/SubtractResponse")]
		double Subtract(double n1, double n2);
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/ICalculator/Multiply", ReplyAction="http://tempuri.org/ICalculator/MultiplyResponse")]
		double Multiply(double n1, double n2);
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/ICalculator/Divide", ReplyAction="http://tempuri.org/ICalculator/DivideResponse")]
		double Divide(double n1, double n2);
	}
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	public interface ICalculatorChannel : ICalculator, System.ServiceModel.IClientChannel
	{
	}
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	public partial class CalculatorClient : System.ServiceModel.ClientBase<ICalculator>, ICalculator
	{
		public CalculatorClient()
		{
		}
		public CalculatorClient(string endpointConfigurationName) : 
				base(endpointConfigurationName)
		{
		}
		public CalculatorClient(string endpointConfigurationName, string remoteAddress) : 
				base(endpointConfigurationName, remoteAddress)
		{
		}
		public CalculatorClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
				base(endpointConfigurationName, remoteAddress)
		{
		}
		public CalculatorClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
				base(binding, remoteAddress)
		{
		}
		public double Add(double n1, double n2)
		{
			return base.Channel.Add(n1, n2);
		}
		public double Subtract(double n1, double n2)
		{
			return base.Channel.Subtract(n1, n2);
		}
		public double Multiply(double n1, double n2)
		{
			return base.Channel.Multiply(n1, n2);
		}
		public double Divide(double n1, double n2)
		{
			return base.Channel.Divide(n1, n2);
		}
	}
}
namespace WCF.Clients.Host
{
	using System;
	using System.ServiceModel;
	using WCF.Clients.Proxys;
	class Client
	{
		static void Main()
		{
			// Create a client
			string address = @"net.tcp://192.168.1.200:9000/servicemodelsamples/service";
			NetTcpBinding binding = new NetTcpBinding();
			CalculatorClient client = new CalculatorClient(binding, new EndpointAddress(address));
			string input = string.Empty;
			while ("q" != (input = Console.ReadLine().ToLower()))
			{
				// Call the Add service operation.
				double value1 = 100.00D;
				double value2 = 15.99D;
				double result = client.Add(value1, value2);
				Console.WriteLine("Add({0},{1}) = {2}", value1, value2, result);
				// Call the Subtract service operation.
				value1 = 145.00D;
				value2 = 76.54D;
				result = client.Subtract(value1, value2);
				Console.WriteLine("Subtract({0},{1}) = {2}", value1, value2, result);
				// Call the Multiply service operation.
				value1 = 9.00D;
				value2 = 81.25D;
				result = client.Multiply(value1, value2);
				Console.WriteLine("Multiply({0},{1}) = {2}", value1, value2, result);
				// Call the Divide service operation.
				value1 = 22.00D;
				value2 = 7.00D;
				result = client.Divide(value1, value2);
				Console.WriteLine("Divide({0},{1}) = {2}", value1, value2, result);
				//Closing the client gracefully closes the connection and cleans up resources
			}
			client.Close();
			Console.WriteLine();
			Console.WriteLine("Press <ENTER> to terminate client.");
			Console.ReadLine();
		}
	}
}
//=============================================================================================================
// Share.cs
namespace Contracts.Operations
{
	using System.ServiceModel;
	// Define a service contract.
	[ServiceContract]
	public interface ICalculator
	{
		[OperationContract]
		double Add(double n1, double n2);
		[OperationContract]
		double Subtract(double n1, double n2);
		[OperationContract]
		double Multiply(double n1, double n2);
		[OperationContract]
		double Divide(double n1, double n2);
	}
}
//====================================================================================
#T=WCF.tcp.AsyncQueue Client
//=======================================================================================================
///// Client.cs
//------------------------------------------------------------------------------
// <auto-generated>
//	 此代码由工具生成。
//	 运行时版本:4.0.30319.1
//
//	 对此文件的更改可能会导致不正确的行为，并且如果
//	 重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
// "D:\Microsoft.SDKs\Windows\v7.1\Bin\NETFX 4.0 Tools\SvcUtil.exe" Share.dll
// "D:\Microsoft.SDKs\Windows\v7.1\Bin\NETFX 4.0 Tools\SvcUtil.exe" *.wsdl *.xsd
// "D:\Microsoft.SDKs\Windows\v7.1\Bin\NETFX 4.0 Tools\SvcUtil.exe" net.tcp://localhost:9000/servicemodelsamples/service/mex
namespace Contracts.Services.Entitys
{
	using System.Runtime.Serialization;
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "4.0.0.0")]
	[System.Runtime.Serialization.DataContractAttribute(Name="Item", Namespace="http://schemas.datacontract.org/2004/07/Contracts.Services.Entitys")]
	public partial class Item : object, System.Runtime.Serialization.IExtensibleDataObject
	{
		private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
		private string ConnectionStringField;
		private System.DateTime EnqueueTimeField;
		private string SqlCommandTextField;
		public System.Runtime.Serialization.ExtensionDataObject ExtensionData
		{
			get
			{
				return this.extensionDataField;
			}
			set
			{
				this.extensionDataField = value;
			}
		}
		
		[System.Runtime.Serialization.DataMemberAttribute()]
		public string ConnectionString
		{
			get
			{
				return this.ConnectionStringField;
			}
			set
			{
				this.ConnectionStringField = value;
			}
		}
		
		[System.Runtime.Serialization.DataMemberAttribute()]
		public System.DateTime EnqueueTime
		{
			get
			{
				return this.EnqueueTimeField;
			}
			set
			{
				this.EnqueueTimeField = value;
			}
		}
		[System.Runtime.Serialization.DataMemberAttribute()]
		public string SqlCommandText
		{
			get
			{
				return this.SqlCommandTextField;
			}
			set
			{
				this.SqlCommandTextField = value;
			}
		}
	}
}
namespace Proxy
{
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	[System.ServiceModel.ServiceContractAttribute(ConfigurationName="IQueueAble")]
	public interface IQueueAble
	{
		
		[System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IQueueAble/Enqueue", ReplyAction="http://tempuri.org/IQueueAble/EnqueueResponse")]
		void Enqueue(Contracts.Services.Entitys.Item element);
	}
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	public interface IQueueAbleChannel : IQueueAble, System.ServiceModel.IClientChannel
	{
	}
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "4.0.0.0")]
	public partial class QueueAbleClient : System.ServiceModel.ClientBase<IQueueAble>, IQueueAble
	{
		
		public QueueAbleClient()
		{
		}
		
		public QueueAbleClient(string endpointConfigurationName) : 
				base(endpointConfigurationName)
		{
		}
		
		public QueueAbleClient(string endpointConfigurationName, string remoteAddress) : 
				base(endpointConfigurationName, remoteAddress)
		{
		}
		
		public QueueAbleClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
				base(endpointConfigurationName, remoteAddress)
		{
		}
		
		public QueueAbleClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
				base(binding, remoteAddress)
		{
		}
		
		public void Enqueue(Contracts.Services.Entitys.Item element)
		{
			base.Channel.Enqueue(element);
		}
	}
}
namespace Microshaoft.WCF.Client
{
	using System;
	using System.Collections;
	using System.Threading;
	using System.ServiceModel;
	using Proxy;
	using Contracts.Services.Entitys;
	public class Class1
	{
		static QueueAbleClient _client;
		public static void Main()
		{
			Console.Title = "Client";
			Console.WriteLine(Environment.Version.ToString());
			Class1 a = new Class1();
			a.Run();
		}
		public void Run()
		{
			string address = @"net.tcp://localhost:9000/servicemodelsamples/service";
			NetTcpBinding binding = new NetTcpBinding();
			_client = new QueueAbleClient(binding, new EndpointAddress(address));
			for (int i = 0; i < 20; i++)
			{
				Thread x = new Thread(new ThreadStart(ThreadProcess));
				x.Start();
			}
		}
		public void ThreadProcess()
		{
			for (int i = 0; i < 1000; i++)
			{
				Item x = new Item();
				DateTime EnqueueTime = DateTime.Now;
				x.EnqueueTime = EnqueueTime;
				x.SqlCommandText = @"
						--==========================
						declare @ varchar(10)
						set @ = 'aaa'
						exec zsp_test @
						--==========================
				";
				x.ConnectionString = "";
				_client.Enqueue(x);
				Console.WriteLine
							(
								"Enqueue: {0},[{1}]"
								, EnqueueTime
								, (DateTime.Now.Ticks - EnqueueTime.Ticks)/10000
							);
			}
		}
	}
}
//============================================================================================================================
#T=WCF.tcp.AsyncQueue Server
//AsyncQueue.cs
^#define c4 //C# 4.0+
//#define c2
namespace Microshaoft
{
	using System;
	using System.Threading;
	using System.Diagnostics;
	using System.Collections.Generic;
^#if c4
	using System.Collections.Concurrent;
^#endif
	using Microshaoft;
	public class AsyncQueue<T>
						where T : class
	{
		public delegate void QueueEventHandler(T element);
		public event QueueEventHandler OnDequeue;
		public delegate void QueueLogEventHandler(string logMessage);
		//public event QueueLogEventHandler OnQueueLog;
		public event QueueLogEventHandler OnQueueRunningThreadStart;
		public event QueueLogEventHandler OnQueueRunningThreadEnd;
		public event QueueLogEventHandler OnDequeueThreadStart;
		public event QueueLogEventHandler OnDequeueThreadEnd;
		public event QueueLogEventHandler OnDequeueAllThreadsEnd;
		public delegate void ExceptionEventHandler(Exception exception);
		public event ExceptionEventHandler OnException;
^#if c2
		private Queue<T> _queue = new Queue<T>();
^#elif c4
		private ConcurrentQueue<T> _queue = new ConcurrentQueue<T>();
^#endif
		private object _syncQueueLockObject = new object();
		//private object _syncQueueRunningLockObject = new object();
		private long _isQueueRunning = 0;
		private long _concurrentDequeueThreadsCount = 0; //Microshaoft 用于控制并发线程数
		private PerformanceCounter _enqueuePerformanceCounter;
		private PerformanceCounter _dequeuePerformanceCounter;
		private PerformanceCounter _dequeueProcessedPerformanceCounter;
		private PerformanceCounter _queueLengthPerformanceCounter;
		private PerformanceCounter _dequeueThreadStartPerformanceCounter;
		private PerformanceCounter _dequeueThreadEndPerformanceCounter;
		private PerformanceCounter _dequeueThreadsCountPerformanceCounter;
		private PerformanceCounter _queueRunningThreadStartPerformanceCounter;
		private PerformanceCounter _queueRunningThreadEndPerformanceCounter;
		private PerformanceCounter _queueRunningThreadsCountPerformanceCounter;
		private bool _isAttachedPerformanceCounters = false;
		public void AttachPerformanceCounters(string instanceNamePrefix)
		{
			string category = "Microshaoft AsyncConurrentQueue Counters";
			string counter = string.Empty;
			Process process = Process.GetCurrentProcess();
			//int processID = 0;//process.Id;
			string processName = process.ProcessName;
			//string processStartTime = "";//process.StartTime;
			string instanceName = string.Empty;
			instanceName = string.Format
									(
										"{0}-{1}"
										, instanceNamePrefix
										, processName
				//, processID
				//, processStartTime.ToString("yyyy-MM-dd HH:mm:ss.fff")
									);
			CounterCreationDataCollection ccdc = new CounterCreationDataCollection();
			if (PerformanceCounterCategory.Exists(category))
			{
				PerformanceCounterCategory.Delete(category);
			}
			CounterCreationData ccd = null;
			counter = "EnqueueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueLengthCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueProcessedCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "DequeueThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadStartCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadEndCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			counter = "QueueRunningThreadsCountCounter";
			ccd = PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64);
			ccdc.Add(PerformanceCounterHelper.GetCounterCreationData(counter, PerformanceCounterType.NumberOfItems64));
			PerformanceCounterCategory.Create
											(
												category,
												string.Format("{0} Category Help.", category),
												PerformanceCounterCategoryType.MultiInstance,
												ccdc
											);
			counter = "EnqueueCounter";
			_enqueuePerformanceCounter = new PerformanceCounter();
			_enqueuePerformanceCounter.CategoryName = category;
			_enqueuePerformanceCounter.CounterName = counter;
			_enqueuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_enqueuePerformanceCounter.InstanceName = instanceName;
			_enqueuePerformanceCounter.ReadOnly = false;
			_enqueuePerformanceCounter.RawValue = 0;
			counter = "DequeueCounter";
			_dequeuePerformanceCounter = new PerformanceCounter();
			_dequeuePerformanceCounter.CategoryName = category;
			_dequeuePerformanceCounter.CounterName = counter;
			_dequeuePerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeuePerformanceCounter.InstanceName = instanceName;
			_dequeuePerformanceCounter.ReadOnly = false;
			_dequeuePerformanceCounter.RawValue = 0;
			counter = "DequeueProcessedCounter";
			_dequeueProcessedPerformanceCounter = new PerformanceCounter();
			_dequeueProcessedPerformanceCounter.CategoryName = category;
			_dequeueProcessedPerformanceCounter.CounterName = counter;
			_dequeueProcessedPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueProcessedPerformanceCounter.InstanceName = instanceName;
			_dequeueProcessedPerformanceCounter.ReadOnly = false;
			_dequeueProcessedPerformanceCounter.RawValue = 0;
			counter = "QueueLengthCounter";
			_queueLengthPerformanceCounter = new PerformanceCounter();
			_queueLengthPerformanceCounter.CategoryName = category;
			_queueLengthPerformanceCounter.CounterName = counter;
			_queueLengthPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueLengthPerformanceCounter.InstanceName = instanceName;
			_queueLengthPerformanceCounter.ReadOnly = false;
			_queueLengthPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadStartCounter";
			_dequeueThreadStartPerformanceCounter = new PerformanceCounter();
			_dequeueThreadStartPerformanceCounter.CategoryName = category;
			_dequeueThreadStartPerformanceCounter.CounterName = counter;
			_dequeueThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadStartPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadStartPerformanceCounter.ReadOnly = false;
			_dequeueThreadStartPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadEndCounter";
			_dequeueThreadEndPerformanceCounter = new PerformanceCounter();
			_dequeueThreadEndPerformanceCounter.CategoryName = category;
			_dequeueThreadEndPerformanceCounter.CounterName = counter;
			_dequeueThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadEndPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadEndPerformanceCounter.ReadOnly = false;
			_dequeueThreadEndPerformanceCounter.RawValue = 0;
			counter = "DequeueThreadsCountCounter";
			_dequeueThreadsCountPerformanceCounter = new PerformanceCounter();
			_dequeueThreadsCountPerformanceCounter.CategoryName = category;
			_dequeueThreadsCountPerformanceCounter.CounterName = counter;
			_dequeueThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_dequeueThreadsCountPerformanceCounter.InstanceName = instanceName;
			_dequeueThreadsCountPerformanceCounter.ReadOnly = false;
			_dequeueThreadsCountPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadStartCounter";
			_queueRunningThreadStartPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadStartPerformanceCounter.CategoryName = category;
			_queueRunningThreadStartPerformanceCounter.CounterName = counter;
			_queueRunningThreadStartPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadStartPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadStartPerformanceCounter.ReadOnly = false;
			_queueRunningThreadStartPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadEndCounter";
			_queueRunningThreadEndPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadEndPerformanceCounter.CategoryName = category;
			_queueRunningThreadEndPerformanceCounter.CounterName = counter;
			_queueRunningThreadEndPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadEndPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadEndPerformanceCounter.ReadOnly = false;
			_queueRunningThreadEndPerformanceCounter.RawValue = 0;
			counter = "QueueRunningThreadsCountCounter";
			_queueRunningThreadsCountPerformanceCounter = new PerformanceCounter();
			_queueRunningThreadsCountPerformanceCounter.CategoryName = category;
			_queueRunningThreadsCountPerformanceCounter.CounterName = counter;
			_queueRunningThreadsCountPerformanceCounter.InstanceLifetime = PerformanceCounterInstanceLifetime.Process;
			_queueRunningThreadsCountPerformanceCounter.InstanceName = instanceName;
			_queueRunningThreadsCountPerformanceCounter.ReadOnly = false;
			_queueRunningThreadsCountPerformanceCounter.RawValue = 0;
			_isAttachedPerformanceCounters = true;
		}
		private int _maxConcurrentThreadsCount = 1; //Microshaoft 允许并发出列处理线程数为 1
		public int MaxConcurrentThreadsCount
		{
			set
			{
				_maxConcurrentThreadsCount = value;
			}
			get
			{
				return _maxConcurrentThreadsCount;
			}
		}
		//Microshaoft 服务启动后可立即开启新的线程调用此方法(死循环)
		private void QueueRun() //Microshaoft ThreadStart
		{
			if (Interlocked.Read(ref _concurrentDequeueThreadsCount) < _maxConcurrentThreadsCount)
			{
				if (Interlocked.CompareExchange(ref _isQueueRunning, 0, 1) == 0)
				{
					ThreadStart ts = new ThreadStart(QueueRunThreadProcess);
					Thread t = new Thread(ts);
					t.Name = "QueueRunningThreadProcess";
					t.Start();
				}
			}
		}
		public int Count
		{
			get
			{
				return _queue.Count;
			}
		}
		public long ConcurrentThreadsCount
		{
			get
			{
				return _concurrentDequeueThreadsCount;
			}
		}
		private void QueueRunThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadStartPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Increment();
			}
			if (OnQueueRunningThreadStart != null)
			{
				OnQueueRunningThreadStart
					(
						string.Format
								(
									"{0} Threads Count {1},Queue Count {2},Current Thread: {3}({4}) at {5}"
									, "Queue Running Start ..."
									, _concurrentDequeueThreadsCount
									, _queue.Count
									, Thread.CurrentThread.Name
									, Thread.CurrentThread.ManagedThreadId
									, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
								)
					);
			}
^#if c2
			while ((_queue.Count > 0)) //Microshaoft 死循环
^#elif c4
			while (!_queue.IsEmpty) //Microshaoft 死循环
^#endif
			{
				int threadID = -1;
				{
					int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
					if (r < _maxConcurrentThreadsCount)
					{
						//if (_queue.Count > 0)
						{
							r = (int)Interlocked.Increment(ref _concurrentDequeueThreadsCount);
							threadID = (int)_concurrentDequeueThreadsCount;
							//ThreadProcessState tps = new ThreadProcessState();
							//tps.element = element;
							//tps.Sender = this;
							Thread t = new Thread(new ThreadStart(DequeueThreadProcess));
							t.Name = string.Format("ConcurrentDequeueProcessThread[{0}]", threadID);
							t.Start();
						}
						///						else
						///						{
						///							break;
						///						}
					}
					else
					{
						break;
					}
				}
			}
			//Interlocked.CompareExchange(ref _queueRuning, 0, 1);
			if (OnQueueRunningThreadEnd != null)
			{
				int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnQueueRunningThreadEnd
							(
								string.Format
										(
											"{0} Threads Count {1}, Queue Count {2}, Current Thread: {3}({4}) at {5}"
											, "Queue Running Stop ..."
											, r
											, _queue.Count
											, Thread.CurrentThread.Name
											, Thread.CurrentThread.ManagedThreadId
											, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
										)
							);
			}
			if (_isAttachedPerformanceCounters)
			{
				_queueRunningThreadEndPerformanceCounter.Increment();
				_queueRunningThreadsCountPerformanceCounter.Decrement();
			}
			Interlocked.Exchange(ref _isQueueRunning, 0);
		}
		public void Enqueue(T element)
		{
			try
			{
^#if c2
				lock (_syncQueueLockObject) //还算并发吗?
^#endif
				{
					_queue.Enqueue(element);
				}
				if (_isAttachedPerformanceCounters)
				{
					_enqueuePerformanceCounter.Increment();
					_queueLengthPerformanceCounter.Increment();
				}
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			//int r = Interlocked.CompareExchange(ref _queueRuning, 1, 0))
			//if (r == 1)
			//{
			QueueRun();
			//}
		}
		private void DequeueThreadProcess()
		{
			if (_isAttachedPerformanceCounters)
			{
				_dequeueThreadStartPerformanceCounter.Increment();
				_dequeueThreadsCountPerformanceCounter.Increment();
			}
			if (OnDequeueThreadStart != null)
			{
				int r = (int)Interlocked.Read(ref _concurrentDequeueThreadsCount);
				OnDequeueThreadStart
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads ++ !"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
			}
			bool queueWasNotEmpty = false;
			try
			{
^#if c2
				while (true)
^#elif c4
				while (!_queue.IsEmpty)
^#endif
				{
					T element = null;
^#if c2
					lock (_syncQueueLockObject)
					{
						if (_queue.Count > 0)
						{
							element = _queue.Dequeue();
						}
						else
						{
							//避免QueueRun 死循环
							break;
						}
					}
^#elif c4
					if (_queue.TryDequeue(out element))
					{
^#elif c2
						if (element != null)
						{
^#endif
						if (!queueWasNotEmpty)
						{
							queueWasNotEmpty = true;
						}
						if (_isAttachedPerformanceCounters)
						{
							_dequeuePerformanceCounter.Increment();
							_queueLengthPerformanceCounter.Decrement();
						}
						if (OnDequeue != null)
						{
							OnDequeue(element);
						}
						if (_isAttachedPerformanceCounters)
						{
							_dequeueProcessedPerformanceCounter.Increment();
						}
^#if c2
						}
^#elif c4
					}
				}
^#endif
			}
			catch (Exception e)
			{
				if (OnException != null)
				{
					OnException(e);
				}
			}
			finally
			{
				int r = (int)Interlocked.Decrement(ref _concurrentDequeueThreadsCount);
				if (OnDequeueThreadEnd != null)
				{
					OnDequeueThreadEnd
								(
									string.Format
											(
												"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
												, "Threads--"
												, r
												, _queue.Count
												, Thread.CurrentThread.Name
												, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
											)
								);
				}
				if (r == 0)
				{
					if (OnDequeueAllThreadsEnd != null)
					{
						OnDequeueAllThreadsEnd
									(
										string.Format
												(
													"{0} Threads Count {1},Queue Count {2},Current Thread: {3} at {4}"
													, "All Threads End"
													, r
													, _queue.Count
													, Thread.CurrentThread.Name
													, DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff")
												)
									);
					}
				}
				if (_isAttachedPerformanceCounters)
				{
					_dequeueThreadEndPerformanceCounter.Increment();
					_dequeueThreadsCountPerformanceCounter.Decrement();
				}
				if (queueWasNotEmpty)
				{
					QueueRun(); //死循环???
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static class PerformanceCounterHelper
	{
		public static CounterCreationData GetCounterCreationData(string counterName, PerformanceCounterType performanceCounterType)
		{
			CounterCreationData ccd = new CounterCreationData();
			ccd.CounterName = counterName;
			ccd.CounterHelp = string.Format("{0} Help", counterName);
			ccd.CounterType = performanceCounterType;
			return ccd;
		}
	}
}
//========================================================================================================================================
// Server.cs
namespace Microshaoft.WCF.Services
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using Contracts.Services;
	using Contracts.Services.Entitys;
	using Microshaoft.WCF.Server;
	public class AsyncQueueWcfNetNetTcpService : IQueueAble
	{
		public void Enqueue(Item item)
		{
			WindowsServiceHost.AsyncQueueProcessor.Enqueue(item);
		}
	}
}
namespace Microshaoft.WCF.Server
{
	using System;
	using System.ComponentModel;
	using System.ServiceProcess;
	using System.Configuration.Install;
	using System.Security.Principal;
	using System.ServiceModel;
	using System.ServiceModel.Description;
	using Microshaoft;
	using Microshaoft.Win32;
	using Microshaoft.WCF.Services;
	using Contracts.Services;
	using Contracts.Services.Entitys;
	public class WindowsServiceHost : ServiceBase
	{
		///// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		public static readonly string serviceName = "AsyncConcurrentQueueWcfNetTcpService";
		private static AsyncQueueProcessor _asyncQueueProcessor;
		public static AsyncQueueProcessor AsyncQueueProcessor
		{
			get
			{
				return _asyncQueueProcessor;
			}
		}
		static void Main(string[] args)
		{
			//Microshaoft
			//Microshaoft TODO: 在此处添加代码以启动应用程序
			//Microshaoft 
			WindowsServiceHost service = new WindowsServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					NativeMethods.AllocConsole();
					Console.Title = "Server ...";
					Console.WriteLine("Alloc Console ...");
					Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
					Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
					Console.Title = string.Format
											(
												"{0} Host Server"
												, WindowsServiceHost.serviceName
											); //不能以服务运行
					Console.WriteLine("Console");
					service.OnStart(null);
					Console.ReadLine();
					return;
				}
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		public static ServiceHost _serviceHost;
		public WindowsServiceHost()
		{
			CanPauseAndContinue = true;
			ServiceName = WindowsServiceHost.serviceName;
		}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine(Environment.Version.ToString());
			AsyncQueue<Item> queue = new AsyncQueue<Item>();
			queue.AttachPerformanceCounters("Q1");
			_asyncQueueProcessor = new AsyncQueueProcessor(queue);
			_serviceHost = new ServiceHost(typeof(AsyncQueueWcfNetNetTcpService));
			string address = "{0}://localhost{1}/servicemodelsamples/service";
			string netTcpUrl = string.Format
										(
											address
											, "net.tcp"
											, ":9000"
										);
			string httpUrl = string.Format
										(
											address
											, "http"
											, ":8080"
										);
			NetTcpBinding binding = new NetTcpBinding();
			//binding.Security.Transport.MsmqAuthenticationMode = MsmqAuthenticationMode.None;
			//binding.Security.Mode = MsmqIntegrationSecurityMode.None;
			_serviceHost.AddServiceEndpoint
									(
										typeof(IQueueAble)
										, binding
										, netTcpUrl
									);
			
			ServiceMetadataBehavior smb = _serviceHost.Description.Behaviors.Find<ServiceMetadataBehavior>();
			//发布元数据
			if (smb == null)
			{
				smb = new ServiceMetadataBehavior();
			}
			//smb.HttpGetEnabled = true;
			//smb.HttpGetUrl = new Uri(httpUrl);
			//smb.MetadataExporter.PolicyVersion = PolicyVersion.Policy15;
			_serviceHost.Description.Behaviors.Add(smb);
			// Add MEX endpoint
			_serviceHost.AddServiceEndpoint
									(
										ServiceMetadataBehavior.MexContractName,
										MetadataExchangeBindings.CreateMexTcpBinding(),
										netTcpUrl + "/mex"
									);
			ServiceThrottlingBehavior stb = new ServiceThrottlingBehavior();
			stb.MaxConcurrentCalls = 1000;
			stb.MaxConcurrentInstances = 1000;
			stb.MaxConcurrentSessions = 1000;
			_serviceHost.Description.Behaviors.Add(stb);
			_serviceHost.Open();
			Console.WriteLine("Wcf Service Host Opened ...");
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller serviceInstaller;
		private ServiceProcessInstaller processInstaller;
		public ProjectInstaller()
		{
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			serviceInstaller.StartType = ServiceStartMode.Manual;
			serviceInstaller.ServiceName = WindowsServiceHost.serviceName;
			Installers.Add(serviceInstaller);
			Installers.Add(processInstaller);
		}
	}
}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}
namespace Microshaoft
{
	using System;
	using Contracts.Services.Entitys;
	public class AsyncQueueProcessor
	{
		private AsyncQueue<Item> _queue;
		public AsyncQueue<Item> Queue
		{
			get
			{
				return _queue;
			}
		}
		public AsyncQueueProcessor(AsyncQueue<Item> queue)
		{
			_queue = queue;
			_queue.OnDequeue += new AsyncQueue<Item>.QueueEventHandler(_queue_OnDequeue);
			//_queue.OnDequeueThreadStart += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnDequeueAllThreadsEnd += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnDequeueThreadEnd += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			//_queue.OnQueueRunningThreadStart += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			//_queue.OnQueueRunningThreadEnd += new AsyncQueue<Item>.QueueLogEventHandler(_queue_OnQueueLog);
			_queue.OnException += new AsyncQueue<Item>.ExceptionEventHandler(_queue_OnException);
			_queue.MaxConcurrentThreadsCount = 64;
		}
		public void Enqueue(Item item)
		{
			_queue.Enqueue(item);
		}
		void _queue_OnQueueLog(string logMessage)
		{
			Console.WriteLine(logMessage);
		}
		void _queue_OnDequeue(Item item)
		{
			DateTime DequeueBeginTime = DateTime.Now;
			///			SqlConnection connection = null;
			///			try
			///			{
			///				connection = new SqlConnection(item.ConnectionString);
			///				SqlCommand command = new SqlCommand(item.SqlCommandText, connection);
			///				command.CommandType = CommandType.Text;
			///				connection.Open();
			///				command.ExecuteNonQuery();
			///			}
			///			catch (Exception e)
			///			{
			///				Console.WriteLine("Exception on Dequeue Process:{0}{1}", "\r\n", e.ToString());
			///			}
			///			finally
			///			{
			///				connection.Close();
			///				connection.Dispose();
			///				connection = null;
			///			}
			DateTime DequeueEndTime = DateTime.Now;
			Console.WriteLine
						(
							"QueueRemainCount {0}, Enqueue {1}, Dequeue {2},[{3}], End {4},[{5}],[{6}]"
							, _queue.Count
							, item.EnqueueTime
							, DequeueBeginTime
							, (DequeueBeginTime.Ticks - item.EnqueueTime.Ticks) / 10000 / 1000
							, DequeueEndTime
							, (DequeueEndTime.Ticks - DequeueBeginTime.Ticks) / 10000 / 1000
							, _queue.ConcurrentThreadsCount
						);
		}
		void _queue_OnException(Exception e)
		{
			Console.WriteLine(e.ToString());
		}
	}
}
//================================================================================================================
// Share.cs
namespace Contracts.Services
{
	using System.ServiceModel;
	using Contracts.Services.Entitys;
	[ServiceContract]
	public interface IQueueAble
	{
		[OperationContract]
		void Enqueue(Item element);
	}
}
namespace Contracts.Services.Entitys
{
	using System;
	using System.Runtime.Serialization;
	[DataContract]
	public class Item
	{
		private DateTime _EnqueueTime;
		[DataMember]
		public DateTime EnqueueTime
		{
			get
			{
				return _EnqueueTime;
			}
			set
			{
				_EnqueueTime = value;
			}
		}
		private string _sql;
		[DataMember]
		public string SqlCommandText
		{
			get
			{
				return _sql;
			}
			set
			{
				_sql = value;
			}
		}
		private string _connectionString;
		[DataMember]
		public string ConnectionString
		{
			get
			{
				return _connectionString;
			}
			set
			{
				_connectionString = value;
			}
		}
	}
}
//=======================================================================================
#T=Web.Config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    
  <system.web>

    <!--  动态调试编译
          设置 compilation debug="true" 以启用 ASPX 调试。否则，将此值设置为
          false 将提高此应用程序的运行时性能。
          设置 compilation debug="true" 以将调试符号(.pdb 信息)
          插入到编译页中。因为这将创建执行起来
          较慢的大文件，所以应该只在调试时将此值设置为 true，而在所有其他时候都设置为
          false。有关更多信息，请参考有关
          调试 ASP.NET 文件的文档。
    -->
    <compilation 
         defaultLanguage="c#"
         debug="true"
    />

    <!--  自定义错误信息
          设置 customErrors mode="On" 或 "RemoteOnly" 以启用自定义错误信息，或设置为 "Off" 以禁用自定义错误信息。 
          为每个要处理的错误添加 <error> 标记。

          "On" 始终显示自定义(友好的)信息。
          "Off" 始终显示详细的 ASP.NET 错误信息。
          "RemoteOnly" 只对不在本地 Web 服务器上运行的
           用户显示自定义(友好的)信息。出于安全目的，建议使用此设置，以便 
           不向远程客户端显示应用程序的详细信息。
    -->
    <customErrors 
    mode="RemoteOnly" 
    /> 

    <!--  身份验证 
          此节设置应用程序的身份验证策略。可能的模式是 "Windows"、 
          "Forms"、 "Passport" 和 "None"

          "None" 不执行身份验证。 
          "Windows" IIS 根据应用程序的设置执行身份验证 
            (基本、简要或集成 Windows)。在 IIS 中必须禁用匿名访问。
          "Forms" 您为用户提供一个输入凭据的自定义窗体(Web 页)，然后 
           在您的应用程序中验证他们的身份。用户凭据标记存储在 Cookie 中。
          "Passport" 身份验证是通过 Microsoft 的集中身份验证服务执行的，
           它为成员站点提供单独登录和核心配置文件服务。
    -->
    <authentication mode="Windows" /> 

	<!--  授权 
           此节设置应用程序的授权策略。可以允许或拒绝不同的用户或角色访问
          应用程序资源。通配符: "*" 表示任何人，"?" 表示匿名
          (未经身份验证的)用户。
    -->

    <authorization>
        <allow users="*" /> <!-- 允许所有用户 -->
            <!--  <allow     users="[逗号分隔的用户列表]"
                             roles="[逗号分隔的角色列表]"/>
                  <deny      users="[逗号分隔的用户列表]"
                             roles="[逗号分隔的角色列表]"/>
            -->
    </authorization>

    <!--  应用程序级别跟踪记录
          应用程序级别跟踪为应用程序中的每一页启用跟踪日志输出。
          设置 trace enabled="true" 可以启用应用程序跟踪记录。如果 pageOutput="true"，则
          在每一页的底部显示跟踪信息。否则，可以通过浏览 Web 应用程序
           根目录中的 "trace.axd" 页来查看
          应用程序跟踪日志。
    -->
    <trace
        enabled="false"
        requestLimit="10"
        pageOutput="false"
        traceMode="SortByTime"
		localOnly="true"
    />

    <!--  会话状态设置
          默认情况下，ASP.NET 使用 Cookie 来标识哪些请求属于特定的会话。
          如果 Cookie 不可用，则可以通过将会话标识符添加到 URL 来跟踪会话。
         若要禁用 Cookie，请设置 sessionState cookieless="true"。
    -->
    <sessionState 
            mode="InProc"
            stateConnectionString="tcpip=127.0.0.1:42424"
            sqlConnectionString="data source=127.0.0.1;Trusted_Connection=yes"
            cookieless="false" 
            timeout="20" 
    />

    <!--  全球化
          此节设置应用程序的全球化设置。
    -->
    <globalization 
            requestEncoding="utf-8" 
            responseEncoding="utf-8" 
   />
   
 </system.web>

</configuration>

#T=WebAPI/WCF restful jsonp 跨域 knockout.js simple Sample
// WCF.ServiceHost.cs
namespace Microshaoft.WCF.Services
{
	using System;
	using System.ServiceModel.Web;
	public class Program
	{
		static void Main()
		{
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
			using (WebServiceHost host = new WebServiceHost(typeof(PersonsServices)))
			{
				host.Open();
				Console.ReadLine();
			}
		}
	}
}
// Models.cs
namespace Microshaoft.Models
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Runtime.Serialization;
	public static class PersonsManager
	{
		public static List<Person> _persons = new Person[]
								{
									new Person("张嘀", 71, 178, 49)
									, new Person("章子怡", 23, 177, 33)
									, new Person("周迅", 12, 180, 80)
									, new Person("徐静蕾", 12, 150, 70)
									, new Person("赵薇", 23, 166, 60)
									, new Person("宋丹丹", 50, 183, 50)
									, new Person("翠花儿", 23, 177, 34)
									, new Person("赵丽蓉", 50, 184, 40)
									, new Person("郭晶晶", 50, 184, 41)
								}.ToList();
		public static List<Person> Persons
		{
			get
			{
				return _persons;
			}
		}
	}
	[DataContract]
	public class Person : IComparable<Person>
	{
		[DataMember]
		public string Name
		{
			get;
			set;
		}
		[DataMember]
		public int Age
		{
			get;
			set;
		}
		[DataMember]
		public int Height
		{
			get;
			set;
		}
		[DataMember]
		public int Weight
		{
			get;
			set;
		}
		public Person(string name, int age, int height, int weight)
		{
			Name = name;
			Age = age;
			Height = height;
			Weight = weight;
		}
		public Person()
		{
		}
		public override string ToString()
		{
			return
				string.Format
						(
							"姓名:{0}, 年龄:{1:N}, 体重:{2:N}, 身高:{3:N}"
							, Name
							, Age
							, Height
							, Weight
						);
		}
		public int CompareTo(Person other)
		{
			int r = 0;
			r = Age - other.Age;
			if (r == 0)
			{
				r = Height - other.Height;
				if (r == 0)
				{
					r = Weight - other.Weight;
				}
			}
			return r;
		}
	}
}
// WCF.Contracts.cs
namespace Microshaoft.WCF.Contracts
{
	using Microshaoft.Models;
	using System.Collections.Generic;
	using System.ServiceModel;
	using System.ServiceModel.Web;
	[ServiceContract]
	public interface IPersonsServices
	{
		[OperationContract]
		[
			WebInvoke
				(
					Method = "GET"
					, BodyStyle = WebMessageBodyStyle.WrappedRequest
					, ResponseFormat = WebMessageFormat.Json
					, UriTemplate = "{name}"
				)
		]
		IEnumerable<Person> GetData(string name);
	}
}
// WCF.Services.cs
namespace Microshaoft.WCF.Services
{
	using Microshaoft.Models;
	using Microshaoft.WCF.Contracts;
	using System.Collections.Generic;
	using System.Linq;
	using System.ServiceModel.Activation;
	[AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
	public class PersonsServices : IPersonsServices
	{
		public IEnumerable<Person> GetData(string name)
		{
			if (name == "*")
			{
				return PersonsManager.Persons;
			}
			else
			{
				return PersonsManager.Persons.Where(x => x.Name == name).ToList();
			}
		}
	}
}
// WebAPI.Controllers.cs
namespace Microshaoft.WebApi.Controllers
{
	using Microshaoft.Models;
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Net;
	using System.Net.Http;
	using System.Web.Http;
	public class PersonsController : ApiController
	{
		[HttpGet]
		public IEnumerable<Person> Jet(string name = "*")
		{
			if (name == "*")
			{
				return PersonsManager.Persons;
			}
			else
			{
				return PersonsManager.Persons.Where(x => x.Name == name).ToList();
			}
		}
		// POST api/values
		public void Post([FromBody]string value)
		{
		}
		public HttpResponseMessage Post(Person item)
		{
			PersonsManager.Persons.Add(item);
			var response = Request.CreateResponse<Person>(HttpStatusCode.Created, item);
			string uri = Url.Link("DefaultApi", new { Name = item.Name });
			response.Headers.Location = new Uri(uri);
			return response;
		}
		// PUT api/values/5
		public void Put(int id, [FromBody]string value)
		{
		}
		public void Put(int id, Person item)
		{
			PersonsManager.Persons[id] = item;
		}
		// DELETE api/values/5
		public void Delete(int id)
		{
			PersonsManager.Persons.RemoveAt(id);
		}
	}
}
// WebAPI.BundleConfig.cs
namespace Microshaoft.WebMvc
{
	using System.Web.Optimization;
	public class BundleConfig
	{
		// For more information on Bundling, visit http://go.microsoft.com/fwlink/?LinkId=254725
		public static void RegisterBundles(BundleCollection bundles)
		{
			bundles.Add
					(
						new ScriptBundle("~/bundles/jquery")
								.Include("~/Scripts/jquery-{version}.js")
					);
			bundles.Add
					(
						new ScriptBundle("~/bundles/jqueryui")
								.Include("~/Scripts/jquery-ui-{version}.js")
					);
			bundles.Add
					(
						new ScriptBundle("~/bundles/jqueryval")
								.Include
									(
										"~/Scripts/jquery.unobtrusive*"
										, "~/Scripts/jquery.validate*"
									)
					);
			// Use the development version of Modernizr to develop with and learn from. Then, when you're
			// ready for production, use the build tool at http://modernizr.com to pick only the tests you need.
			bundles.Add
					(
						new ScriptBundle("~/bundles/modernizr")
								.Include("~/Scripts/modernizr-*")
					);
			bundles.Add
					(
						new StyleBundle("~/Content/css")
								.Include("~/Content/site.css")
					);
			bundles.Add
					(
						new StyleBundle("~/Content/themes/base/css")
								.Include
									(
										"~/Content/themes/base/jquery.ui.core.css",
										"~/Content/themes/base/jquery.ui.resizable.css",
										"~/Content/themes/base/jquery.ui.selectable.css",
										"~/Content/themes/base/jquery.ui.accordion.css",
										"~/Content/themes/base/jquery.ui.autocomplete.css",
										"~/Content/themes/base/jquery.ui.button.css",
										"~/Content/themes/base/jquery.ui.dialog.css",
										"~/Content/themes/base/jquery.ui.slider.css",
										"~/Content/themes/base/jquery.ui.tabs.css",
										"~/Content/themes/base/jquery.ui.datepicker.css",
										"~/Content/themes/base/jquery.ui.progressbar.css",
										"~/Content/themes/base/jquery.ui.theme.css"
									)
					);
		}
	}
}
// WebAPI.FilterConfig.cs
namespace Microshaoft.WebMvc
{
	using System.Web.Mvc;
	public class FilterConfig
	{
		public static void RegisterGlobalFilters(GlobalFilterCollection filters)
		{
			filters.Add(new HandleErrorAttribute());
		}
	}
}
// WebAPI.RouteConfig.cs
namespace Microshaoft.WebMvc
{
	using System.Web.Mvc;
	using System.Web.Routing;
	public class RouteConfig
	{
		public static void RegisterRoutes(RouteCollection routes)
		{
			routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
			routes.MapRoute
						(
							name :
									"Default",
							url :
									"{controller}/{action}/{id}",
							defaults :
									new
									{
										controller = "Home",
										action = "Index",
										id = UrlParameter.Optional
									}
			);
		}
	}
}
// WebAPI.WebApiConfig.cs
namespace Microshaoft.WebApi
{
	using System.Web.Http;
	public static class WebApiConfig
	{
		public static void Register(HttpConfiguration config)
		{
			config.Routes.MapHttpRoute
							(
								name:
										"DefaultApi",
								routeTemplate:
										"services/restful/api/{controller}/{name}",
								defaults:
										new
										{
											id = RouteParameter.Optional
										}
							);
			// Uncomment the following line of code to enable query support for actions with an IQueryable or IQueryable<T> return type.
			// To avoid processing unexpected or malicious queries, use the validation settings on QueryableAttribute to validate incoming queries.
			// For more information, visit http://go.microsoft.com/fwlink/?LinkId=279712.
			//config.EnableQuerySupport();
			// To disable tracing in your application, please comment out or remove the following line of code
			// For more information, refer to: http://www.asp.net/web-api
			config.EnableSystemDiagnosticsTracing();
		}
	}
}
// Global.asax.cs
// Global.asax
/*
	<%@ Application Language="C#" Inherits="Microshaoft.Web.Global" %>
*/
namespace Microshaoft.Web
{
	using System.Diagnostics;
	using System.Web;
	using System.Web.Http;
	using System.Web.Mvc;
	using System.Web.Optimization;
	using System.Web.Routing;
	using System.ServiceModel.Activation;
	using Microshaoft;
	using Microshaoft.WebApi;
	using Microshaoft.WebMvc;
	using Microshaoft.WCF.Services;
	// Note: For instructions on enabling IIS6 or IIS7 classic mode, 
	// visit http://go.microsoft.com/?LinkId=9394801
	public class Global : HttpApplication
	{
		public static string PerformanceCountersCategoryName
		{
			get
			{
				return "Microshaoft EasyPerformanceCounters Category";
			}
		}
		public static string PerformanceCountersCategoryInstanceName
		{
			get
			{
				return string.Format
								(
									"{2}{0}{3}{1}{4}"
									, ": "
									, " @ "
									, Process.GetCurrentProcess().ProcessName
									, ""
									, "InTimingActionFilter"
								);
			}
		}
		public static MultiPerformanceCountersTypeFlags EnableCounters 
		{
			get
			{ 
				return
					MultiPerformanceCountersTypeFlags.ProcessCounter
					| MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
					| MultiPerformanceCountersTypeFlags.ProcessedCounter
					| MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter
					| MultiPerformanceCountersTypeFlags.ProcessingCounter;
			}
		}
		protected void Application_Start()
		{
			//return;
			AreaRegistration.RegisterAllAreas();
			var globalConfiguration = GlobalConfiguration.Configuration;
			globalConfiguration.Formatters.Insert(0, new JsonpMediaTypeFormatter());
			WebApiConfig.Register(globalConfiguration);
			FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
			RouteConfig.RegisterRoutes(RouteTable.Routes);
			// comment for Web API
			BundleConfig.RegisterBundles(BundleTable.Bundles);
			// WCF
			RouteTable.Routes.Add
							(
								new ServiceRoute
										(
											"services/restful/wcf/persons"
											, new WebServiceHostFactory()
											, typeof(PersonsServices)
										)
							);
			// PerformanceCounters
			EasyPerformanceCountersHelper.AttachPerformanceCountersCategoryInstance
					(
						Global.PerformanceCountersCategoryName
						, Global.PerformanceCountersCategoryInstanceName
					);
			GlobalConfiguration.Configuration.Filters.Add(new TimingActionFilter());
		}
	}
}
// WebAPI.JsonpMediaTypeFormatter.cs
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Net;
	using System.Net.Http;
	using System.Net.Http.Formatting;
	using System.Net.Http.Headers;
	using System.Threading.Tasks;
	using System.Web;
	public class JsonpMediaTypeFormatter : JsonMediaTypeFormatter
	{
		private string _callbackQueryParamter;
		public JsonpMediaTypeFormatter()
		{
			SupportedMediaTypes.Add(DefaultMediaType);
			SupportedMediaTypes.Add(new MediaTypeWithQualityHeaderValue("text/javascript"));
			MediaTypeMappings.Add(new UriPathExtensionMapping("jsonp", DefaultMediaType));
		}
		public string CallbackQueryParameter
		{
			get
			{
				return _callbackQueryParamter ?? "callback";
			}
			set
			{
				_callbackQueryParamter = value;
			}
		}
		public override Task WriteToStreamAsync
									(
										Type type
										, object value
										, Stream writeStream
										, HttpContent content
										, TransportContext transportContext
									)
		{
			string callback;
			if (IsJsonpRequest(out callback))
			{
				return Task.Factory.StartNew
										(
											() =>
											{
												var writer = new StreamWriter(writeStream);
												writer.Write(callback + "(");
												writer.Flush();
												base.WriteToStreamAsync(type, value, writeStream, content, transportContext).Wait();
												writer.Write(")");
												writer.Flush();
											}
										);
			}
			return base.WriteToStreamAsync(type, value, writeStream, content, transportContext);
		}
		private bool IsJsonpRequest(out string callback)
		{
			callback = null;
			switch (HttpContext.Current.Request.HttpMethod)
			{
				case "POST":
					callback = HttpContext.Current.Request.Form[CallbackQueryParameter];
					break;
				default:
					callback = HttpContext.Current.Request.QueryString[CallbackQueryParameter];
					break;
			}
			return !string.IsNullOrEmpty(callback);
		}
	}
}
// WebApi.MVC.TimingActionFilter.cs
namespace Microshaoft.Web
{
	using System;
	using System.Diagnostics;
	using System.Linq;
	using System.Web.Http.Controllers;
	using System.Web.Http.Filters;
	//using Microshaoft.WebApplications;
	public class TimingActionFilter : ActionFilterAttribute
	{
		private const string Key = "__action_duration__";
		private string _performanceCountersCategoryName = Global.PerformanceCountersCategoryName;
		private string _performanceCountersCategoryInstanceName = Global.PerformanceCountersCategoryInstanceName;
		private MultiPerformanceCountersTypeFlags _enableCounters = Global.EnableCounters;
		public override void OnActionExecuting(HttpActionContext actionContext)
		{
			if (SkipLogging(actionContext))
			{
				return;
			}
			Stopwatch stopwatch =
								EasyPerformanceCountersHelper.CountPerformanceBegin
											(
												_enableCounters
												, _performanceCountersCategoryName
												, _performanceCountersCategoryInstanceName
											);
			if (stopwatch != null)
			{
				actionContext.Request.Properties[Key] = stopwatch;
			}
		}
		public override void OnActionExecuted(HttpActionExecutedContext actionExecutedContext)
		{
			if (!actionExecutedContext.Request.Properties.ContainsKey(Key))
			{
				return;
			}
			var stopwatch = actionExecutedContext.Request.Properties[Key] as Stopwatch;
			EasyPerformanceCountersHelper.CountPerformanceEnd
								(
									_enableCounters
									, _performanceCountersCategoryName
									, _performanceCountersCategoryInstanceName
									, stopwatch
								);
			if (stopwatch != null)
			{
				var actionName = actionExecutedContext.ActionContext.ActionDescriptor.ActionName;
				var controllerName = actionExecutedContext.ActionContext.ActionDescriptor.ControllerDescriptor.ControllerName;
				Debug.Print(string.Format("[Execution of{0}- {1} took {2}.]", controllerName, actionName, stopwatch.Elapsed));
				stopwatch = null;
			}
		}
		private static bool SkipLogging(HttpActionContext actionContext)
		{
			return actionContext.ActionDescriptor.GetCustomAttributes<NoLogAttribute>().Any() ||
					actionContext.ControllerContext.ControllerDescriptor.GetCustomAttributes<NoLogAttribute>().Any();
		}
	}
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, Inherited = true)]
	public class NoLogAttribute : Attribute
	{
	}
}
// .html
/*
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Microshaoft Cross-Domain + ASP.NET MVC 4 WebAPI  + JsonpMediaTypeFormatter + WCF + JsonP + Knockout.js + MVVM Sample</title>
	<!-- <base href="http://api.asp.net.local" /> -->
	<!-- <script src="http://api.asp.net.local/Scripts/jquery.mobile-1.3.1.js" type="text/javascript"></script> -->
	<script src="http://scripts.asp.net.local/Scripts/jquery-1.8.2.js" type="text/javascript"></script>
	<script src="http://scripts.asp.net.local/Scripts/knockout-2.3.0.js" type="text/javascript"></script>
	<script src="http://scripts.asp.net.local/Scripts/knockout.simpleGrid.1.3.js" type="text/javascript"></script>
</head>
<body>
	<input type="button" value="Load from IIS+WebAPI+JsonP+Cross-Domain" onclick="GetData('http://api.asp.net.local/services/restful/api/persons/*?callback=?');" />
	<br />
	<input type="button" value="Load from Console+WCF+JsonP+Cross-Domain" onclick="GetData('http://api.asp.net.local:1080/services/restful/wcf/persons/*?callback=?');" />
	<br />
	<input type="button" value="Load from IIS+WCF+Json" onclick="GetData('http://portal.asp.net.local/services/restful/wcf/persons/*');" />
	<br />
	<div>
		<div data-bind='simpleGrid: gridViewModel'>
			PlaceHolder
		</div>
		<button data-bind='click: sortByPriceDesc'>
			Sort by Price Desc
		</button>
		<button data-bind='click: jumpToFirstPage, enable: gridViewModel.currentPageIndex'>
			Jump to first page
		</button> 
	</div>
	<script type="text/javascript">
	<!--
		function GetData(url)
		{
			//jsonp cross domain
			//alert(url);
			$.getJSON(
						url
						, function(data){
							//alert(data);
							$.each(data, function(i ,item){
								vm.addItem(item);
										}
									);
							}
					);
			//jsonp cross domain
//			$.ajax({
//				url : 'http://api.asp.net.local/services/restful/api/persons',
//				type : 'GET',
//				dataType : 'jsonp',
//				success : function (data) {
//					vm.addItems(data);
//				}
//			});
//			$.get(
//					'http://api.asp.net.local/services/restful/api/persons'
//					, function (data) {
//						vm.addItems(data);
//					}
//				);
		}
		var PagedGridModel = function(items) {
			this.items = ko.observableArray(items);
			this.addItem = function(item) {
				this.items.push(item);
			};
			this.addItems = function(items) {
				for (var i in items) {
					this.items.push(items[i]);
				}
			};
			this.sortByPriceDesc = function() {
				this.items.sort(function(a, b) {
					var r = a.Weight.toFixed(2) < b.Weight.toFixed(2) ? 1 : -1;
					return r;
				});
			};
			this.jumpToFirstPage = function() {
				this.gridViewModel.currentPageIndex(0);
			};
			this.gridViewModel = new ko.simpleGrid.viewModel(
				{
					data: this.items ,
					columns: [
								{
									headerText : "Item Name",
									rowText : "Name"
								},
								{
									headerText : "Sales Count",
									rowText : "Age"
								},
								{
									headerText : "Price",
									rowText : function (item) {
													return "$" + item.Weight.toFixed(2)
												}
								}
					],
					pageSize : 9
				});
		};
		var vm = new PagedGridModel([]);
		ko.applyBindings(vm);
	//-->
	</script>
</body>
</html>
*/
// Web.Config
/*
<?xml version="1.0" encoding="utf-8"?>
<!--
	For more information on how to configure your ASP.NET application, please visit
	http://go.microsoft.com/fwlink/?LinkId=169433
-->
<configuration>
	<configSections>
		<section name="glimpse" type="Glimpse.Core.Configuration.Section, Glimpse.Core" />
	</configSections>
	<system.serviceModel>
		<behaviors>
			<endpointBehaviors>
				<behavior name="webHttpBehavior">
					<webHttp />
				</behavior>
			</endpointBehaviors>
		</behaviors>
		<bindings>
			<webHttpBinding>
				<binding
					name="webHttpBindingWithJsonP"
					crossDomainScriptAccessEnabled="true"
				/>
			</webHttpBinding>
		</bindings>
		<services>
			<service name="Microshaoft.WCF.Services.PersonsServices">
				<endpoint
					binding="webHttpBinding"
					bindingConfiguration="webHttpBindingWithJsonP"
					contract="Microshaoft.WCF.Contracts.IPersonsServices"
					behaviorConfiguration="webHttpBehavior"
				/>
			</service>
		</services>
		<serviceHostingEnvironment
			aspNetCompatibilityEnabled="true"
			multipleSiteBindingsEnabled="true"
		/>
	</system.serviceModel>
	<connectionStrings>
		<add
			name="GlimpseAppDB"
			connectionString="Application Name=GlimpseApp;Persist Security Info=False;Data Source=.\Enterprise2012;Integrated Security=SSPI;"
			providerName="System.Data.SqlClient"
		/>
	</connectionStrings>
	<system.diagnostics>
			<sources>
				<source name="Example Source" switchName="sourceSwitch" switchType="System.Diagnostics.SourceSwitch">
					<listeners>
						<add name="GlimpseListener"/>
					</listeners>
				</source>
			</sources>
			<switches>
				<add name="sourceSwitch" value="Warning"/>
			</switches>
		<sharedListeners>
			<add name="GlimpseListener" type="Glimpse.Core.TraceListener, Glimpse.Core"/>
		</sharedListeners>
	</system.diagnostics>
	<system.web>
	<!--
		Glimpse: This can be commented in to add additional data to the Trace tab when using WebForms
		<trace writeToDiagnosticsTrace="true" enabled="true" pageOutput="false"/>
	-->
		<trace enabled="false" pageOutput="false" localOnly="false"/>
		<httpModules>
			<add name="Glimpse" type="Glimpse.AspNet.HttpModule, Glimpse.AspNet" />
		</httpModules>
		<httpHandlers>
			<add path="glimpse.axd" verb="GET" type="Glimpse.AspNet.HttpHandler, Glimpse.AspNet" />
		</httpHandlers>
		<httpRuntime requestPathInvalidCharacters="" requestValidationMode="2.0" />
		<pages validateRequest="false" />
	</system.web>
	<system.webServer>
		<validation validateIntegratedModeConfiguration="false" />
		<handlers>
			<add name="Glimpse" path="glimpse.axd" verb="GET" type="Glimpse.AspNet.HttpHandler, Glimpse.AspNet" preCondition="integratedMode" />
		</handlers>
		<modules>
			<add name="Glimpse" type="Glimpse.AspNet.HttpModule, Glimpse.AspNet" preCondition="integratedMode" />
		</modules>
	</system.webServer>
	<glimpse defaultRuntimePolicy="On" endpointBaseUri="~/Glimpse.axd">
	<!--
		If you are having issues with Glimpse, please include this. It will help us figure out whats going on.
		<logging level="Trace" />
	-->
	<!--
		Want to use Glimpse on a remote server? Ignore the LocalPolicy by removing this comment.
		<runtimePolicies>
			<ignoredTypes>
				<add type="Glimpse.AspNet.Policy.LocalPolicy, Glimpse.AspNet"/>
			</ignoredTypes>
		</runtimePolicies>
	-->
	</glimpse>
</configuration>
*/
// WCF.ServiceHost.exe.Config
/*
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
	<system.serviceModel>
		<behaviors>
			<endpointBehaviors>
				<behavior name="webHttpBehavior">
					<webHttp />
				</behavior>
			</endpointBehaviors>
		</behaviors>
		<bindings>
			<webHttpBinding>
				<binding
					name="webHttpBindingWithJsonP"
					crossDomainScriptAccessEnabled="true"
				/>
			</webHttpBinding>
		</bindings>
		<services>
			<service name="Microshaoft.WCF.Services.PersonsServices">
				<!--
					address="http://api.asp.net.local:1080/services/restful/wcf/persons"
				-->
				<endpoint
					address="http://api.asp.net.local:1080/services/restful/wcf/persons"
					binding="webHttpBinding"
					bindingConfiguration="webHttpBindingWithJsonP"
					contract="Microshaoft.WCF.Contracts.IPersonsServices"
					behaviorConfiguration="webHttpBehavior"
				/>
			</service>
		</services>
		<serviceHostingEnvironment
			aspNetCompatibilityEnabled="true"
			multipleSiteBindingsEnabled="true"
		/>
	</system.serviceModel>
</configuration>
*/

#T=WebBrowser ActiveXInstance Simple Sample
// /r:"C:\Program Files\Microsoft.NET\Primary Interop Assemblies\Microsoft.mshtml.dll";"C:\Program Files\Microsoft.NET\Primary Interop Assemblies\Interop.SHDocVw.dll"
namespace Microshaoft
{
	using System;
	using System.ComponentModel;
	using System.Drawing;
	using System.Windows.Forms;
	using AxWebBrowser = SHDocVw.WebBrowser;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
	public partial class Form1 : Form
	{
		public AxWebBrowser _AxWebBrowser = null;
		public Form1()
		{
			InitializeComponent();
			this._AxWebBrowser = (AxWebBrowser) webBrowser1.ActiveXInstance;
			this._AxWebBrowser.NewWindow3 += new SHDocVw.DWebBrowserEvents2_NewWindow3EventHandler(_AxWebBrowser_NewWindow3);
			this._AxWebBrowser.NewWindow2 += new SHDocVw.DWebBrowserEvents2_NewWindow2EventHandler(_AxWebBrowser_NewWindow2);
			this.webBrowser1.Navigated += new WebBrowserNavigatedEventHandler(webBrowser1_Navigated);
		}
		void _AxWebBrowser_NewWindow2(ref object ppDisp, ref bool Cancel)
		{
			throw new NotImplementedException();
		}
		void _AxWebBrowser_NewWindow3(ref object ppDisp, ref bool Cancel, uint dwFlags, string bstrUrlContext, string bstrUrl)
		{
			throw new NotImplementedException();
		}
		private void button1_Click(object sender, EventArgs e)
		{
			this.webBrowser1.Navigate(@"http://test.v20.asp.net/CookiesWrite.aspx");
		}
		void webBrowser1_Navigated(object sender, WebBrowserNavigatedEventArgs e)
		{
			MessageBox.Show("webBrowser1_Navigated");
		}
	}
	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.webBrowser1 = new WebBrowser();
			this.button1 = new Button();
			this.SuspendLayout();
			// 
			// webBrowser1
			// 
			this.webBrowser1.Dock = DockStyle.Bottom;
			this.webBrowser1.Location = new Point(0, 91);
			this.webBrowser1.MinimumSize = new Size(20, 20);
			this.webBrowser1.Name = "webBrowser1";
			this.webBrowser1.Size = new Size(292, 182);
			this.webBrowser1.TabIndex = 0;
			// 
			// button1
			// 
			this.button1.Location = new Point(41, 34);
			this.button1.Name = "button1";
			this.button1.Size = new Size(75, 23);
			this.button1.TabIndex = 1;
			this.button1.Text = "button1";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new EventHandler(this.button1_Click);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new SizeF(6F, 12F);
			this.AutoScaleMode = AutoScaleMode.Font;
			this.ClientSize = new Size(292, 273);
			this.Controls.Add(this.button1);
			this.Controls.Add(this.webBrowser1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.ResumeLayout(false);
		}
		#endregion
		private WebBrowser webBrowser1;
		private Button button1;
	}
}

#T=WebBrowser Doc mshtml event
namespace TestApplication
{
	using System;
	using System.Collections.Generic;
	//using System.Linq;
	using System.Windows.Forms;

	using Microshaoft;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}

namespace TestApplication
{
	using System;

	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;

	using System.Collections.Generic;
	using System.ComponentModel;

	using System.Threading;

	using Microshaoft;

	using mshtml;

	public partial class Form1 : Form
	{
		public Form1()
		{
			InitializeComponent();
		}

		private MouseHooker hooker;

		private void Form1_Load(object sender, EventArgs e)
		{

			Rectangle rect = new Rectangle(0, 0, 300, 300);
			// Create a Shape object and call 
			// GetRectRegion method 
			Shape shp = new Shape();
			//this.Region = shp.GetRectRegion(rect);	
			//this.BackColor = Color.BurlyWood;
			//this.Border = 

			hooker = new MouseHooker();
			this.DoubleBuffered = true;
			this.webBrowser1.DocumentCompleted += new WebBrowserDocumentCompletedEventHandler(AddScriptSrc);

			this.webBrowser1.Navigate(@"http://microshaoft.google.com/text.htm");

			this.AllowDrop = true;
			bool b = false;
			b = hooker.SetHook();
			Console.WriteLine(b);



			this.hooker.HookedMouseActive += new MouseHooker.MouseHookerEventHandler(hooker_HookedMouseActive);

			this.hooker.HookedMouseDrag += new MouseHooker.MouseHookerEventHandler(hooker_HookedMouseDrag);
			this.hooker.HookedMouseDown += new MouseHooker.MouseHookerEventHandler(hooker_HookedMouseDown);
			this.hooker.HookedMouseUp += new MouseHooker.MouseHookerEventHandler(hooker_HookedMouseUp);

		}

		void hooker_HookedMouseUp(MouseHooker sender, MouseEventArgs e)
		{
			Console.WriteLine("Type: {0}", doc.selection.type);
			Console.WriteLine("className: {0}", doc.activeElement.className);
			Console.WriteLine("tagName: {0}", doc.activeElement.tagName);
			if ("textarea,input".IndexOf(doc.activeElement.tagName.ToLower()) < 0 )
			{
				doc.selection.empty();
			}
		}


		private bool domDocument_onselectstart(mshtml.IHTMLEventObj e)
		{
			bool b = !this._IsDragging;
			b = true;
			//e.returnValue = b;
			Console.WriteLine("domDocument_onselectstart {0}", b);
			return (bool)e.returnValue;
		}
		private void domDocument_onselectchange(mshtml.IHTMLEventObj e)
		{
			e.returnValue = false;
			Console.WriteLine("domDocument_onselectchange");

		}

		void domDocument_onbeforeeditfocus(IHTMLEventObj pEvtObj)
		{
			//throw new NotImplementedException();
			Console.WriteLine("domDocument_onbeforeeditfocus");
		}
		private bool domDocument_ondblclick(mshtml.IHTMLEventObj e)
		{
			bool b = false;
			e.returnValue = b;
			Console.WriteLine("domDocument_ondblclick {0}", e.returnValue);
			_AllowFocus = true;
			return b;
		}
		private bool _AllowFocus = false;
		bool domDocument_ondragstart(IHTMLEventObj e)
		{
			bool b = e.fromElement.isTextEdit;

			e.returnValue = true;//e.fromElement.isTextEdit;
			Console.WriteLine("domDocument_ondragstart {0}", e.fromElement.isTextEdit);
			//_AllowFocus = false;
			return true;
		}
		private mshtml.HTMLDocumentEvents2_Event _iEvent;
		mshtml.HTMLDocument doc;
		private void AddScriptSrc(object sender, WebBrowserDocumentCompletedEventArgs e)
		{
			WebBrowser wb = (WebBrowser)sender;
			HtmlDocument hd = wb.Document;
			HtmlElement body = hd.Body;

		  
			doc = (mshtml.HTMLDocument)hd.DomDocument;
			//mshtml.HTMLDocumentEvents2_Event _iEvent;
			_iEvent = (mshtml.HTMLDocumentEvents2_Event)doc;
			//_iEvent.ondblclick += new HTMLDocumentEvents2_ondblclickEventHandler(domDocument_ondblclick);
			//_iEvent.onselectstart += new mshtml.HTMLDocumentEvents2_onselectstartEventHandler(domDocument_onselectstart);
			//_iEvent.onselectchange += new mshtml.HTMLDocumentEvents2_onselectchangeEventHandler(domDocument_onselectchange);
			//_iEvent.ondragstart += new HTMLDocumentEvents2_ondragstartEventHandler(domDocument_ondragstart);

			//iEvent.onmouseover += new mshtml.HTMLDocumentEvents2_onmouseoverEventHandler(MouseOverEventHandler);

   



			HtmlElement script = hd.CreateElement("script");
			IHTMLScriptElement IScript = (IHTMLScriptElement)script.DomElement;
			try
			{
				IScript.src = @"C:\Documents and Settings\v-xiyu\桌面\MicrosoftAjax.debug.js";
				//IScript.text = s;
				IScript.type = "text/javascript";
				IScript.defer = true;
				body.InsertAdjacentElement(HtmlElementInsertionOrientation.AfterBegin, script);
			}
			catch (Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
		}


		private Point lastLocation;
		void hooker_HookedMouseDown(MouseHooker sender, MouseEventArgs e)
		{

			
			if (e.Button == MouseButtons.Left)
			{
				if (lastLocation == null)
				{
					lastLocation = new Point();
				}
				lastLocation.X = e.X - this.Left;
				lastLocation.Y = e.Y - this.Top;
			}
		   // doc.selection.clear();
		}

		bool lastIsMouseIn = false;
		void hooker_HookedMouseActive(MouseHooker sender, MouseEventArgs e)
		{

			bool IsMouseIn = false;
			if ((e.X < this.Left)
				|| (e.Y < this.Top)
				|| (e.X > this.Left + this.Width)
				|| (e.Y > this.Top + this.Height)
				)
			{
				//Console.WriteLine("leave");
				IsMouseIn = false;
			}
			else//(IsMouseIn)
			{
				//Console.WriteLine("enter");
				IsMouseIn = true;
			}
			if (IsMouseIn != lastIsMouseIn)
			{
				//this.Visible = false;
				if (IsMouseIn)
				{

					this.Opacity = 1;
				}
				else
				{
					this.Opacity = .5;
				}
				this.Invalidate();
				lastIsMouseIn = IsMouseIn;
				Console.WriteLine(lastIsMouseIn);
			}


			//doc.selection.clear();
		}
		private bool _IsDragging = false;

		void hooker_HookedMouseDrag(MouseHooker sender, MouseEventArgs e)
		{
			//throw new NotImplementedException();
			this.Text = e.X.ToString();
			this.Location = new Point(e.X - lastLocation.X, e.Y - lastLocation.Y);
			this._IsDragging = true;

			//this.Location = new Point(this.Left + (e.X - hooker.LastMousePosition.X),this.Top + (e.Y - hooker.LastMousePosition.Y));
		}

		private void button1_Click(object sender, EventArgs e)
		{
			MessageBox.Show("Button Click");
			Screen.GetWorkingArea(this.webBrowser1);
		}
		private void Form1_Click(object sender, EventArgs e)
		{
			MessageBox.Show("Form Click");
		}
	}

}

namespace TestApplication
{
	using System;
	using System.Drawing;
	using System.Windows.Forms;

	using Microshaoft;

	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			bool b = hooker.UnHook();
			Console.WriteLine(b);
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new Button();
			this.webBrowser1 = new WebBrowser();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new Point(117, 67);
			this.button1.Name = "button1";
			this.button1.Size = new Size(92, 37);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new EventHandler(this.button1_Click);
			// 
			// webBrowser1
			// 
			this.webBrowser1.Location = new Point(72, 148);
			this.webBrowser1.MinimumSize = new Size(20, 20);
			this.webBrowser1.Name = "webBrowser1";
			this.webBrowser1.Size = new Size(125, 82);
			this.webBrowser1.TabIndex = 1;
			this.webBrowser1.IsWebBrowserContextMenuEnabled = false;
			this.webBrowser1.Dock = DockStyle.Fill;
			//this.webBrowser1.ScrollBarsEnabled = false;
			// 
			// Form1
			// 
			//this.BackgroundImage = (Image) new Bitmap(AppDomain.CurrentDomain.BaseDirectory + @"\bill.jpg");
			this.AutoScaleDimensions = new SizeF(6F, 12F);
			this.AutoScaleMode = AutoScaleMode.Font;
			this.ClientSize = new Size(292, 273);
			this.Controls.Add(this.webBrowser1);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new EventHandler(this.Form1_Load);
			this.Click += new EventHandler(this.Form1_Click);
			this.ResumeLayout(false);

		}

		#endregion

		private Button button1;
		public WebBrowser webBrowser1;
	}
}

namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Data;
	using System.Drawing.Drawing2D;
	public class Shape
	{
		public Shape()
		{
		}
		public Region GetPolyRegion(Point[] pts)
		{
			// Create a graphics path
			GraphicsPath path =
				new GraphicsPath(FillMode.Alternate);
			path.AddPolygon(pts);
			// Create a Region object from the path
			// and set it as the form's region
			Region rgn = new Region(path);
			return rgn;
		}
		public Region GetRectRegion(Rectangle rct)
		{
			// Create a graphics path
			GraphicsPath path =
				new GraphicsPath(FillMode.Alternate);
			path.AddEllipse(rct);
			// Create a Region object from the path
			// and set it as the form's region
			Region rgn = new Region(path);
			return rgn;
		}
	}

}

namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	using System.Windows.Forms;

	using System.Drawing;

	using System.Reflection;

	using System.Threading;

	using System.Diagnostics;
	public class MouseHooker
	{

		public delegate void MouseHookerEventHandler
					(
						MouseHooker sender
						, MouseEventArgs e
					);

		public event MouseHookerEventHandler HookedMouseMove;
		public event MouseHookerEventHandler HookedMouseDown;
		public event MouseHookerEventHandler HookedMouseUp;
		public event MouseHookerEventHandler HookedMouseDrag;

		public event MouseHookerEventHandler HookedMouseActive;

		private delegate int HookProc(int nCode, IntPtr wParam, IntPtr lParam);
		//Declare the mouse hook constant.
		//For other hook types, you can obtain these values from Winuser.h in the Microsoft SDK.
		//Declare MouseHookedProcedure as a HookProc type.
		private HookProc MouseHookedProcedure;

		//Declare the hook handle as an int.
		private int hHook = 0;
		private Point lastMousePosition;
		private bool IsDrag = false;

		public bool SetHook()
		{
			if (hHook == 0)
			{
				// Create an instance of HookProc.
				MouseHookedProcedure = new HookProc(MouseHookedProc);

				///			using (Process process = Process.GetCurrentProcess())
				///
				///			using (ProcessModule pm = process.MainModule)
				///			{
				///				hHook = SetWindowsHookEx
				///							(
				///								WH_MOUSE
				///								, MouseHookedProcedure
				///								
				///								, GetModuleHandle(pm.ModuleName)
				///								, 0
				///							);
				///			}

				///				hMouseHook = SetWindowsHookEx( WH_MOUSE_LL,
				///					MouseHookProcedure, 
				///					Marshal.GetHINSTANCE(
				///						Assembly.GetExecutingAssembly().GetModules()[0]),
				///					0);

				hHook = SetWindowsHookEx
							(
								WH_MOUSE_LL
								, MouseHookedProcedure
					//, (IntPtr) 0
				, Marshal.GetHINSTANCE(
						Assembly.GetExecutingAssembly().GetModules()[0])

								//, threadID
								, 0 //GetCurrentThreadId()
					//Thread.CurrentThread.ManagedThreadId
							);

				//Console.WriteLine("{0},{1}", AppDomain.GetCurrentThreadId(), Thread.CurrentThread.ManagedThreadId);
				//If the SetWindowsHookEx function fails.

			}
			return (hHook != 0);
		}
		public bool UnHook()
		{
			bool r = UnhookWindowsHookEx(hHook);
			hHook = 0;
			return r;
		}

		//Declare the wrapper managed POINT class.
		[StructLayout(LayoutKind.Sequential)]
		public struct PointStruct
		{
			public int x;
			public int y;
		}

		//Declare the wrapper managed MouseHookStruct class.
		[StructLayout(LayoutKind.Sequential)]
		public struct MouseHookStruct
		{
			public PointStruct pt;
			public int hwnd;
			public int wHitTestCode;
			public int dwExtraInfo;
		}

		[
			DllImport
				(
					"kernel32.dll"
				)
		]
		private static extern int GetCurrentThreadId();


		//This is the Import for the SetWindowsHookEx function.
		//Use this function to install a thread-specific hook.
		[
			DllImport
				(
					"user32.dll"
					, CharSet = CharSet.Auto
					, CallingConvention = CallingConvention.StdCall
				)
		]
		private static extern int SetWindowsHookEx
										(
											int idHook
											, HookProc lpfn
											, IntPtr hInstance
											, int threadId
										);

		//This is the Import for the UnhookWindowsHookEx function.
		//Call this function to uninstall the hook.
		[
			DllImport
				(
					"user32.dll"
					, CharSet = CharSet.Auto
					, CallingConvention = CallingConvention.StdCall
				)
		]
		private static extern bool UnhookWindowsHookEx(int idHook);

		//This is the Import for the CallNextHookEx function.
		//Use this function to pass the hook information to the next hook procedure in chain.
		[
			DllImport
				(
					"user32.dll"
					, CharSet = CharSet.Auto
					, CallingConvention = CallingConvention.StdCall
				)
		]
		private static extern int CallNextHookEx
									(
										int idHook
										, int nCode
										, IntPtr wParam
										, IntPtr lParam
									);

		[
			DllImport
				(
					"kernel32.dll"
					, CharSet = CharSet.Auto
					, SetLastError = true
				)
		]
		private static extern IntPtr GetModuleHandle(string lpModuleName);


		public Point LastMousePosition
		{
			private set
			{
				this.lastMousePosition = value;
			}
			get
			{
				return this.lastMousePosition;
			}
		}

		private int MouseHookedProc(int nCode, IntPtr wParam, IntPtr lParam)
		{
			int wparam = (int)wParam;
			//Marshall the data from the callback.
			MouseHookStruct mouseHookStruct = (MouseHookStruct)Marshal.PtrToStructure
															(
																lParam
																, typeof(MouseHookStruct)
															);


			if (nCode >= 0)
			{

				int x = mouseHookStruct.pt.x;//; - this.Left;
				int y = mouseHookStruct.pt.y;//; - this.Top;
				//Console.WriteLine("{0},{1}", x,y);

				if (this.HookedMouseActive != null)
				{
					MouseButtons mb = MouseButtons.None;
					MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
					this.HookedMouseActive(this, e);
				}

				if (wparam == WM_LBUTTONDOWN)
				{
					if (this.IsDrag == false)
					{
						this.IsDrag = true;

						if (this.lastMousePosition == null)
						{
							this.lastMousePosition = new Point();
						}

						this.lastMousePosition.X = x;
						this.lastMousePosition.Y = y;
						if (this.HookedMouseDown != null)
						{
							MouseEventArgs e = new MouseEventArgs(MouseButtons.Left, 1, x, y, 0);
							this.HookedMouseDown(this, e);
						}
					}
				}
				if (wparam == WM_MOUSEMOVE)
				{
					MouseButtons mb = MouseButtons.None;
					if (IsDrag == true)
					{
						mb = MouseButtons.Left;
						if (this.HookedMouseDrag != null)
						{
							MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
							this.HookedMouseDrag(this, e);
						}
					}

					if (this.HookedMouseMove != null)
					{
						MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
						this.HookedMouseMove(this, e);
					}
					//IsDrag = false;
				}

				if ((wparam == WM_LBUTTONUP) || (wparam == WM_RBUTTONUP))
				{
					IsDrag = false;
					MouseButtons mb = MouseButtons.None;
					if (this.HookedMouseUp != null)
					{
						if (wparam == WM_LBUTTONUP)
						{
							mb = MouseButtons.Left;
						}
						else if (wparam == WM_RBUTTONUP)
						{
							mb = MouseButtons.Right;
						}
						MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
						this.HookedMouseUp(this, e);
					}
				}
				if (wparam == WM_RBUTTONDOWN)
				{
					IsDrag = false;
				}
			}
			return CallNextHookEx(hHook, nCode, wParam, lParam);
		}

		[DllImport("user32.dll")]
		public static extern bool ReleaseCapture();


		[DllImport("user32")]
		public static extern IntPtr SetCapture(IntPtr hWnd);

		[DllImport("user32")]
		public static extern IntPtr GetCapture();



		[DllImport("user32.dll")]
		public static extern bool SendMessage
									(
										IntPtr hwnd
										, int wMsg
										, int wParam
										, int lParam
									);

		private const int WM_SYSCOMMAND = 0x0112;
		private const int SC_MOVE = 0xF010;
		private const int HTCAPTION = 0x0002;

		private const int WM_MOUSEMOVE = 0x200;
		private const int WM_LBUTTONDOWN = 0x201;
		private const int WM_RBUTTONDOWN = 0x204;
		private const int WM_MBUTTONDOWN = 0x207;
		private const int WM_LBUTTONUP = 0x202;
		private const int WM_RBUTTONUP = 0x205;
		private const int WM_MBUTTONUP = 0x208;
		private const int WM_LBUTTONDBLCLK = 0x203;
		private const int WM_RBUTTONDBLCLK = 0x206;
		private const int WM_MBUTTONDBLCLK = 0x209;

		private const int WH_MOUSE = 7;
		private const int WH_MOUSE_LL = 14;
	}

}
#T=WebBrowser Drag Hook

namespace TestApplication
{
	using System;
	using System.Collections.Generic;
	//using System.Linq;
	using System.Windows.Forms;

	using Microshaoft;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}

namespace TestApplication
{
	using System;

	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;

	using System.Collections.Generic;
	using System.ComponentModel;

	using System.Threading;

	using Microshaoft;

	using mshtml;

	public partial class Form1 : Form
	{
		public Form1()
		{
			InitializeComponent();
		}

		private MouseHooker hooker;

		private void Form1_Load(object sender, EventArgs e)
		{

			Rectangle rect = new Rectangle(0, 0, 300, 300);
			// Create a Shape object and call 
			// GetRectRegion method 
			Shape shp = new Shape();
			this.Region = shp.GetRectRegion(rect);	
			//this.BackColor = Color.BurlyWood;
			//this.Border = 

			hooker = new MouseHooker();
			this.DoubleBuffered = true;
			this.webBrowser1.DocumentCompleted += new WebBrowserDocumentCompletedEventHandler(AddScriptSrc);

			this.webBrowser1.Navigate(@"http://silverlight.local.microshaoft.net/SLvsFlash/Default.htm");

			this.AllowDrop = true;
			bool b = hooker.SetHook();
			Console.WriteLine(b);



			this.hooker.HookedMouseActive += new MouseHooker.MouseHookerEventHandler(hooker_HookedMouseActive);

			this.hooker.HookedMouseDrag += new MouseHooker.MouseHookerEventHandler(hooker_HookedMouseDrag);
			this.hooker.HookedMouseDown += new MouseHooker.MouseHookerEventHandler(hooker_HookedMouseDown);

		}

		private void AddScriptSrc(object sender, WebBrowserDocumentCompletedEventArgs e)
		{
			WebBrowser wb = (WebBrowser) sender;
			HtmlDocument hd = wb.Document;
			HtmlElement body = hd.Body;
			HtmlElement script = hd.CreateElement("script");
			IHTMLScriptElement IScript = (IHTMLScriptElement) script.DomElement;
			try
			{
				IScript.src = @"C:\Documents and Settings\v-xiyu\桌面\MicrosoftAjax.debug.js";
				//IScript.text = s;
				IScript.type = "text/javascript";
				IScript.defer = true;
				body.InsertAdjacentElement(HtmlElementInsertionOrientation.AfterBegin, script);
			}
			catch (Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
		}


		private Point lastLocation;
		void hooker_HookedMouseDown(MouseHooker sender, MouseEventArgs e)
		{
			if (e.Button == MouseButtons.Left)
			{
				if (lastLocation == null)
				{
					lastLocation = new Point();
				}
				lastLocation.X = e.X - this.Left;
				lastLocation.Y = e.Y - this.Top;
			}
		}

		bool lastIsMouseIn = false;
		void hooker_HookedMouseActive(MouseHooker sender, MouseEventArgs e)
		{

			bool IsMouseIn = false;
				if ((e.X < this.Left) 
					|| (e.Y < this.Top)
					|| (e.X > this.Left + this.Width)
					|| (e.Y > this.Top + this.Height)
					)
				{
					//Console.WriteLine("leave");
					IsMouseIn = false;
				}
				else//(IsMouseIn)
				{
					//Console.WriteLine("enter");
					IsMouseIn = true;
				}
				if (IsMouseIn != lastIsMouseIn)
				{
					//this.Visible = false;
					if (IsMouseIn)
					{
						
						this.Opacity = 1;
					}
					else
					{
						this.Opacity = .5;
					}
					this.Invalidate () ;
					lastIsMouseIn = IsMouseIn;
					Console.WriteLine(lastIsMouseIn);
				}
				
			

		}
		

		void hooker_HookedMouseDrag(MouseHooker sender, MouseEventArgs e)
		{
			//throw new NotImplementedException();
			this.Text = e.X.ToString();
			this.Location = new Point(e.X - lastLocation.X, e.Y - lastLocation.Y);
			//this.Location = new Point(this.Left + (e.X - hooker.LastMousePosition.X),this.Top + (e.Y - hooker.LastMousePosition.Y));
		}
		
		private void button1_Click(object sender, EventArgs e)
		{
			MessageBox.Show("Button Click");
			Screen.GetWorkingArea(this.webBrowser1);
		}
		private void Form1_Click(object sender, EventArgs e)
		{
			MessageBox.Show("Form Click");
		}
	}

}

namespace TestApplication
{
	using System;
	using System.Drawing;
	using System.Windows.Forms;

	using Microshaoft;

	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			bool b = hooker.UnHook();
			Console.WriteLine(b);
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new Button();
			this.webBrowser1 = new WebBrowser();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new Point(117, 67);
			this.button1.Name = "button1";
			this.button1.Size = new Size(92, 37);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new EventHandler(this.button1_Click);
			// 
			// webBrowser1
			// 
			this.webBrowser1.Location = new Point(72, 148);
			this.webBrowser1.MinimumSize = new Size(20, 20);
			this.webBrowser1.Name = "webBrowser1";
			this.webBrowser1.Size = new Size(125, 82);
			this.webBrowser1.TabIndex = 1;
			this.webBrowser1.IsWebBrowserContextMenuEnabled = false;
			this.webBrowser1.Dock = DockStyle.Fill;
			//this.webBrowser1.ScrollBarsEnabled = false;
			// 
			// Form1
			// 
			//this.BackgroundImage = (Image) new Bitmap(AppDomain.CurrentDomain.BaseDirectory + @"\bill.jpg");
			this.AutoScaleDimensions = new SizeF(6F, 12F);
			this.AutoScaleMode = AutoScaleMode.Font;
			this.ClientSize = new Size(292, 273);
			this.Controls.Add(this.webBrowser1);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new EventHandler(this.Form1_Load);
			this.Click += new EventHandler(this.Form1_Click);
			this.ResumeLayout(false);

		}

		#endregion

		private Button button1;
		public WebBrowser webBrowser1;
	}
}

namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Data;
	using System.Drawing.Drawing2D;
	public class Shape
	{
		public Shape()
		{
		}
		public Region GetPolyRegion(Point[] pts)
		{
			// Create a graphics path
			GraphicsPath path = 
				new GraphicsPath(FillMode.Alternate);
			path.AddPolygon(pts);
			// Create a Region object from the path
			// and set it as the form's region
			Region rgn = new Region(path);  
			return rgn;
		}
		public Region GetRectRegion(Rectangle rct)
		{
			// Create a graphics path
			GraphicsPath path = 
				new GraphicsPath(FillMode.Alternate);
			path.AddEllipse(rct); 
			// Create a Region object from the path
			// and set it as the form's region
			Region rgn = new Region(path);  
			return rgn;
		}
	}

}

namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	using System.Windows.Forms;

	using System.Drawing;

	using System.Reflection;

	using System.Threading;

	using System.Diagnostics;
	public class MouseHooker
	{

		public delegate void MouseHookerEventHandler
					(
						MouseHooker sender
						, MouseEventArgs e
					);

		public event MouseHookerEventHandler HookedMouseMove;
		public event MouseHookerEventHandler HookedMouseDown;
		public event MouseHookerEventHandler HookedMouseDrag;

		public event MouseHookerEventHandler HookedMouseActive;

		private delegate int HookProc(int nCode, IntPtr wParam, IntPtr lParam);
		//Declare the mouse hook constant.
		//For other hook types, you can obtain these values from Winuser.h in the Microsoft SDK.
		//Declare MouseHookedProcedure as a HookProc type.
		private HookProc MouseHookedProcedure;

		//Declare the hook handle as an int.
		private int hHook = 0;
		private Point lastMousePosition;
		private bool IsDrag = false;

		public bool SetHook()
		{
			if (hHook == 0)
			{
				// Create an instance of HookProc.
				MouseHookedProcedure = new HookProc(MouseHookedProc);

///			using (Process process = Process.GetCurrentProcess())
///
///			using (ProcessModule pm = process.MainModule)
///			{
///				hHook = SetWindowsHookEx
///							(
///								WH_MOUSE
///								, MouseHookedProcedure
///								
///								, GetModuleHandle(pm.ModuleName)
///								, 0
///							);
///			}

///				hMouseHook = SetWindowsHookEx( WH_MOUSE_LL,
///					MouseHookProcedure, 
///					Marshal.GetHINSTANCE(
///						Assembly.GetExecutingAssembly().GetModules()[0]),
///					0);

				hHook = SetWindowsHookEx
							(
								WH_MOUSE_LL
								, MouseHookedProcedure
								//, (IntPtr) 0
				,Marshal.GetHINSTANCE(
						Assembly.GetExecutingAssembly().GetModules()[0])
					
								//, threadID
								, 0 //GetCurrentThreadId()
								//Thread.CurrentThread.ManagedThreadId
							);

							//Console.WriteLine("{0},{1}", AppDomain.GetCurrentThreadId(), Thread.CurrentThread.ManagedThreadId);
				//If the SetWindowsHookEx function fails.

			}
			return (hHook != 0);
		}
		public bool UnHook()
		{
			bool r = UnhookWindowsHookEx(hHook);
			hHook = 0;
			return r;
		}

		//Declare the wrapper managed POINT class.
		[StructLayout(LayoutKind.Sequential)]
		public struct PointStruct
		{
			public int x;
			public int y;
		}

		//Declare the wrapper managed MouseHookStruct class.
		[StructLayout(LayoutKind.Sequential)]
		public struct MouseHookStruct
		{
			public PointStruct pt;
			public int hwnd;
			public int wHitTestCode;
			public int dwExtraInfo;
		}

		[
			DllImport
				(
					"kernel32.dll"
				)
		]
		private static extern int GetCurrentThreadId();


		//This is the Import for the SetWindowsHookEx function.
		//Use this function to install a thread-specific hook.
		[
			DllImport
				(
					"user32.dll"
					, CharSet = CharSet.Auto
					, CallingConvention = CallingConvention.StdCall
				)
		]
		private static extern int SetWindowsHookEx
										(
											int idHook
											, HookProc lpfn
											, IntPtr hInstance
											, int threadId
										);

		//This is the Import for the UnhookWindowsHookEx function.
		//Call this function to uninstall the hook.
		[
			DllImport
				(
					"user32.dll"
					, CharSet = CharSet.Auto
					, CallingConvention = CallingConvention.StdCall
				)
		]
		private static extern bool UnhookWindowsHookEx(int idHook);

		//This is the Import for the CallNextHookEx function.
		//Use this function to pass the hook information to the next hook procedure in chain.
		[
			DllImport
				(
					"user32.dll"
					, CharSet = CharSet.Auto
					, CallingConvention = CallingConvention.StdCall
				)
		]
		private static extern int CallNextHookEx
									(
										int idHook
										, int nCode
										, IntPtr wParam
										, IntPtr lParam
									);

		[
			DllImport
				(
					"kernel32.dll"
					, CharSet = CharSet.Auto
					, SetLastError = true
				)
		]
		private static extern IntPtr GetModuleHandle(string lpModuleName);


		public Point LastMousePosition
		{
			private set
			{
				this.lastMousePosition = value;
			}
			get
			{
				return this.lastMousePosition;
			}
		}

		private int MouseHookedProc(int nCode, IntPtr wParam, IntPtr lParam)
		{
			int wparam = (int) wParam;
			//Marshall the data from the callback.
			MouseHookStruct mouseHookStruct = (MouseHookStruct) Marshal.PtrToStructure
															(
																lParam
																, typeof(MouseHookStruct)
															);
			

			if (nCode >= 0)
			{
			
				int x = mouseHookStruct.pt.x;//; - this.Left;
				int y = mouseHookStruct.pt.y;//; - this.Top;
				//Console.WriteLine("{0},{1}", x,y);

				if (this.HookedMouseActive != null)
				{
						MouseButtons mb = MouseButtons.None;
						MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
						this.HookedMouseActive(this, e);
				}

				if (wparam == WM_LBUTTONDOWN)
				{
					if (this.IsDrag == false)
					{
						this.IsDrag = true;

						if (this.lastMousePosition == null)
						{
							this.lastMousePosition = new Point();
						}

						this.lastMousePosition.X = x;
						this.lastMousePosition.Y = y;
						if (this.HookedMouseDown != null)
						{
							MouseEventArgs e = new MouseEventArgs(MouseButtons.Left, 1, x, y, 0);
							this.HookedMouseDown(this, e);
						}
					}
				}
				if (wparam ==  WM_MOUSEMOVE)
				{
					MouseButtons mb = MouseButtons.None;
					if (IsDrag == true)
					{
						mb = MouseButtons.Left;
						if (this.HookedMouseDrag != null)
						{
							MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
							this.HookedMouseDrag(this, e);
						}
					}

					if (this.HookedMouseMove != null)
					{
						MouseEventArgs e = new MouseEventArgs(mb, 1, x, y, 0);
						this.HookedMouseMove(this, e);
					}
					//IsDrag = false;
				}

				if (wparam == WM_LBUTTONUP)
				{
					IsDrag = false;
				}
				if (wparam == WM_RBUTTONDOWN)
				{
					IsDrag = false;
				}
			}
			return CallNextHookEx(hHook, nCode, wParam, lParam);
		}

		[DllImport("user32.dll")]
		public static extern bool ReleaseCapture();


			[DllImport("user32")]
	public static extern IntPtr SetCapture( IntPtr hWnd );

	[DllImport("user32")]
	public static extern IntPtr GetCapture();

	

		[DllImport("user32.dll")]
		public static extern bool SendMessage
									(
										IntPtr hwnd
										, int wMsg
										, int wParam
										, int lParam
									);

		private const int WM_SYSCOMMAND = 0x0112;
		private const int SC_MOVE = 0xF010;
		private const int HTCAPTION = 0x0002;

		private const int WM_MOUSEMOVE = 0x200;
		private const int WM_LBUTTONDOWN = 0x201;
		private const int WM_RBUTTONDOWN = 0x204;
		private const int WM_MBUTTONDOWN = 0x207;
		private const int WM_LBUTTONUP = 0x202;
		private const int WM_RBUTTONUP = 0x205;
		private const int WM_MBUTTONUP = 0x208;
		private const int WM_LBUTTONDBLCLK = 0x203;
		private const int WM_RBUTTONDBLCLK = 0x206;
		private const int WM_MBUTTONDBLCLK = 0x209;

		private const int WH_MOUSE = 7;
		private const int WH_MOUSE_LL = 14;
	}

}
#T=WebBrowser FSO execScript OnExternalEvent
/*
	/r:"D:\MyC#\WebBrowser.FSO.OnExternalEvent\Interop.Scripting.dll";"C:\Program Files\Microsoft.NET\Primary Interop Assemblies\Microsoft.mshtml.dll"
*/
namespace Test
{
	using System;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Reflection;
	using Microshaoft;

	public class Form1 : Form
	{

		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.webBrowser1 = new System.Windows.Forms.WebBrowser();
			this.button1 = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// webBrowser1
			// 
			this.webBrowser1.Location = new System.Drawing.Point(58, 60);
			this.webBrowser1.MinimumSize = new System.Drawing.Size(20, 20);
			this.webBrowser1.Name = "webBrowser1";
			this.webBrowser1.Size = new System.Drawing.Size(199, 163);
			this.webBrowser1.TabIndex = 0;
			this.webBrowser1.Dock = DockStyle.Bottom;
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(105, 4);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(200, 27);
			this.button1.TabIndex = 1;
			this.button1.Text = "第二步: C# Invoke Script";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(292, 273);
			this.Controls.Add(this.button1);
			this.Controls.Add(this.webBrowser1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new System.EventHandler(this.Form1_Load);
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.WebBrowser webBrowser1;
		private System.Windows.Forms.Button button1;

		public Form1()
		{
			InitializeComponent();
		}


		private DocumentScriptingObject _dso;
		private void Form1_Load(object sender, EventArgs e)
		{
			this._dso = new DocumentScriptingObject();
			this.webBrowser1.ObjectForScripting = _dso;
			//HTML 在最下面
			
			string s;
			s = AppDomain.CurrentDomain.BaseDirectory + @"Noname1.html";
			this.webBrowser1.Navigate
				(
					s
				);
			webBrowser1.Navigated += new WebBrowserNavigatedEventHandler(webBrowser1_Navigated);
		}

		void webBrowser1_Navigated(object sender, WebBrowserNavigatedEventArgs e)
		{
			WebBrowser wb = sender as WebBrowser;
			mshtml.HTMLWindow2 win = (mshtml.HTMLWindow2) wb.Document.Window.DomWindow;
			win.execScript("var Microshaoft = window.external;alert('C# exec JavaScript')", "javascript");
		}

		private void button1_Click(object sender, EventArgs e)
		{
			object[] args = new object[1];
			args[0] = (object) "第二步: C# Invoke Script";
			_dso.Sys.OnExternalEvent1.GetType().InvokeMember
												(
													""
													, BindingFlags.InvokeMethod
													, null
													, _dso.Sys.OnExternalEvent1
													, args
												);
		}
	}
}

namespace Microshaoft
{
	using System;
	using System.Security.Permissions;
	using System.Runtime.InteropServices;
	using System.Windows.Forms;

	using System.Collections.Generic;

	using System.IO;

	//using Scripting;

	[PermissionSet(SecurityAction.Demand, Name="FullTrust")]
	[ComVisible(true)]
	public class DocumentScriptingObject
	{
		private SysClass _Sys = new SysClass("default");

		public SysClass Sys
		{
			get
			{
				return _Sys;
			}
		}
		
		public class SysClass
		{
			private object _onExternalEvent1;

			
			//private List<SysClass> _a;
			public void ShowMessage()
			{
				MessageBox.Show(_msg);
			
			}
			private string _msg = "default";
			public SysClass(string s)
			{
				_msg = s;
			}
			///public FileSystemObject NewFSO()
			public object NewFSO()
			{
				//return  new FileSystemObject();
				return new object();
			
			}
			public int Hello(string x, out string y, ref string z)
			{
				y = string.Format("hello: {0}!", x);
				z = string.Format("bye: {0}!", x);
				return 1;
			}

			public object OnExternalEvent1
			{
				get 
				{
					return _onExternalEvent1; 
				}
				set 
				{
					//Console.WriteLine(Microsoft.VisualBasic.Information.TypeName(value));
					_onExternalEvent1 = value; 
				}
			}
		}

	}
}
/*
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title> new document </title>
<meta name="generator" content="editplus" />
<meta name="author" content="" />
<meta name="keywords" content="" />
<meta name="description" content="" />
<script type="text/javascript">

alert('html Script')
<!--
	function RegisterExternalEvent()
	{
		Microshaoft.Sys.OnExternalEvent1 = function(x)
											{
												//invoke by c#
												alert(x)
											};
	}
	function Call()
	{
		var x = "xxxxx";
		var y = "yyyyy";
		var z = "xxxxx";
		var r = Microshaoft.Sys.Hello(x,y,z);
		alert(r);
		alert(x);
		alert(y);
		alert(z);
	}
//-->
</script>
</head>


<body>

<input type="button" value= "第一步: HTML Script Register C# External Event" onclick="RegisterExternalEvent();alert('HTML Script Register External Event')" />

<input type="button" value= "调用 C#" onclick="Call();" />
</body>
</html>
*/

#T=WebBrowser HTML Editor KindEditor
/*
	KindEditor
	http://www.kindsoft.net/view.php?bbsid=3&postid=4531
*/
namespace WebBrowserHTMLEditor
{
	using System;
	using System.Collections.Generic;
	using System.Windows.Forms;

	static class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}
namespace WebBrowserHTMLEditor
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;

	[ComVisible(true)]
	public partial class Form1 : Form
	{
		string content = "";
		public Form1()
		{
			InitializeComponent();
			this.webBrowser1.Url = new System.Uri(Application.StartupPath + "\\kindeditor\\e.html", System.UriKind.Absolute);
			this.webBrowser1.ObjectForScripting = this;

		}
		public void SetDetailContent()
		{

			webBrowser1.Document.InvokeScript("setContent", new object[] { content });
		}
		public string GetContent()
		{
			return content;
		}
		public void RequestContent(string str)
		{
			content = str;
			richTextBox1.Text = content;
		}

		private void richTextBox1_TextChanged(object sender, EventArgs e)
		{
			if (richTextBox1.Focused)
			{
				content = richTextBox1.Text;
				SetDetailContent();
			}
		}

		private void webBrowser1_Resize(object sender, EventArgs e)
		{
			this.webBrowser1.Refresh();
		}
	}
}

namespace WebBrowserHTMLEditor
{
	partial class Form1
	{
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		/// <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows 窗体设计器生成的代码

		/// <summary>
		/// 设计器支持所需的方法 - 不要
		/// 使用代码编辑器修改此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.webBrowser1 = new System.Windows.Forms.WebBrowser();
			this.richTextBox1 = new System.Windows.Forms.RichTextBox();
			this.SuspendLayout();
			// 
			// webBrowser1
			// 
			this.webBrowser1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
						| System.Windows.Forms.AnchorStyles.Left)
						| System.Windows.Forms.AnchorStyles.Right)));
			this.webBrowser1.Location = new System.Drawing.Point(2, 102);
			this.webBrowser1.MinimumSize = new System.Drawing.Size(20, 20);
			this.webBrowser1.Name = "webBrowser1";
			this.webBrowser1.Size = new System.Drawing.Size(466, 346);
			this.webBrowser1.TabIndex = 0;
			this.webBrowser1.Resize += new System.EventHandler(this.webBrowser1_Resize);
			// 
			// richTextBox1
			// 
			this.richTextBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
						| System.Windows.Forms.AnchorStyles.Right)));
			this.richTextBox1.Location = new System.Drawing.Point(2, 0);
			this.richTextBox1.Name = "richTextBox1";
			this.richTextBox1.Size = new System.Drawing.Size(466, 96);
			this.richTextBox1.TabIndex = 1;
			this.richTextBox1.Text = "";
			this.richTextBox1.TextChanged += new System.EventHandler(this.richTextBox1_TextChanged);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(469, 448);
			this.Controls.Add(this.richTextBox1);
			this.Controls.Add(this.webBrowser1);
			this.Name = "Form1";
			this.Text = "WebBrowserHTMLEditor";
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.WebBrowser webBrowser1;
		private System.Windows.Forms.RichTextBox richTextBox1;
	}
}


#T=WebBrowser NativeWindow MouseMove
namespace WindowsFormsApplication1
{
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using Microshaoft;

	public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

    [DllImport("user32.dll", SetLastError = true)]

    static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

    [DllImport("user32.dll", SetLastError = true)]

    static extern IntPtr FindWindowEx(IntPtr hwndParent,

        IntPtr hwndChildAfter, string lpszClass, string lpszWindow);

    private void Form1_Load(object sender, EventArgs e)

    {

					Rectangle rect = new Rectangle(0, 0, 300, 300);
			// Create a Shape object and call 
			// GetRectRegion method 
			Shape shp = new Shape();
			this.Region = shp.GetRectRegion(rect);	


        webBrowser1_DocumentCompleted(null, null);

        this.webBrowser1.Navigate("www.google.com");

        this.webBrowser1.DocumentCompleted += new WebBrowserDocumentCompletedEventHandler(webBrowser1_DocumentCompleted);

    }

 

    void webBrowser1_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)

    {

        IntPtr wbHandle = FindWindowEx(this.webBrowser1.Handle, IntPtr.Zero,

            "Shell Embedding", String.Empty);

        wbHandle = FindWindowEx(wbHandle, IntPtr.Zero,

            "Shell DocObject View", String.Empty);

        wbHandle = FindWindowEx(wbHandle, IntPtr.Zero,

            "Internet Explorer_Server", String.Empty);

        WbInternal wb = new WbInternal(wbHandle);

    }

    class WbInternal : NativeWindow

    {

        public WbInternal(IntPtr handle)

        {

            this.AssignHandle(handle);

        }

        protected override void WndProc(ref Message m)

        {

            if ((m.Msg ==WM_LBUTTONDOWN)//WM_MOUSEWHEEL
                || (m.Msg ==WM_MOUSEMOVE))
            {
                Console.WriteLine(m.Msg.ToString());
              

            }
            //Console.WriteLine();
            Console.WriteLine(m.ToString());
            base.WndProc(ref m);

        }
        private const int WM_SYSCOMMAND = 0x0112;
        private const int SC_MOVE = 0xF010;
        private const int HTCAPTION = 0x0002;

        private const int WM_MOUSEMOVE = 0x200;
        private const int WM_LBUTTONDOWN = 0x201;
        private const int WM_RBUTTONDOWN = 0x204;
        private const int WM_MBUTTONDOWN = 0x207;
        private const int WM_LBUTTONUP = 0x202;
        private const int WM_RBUTTONUP = 0x205;
        private const int WM_MBUTTONUP = 0x208;
        private const int WM_LBUTTONDBLCLK = 0x203;
        private const int WM_RBUTTONDBLCLK = 0x206;
        private const int WM_MBUTTONDBLCLK = 0x209;

        private const int WH_MOUSE = 7;
        private const int WH_MOUSE_LL = 14;

    }


 

}



}

namespace WindowsFormsApplication1
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.webBrowser1 = new System.Windows.Forms.WebBrowser();
            this.SuspendLayout();
            // 
            // webBrowser1
            // 
            this.webBrowser1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.webBrowser1.Location = new System.Drawing.Point(0, 0);
            this.webBrowser1.MinimumSize = new System.Drawing.Size(20, 20);
            this.webBrowser1.Name = "webBrowser1";
            this.webBrowser1.Size = new System.Drawing.Size(292, 273);
            this.webBrowser1.TabIndex = 0;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(292, 273);
            this.Controls.Add(this.webBrowser1);
            this.Name = "Form1";
            this.Text = "Form1";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.WebBrowser webBrowser1;
    }
}


namespace WindowsFormsApplication1
{
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

	static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
			Form1 f = new Form1();
			f.Show();

            Application.Run(new Form1());
        }
    }
}



namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Data;
	using System.Drawing.Drawing2D;
	public class Shape
	{
		public Shape()
		{
		}
		public Region GetPolyRegion(Point[] pts)
		{
			// Create a graphics path
			GraphicsPath path = 
				new GraphicsPath(FillMode.Alternate);
			path.AddPolygon(pts);
			// Create a Region object from the path
			// and set it as the form's region
			Region rgn = new Region(path);  
			return rgn;
		}
		public Region GetRectRegion(Rectangle rct)
		{
			// Create a graphics path
			GraphicsPath path = 
				new GraphicsPath(FillMode.Alternate);
			path.AddEllipse(rct); 
			// Create a Region object from the path
			// and set it as the form's region
			Region rgn = new Region(path);  
			return rgn;
		}
	}

}

#T=WebBrowser Site Thumbnail
namespace GetSiteThumbnail
{
	using System;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.Windows.Forms;
	using System.Diagnostics;
	class Program
	{


		public delegate void WebBrowserDocumentCompletedEventHandler(object sender, WebBrowserDocumentCompletedEventArgs e);
		
		[STAThread]
		static void Main(string[] args)
		{
			
			if (args.Length < 2)
			{
				MessageBox.Show("Usage:\nGetSiteThumbnail.exe http://www.yoursite.com/ thumbnail.jpg [browser_width(defaults to 800) browser_height (defaults to 600) ] [thumbnail_width thumbnail_height]\n\n"+
					"Sample:\nGetSiteThumbnail.exe http://www.cognifide.com/ cognifide.jpg 1280 1024 640 480\n\n",
					"Get Site Thumbnail");
				return;
			}
			
			int width = 800;
			int height = 600;
			if (args.Length > 2)
			{
				width = Int32.Parse(args[2]);
				height = Int32.Parse(args[3]);
			}

			int thumbwidth = width;
			int thumbheight = height;

			if (args.Length > 4)
			{
				thumbwidth = Int32.Parse(args[4]);
				thumbheight = Int32.Parse(args[5]);
			}
			
			WebPageBitmap webBitmap = new WebPageBitmap(args[0], width, height, false);
			webBitmap.Fetch();
			Bitmap thumbnail = webBitmap.GetBitmap(thumbwidth, thumbheight);
			thumbnail.Save(args[1],ImageFormat.Jpeg);
			thumbnail.Dispose();
		}
	}
}
namespace GetSiteThumbnail
{
	using System.Windows.Forms;
	using System.Drawing;
	class WebPageBitmap
	{
		private WebBrowser webBrowser;
		private string url;
		private int width;
		private int height;
		private bool isReady = false;

		public WebPageBitmap(string url, int width, int height, bool scrollBarsEnabled)
		{
			this.url = url;
			this.width = width;
			this.height = height;
			webBrowser = new WebBrowser();
			webBrowser.DocumentCompleted +=
				new WebBrowserDocumentCompletedEventHandler(documentCompletedEventHandler);
			webBrowser.Size = new Size(width, height);
			webBrowser.ScrollBarsEnabled = scrollBarsEnabled;
		}
		
		public void Fetch()
		{
			webBrowser.Navigate(url);
			while (webBrowser.ReadyState != WebBrowserReadyState.Complete)
			{
				Application.DoEvents();
			}
			
		}
		private void documentCompletedEventHandler(object sender, WebBrowserDocumentCompletedEventArgs e)
		{
			isReady = true;
		}
		
		~WebPageBitmap()
		{
/*			webBrowser.Dispose();
 */
		}

		internal Bitmap GetBitmap(int thumbwidth, int thumbheight)
		{
			Bitmap bitmap = new Bitmap(width, height);
			Rectangle bitmapRect = new Rectangle(0, 0, width, height);
			webBrowser.DrawToBitmap(bitmap, bitmapRect);
			if (thumbheight == height && thumbwidth == width)
			{
				return bitmap;
			}
			else
			{
				Bitmap thumbnail = new Bitmap(thumbwidth, thumbheight);
				Graphics gfx = Graphics.FromImage(thumbnail);
				gfx.DrawImage(bitmap, new Rectangle(0,0, thumbwidth, thumbheight), bitmapRect,GraphicsUnit.Pixel);

				bitmap.Dispose();
				return thumbnail;
			}
		}
	}
}

#T=WebBrowser.ExecWB
打开,另存为,属性,打印等14个JS代码
Posted on 2006-08-11 18:38 独孤雁 阅读(1276) 评论(1) 编辑 收藏  
■打开■ 
<input name=Button onClick=document.all.WebBrowser.ExecWB(1,1) type=button value=打开> 
<OBJECT classid=CLSID:8856F961-340A-11D0-A96B-00C04FD705A2 height=0 id=WebBrowser width=0></OBJECT> 
■另存为■ 
<input name=Button onClick=document.all.WebBrowser.ExecWB(4,1) type=button value=另存为><OBJECT classid=CLSID:8856F961-340A-11D0-A96B-00C04FD705A2 height=0 id=WebBrowser width=0></OBJECT> 
■属性■ 
<input name=Button onClick=document.all.WebBrowser.ExecWB(10,1) type=button value=属性><OBJECT classid=CLSID:8856F961-340A-11D0-A96B-00C04FD705A2 height=0 id=WebBrowser width=0></OBJECT> 
■打印■ 
<input name=Button onClick=document.all.WebBrowser.ExecWB(6,1) type=button value=打印><OBJECT classid=CLSID:8856F961-340A-11D0-A96B-00C04FD705A2 height=0 id=WebBrowser width=0></OBJECT> 
■页面设置■ 
<input name=Button onClick=document.all.WebBrowser.ExecWB(8,1) type=button value=页面设置><OBJECT classid=CLSID:8856F961-340A-11D0-A96B-00C04FD705A2 height=0 id=WebBrowser width=0></OBJECT> 
■刷新■ 
<input type=button value=刷新 name=refresh onclick="window.location.reload()"> 
■导入收藏■ 
<input type="button" name="Button" value="导入收藏夹" onClick=window.external.ImportExportFavorites(true,);> 
■导出收藏■ 
<input type="button" name="Button3" value="导出收藏夹" onClick=window.external.ImportExportFavorites(false,);> 
■加入收藏■ 
<INPUT name=Button2 onclick="window.external.AddFavorite(location.href, document.title)" type=button value=加入收藏夹> 
■整理收藏夹■ 
<INPUT name=Submit2 onclick="window.extern 



WebBrowser.ExecWB(1,1) 打开 
WebBrowser.ExecWB(2,1) 关闭现在所有的IE窗口，并打开一个新窗口 
WebBrowser.ExecWB(4,1) 保存网页 
WebBrowser.ExecWB(6,1) 打印 
WebBrowser.ExecWB(7,1) 打印预览 
WebBrowser.ExecWB(8,1) 打印页面设置 
WebBrowser.ExecWB(10,1) 查看页面属性 
WebBrowser.ExecWB(15,1) 好像是撤销，有待确认 
WebBrowser.ExecWB(17,1) 全选 
WebBrowser.ExecWB(22,1) 刷新 
WebBrowser.ExecWB(45,1) 关闭窗体无提示 

这些只对IE5.5以上版本有效，我是在IE6下测试的，通过的。
#T=WebBrowserExtensibility Nav Err event
namespace WebBrowserExtensibility
{
	using System;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;
	using System.Security.Permissions;
	[PermissionSetAttribute(SecurityAction.Demand, Name="FullTrust")]
	public class Form1 : Form
	{
		[STAThread]
		public static void Main()
		{
			Application.Run(new Form1());
		}

		private WebBrowser2 wb = new WebBrowser2();
		public Form1()
		{
			wb.Dock = DockStyle.Fill;
			wb.NavigateError += new 
				WebBrowserNavigateErrorEventHandler(wb_NavigateError);
			Controls.Add(wb);

			// Attempt to navigate to an invalid address.
			wb.Navigate("www.widgets.microsoft.com");
		}

		private void wb_NavigateError(
			object sender, WebBrowserNavigateErrorEventArgs e)
		{
			// Display an error message to the user.
			MessageBox.Show("Cannot navigate to " + e.Url);
		}
	}

	public class WebBrowser2 : WebBrowser
	{
		AxHost.ConnectionPointCookie cookie;
		WebBrowser2EventHelper helper;

		[PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
		protected override void CreateSink()
		{
			base.CreateSink();

			// Create an instance of the client that will handle the event
			// and associate it with the underlying ActiveX control.
			helper = new WebBrowser2EventHelper(this);
			cookie = new AxHost.ConnectionPointCookie(
				this.ActiveXInstance, helper, typeof(DWebBrowserEvents2));
		}

		[PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
		protected override void DetachSink()
		{
			// Disconnect the client that handles the event
			// from the underlying ActiveX control.
			if (cookie != null)
			{
				cookie.Disconnect();
				cookie = null;
			}
			base.DetachSink();
		}

		public event WebBrowserNavigateErrorEventHandler NavigateError;

		// Raises the NavigateError event.
		protected virtual void OnNavigateError(
			WebBrowserNavigateErrorEventArgs e)
		{
			if (this.NavigateError != null)
			{
				this.NavigateError(this, e);
			}
		}

		// Handles the NavigateError event from the underlying ActiveX 
		// control by raising the NavigateError event defined in this class.
		private class WebBrowser2EventHelper : 
			StandardOleMarshalObject, DWebBrowserEvents2
		{
			private WebBrowser2 parent;

			public WebBrowser2EventHelper(WebBrowser2 parent)
			{
				this.parent = parent;
			}

			public void NavigateError(object pDisp, ref object url, 
				ref object frame, ref object statusCode, ref bool cancel)
			{
				// Raise the NavigateError event.
				this.parent.OnNavigateError(
					new WebBrowserNavigateErrorEventArgs(
					(String)url, (String)frame, (Int32)statusCode, cancel));
			}
		}
	}

	// Represents the method that will handle the WebBrowser2.NavigateError event.
	public delegate void WebBrowserNavigateErrorEventHandler(object sender, 
		WebBrowserNavigateErrorEventArgs e);

	// Provides data for the WebBrowser2.NavigateError event.
	public class WebBrowserNavigateErrorEventArgs : EventArgs
	{
		private String urlValue;
		private String frameValue;
		private Int32 statusCodeValue;
		private Boolean cancelValue;

		public WebBrowserNavigateErrorEventArgs(
			String url, String frame, Int32 statusCode, Boolean cancel)
		{
			urlValue = url;
			frameValue = frame;
			statusCodeValue = statusCode;
			cancelValue = cancel;
		}

		public String Url
		{
			get { return urlValue; }
			set { urlValue = value; }
		}

		public String Frame
		{
			get { return frameValue; }
			set { frameValue = value; }
		}

		public Int32 StatusCode
		{
			get { return statusCodeValue; }
			set { statusCodeValue = value; }
		}

		public Boolean Cancel
		{
			get { return cancelValue; }
			set { cancelValue = value; }
		}
	}

	// Imports the NavigateError method from the OLE DWebBrowserEvents2 
	// interface. 
	[ComImport, Guid("34A715A0-6587-11D0-924A-0020AFC7AC4D"),
	InterfaceType(ComInterfaceType.InterfaceIsIDispatch),
	TypeLibType(TypeLibTypeFlags.FHidden)]
	public interface DWebBrowserEvents2
	{
		[DispId(271)]
		void NavigateError(
			[In, MarshalAs(UnmanagedType.IDispatch)] object pDisp,
			[In] ref object URL, [In] ref object frame, 
			[In] ref object statusCode, [In, Out] ref bool cancel);
	}
}


#T=WebForm Codebehind C#
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace WebApplication1
{
	/// <summary>
	/// WebForm1 的摘要说明。
	/// </summary>
	public class WebForm1 : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			// 在此处放置用户代码以初始化页面
		}

		#region Web 窗体设计器生成的代码
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: 该调用是 ASP.NET Web 窗体设计器所必需的。
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// 设计器支持所需的方法 - 不要使用代码编辑器修改
		/// 此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
#T=WebForm HTML
<%@ Page language="c#" Codebehind="WebForm1.aspx.cs" AutoEventWireup="false" Inherits="WebApplication1.WebForm1" %>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" >
<HTML>
	<HEAD>
		<title>WebForm1</title>
		<meta name="GENERATOR" Content="Microsoft Visual Studio .NET 7.1">
		<meta name="CODE_LANGUAGE" Content="C#">
		<meta name="vs_defaultClientScript" content="JavaScript">
		<meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5">
	</HEAD>
	<body MS_POSITIONING="GridLayout">
		<form id="Form1" method="post" runat="server">
		</form>
	</body>
</HTML>
#T=Win32 User32.dll API
namespace Microshaoft.Win32
{
	using System;
	using System.Drawing;
	using System.Runtime.InteropServices;
	using Microshaoft.Win32;

	internal class User32
	{
		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool AnimateWindow(IntPtr hWnd, uint dwTime, FlagsAnimateWindow dwFlags);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool DragDetect(IntPtr hWnd, Point pt);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr GetSysColorBrush(int index);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr GetDesktopWindow();

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool InvalidateRect(IntPtr hWnd, ref RECT rect, bool erase);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr LoadCursor(IntPtr hInstance, uint cursor);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr SetCursor(IntPtr hCursor);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr GetFocus();

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr SetFocus(IntPtr hWnd);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool ReleaseCapture();

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool WaitMessage();

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool TranslateMessage(ref MSG msg);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool DispatchMessage(ref MSG msg);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool PostMessage(IntPtr hWnd, int Msg, uint wParam, uint lParam);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern uint SendMessage(IntPtr hWnd, int Msg, uint wParam, uint lParam);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern uint SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool GetMessage(ref MSG msg, int hWnd, uint wFilterMin, uint wFilterMax);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool PeekMessage(ref MSG msg, int hWnd, uint wFilterMin, uint wFilterMax, uint wFlag);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr BeginPaint(IntPtr hWnd, ref PAINTSTRUCT ps);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool EndPaint(IntPtr hWnd, ref PAINTSTRUCT ps);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr GetDC(IntPtr hWnd);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr GetWindowDC(IntPtr hWnd);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern int ShowWindow(IntPtr hWnd, short cmdShow);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool MoveWindow(IntPtr hWnd, int x, int y, int width, int height, bool repaint);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern int SetWindowPos(IntPtr hWnd, IntPtr hWndAfter, int X, int Y, int Width, int Height, FlagsSetWindowPos flags);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, ref POINT pptDst, ref SIZE psize, IntPtr hdcSrc, ref POINT pprSrc, Int32 crKey, ref BLENDFUNCTION pblend, Int32 dwFlags);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool GetWindowRect(IntPtr hWnd, ref RECT rect);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool ClientToScreen(IntPtr hWnd, ref POINT pt);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool ScreenToClient(IntPtr hWnd, ref POINT pt);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool TrackMouseEvent(ref TRACKMOUSEEVENTS tme);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool SetWindowRgn(IntPtr hWnd, IntPtr hRgn, bool redraw);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern ushort GetKeyState(int virtKey);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr GetParent(IntPtr hWnd);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool DrawFocusRect(IntPtr hWnd, ref RECT rect);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool HideCaret(IntPtr hWnd);

		[DllImport("User32.dll", CharSet=CharSet.Auto)]
		public static extern bool ShowCaret(IntPtr hWnd);

		[DllImport("user32.dll", CharSet=CharSet.Auto)]
		public static extern bool SystemParametersInfo(SystemParametersInfoActions uAction, uint uParam, ref uint lpvParam, uint fuWinIni);

		[DllImport("user32.dll", CharSet=CharSet.Auto)]
		public static extern IntPtr WindowFromPoint(POINT point);
	}
}


namespace Microshaoft.Win32
{
	using System;
	using System.Drawing;
	using System.Runtime.InteropServices;

	[StructLayout(LayoutKind.Sequential)]
	internal struct MSG
	{
		public IntPtr hwnd;
		public int message;
		public IntPtr wParam;
		public IntPtr lParam;
		public int time;
		public int pt_x;
		public int pt_y;
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct PAINTSTRUCT
	{
		public IntPtr hdc;
		public int fErase;
		public Rectangle rcPaint;
		public int fRestore;
		public int fIncUpdate;
		public int Reserved1;
		public int Reserved2;
		public int Reserved3;
		public int Reserved4;
		public int Reserved5;
		public int Reserved6;
		public int Reserved7;
		public int Reserved8;
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct RECT
	{
		public int left;
		public int top;
		public int right;
		public int bottom;

		public override string ToString()
		{
			return "{left=" + left.ToString() + ", " + "top=" + top.ToString() + ", " +
				"right=" + right.ToString() + ", " + "bottom=" + bottom.ToString() + "}";
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct POINT
	{
		public int x;
		public int y;
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct SIZE
	{
		public int cx;
		public int cy;
	}

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	internal struct BLENDFUNCTION
	{
		public byte BlendOp;
		public byte BlendFlags;
		public byte SourceConstantAlpha;
		public byte AlphaFormat;
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct TRACKMOUSEEVENTS
	{
		public const uint TME_HOVER = 0x00000001;
		public const uint TME_LEAVE = 0x00000002;
		public const uint TME_NONCLIENT = 0x00000010;
		public const uint TME_QUERY = 0x40000000;
		public const uint TME_CANCEL = 0x80000000;
		public const uint HOVER_DEFAULT = 0xFFFFFFFF;

		private uint cbSize;
		private uint dwFlags;
		private IntPtr hWnd;
		private uint dwHoverTime;

		public TRACKMOUSEEVENTS(uint dwFlags, IntPtr hWnd, uint dwHoverTime)
		{
			cbSize = 16;
			this.dwFlags = dwFlags;
			this.hWnd = hWnd;
			this.dwHoverTime = dwHoverTime;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct LOGBRUSH
	{
		public uint lbStyle;
		public uint lbColor;
		public uint lbHatch;
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct NCCALCSIZE_PARAMS
	{
		public RECT rgrc1;
		public RECT rgrc2;
		public RECT rgrc3;
		IntPtr lppos;
	}

	[StructLayout(LayoutKind.Sequential)]
	internal struct CWPRETSTRUCT
	{
		public int lResult;
		public int lParam;
		public int wParam;
		public int message;
		public IntPtr hwnd;
	}
}



namespace Microshaoft.Win32
{
	using System;
	internal enum PeekMessageFlags
	{
		PM_NOREMOVE		= 0,
		PM_REMOVE		= 1,
		PM_NOYIELD		= 2
	}

	[Flags]
	internal enum FlagsSetWindowPos : uint
	{
		SWP_NOSIZE		  = 0x0001,
		SWP_NOMOVE		  = 0x0002,
		SWP_NOZORDER		= 0x0004,
		SWP_NOREDRAW		= 0x0008,
		SWP_NOACTIVATE	  = 0x0010,
		SWP_FRAMECHANGED	= 0x0020,
		SWP_SHOWWINDOW	  = 0x0040,
		SWP_HIDEWINDOW	  = 0x0080,
		SWP_NOCOPYBITS	  = 0x0100,
		SWP_NOOWNERZORDER   = 0x0200,
		SWP_NOSENDCHANGING  = 0x0400,
		SWP_DRAWFRAME	   = 0x0020,
		SWP_NOREPOSITION	= 0x0200,
		SWP_DEFERERASE	  = 0x2000,
		SWP_ASYNCWINDOWPOS  = 0x4000
	}

	internal enum SetWindowPosZ
	{
		HWND_TOP		= 0,
		HWND_BOTTOM	 = 1,
		HWND_TOPMOST	= -1,
		HWND_NOTOPMOST  = -2
	}

	internal enum ShowWindowStyles : short
	{
		SW_HIDE			 = 0,
		SW_SHOWNORMAL	   = 1,
		SW_NORMAL		   = 1,
		SW_SHOWMINIMIZED	= 2,
		SW_SHOWMAXIMIZED	= 3,
		SW_MAXIMIZE		 = 3,
		SW_SHOWNOACTIVATE   = 4,
		SW_SHOW			 = 5,
		SW_MINIMIZE		 = 6,
		SW_SHOWMINNOACTIVE  = 7,
		SW_SHOWNA		   = 8,
		SW_RESTORE		  = 9,
		SW_SHOWDEFAULT	  = 10,
		SW_FORCEMINIMIZE	= 11,
		SW_MAX			  = 11
	}

	internal enum WindowStyles : uint
	{
		WS_OVERLAPPED	   = 0x00000000,
		WS_POPUP			= 0x80000000,
		WS_CHILD			= 0x40000000,
		WS_MINIMIZE		 = 0x20000000,
		WS_VISIBLE		  = 0x10000000,
		WS_DISABLED		 = 0x08000000,
		WS_CLIPSIBLINGS	 = 0x04000000,
		WS_CLIPCHILDREN	 = 0x02000000,
		WS_MAXIMIZE		 = 0x01000000,
		WS_CAPTION		  = 0x00C00000,
		WS_BORDER		   = 0x00800000,
		WS_DLGFRAME		 = 0x00400000,
		WS_VSCROLL		  = 0x00200000,
		WS_HSCROLL		  = 0x00100000,
		WS_SYSMENU		  = 0x00080000,
		WS_THICKFRAME	   = 0x00040000,
		WS_GROUP			= 0x00020000,
		WS_TABSTOP		  = 0x00010000,
		WS_MINIMIZEBOX	  = 0x00020000,
		WS_MAXIMIZEBOX	  = 0x00010000,
		WS_TILED			= 0x00000000,
		WS_ICONIC		   = 0x20000000,
		WS_SIZEBOX		  = 0x00040000,
		WS_POPUPWINDOW	  = 0x80880000,
		WS_OVERLAPPEDWINDOW = 0x00CF0000,
		WS_TILEDWINDOW	  = 0x00CF0000,
		WS_CHILDWINDOW	  = 0x40000000
	}

	internal enum WindowExStyles
	{
		WS_EX_DLGMODALFRAME	 = 0x00000001,
		WS_EX_NOPARENTNOTIFY	= 0x00000004,
		WS_EX_TOPMOST		   = 0x00000008,
		WS_EX_ACCEPTFILES	   = 0x00000010,
		WS_EX_TRANSPARENT	   = 0x00000020,
		WS_EX_MDICHILD		  = 0x00000040,
		WS_EX_TOOLWINDOW		= 0x00000080,
		WS_EX_WINDOWEDGE		= 0x00000100,
		WS_EX_CLIENTEDGE		= 0x00000200,
		WS_EX_CONTEXTHELP	   = 0x00000400,
		WS_EX_RIGHT			 = 0x00001000,
		WS_EX_LEFT			  = 0x00000000,
		WS_EX_RTLREADING		= 0x00002000,
		WS_EX_LTRREADING		= 0x00000000,
		WS_EX_LEFTSCROLLBAR	 = 0x00004000,
		WS_EX_RIGHTSCROLLBAR	= 0x00000000,
		WS_EX_CONTROLPARENT	 = 0x00010000,
		WS_EX_STATICEDGE		= 0x00020000,
		WS_EX_APPWINDOW		 = 0x00040000,
		WS_EX_OVERLAPPEDWINDOW  = 0x00000300,
		WS_EX_PALETTEWINDOW	 = 0x00000188,
		WS_EX_LAYERED			= 0x00080000
	}

	internal enum VirtualKeys
	{
		VK_LBUTTON		= 0x01,
		VK_CANCEL		= 0x03,
		VK_BACK			= 0x08,
		VK_TAB			= 0x09,
		VK_CLEAR		= 0x0C,
		VK_RETURN		= 0x0D,
		VK_SHIFT		= 0x10,
		VK_CONTROL		= 0x11,
		VK_MENU			= 0x12,
		VK_CAPITAL		= 0x14,
		VK_ESCAPE		= 0x1B,
		VK_SPACE		= 0x20,
		VK_PRIOR		= 0x21,
		VK_NEXT			= 0x22,
		VK_END			= 0x23,
		VK_HOME			= 0x24,
		VK_LEFT			= 0x25,
		VK_UP			= 0x26,
		VK_RIGHT		= 0x27,
		VK_DOWN			= 0x28,
		VK_SELECT		= 0x29,
		VK_EXECUTE		= 0x2B,
		VK_SNAPSHOT		= 0x2C,
		VK_HELP			= 0x2F,
		VK_0			= 0x30,
		VK_1			= 0x31,
		VK_2			= 0x32,
		VK_3			= 0x33,
		VK_4			= 0x34,
		VK_5			= 0x35,
		VK_6			= 0x36,
		VK_7			= 0x37,
		VK_8			= 0x38,
		VK_9			= 0x39,
		VK_A			= 0x41,
		VK_B			= 0x42,
		VK_C			= 0x43,
		VK_D			= 0x44,
		VK_E			= 0x45,
		VK_F			= 0x46,
		VK_G			= 0x47,
		VK_H			= 0x48,
		VK_I			= 0x49,
		VK_J			= 0x4A,
		VK_K			= 0x4B,
		VK_L			= 0x4C,
		VK_M			= 0x4D,
		VK_N			= 0x4E,
		VK_O			= 0x4F,
		VK_P			= 0x50,
		VK_Q			= 0x51,
		VK_R			= 0x52,
		VK_S			= 0x53,
		VK_T			= 0x54,
		VK_U			= 0x55,
		VK_V			= 0x56,
		VK_W			= 0x57,
		VK_X			= 0x58,
		VK_Y			= 0x59,
		VK_Z			= 0x5A,
		VK_NUMPAD0		= 0x60,
		VK_NUMPAD1		= 0x61,
		VK_NUMPAD2		= 0x62,
		VK_NUMPAD3		= 0x63,
		VK_NUMPAD4		= 0x64,
		VK_NUMPAD5		= 0x65,
		VK_NUMPAD6		= 0x66,
		VK_NUMPAD7		= 0x67,
		VK_NUMPAD8		= 0x68,
		VK_NUMPAD9		= 0x69,
		VK_MULTIPLY		= 0x6A,
		VK_ADD			= 0x6B,
		VK_SEPARATOR	= 0x6C,
		VK_SUBTRACT		= 0x6D,
		VK_DECIMAL		= 0x6E,
		VK_DIVIDE		= 0x6F,
		VK_ATTN			= 0xF6,
		VK_CRSEL		= 0xF7,
		VK_EXSEL		= 0xF8,
		VK_EREOF		= 0xF9,
		VK_PLAY			= 0xFA,
		VK_ZOOM			= 0xFB,
		VK_NONAME		= 0xFC,
		VK_PA1			= 0xFD,
		VK_OEM_CLEAR	= 0xFE,
		VK_LWIN			= 0x5B,
		VK_RWIN			= 0x5C,
		VK_APPS			= 0x5D,
		VK_LSHIFT		= 0xA0,
		VK_RSHIFT		= 0xA1,
		VK_LCONTROL		= 0xA2,
		VK_RCONTROL		= 0xA3,
		VK_LMENU		= 0xA4,
		VK_RMENU		= 0xA5
	}

	internal enum Msgs
	{
		WM_NULL				   = 0x0000,
		WM_CREATE				 = 0x0001,
		WM_DESTROY				= 0x0002,
		WM_MOVE				   = 0x0003,
		WM_SIZE				   = 0x0005,
		WM_ACTIVATE			   = 0x0006,
		WM_SETFOCUS			   = 0x0007,
		WM_KILLFOCUS			  = 0x0008,
		WM_ENABLE				 = 0x000A,
		WM_SETREDRAW			  = 0x000B,
		WM_SETTEXT				= 0x000C,
		WM_GETTEXT				= 0x000D,
		WM_GETTEXTLENGTH		  = 0x000E,
		WM_PAINT				  = 0x000F,
		WM_CLOSE				  = 0x0010,
		WM_QUERYENDSESSION		= 0x0011,
		WM_QUIT				   = 0x0012,
		WM_QUERYOPEN			  = 0x0013,
		WM_ERASEBKGND			 = 0x0014,
		WM_SYSCOLORCHANGE		 = 0x0015,
		WM_ENDSESSION			 = 0x0016,
		WM_SHOWWINDOW			 = 0x0018,
		WM_WININICHANGE		   = 0x001A,
		WM_SETTINGCHANGE		  = 0x001A,
		WM_DEVMODECHANGE		  = 0x001B,
		WM_ACTIVATEAPP			= 0x001C,
		WM_FONTCHANGE			 = 0x001D,
		WM_TIMECHANGE			 = 0x001E,
		WM_CANCELMODE			 = 0x001F,
		WM_SETCURSOR			  = 0x0020,
		WM_MOUSEACTIVATE		  = 0x0021,
		WM_CHILDACTIVATE		  = 0x0022,
		WM_QUEUESYNC			  = 0x0023,
		WM_GETMINMAXINFO		  = 0x0024,
		WM_PAINTICON			  = 0x0026,
		WM_ICONERASEBKGND		 = 0x0027,
		WM_NEXTDLGCTL			 = 0x0028,
		WM_SPOOLERSTATUS		  = 0x002A,
		WM_DRAWITEM			   = 0x002B,
		WM_MEASUREITEM			= 0x002C,
		WM_DELETEITEM			 = 0x002D,
		WM_VKEYTOITEM			 = 0x002E,
		WM_CHARTOITEM			 = 0x002F,
		WM_SETFONT				= 0x0030,
		WM_GETFONT				= 0x0031,
		WM_SETHOTKEY			  = 0x0032,
		WM_GETHOTKEY			  = 0x0033,
		WM_QUERYDRAGICON		  = 0x0037,
		WM_COMPAREITEM			= 0x0039,
		WM_GETOBJECT			  = 0x003D,
		WM_COMPACTING			 = 0x0041,
		WM_COMMNOTIFY			 = 0x0044 ,
		WM_WINDOWPOSCHANGING	  = 0x0046,
		WM_WINDOWPOSCHANGED	   = 0x0047,
		WM_POWER				  = 0x0048,
		WM_COPYDATA			   = 0x004A,
		WM_CANCELJOURNAL		  = 0x004B,
		WM_NOTIFY				 = 0x004E,
		WM_INPUTLANGCHANGEREQUEST = 0x0050,
		WM_INPUTLANGCHANGE		= 0x0051,
		WM_TCARD				  = 0x0052,
		WM_HELP				   = 0x0053,
		WM_USERCHANGED			= 0x0054,
		WM_NOTIFYFORMAT		   = 0x0055,
		WM_CONTEXTMENU			= 0x007B,
		WM_STYLECHANGING		  = 0x007C,
		WM_STYLECHANGED		   = 0x007D,
		WM_DISPLAYCHANGE		  = 0x007E,
		WM_GETICON				= 0x007F,
		WM_SETICON				= 0x0080,
		WM_NCCREATE			   = 0x0081,
		WM_NCDESTROY			  = 0x0082,
		WM_NCCALCSIZE			 = 0x0083,
		WM_NCHITTEST			  = 0x0084,
		WM_NCPAINT				= 0x0085,
		WM_NCACTIVATE			 = 0x0086,
		WM_GETDLGCODE			 = 0x0087,
		WM_SYNCPAINT			  = 0x0088,
		WM_NCMOUSEMOVE			= 0x00A0,
		WM_NCLBUTTONDOWN		  = 0x00A1,
		WM_NCLBUTTONUP			= 0x00A2,
		WM_NCLBUTTONDBLCLK		= 0x00A3,
		WM_NCRBUTTONDOWN		  = 0x00A4,
		WM_NCRBUTTONUP			= 0x00A5,
		WM_NCRBUTTONDBLCLK		= 0x00A6,
		WM_NCMBUTTONDOWN		  = 0x00A7,
		WM_NCMBUTTONUP			= 0x00A8,
		WM_NCMBUTTONDBLCLK		= 0x00A9,
		WM_KEYDOWN				= 0x0100,
		WM_KEYUP				  = 0x0101,
		WM_CHAR				   = 0x0102,
		WM_DEADCHAR			   = 0x0103,
		WM_SYSKEYDOWN			 = 0x0104,
		WM_SYSKEYUP			   = 0x0105,
		WM_SYSCHAR				= 0x0106,
		WM_SYSDEADCHAR			= 0x0107,
		WM_KEYLAST				= 0x0108,
		WM_IME_STARTCOMPOSITION   = 0x010D,
		WM_IME_ENDCOMPOSITION	 = 0x010E,
		WM_IME_COMPOSITION		= 0x010F,
		WM_IME_KEYLAST			= 0x010F,
		WM_INITDIALOG			 = 0x0110,
		WM_COMMAND				= 0x0111,
		WM_SYSCOMMAND			 = 0x0112,
		WM_TIMER				  = 0x0113,
		WM_HSCROLL				= 0x0114,
		WM_VSCROLL				= 0x0115,
		WM_INITMENU			   = 0x0116,
		WM_INITMENUPOPUP		  = 0x0117,
		WM_MENUSELECT			 = 0x011F,
		WM_MENUCHAR			   = 0x0120,
		WM_ENTERIDLE			  = 0x0121,
		WM_MENURBUTTONUP		  = 0x0122,
		WM_MENUDRAG			   = 0x0123,
		WM_MENUGETOBJECT		  = 0x0124,
		WM_UNINITMENUPOPUP		= 0x0125,
		WM_MENUCOMMAND			= 0x0126,
		WM_CTLCOLORMSGBOX		 = 0x0132,
		WM_CTLCOLOREDIT		   = 0x0133,
		WM_CTLCOLORLISTBOX		= 0x0134,
		WM_CTLCOLORBTN			= 0x0135,
		WM_CTLCOLORDLG			= 0x0136,
		WM_CTLCOLORSCROLLBAR	  = 0x0137,
		WM_CTLCOLORSTATIC		 = 0x0138,
		WM_MOUSEMOVE			  = 0x0200,
		WM_LBUTTONDOWN			= 0x0201,
		WM_LBUTTONUP			  = 0x0202,
		WM_LBUTTONDBLCLK		  = 0x0203,
		WM_RBUTTONDOWN			= 0x0204,
		WM_RBUTTONUP			  = 0x0205,
		WM_RBUTTONDBLCLK		  = 0x0206,
		WM_MBUTTONDOWN			= 0x0207,
		WM_MBUTTONUP			  = 0x0208,
		WM_MBUTTONDBLCLK		  = 0x0209,
		WM_MOUSEWHEEL			 = 0x020A,
		WM_PARENTNOTIFY		   = 0x0210,
		WM_ENTERMENULOOP		  = 0x0211,
		WM_EXITMENULOOP		   = 0x0212,
		WM_NEXTMENU			   = 0x0213,
		WM_SIZING				 = 0x0214,
		WM_CAPTURECHANGED		 = 0x0215,
		WM_MOVING				 = 0x0216,
		WM_DEVICECHANGE		   = 0x0219,
		WM_MDICREATE			  = 0x0220,
		WM_MDIDESTROY			 = 0x0221,
		WM_MDIACTIVATE			= 0x0222,
		WM_MDIRESTORE			 = 0x0223,
		WM_MDINEXT				= 0x0224,
		WM_MDIMAXIMIZE			= 0x0225,
		WM_MDITILE				= 0x0226,
		WM_MDICASCADE			 = 0x0227,
		WM_MDIICONARRANGE		 = 0x0228,
		WM_MDIGETACTIVE		   = 0x0229,
		WM_MDISETMENU			 = 0x0230,
		WM_ENTERSIZEMOVE		  = 0x0231,
		WM_EXITSIZEMOVE		   = 0x0232,
		WM_DROPFILES			  = 0x0233,
		WM_MDIREFRESHMENU		 = 0x0234,
		WM_IME_SETCONTEXT		 = 0x0281,
		WM_IME_NOTIFY			 = 0x0282,
		WM_IME_CONTROL			= 0x0283,
		WM_IME_COMPOSITIONFULL	= 0x0284,
		WM_IME_SELECT			 = 0x0285,
		WM_IME_CHAR			   = 0x0286,
		WM_IME_REQUEST			= 0x0288,
		WM_IME_KEYDOWN			= 0x0290,
		WM_IME_KEYUP			  = 0x0291,
		WM_MOUSEHOVER			 = 0x02A1,
		WM_MOUSELEAVE			 = 0x02A3,
		WM_CUT					= 0x0300,
		WM_COPY				   = 0x0301,
		WM_PASTE				  = 0x0302,
		WM_CLEAR				  = 0x0303,
		WM_UNDO				   = 0x0304,
		WM_RENDERFORMAT		   = 0x0305,
		WM_RENDERALLFORMATS	   = 0x0306,
		WM_DESTROYCLIPBOARD	   = 0x0307,
		WM_DRAWCLIPBOARD		  = 0x0308,
		WM_PAINTCLIPBOARD		 = 0x0309,
		WM_VSCROLLCLIPBOARD	   = 0x030A,
		WM_SIZECLIPBOARD		  = 0x030B,
		WM_ASKCBFORMATNAME		= 0x030C,
		WM_CHANGECBCHAIN		  = 0x030D,
		WM_HSCROLLCLIPBOARD	   = 0x030E,
		WM_QUERYNEWPALETTE		= 0x030F,
		WM_PALETTEISCHANGING	  = 0x0310,
		WM_PALETTECHANGED		 = 0x0311,
		WM_HOTKEY				 = 0x0312,
		WM_PRINT				  = 0x0317,
		WM_PRINTCLIENT			= 0x0318,
		WM_HANDHELDFIRST		  = 0x0358,
		WM_HANDHELDLAST		   = 0x035F,
		WM_AFXFIRST			   = 0x0360,
		WM_AFXLAST				= 0x037F,
		WM_PENWINFIRST			= 0x0380,
		WM_PENWINLAST			 = 0x038F,
		WM_APP					= 0x8000,
		WM_USER				   = 0x0400
	}

	internal enum Cursors : uint
	{
		IDC_ARROW		= 32512U,
		IDC_IBEAM	   = 32513U,
		IDC_WAIT		= 32514U,
		IDC_CROSS	   = 32515U,
		IDC_UPARROW	 = 32516U,
		IDC_SIZE		= 32640U,
		IDC_ICON		= 32641U,
		IDC_SIZENWSE	= 32642U,
		IDC_SIZENESW	= 32643U,
		IDC_SIZEWE	  = 32644U,
		IDC_SIZENS	  = 32645U,
		IDC_SIZEALL	 = 32646U,
		IDC_NO		  = 32648U,
		IDC_HAND		= 32649U,
		IDC_APPSTARTING = 32650U,
		IDC_HELP		= 32651U
	}

	internal enum TrackerEventFlags : uint
	{
		TME_HOVER	= 0x00000001,
		TME_LEAVE	= 0x00000002,
		TME_QUERY	= 0x40000000,
		TME_CANCEL	= 0x80000000
	}

	internal enum MouseActivateFlags
	{
		MA_ACTIVATE			= 1,
		MA_ACTIVATEANDEAT   = 2,
		MA_NOACTIVATE	   = 3,
		MA_NOACTIVATEANDEAT = 4
	}

	internal enum DialogCodes
	{
		DLGC_WANTARROWS			= 0x0001,
		DLGC_WANTTAB			= 0x0002,
		DLGC_WANTALLKEYS		= 0x0004,
		DLGC_WANTMESSAGE		= 0x0004,
		DLGC_HASSETSEL			= 0x0008,
		DLGC_DEFPUSHBUTTON		= 0x0010,
		DLGC_UNDEFPUSHBUTTON	= 0x0020,
		DLGC_RADIOBUTTON		= 0x0040,
		DLGC_WANTCHARS			= 0x0080,
		DLGC_STATIC				= 0x0100,
		DLGC_BUTTON				= 0x2000
	}
	internal enum UpdateLayeredWindowsFlags
	{
		ULW_COLORKEY = 0x00000001,
		ULW_ALPHA	= 0x00000002,
		ULW_OPAQUE   = 0x00000004
	}

	internal enum AlphaFlags : byte
	{
		AC_SRC_OVER  = 0x00,
		AC_SRC_ALPHA = 0x01
	}

	internal enum RasterOperations : uint
	{
		SRCCOPY		= 0x00CC0020,
		SRCPAINT	= 0x00EE0086,
		SRCAND		= 0x008800C6,
		SRCINVERT	= 0x00660046,
		SRCERASE	= 0x00440328,
		NOTSRCCOPY	= 0x00330008,
		NOTSRCERASE = 0x001100A6,
		MERGECOPY	= 0x00C000CA,
		MERGEPAINT	= 0x00BB0226,
		PATCOPY		= 0x00F00021,
		PATPAINT	= 0x00FB0A09,
		PATINVERT	= 0x005A0049,
		DSTINVERT	= 0x00550009,
		BLACKNESS	= 0x00000042,
		WHITENESS	= 0x00FF0062
	}

	internal enum BrushStyles
	{
		BS_SOLID			= 0,
		BS_NULL			 = 1,
		BS_HOLLOW		   = 1,
		BS_HATCHED		  = 2,
		BS_PATTERN		  = 3,
		BS_INDEXED		  = 4,
		BS_DIBPATTERN	   = 5,
		BS_DIBPATTERNPT	 = 6,
		BS_PATTERN8X8	   = 7,
		BS_DIBPATTERN8X8	= 8,
		BS_MONOPATTERN	  = 9
	}

	internal enum HatchStyles
	{
		HS_HORIZONTAL	   = 0,
		HS_VERTICAL		 = 1,
		HS_FDIAGONAL		= 2,
		HS_BDIAGONAL		= 3,
		HS_CROSS			= 4,
		HS_DIAGCROSS		= 5
	}

	internal enum CombineFlags
	{
		RGN_AND		= 1,
		RGN_OR		= 2,
		RGN_XOR		= 3,
		RGN_DIFF	= 4,
		RGN_COPY	= 5
	}

	internal enum HitTest
	{
		HTERROR			= -2,
		HTTRANSPARENT   = -1,
		HTNOWHERE		= 0,
		HTCLIENT		= 1,
		HTCAPTION		= 2,
		HTSYSMENU		= 3,
		HTGROWBOX		= 4,
		HTSIZE			= 4,
		HTMENU			= 5,
		HTHSCROLL		= 6,
		HTVSCROLL		= 7,
		HTMINBUTTON		= 8,
		HTMAXBUTTON		= 9,
		HTLEFT			= 10,
		HTRIGHT			= 11,
		HTTOP			= 12,
		HTTOPLEFT		= 13,
		HTTOPRIGHT		= 14,
		HTBOTTOM		= 15,
		HTBOTTOMLEFT	= 16,
		HTBOTTOMRIGHT	= 17,
		HTBORDER		= 18,
		HTREDUCE		= 8,
		HTZOOM			= 9 ,
		HTSIZEFIRST		= 10,
		HTSIZELAST		= 17,
		HTOBJECT		= 19,
		HTCLOSE			= 20,
		HTHELP			= 21
	}

	internal enum SystemParametersInfoActions : uint
	{
		GetBeep = 1,
		SetBeep = 2,
		GetMouse = 3,
		SetMouse = 4,
		GetBorder = 5,
		SetBorder = 6,
		GetKeyboardSpeed = 10,
		SetKeyboardSpeed = 11,
		LangDriver = 12,
		IconHorizontalSpacing = 13,
		GetScreenSaveTimeout = 14,
		SetScreenSaveTimeout = 15,
		GetScreenSaveActive = 16,
		SetScreenSaveActive = 17,
		GetGridGranularity = 18,
		SetGridGranularity = 19,
		SetDeskWallPaper = 20,
		SetDeskPattern = 21,
		GetKeyboardDelay = 22,
		SetKeyboardDelay = 23,
		IconVerticalSpacing = 24,
		GetIconTitleWrap = 25,
		SetIconTitleWrap = 26,
		GetMenuDropAlignment = 27,
		SetMenuDropAlignment = 28,
		SetDoubleClkWidth = 29,
		SetDoubleClkHeight = 30,
		GetIconTitleLogFont = 31,
		SetDoubleClickTime = 32,
		SetMouseButtonSwap = 33,
		SetIconTitleLogFont = 34,
		GetFastTaskSwitch = 35,
		SetFastTaskSwitch = 36,
		SetDragFullWindows = 37,
		GetDragFullWindows = 38,
		GetNonClientMetrics = 41,
		SetNonClientMetrics = 42,
		GetMinimizedMetrics = 43,
		SetMinimizedMetrics = 44,
		GetIconMetrics = 45,
		SetIconMetrics = 46,
		SetWorkArea = 47,
		GetWorkArea = 48,
		SetPenWindows = 49,
		GetFilterKeys = 50,
		SetFilterKeys = 51,
		GetToggleKeys = 52,
		SetToggleKeys = 53,
		GetMouseKeys = 54,
		SetMouseKeys = 55,
		GetShowSounds = 56,
		SetShowSounds = 57,
		GetStickyKeys = 58,
		SetStickyKeys = 59,
		GetAccessTimeout = 60,
		SetAccessTimeout = 61,
		GetSerialKeys = 62,
		SetSerialKeys = 63,
		GetSoundsEntry = 64,
		SetSoundsEntry = 65,
		GetHighContrast = 66,
		SetHighContrast = 67,
		GetKeyboardPref = 68,
		SetKeyboardPref = 69,
		GetScreenReader = 70,
		SetScreenReader = 71,
		GetAnimation = 72,
		SetAnimation = 73,
		GetFontSmoothing = 74,
		SetFontSmoothing = 75,
		SetDragWidth = 76,
		SetDragHeight = 77,
		SetHandHeld = 78,
		GetLowPowerTimeout = 79,
		GetPowerOffTimeout = 80,
		SetLowPowerTimeout = 81,
		SetPowerOffTimeout = 82,
		GetLowPowerActive = 83,
		GetPowerOffActive = 84,
		SetLowPowerActive = 85,
		SetPowerOffActive = 86,
		SetCursors = 87,
		SetIcons = 88,
		GetDefaultInputLang = 89,
		SetDefaultInputLang = 90,
		SetLangToggle = 91,
		GetWindwosExtension = 92,
		SetMouseTrails = 93,
		GetMouseTrails = 94,
		ScreenSaverRunning = 97,
		GetMouseHoverTime = 0x0066
	}

	[Flags]
	internal enum FlagsAnimateWindow : uint
	{
		AW_HOR_POSITIVE = 0x00000001,
		AW_HOR_NEGATIVE = 0x00000002,
		AW_VER_POSITIVE = 0x00000004,
		AW_VER_NEGATIVE = 0x00000008,
		AW_CENTER = 0x00000010,
		AW_HIDE = 0x00010000,
		AW_ACTIVATE = 0x00020000,
		AW_SLIDE = 0x00040000,
		AW_BLEND =0x00080000
	}

	[Flags]
	internal enum FlagsDCX : uint
	{
		DCX_WINDOW = 0x1,
		DCX_CACHE = 0x2,
		DCX_NORESETATTRS = 0x4,
		DCX_CLIPCHILDREN = 0x8,
		DCX_CLIPSIBLINGS = 0x10,
		DCX_PARENTCLIP = 0x20,
		DCX_EXCLUDERGN = 0x40,
		DCX_INTERSECTRGN = 0x80,
		DCX_EXCLUDEUPDATE = 0x100,
		DCX_INTERSECTUPDATE = 0x200,
		DCX_LOCKWINDOWUPDATE = 0x400,
		DCX_NORECOMPUTE = 0x100000,
		DCX_VALIDATE = 0x200000
	}
}

#T=WinDbg CmdTree
windbg ANSI Command Tree 1.0
title {"Microshaoft Commands"}
body
{"cmdtree"}
	{"Microshaoft.WinDbg.CmdTree.txt"} {".cmdtree microshaoft.windbg.cmdtree.txt"}
{"SOS Commands"}
	{"Load SOS and SOSEX"} {".loadby sos mscorwks;.load sosex"}
	{"Microshaoft Load .NET v4.0+ sos.dll"} {".load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\SOS.dll"}
	{"Microshaoft Load .NET v4.0+ mscorwks.dll"} {".load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\mscorwks.dll"}
	{"Microshaoft Load .NET v3.5- sos.dll"} {".load C:\Windows\Microsoft.NET\Framework64\v2.0.50727\SOS.dll"}
	{"Microshaoft Load .NET v3.5- mscorwks.dll"} {".load C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorwks.dll"}
	{"PSSCOR"}
		{"Microshaoft Load .NET v4.0+ AMD64 psscor4.dll"} {".load D:\WinDbg\Psscor\psscor4\amd64\psscor4.dll"}
		{"Microshaoft Load .NET v3.5- AMD64 psscor2.dll"} {".load D:\WinDbg\Psscor\psscor2\amd64\psscor2.dll"}
	{"Modules"}
		{"All Modules"} {"lm D sm"}
		{"Loaded Modules"} {"lmo D sm"}
		{"Loaded Modules (verbose)"} {"lmvo D sm"}
		{"Modules w/o symbols"} {"lme D sm"}
	{"Threads"}
		{"Managed Threads"} {"!threads"}
		{"Native Threads"} {"~"}
		{"Thread Pool Threads"} {"!threadpool"}
		{"Sync Block Deadlocks"} {"!dlk"}
	{"Stacks"}
		{"Current Managed Stack"} {"!clrstack"}
		{"DumpObj"} {"!do ###"}
		{"Current Managed Stack Parameters and Locals"} {"!vars -w"}
		{"Current Native Stack"} {"kP"}
		{"Current Dump Stack"} {"!dumpstack"}
		{"All Managed Stacks"} {"~*e!clrstack"}
		{"All Managed Stack Parameters and Locals"} {"~*e!vars -w"}
		{"All Native Stacks"} {"~*kP"}
		{"All Dump Stacks"} {"!eestack"}
	{"Memory"}
		{"Stack Objects"} {"!dso"}
		{"GC Heap"} {"!eeheap -gc"}
		{"Heap Stats"} {"!dumpheap -stat"}
		{"Objects > 500 bytes"} {"!dumpheap -min 500"}
		{"Objects > 1000 bytes"} {"!dumpheap -min 1000"}
		{"Gen 2 Objects"} {"!dumpgen -stat 2"}
{"Common Commands"}
	{"Information"}
		{"Time of dump"} {".time"}
		{"Process being debugged"} {"|"}
		{"Dump Location"} {"||"}
		{"Create server on port 9999"} {".server tcp:port=9999"}
		{"Show remote connections"} {".clients"}
		{"Process Environment Block"} {"!peb"}
	{"Logging"}
		{"Open Log"} {".logopen /t /u /d"}
		{"Close Log"} {".logclose"}
	{"Modules"}
		{"All Modules"} {"lm D sm"}
		{"Loaded Modules"} {"lmo D sm"}
		{"Loaded Modules (verbose)"} {"lmvo D sm"}
		{"Modules w/o symbols"} {"lme D sm"}
	{"Stacks"}
		{"Set frame length to 2000"} {".kframes 2000"}
		{"Dump current stack w/ DML"} {"kpM 1000"}
		{"Dump stacks without private info"} {"knL 1000"}
		{"Dump stacks with all parameters"} {"kPn 1000"}
		{"Dump stacks (distance from last frame)"} {"kf 1000"}
		{"Dump stacks with Frame Pointer Omission"} {"kvn 1000"}
		{"Dump all stack"} {"~*kbn 1000"}
		{"Dump unique stacks"} {"!uniqstack -pn"}
		{"Thread environment block"} {"!teb"}
		{"Move to next frame"} {".f+"}
		{"Move to previous frame"} {".f-"}
	{"Memory"}
		{"Dump heaps"} {"!heap -a"}
	{"Automated Task"}
		{"!analyze"} {"!analyze -v"}
		{"Locks"} {"!ntsdexts.locks"}
		{"CPU time for User and Kernel Mode"} {"!runaway 7"}
	{"Managed"}
		{"Load sos"} {".loadby sos mscorwks"}
		{"Microshaoft Load .NET v4.0+ sos.dll"} {".load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\SOS.dll"}
		{"Microshaoft Load .NET v4.0+ mscorwks.dll"} {".load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\mscorwks.dll"}
		{"Microshaoft Load .NET v3.5- sos.dll"} {".load C:\Windows\Microsoft.NET\Framework64\v2.0.50727\SOS.dll"}
		{"Microshaoft Load .NET v3.5- mscorwks.dll"} {".load C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorwks.dll"}
		{"clrstack"} {"!clrstack"}
		{"Threads"} {"!threads"}
		{"Stack Objects"} {"!dso"}
		{"Exceptions"} {"!dae"}
{"Crash Dump Analysis Checklist (www.dumpanalysis.org)"}
	{"General"}
		{"Versions and locations"} {"version"}
		{"Set longer stack trace"} {".kframes 100"}
	{"Application crash or hang"}
		{"Default analysis (crash)"} {"!analyze -v"}
		{"Default analysis (hang)"} {"!analyze -v -hang"}
		{"Switch to x86 architecture"} {".load wow64exts; .effmach x86"}
		{"Critical sections (locked)"} {"!locks"}
		{"Modules"} {"lmv"}
		{"Threads (all)"} {"~*kv 250"}
		{"Threads (unique)"} {"!uniqstack"}
		{"Gflags"} {"!gflag"}
		{"Time consumed by thread"} {"!runaway"}
		{"PEB"} {"!peb"}
		{"TEB"} {"!teb"}
		{"Hooked functions (ntdll)"} {"!chkimg -lo 50 -d !ntdll -v"}
		{"Hooked functions (kernel32)"} {"!chkimg -lo 50 -d !kernel32 -v"}
		{"Hooked functions (user32)"} {"!chkimg -lo 50 -d !user32 -v"}
		{"Hooked functions (ALL)"} {"!for_each_module !chkimg -lo 50 -d !${@#ModuleName} -v"}
		{"Exception handlers"} {"!exchain"}
		{"Computer name"} {"!envvar COMPUTERNAME"}
		{"Stack of exception thread"} {"~#kv 250"}
		{"Stack of current thread"} {"~.kv 250"}
		{"Switch to thread"}
			{"#0"} {"~0s"}
			{"#1"} {"~1s"}
			{"#2"} {"~2s"}
			{"#3"} {"~3s"}
			{"#4"} {"~4s"}
			{"#5"} {"~5s"}
			{"#6"} {"~6s"}
			{"#7"} {"~7s"}
			{"#8"} {"~8s"}
			{"#9"} {"~9s"}
	{"System hang"}
		{"Default analysis"} {"!analyze -v -hang"}
		{"ERESOURCE contention"} {"!locks"}
		{"Processes and virtual memory"} {"!vm 4"}
		{"Sorted pool consumption (paged)"} {"!poolused 4"}
		{"Sorted pool consumption (nonpaged)"} {"!poolused 3"}
		{"Waiting threads"} {"!stacks"}
		{"Critical system queues"} {"!exqueue f"}
		{"I/O"} {"!irpfind"}
		{"The list of all thread stack traces"} {"!process 0 ff"}
		{"Critical sections for current process"} {"!ntsdexts.locks"}
		{"Sessions"} {"!session"}
		{"Processes"} {"!process 0 0"}
		{"Running threads"} {"!running"}
		{"Ready threads"} {"!ready"}
		{"DPC queues"} {"!dpcs"}
		{"The list of APCs"} {"!apc"}
		{"Internal queued spinlocks"} {"!qlocks"}
		{"Computer name"} {"dS srv!srvcomputername"}
		{"Switch to processor"}
			{"#0"} {"~0s"}
			{"#1"} {"~1s"}
			{"#2"} {"~2s"}
			{"#3"} {"~3s"}
			{"#4"} {"~4s"}
			{"#5"} {"~5s"}
			{"#6"} {"~6s"}
			{"#7"} {"~7s"}
	{"BSOD"}
		{"Default analysis"} {"!analyze -v"}
		{"Processes and virtual memory"} {"!vm 4"}
		{"Bugcheck callback data (prior to Windows XP SP1)"} {"!bugdump"}
		{"Bugcheck secondary callback data"} {".enumtag"}
		{"Computer name"} {"dS srv!srvcomputername"}
{"Microshaoft .NET"}
	{"show objects on current stack"} {"!dumpstackobjects"}
	{"show ThreadPool running"} {"!threadpool"}
	{"show all threads running time utilization"} {"!runaway"}
	{"gc handles"} {"!gchandles"}
	{"go to thread ~#s"} {"~1s"}
	{"!DumpStack [-EE] [top stack [bottom stack]]"} {"!dumpstack"}
	{"show class instance member value !DumpVC <MethodTable address> <address>"} {"!DumpVC"}
	{"show managed heaps"} {"!eeheap -gc"}
	{"show heaps memory statistic"} {"!dumpheap -min 200 -stat"}
	{"show Byte array heap memory usage"} {"!dumpheap -type Byte[] -min 200"}
	{"show managed heap's MethodTable objects !dumpheap -mt <MethodTable address>"} {"!dumpheap -mt"}
	{"show object reference info !GCRoot [-nostacks] <Object address>"} {"!gcroot"}
	{"show object detail !DumpObj [-nofields] <object address>"} {"!do"}
	{"show data object detail !da <address>"} {"!da"}
	{"show all objects in current stack !DumpStackObjects [-verify] [top stack [bottom stack]]"} {"!dso"}
	{"show object size !ObjSize [<Object address>]"} {"!objsize"}
	{"!PrintException [-nested] [<Exception object address>]"} {"!pe"}

#T=Windows Sevice
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Configuration.Install;
	using System.Security.Principal;
	using System.ServiceProcess;
	using Microshaoft.Win32;
	public class WindowsServiceHost : ServiceBase
	{
		static void Main(string[] args)
		{
			Console.WriteLine(Environment.CommandLine);
			WindowsServiceHost service = new WindowsServiceHost();
			int l = 0;
			bool needFreeConsole = false;
			if (args != null)
			{
				l = args.Length;
			}
			if (l > 0)
			{
				if (args[0].ToLower() == "/console")
				{
					needFreeConsole = true;
					Console.Title = "Service Run as Console ...";
					Console.WriteLine("Alloc Console ...");
					NativeMethods.AllocConsole();
					service.OnStart(args);
					Console.ReadLine();
					return;
				}
			}
			Console.WriteLine("Service");
			ServiceBase.Run(service);
			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
		//public WindowsServiceHost()
		//{
			//CanPauseAndContinue = true;
		//}
		protected override void OnStart(string[] args)
		{
			Console.WriteLine("[{0}]", string.Join(" ", args));
			Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
			Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());
		}
	}
	[RunInstallerAttribute(true)]
	public class ProjectInstaller : Installer
	{
		private ServiceInstaller _serviceInstaller;
		private ServiceProcessInstaller _processInstaller;
		public ProjectInstaller()
		{
			_processInstaller = new ServiceProcessInstaller();
			_serviceInstaller = new ServiceInstaller();
			// Service will run under system account
			_processInstaller.Account = ServiceAccount.LocalSystem;
			// Service will have Start Type of Manual
			_serviceInstaller.StartType = ServiceStartMode.Manual;
			//_serviceInstaller.ServiceName = WindowsServiceHost.serviceName;
			Installers.Add(_serviceInstaller);
			Installers.Add(_processInstaller);
		}
		public override void Install(IDictionary stateSaver)
		{
			SetServiceName();
			base.Install(stateSaver);
		}
		public override void Uninstall(IDictionary savedState)
		{
			SetServiceName();
			base.Uninstall(savedState);
		}
		private void SetServiceName()
		{
			var parameters = Context.Parameters;
			var parametersKeys = parameters.Keys;
			//foreach (KeyValuePair<string, string> kvp in parameters)
			foreach (string s in parametersKeys)
			{
				var k = s.Trim().ToLower();
				if (k == "servicename")
				{
					//var serviceName = kvp.Value;
					var serviceName = parameters[k];
					_serviceInstaller.ServiceName = serviceName;
					_serviceInstaller.DisplayName = serviceName;
					break;
				}
			}
		}
	}
}
namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}
#T=WinForm C#
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;

namespace WindowsApplication1
{
	/// <summary>
	/// Form1 的摘要说明。
	/// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button button1;
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form1()
		{
			//
			// Windows 窗体设计器支持所必需的
			//
			InitializeComponent();

			//
			// TODO: 在 InitializeComponent 调用后添加任何构造函数代码
			//
		}

		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要使用代码编辑器修改
		/// 此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(96, 112);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(88, 32);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// Form1
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
			this.ClientSize = new System.Drawing.Size(292, 273);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new System.EventHandler(this.Form1_Load);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new Form1());
		}

		private void Form1_Load(object sender, System.EventArgs e)
		{
		
		}

		private void button1_Click(object sender, System.EventArgs e)
		{
		
		}
	}
}
#T=WinForm FlashTrackBar
namespace Microsoft.Samples.WinForms.Cs.FlashTrackBar {
	using System;
	using System.ComponentModel;
	using System.ComponentModel.Design;
	using System.Drawing;
	using System.Drawing.Drawing2D;
	using System.Drawing.Design;
	using System.Windows.Forms;
	using System.Diagnostics;

	[System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.Demand, Name = "FullTrust")] 
	public class FlashTrackBar : System.Windows.Forms.Control {
		/// <summary>
		///	Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components;

		private const int LeftRightBorder = 10;
		private int value = 0;
		private int min = 0;
		private int max = 100;
		private bool showPercentage = false;
		private bool showValue = false;
		private bool allowUserEdit = true;
		private bool showGradient = true;
		private int dragValue = 0;
		private bool dragging = false;
		private Color startColor = Color.Red;
		private Color endColor = Color.LimeGreen;
		private EventHandler onValueChanged;
		private Brush baseBackground = null;
		private Brush backgroundDim = null;
		private byte darkenBy = 200;


		public FlashTrackBar() {
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			SetStyle(ControlStyles.Opaque, true);
			SetStyle(ControlStyles.ResizeRedraw, true);
			Debug.Assert(GetStyle(ControlStyles.ResizeRedraw), "Should be redraw!");
		}

		/// <summary>
		///	Clean up any resources being used.
		/// </summary>
		protected override void Dispose(bool disposing)
		{
		   if (disposing) {
				if (components != null) {
					components.Dispose();
				}
		   }
		   base.Dispose(disposing);
		}

		/// <summary>
		///	Required method for Designer support - do not modify
		///	the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent () {
			this.components = new System.ComponentModel.Container ();
			this.ForeColor = System.Drawing.Color.White;
			this.BackColor = System.Drawing.Color.Black;
			this.Size = new System.Drawing.Size(100, 23);
			this.Text = "FlashTrackBar";
		}

		[
			Category("Flash"),
			DefaultValue(true)
		]
		public bool AllowUserEdit {
			get {
				return allowUserEdit;
			}
			set {
				if (value != allowUserEdit) {
					allowUserEdit = value;
					if (!allowUserEdit) {
						Capture = false;
						dragging = false;
					}
				}
			}
		}

		[
			Category("Flash")
		]
		public Color EndColor {
			get {
				return endColor;
			}
			set {
				endColor = value;
				if (baseBackground != null && showGradient) {
					baseBackground.Dispose();
					baseBackground = null;
				}
				Invalidate();
			}
		}

		public bool ShouldSerializeEndColor() {
			return !(endColor == Color.LimeGreen);
		}


		[
			Category("Flash"),
			Editor(typeof(FlashTrackBarDarkenByEditor), typeof(UITypeEditor)),
			DefaultValue((byte)200)
		]
		public byte DarkenBy {
			get {
				return darkenBy;
			}
			set {
				if (value != darkenBy) {
					darkenBy = value;
					if (backgroundDim != null) {
						backgroundDim.Dispose();
						backgroundDim = null;
					}
					OptimizedInvalidate(Value, max);
				}
			}
		}

		[
			Category("Flash"),
			DefaultValue(100)
		]
		public int Max {
			get {
				return max;
			}
			set {
				if (max != value) {
					max = value;
					Invalidate();
				}
			}
		}

		[
			Category("Flash"),
			DefaultValue(0)
		]
		public int Min {
			get {
				return min;
			}
			set {
				if (min != value) {
					min = value;
					Invalidate();
				}
			}
		}

		[
			Category("Flash")
		]
		public Color StartColor {
			get {
				return startColor;
			}
			set {
				startColor = value;
				if (baseBackground != null && showGradient) {
					baseBackground.Dispose();
					baseBackground = null;
				}
				Invalidate();
			}
		}

		public bool ShouldSerializeStartColor() {
			return !(startColor == Color.Red);
		}



		[
			Category("Flash"),
			RefreshProperties(RefreshProperties.Repaint),
			DefaultValue(false)
		]
		public bool ShowPercentage {
			get {
				return showPercentage;
			}
			set {
				if (value != showPercentage) {
					showPercentage = value;
					if (showPercentage) {
						showValue = false;
					}
					Invalidate();
				}
			}
		}

		[
			Category("Flash"),
			RefreshProperties(RefreshProperties.Repaint),
			DefaultValue(false)
		]
		public bool ShowValue {
			get {
				return showValue;
			}
			set {
				if (value != showValue) {
					showValue = value;
					if (showValue) {
						showPercentage = false;
					}
					Invalidate();
				}
			}
		}

		[
			Category("Flash"),
			DefaultValue(true)
		]
		public bool ShowGradient {
			get {
				return showGradient;
			}
			set {
				if (value != showGradient) {
					showGradient = value;
					if (baseBackground != null) {
						baseBackground.Dispose();
						baseBackground = null;
					}
					Invalidate();
				}
			}
		}

		[
			Category("Flash"),
			Editor(typeof(FlashTrackBarValueEditor), typeof(UITypeEditor)),
			DefaultValue(0)
		]
		public int Value {
			get {
				if (dragging) {
					return dragValue;
				}
				return value;
			}
			set {
				if (value != this.value) {
					int old = this.value;
					this.value = value;
					OnValueChanged(EventArgs.Empty);
					OptimizedInvalidate(old, this.value);
				}
			}
		}

		// ValueChanged Event
		[Description("Raised when the Value displayed changes")]
		public event EventHandler ValueChanged {
			add {
				onValueChanged += value;
			}
			remove {
				onValueChanged -= value;
			}
		}

		private void OptimizedInvalidate(int oldValue, int newValue) {
			Rectangle client = ClientRectangle;

			float oldPercentValue = ((float)oldValue / ((float)Max - (float)Min));
			int oldNonDimLength = (int)(oldPercentValue * (float)client.Width);

			float newPercentValue = ((float)newValue / ((float)Max - (float)Min));
			int newNonDimLength = (int)(newPercentValue * (float)client.Width);

			int min = Math.Min(oldNonDimLength, newNonDimLength);
			int max = Math.Max(oldNonDimLength, newNonDimLength);

			Rectangle invalid = new Rectangle(
				client.X + min, 
				client.Y, 
				max - min, 
				client.Height);

			Invalidate(invalid);

			string oldToDisplay;
			string newToDisplay;

			if (ShowPercentage) {
				oldToDisplay = Convert.ToString((int)(oldPercentValue * 100f)) + "%";
				newToDisplay = Convert.ToString((int)(newPercentValue * 100f)) + "%";
			}
			else if (ShowValue) {
				oldToDisplay = Convert.ToString(oldValue);
				newToDisplay = Convert.ToString(newValue);
			}
			else {
				oldToDisplay = null;
				newToDisplay = null;
			}

			if (oldToDisplay != null && newToDisplay != null) {
				Graphics g = CreateGraphics();
				SizeF oldFontSize = g.MeasureString(oldToDisplay, Font);
				SizeF newFontSize = g.MeasureString(newToDisplay, Font);
				RectangleF oldFontRect = new RectangleF(new PointF(0, 0), oldFontSize);
				RectangleF newFontRect = new RectangleF(new PointF(0, 0), newFontSize);
				oldFontRect.X = (client.Width - oldFontRect.Width) / 2;
				oldFontRect.Y = (client.Height - oldFontRect.Height) / 2;
				newFontRect.X = (client.Width - newFontRect.Width) / 2;
				newFontRect.Y = (client.Height - newFontRect.Height) / 2;

				Invalidate(new Rectangle((int)oldFontRect.X, (int)oldFontRect.Y, (int)oldFontRect.Width, (int)oldFontRect.Height));
				Invalidate(new Rectangle((int)newFontRect.X, (int)newFontRect.Y, (int)newFontRect.Width, (int)newFontRect.Height));
			}
		}

		protected override void OnMouseDown(MouseEventArgs e) {
			base.OnMouseDown(e);
			if (!allowUserEdit) {
				return;
			}
			Capture = true;
			dragging = true;
			SetDragValue(new Point(e.X, e.Y));
		}

		protected override void OnMouseMove(MouseEventArgs e) {
			base.OnMouseMove(e);
			if (!allowUserEdit || !dragging) {
				return;
			}
			SetDragValue(new Point(e.X, e.Y));
		}

		protected override void OnMouseUp(MouseEventArgs e) {
			base.OnMouseUp(e);
			if (!allowUserEdit || !dragging) {
				return;
			}
			Capture = false;
			dragging = false;
			value = dragValue;
			OnValueChanged(EventArgs.Empty);
		}

		protected override void OnPaint(PaintEventArgs e) {

			base.OnPaint(e);
			if (baseBackground == null) {
				if (showGradient) {
					baseBackground = new LinearGradientBrush(new Point(0, 0),
															 new Point(ClientSize.Width, 0),
															 StartColor,
															 EndColor);
				}
				else if (BackgroundImage != null) {
					baseBackground = new TextureBrush(BackgroundImage);
				}
				else {
					baseBackground = new SolidBrush(BackColor);
				}
			}

			if (backgroundDim == null) {
				backgroundDim = new SolidBrush(Color.FromArgb(DarkenBy, Color.Black));
			}

			Rectangle toDim = ClientRectangle;
			float percentValue = ((float)Value / ((float)Max - (float)Min));
			int nonDimLength = (int)(percentValue * (float)toDim.Width);
			toDim.X += nonDimLength;
			toDim.Width -= nonDimLength;


			string text = Text;
			string toDisplay = null;
			RectangleF textRect = new RectangleF();

			if (ShowPercentage || ShowValue || text.Length > 0) {

				if (ShowPercentage) {
					toDisplay = Convert.ToString((int)(percentValue * 100f)) + "%";
				}
				else if (ShowValue) {
					toDisplay = Convert.ToString(Value);
				}
				else {
					toDisplay = text;
				}

				SizeF textSize = e.Graphics.MeasureString(toDisplay, Font);
				textRect.Width = textSize.Width;
				textRect.Height = textSize.Height;
				textRect.X = (ClientRectangle.Width - textRect.Width) / 2;
				textRect.Y = (ClientRectangle.Height - textRect.Height) / 2;
			}

			e.Graphics.FillRectangle(baseBackground, ClientRectangle);
			e.Graphics.FillRectangle(backgroundDim, toDim);
			e.Graphics.Flush();
			if (toDisplay != null && toDisplay.Length > 0) {
				e.Graphics.DrawString(toDisplay, Font, new SolidBrush(ForeColor), textRect);
			}
		}

		protected override void OnTextChanged(EventArgs e) {
			base.OnTextChanged(e);
			Invalidate();
		}

		protected override void OnBackColorChanged(EventArgs e) {
			base.OnTextChanged(e);
			if ((baseBackground != null) && (!showGradient)) {
						baseBackground.Dispose();
						baseBackground = null;
			}
		}

		protected override void OnBackgroundImageChanged(EventArgs e) {
			base.OnTextChanged(e);
			if ((baseBackground != null) && (!showGradient)) {
						baseBackground.Dispose();
						baseBackground = null;
			}
		}

		protected override void OnResize(EventArgs e) {
			base.OnResize(e);
			if (baseBackground != null) {
				baseBackground.Dispose();
				baseBackground = null;
			}
		}

		protected virtual void OnValueChanged(EventArgs e) {
			if (onValueChanged != null) {
				onValueChanged.Invoke(this, e);
			}
		}

		private void SetDragValue(Point mouseLocation) {

			Rectangle client = ClientRectangle;

			if (client.Contains(mouseLocation)) {
				float percentage = (float)mouseLocation.X / (float)ClientRectangle.Width;
				int newDragValue = (int)(percentage * (float)(max - min));
				if (newDragValue != dragValue) {
					int old = dragValue;
					dragValue = newDragValue;
					OptimizedInvalidate(old, dragValue);
				}
			}
			else {
				if (client.Y <= mouseLocation.Y && mouseLocation.Y <= client.Y + client.Height) {
					if (mouseLocation.X <= client.X && mouseLocation.X > client.X - LeftRightBorder) {
						int newDragValue = min;
						if (newDragValue != dragValue) {
							int old = dragValue;
							dragValue = newDragValue;
							OptimizedInvalidate(old, dragValue);
						}
					}
					else if (mouseLocation.X >= client.X + client.Width && mouseLocation.X < client.X + client.Width + LeftRightBorder) {
						int newDragValue = max;
						if (newDragValue != dragValue) {
							int old = dragValue;
							dragValue = newDragValue;
							OptimizedInvalidate(old, dragValue);
						}
					}
				}
				else {
					if (dragValue != value) {
						int old = dragValue;
						dragValue = value;
						OptimizedInvalidate(old, dragValue);
					}
				}
			}
		}
	}
}

namespace Microsoft.Samples.WinForms.Cs.FlashTrackBar {
   using System;
   using System.ComponentModel;
   using System.ComponentModel.Design;
   using System.Diagnostics;
   using System.Drawing;
   using System.Drawing.Drawing2D;
   using System.Drawing.Design;
   using System.Windows.Forms;
   using System.Windows.Forms.ComponentModel;
   using System.Windows.Forms.Design;

   public class FlashTrackBarDarkenByEditor : FlashTrackBarValueEditor {
	   protected override void SetEditorProps(FlashTrackBar editingInstance, FlashTrackBar editor) {
		   base.SetEditorProps(editingInstance, editor);
		   editor.Min = 0;
		   editor.Max = byte.MaxValue;
	   }
   }
}
namespace Microsoft.Samples.WinForms.Cs.FlashTrackBar {
	using System;
	using System.ComponentModel;
	using System.ComponentModel.Design;
	using System.Diagnostics;
	using System.Drawing;
	using System.Drawing.Drawing2D;
	using System.Drawing.Design;
	using System.Windows.Forms;
	using System.Windows.Forms.ComponentModel;
	using System.Windows.Forms.Design;

	[System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.Demand, Name = "FullTrust")] 
	public class FlashTrackBarValueEditor : System.Drawing.Design.UITypeEditor {

		private IWindowsFormsEditorService edSvc = null;

		protected virtual void SetEditorProps(FlashTrackBar editingInstance, FlashTrackBar editor) {
			editor.ShowValue = true;
			editor.StartColor = Color.Navy;
			editor.EndColor = Color.White;
			editor.ForeColor = Color.White;
			editor.Min = editingInstance.Min;
			editor.Max = editingInstance.Max;
		}

		public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {

			if (context != null
				&& context.Instance != null
				&& provider != null) {

				edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

				if (edSvc != null) {
					FlashTrackBar trackBar = new FlashTrackBar();
					trackBar.ValueChanged += new EventHandler(this.ValueChanged);
					SetEditorProps((FlashTrackBar)context.Instance, trackBar);
					bool asInt = true;
					if (value is int) {
						trackBar.Value = (int)value;
					}
					else if (value is byte) {
						asInt = false;
						trackBar.Value = (byte)value;
					}
					edSvc.DropDownControl(trackBar);
					if (asInt) {
						value = trackBar.Value;
					}
					else {
						value = (byte)trackBar.Value;
					}
				}
			}

			return value;
		}

		public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
			if (context != null && context.Instance != null) {
				return UITypeEditorEditStyle.DropDown;
			}
			return base.GetEditStyle(context);
		}

		private void ValueChanged(object sender, EventArgs e) {
			if (edSvc != null) {
				edSvc.CloseDropDown();
			}
		}
	}
}


namespace Microsoft.Samples.WinForms.Cs.HostApp {
	using System;
	using System.ComponentModel;
	using System.Drawing;
	using System.Windows.Forms;
	using Microsoft.Samples.WinForms.Cs.FlashTrackBar;

	public class HostApp : System.Windows.Forms.Form {
		/// <summary>
		///	Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components;
		protected internal Microsoft.Samples.WinForms.Cs.FlashTrackBar.FlashTrackBar flashTrackBar1;

		public HostApp() {
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

		}

		/// <summary>
		///	Clean up any resources being used.
		/// </summary>
		protected override void Dispose(bool disposing)
		{
		   if (disposing) {
				if (components != null) {
					components.Dispose();
				}
		   }
		   base.Dispose(disposing);
		}

		/// <summary>
		///	Required method for Designer support - do not modify
		///	the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent() {
			this.components = new System.ComponentModel.Container ();
			this.flashTrackBar1 = new Microsoft.Samples.WinForms.Cs.FlashTrackBar.FlashTrackBar ();
			this.Text = "Control Example";
			this.ClientSize = new System.Drawing.Size (600, 450);
			flashTrackBar1.BackColor = System.Drawing.Color.Black;
			flashTrackBar1.Dock = System.Windows.Forms.DockStyle.Fill;
			flashTrackBar1.TabIndex = 0;
			flashTrackBar1.ForeColor = System.Drawing.Color.White;
			flashTrackBar1.Text = "Drag the Mouse and say Wow!";
			flashTrackBar1.Value = 73;
			flashTrackBar1.Size = new System.Drawing.Size (600, 450);
			this.Controls.Add (this.flashTrackBar1);
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		public static void Main(string[] args) {
			Application.Run(new HostApp());
		}

	}
}

#T=winHttp Proxy detect
namespace Microshaoft
{
	//
	// Author: Daniel Vasquez Lopez
	//

	using System;
	using System.Collections.Generic;
	using System.Diagnostics;
	using System.IO;
	using System.Net;
	using System.Runtime.InteropServices;

	internal class Program {

		private static void Main() {
			try {

				// Download danielvl's RSS feed locally.
				Uri requestedUrl = new Uri("http://tinyurl.com/d5yy8a");
				string somePath = Path.Combine(
					Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
					"test.xml");

				WebClient client = new WebClient();
				WebProxy proxy = null;

				for (int i = 0; i < 10; i++) {

					Stopwatch w = Stopwatch.StartNew();

					if (proxy == null) {
						// Comment out foreach statement to use normal System.Net proxy detection 
						foreach (
							Uri address
							in WinHttpSafeNativeMethods.GetProxiesForUrl(requestedUrl)) {

							proxy = new WebProxy(address);
							client.Proxy = proxy;
							break;
						}
					}

					client.DownloadFile(requestedUrl, somePath);

					w.Stop();

					Console.WriteLine("MS:" + w.ElapsedMilliseconds);
				}
			}
			catch (WebException ex) {
				Console.Error.WriteLine(ex);
			}
		}

		internal static class WinHttpSafeNativeMethods {

			internal static IEnumerable<Uri> GetProxiesForUrl(
				Uri requestUrl) {
				return GetProxiesForUrl(requestUrl, string.Empty);
			}

			internal static IEnumerable<Uri> GetProxiesForUrl(
				Uri requestUrl, string userAgent) {

				IntPtr hHttpSession = IntPtr.Zero;
				string[] proxyList = null; ;

				try {
					hHttpSession = WinHttpOpen(userAgent,
						AccessType.NoProxy, null, null, 0);

					if (hHttpSession != IntPtr.Zero) {

						AutoProxyOptions autoProxyOptions = new AutoProxyOptions();
						autoProxyOptions.Flags = AccessType.AutoDetect;
						autoProxyOptions.AutoLogonIfChallenged = true;
						autoProxyOptions.AutoDetectFlags =
							AutoDetectType.Dhcp | AutoDetectType.DnsA;

						ProxyInfo proxyInfo = new ProxyInfo();

						if (WinHttpGetProxyForUrl(hHttpSession,
							requestUrl.ToString(), ref autoProxyOptions, ref proxyInfo)) {
							if (!string.IsNullOrEmpty(proxyInfo.Proxy)) {
								proxyList = proxyInfo.Proxy.Split(';', ' ');
							}
						}
					}
				}
				catch (System.DllNotFoundException) {
					// winhttp.dll is not found. 
				}
				catch (System.EntryPointNotFoundException) {
					// A method within winhttp.dll is not found. 
				}
				finally {
					if (hHttpSession != IntPtr.Zero) {
						WinHttpCloseHandle(hHttpSession);
						hHttpSession = IntPtr.Zero;
					}
				}

				if (proxyList != null && proxyList.Length > 0) {
					Uri proxyUrl;
					foreach (string address in proxyList) {
						if (TryCreateUrlFromPartialAddress(address, out proxyUrl)) {
							yield return proxyUrl;
						}
					}
				}
			}

			private static bool TryCreateUrlFromPartialAddress(string address, out Uri url) {
				address = address.Trim();

				if (string.IsNullOrEmpty(address)) {
					url = null;
					return false;
				}

				try {
					if (address.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
						address.StartsWith("https://", StringComparison.OrdinalIgnoreCase)) {
						url = new Uri(address);
					}
					else if (address.StartsWith("//", StringComparison.Ordinal)) {
						url = new Uri("http:" + address);
					}
					else {
						url = new Uri("http://" + address);
					}
					return true;
				}
				catch (UriFormatException) {
					url = null;
				}
				return false;
			}

			[DllImport("winhttp.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			private static extern IntPtr WinHttpOpen(
				string userAgent,
				AccessType accessType,
				string proxyName,
				string proxyBypass,
				int flags);

			[DllImport("winhttp.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			private static extern bool WinHttpGetProxyForUrl(
				IntPtr hSession,
				string url,
				[In] ref AutoProxyOptions autoProxyOptions,
				[In, Out] ref ProxyInfo proxyInfo);

			[DllImport("winhttp.dll", CharSet = CharSet.Unicode, SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			private static extern bool WinHttpCloseHandle(IntPtr httpSession);

			private enum AccessType {
				NoProxy = 1,
				AutoDetect = 1,
				AutoProxyConfigUrl = 2
			}

			[Flags]
			private enum AutoDetectType {
				Dhcp = 1,
				DnsA = 2,
			}

			[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
			private struct AutoProxyOptions {

				internal AccessType Flags;

				internal AutoDetectType AutoDetectFlags;

				[MarshalAs(UnmanagedType.LPTStr)]
				internal string AutoConfigUrl;

				private IntPtr lpvReserved;

				private int dwReserved;

				internal bool AutoLogonIfChallenged;
			}

			[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
			private struct ProxyInfo {

				internal AccessType dwAccessType;

				[MarshalAs(UnmanagedType.LPTStr)]
				internal string Proxy;

				[MarshalAs(UnmanagedType.LPTStr)]
				internal string ProxyBypass;
			}
		}
	}
}
#T=word excel powerpoint Office to Html/PDF/XPS
namespace ConsoleApplication
{
	using System;
		using Wolfy.OfficePreview;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Office2HtmlHelper.Word2Html("/Doc/分析某网站的SEO策略(外链篇).doc", "/Html/", "分析某网站的SEO策略(外链篇)");
			Office2HtmlHelper.Excel2Html("/Excel/1994-2013北京市历年最低工资标准.xlsx", "/Html/", "1994-2013北京市历年最低工资标准");
			Office2HtmlHelper.PPT2Html("/PPT/23种设计模式详解.ppt", "/Html/", "23种设计模式详解");
			Office2PDFHelper.DOCConvertToPDF(@"\Doc\分析某网站的SEO策略(外链篇).doc", @"\PDF\分析某网站的SEO策略(外链篇).pdf");
			Office2PDFHelper.XLSConvertToPDF(@"\Excel\1994-2013北京市历年最低工资标准.xlsx", @"\PDF\1994-2013北京市历年最低工资标准.pdf");
			Office2PDFHelper.PPTConvertToPDF(@"\PPT\23种设计模式详解.ppt", @"\PDF\23种设计模式详解.pdf");
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Wolfy.OfficePreview
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using Word = Microsoft.Office.Interop.Word;
	using Excel = Microsoft.Office.Interop.Excel;
	using PowerPoint = Microsoft.Office.Interop.PowerPoint;
	using Microsoft.Office.Core;
	/// <summary>
	/// Office2Pdf 将Office文档转化为pdf
	/// </summary>
	public class Office2PDFHelper
	{
		public Office2PDFHelper()
		{
			//
			// TODO: 在此处添加构造函数逻辑
			//
		}
		/// <summary>
		/// Word转换成pdf
		/// </summary>
		/// <param name="sourcePath">源文件路径</param>
		/// <param name="targetPath">目标文件路径</param>
		/// <returns>true=转换成功</returns>
		public static bool DOCConvertToPDF(string sourcePath, string targetPath)
		{
			bool result = false;
			Word.WdExportFormat exportFormat = Word.WdExportFormat.wdExportFormatPDF;
			object paramMissing = Type.Missing;
			Word.ApplicationClass wordApplication = new Word.ApplicationClass();
			Word.Document wordDocument = null;
			try
			{
				object paramSourceDocPath = sourcePath;
				string paramExportFilePath = targetPath;
				Word.WdExportFormat paramExportFormat = exportFormat;
				bool paramOpenAfterExport = false;
				Word.WdExportOptimizeFor paramExportOptimizeFor = Word.WdExportOptimizeFor.wdExportOptimizeForPrint;
				Word.WdExportRange paramExportRange = Word.WdExportRange.wdExportAllDocument;
				int paramStartPage = 0;
				int paramEndPage = 0;
				Word.WdExportItem paramExportItem = Word.WdExportItem.wdExportDocumentContent;
				bool paramIncludeDocProps = true;
				bool paramKeepIRM = true;
				Word.WdExportCreateBookmarks paramCreateBookmarks = Word.WdExportCreateBookmarks.wdExportCreateWordBookmarks;
				bool paramDocStructureTags = true;
				bool paramBitmapMissingFonts = true;
				bool paramUseISO19005_1 = false;
				wordDocument = wordApplication.Documents.Open(
					ref paramSourceDocPath, ref paramMissing, ref paramMissing,
					ref paramMissing, ref paramMissing, ref paramMissing,
					ref paramMissing, ref paramMissing, ref paramMissing,
					ref paramMissing, ref paramMissing, ref paramMissing,
					ref paramMissing, ref paramMissing, ref paramMissing,
					ref paramMissing);
				if (wordDocument != null)
					wordDocument.ExportAsFixedFormat(paramExportFilePath,
						paramExportFormat, paramOpenAfterExport,
						paramExportOptimizeFor, paramExportRange, paramStartPage,
						paramEndPage, paramExportItem, paramIncludeDocProps,
						paramKeepIRM, paramCreateBookmarks, paramDocStructureTags,
						paramBitmapMissingFonts, paramUseISO19005_1,
						ref paramMissing);
				result = true;
			}
			catch
			{
				result = false;
			}
			finally
			{
				if (wordDocument != null)
				{
					wordDocument.Close(ref paramMissing, ref paramMissing, ref paramMissing);
					wordDocument = null;
				}
				if (wordApplication != null)
				{
					wordApplication.Quit(ref paramMissing, ref paramMissing, ref paramMissing);
					wordApplication = null;
				}
				GC.Collect();
				GC.WaitForPendingFinalizers();
				GC.Collect();
				GC.WaitForPendingFinalizers();
			}
			return result;
		}
		/// <summary>
		/// 把Excel文件转换成PDF格式文件  
		/// </summary>
		/// <param name="sourcePath">源文件路径</param>
		/// <param name="targetPath">目标文件路径</param>
		/// <returns>true=转换成功</returns>
		public static bool XLSConvertToPDF(string sourcePath, string targetPath)
		{
			bool result = false;
			Excel.XlFixedFormatType targetType = Excel.XlFixedFormatType.xlTypePDF;
			object missing = Type.Missing;
			Excel.ApplicationClass application = null;
			Excel.Workbook workBook = null;
			try
			{
				application = new Excel.ApplicationClass();
				object target = targetPath;
				object type = targetType;
				workBook = application.Workbooks.Open(sourcePath, missing, missing, missing, missing, missing,
					missing, missing, missing, missing, missing, missing, missing, missing, missing);
				workBook.ExportAsFixedFormat(targetType, target, Excel.XlFixedFormatQuality.xlQualityStandard, true, false, missing, missing, missing, missing);
				result = true;
			}
			catch
			{
				result = false;
			}
			finally
			{
				if (workBook != null)
				{
					workBook.Close(true, missing, missing);
					workBook = null;
				}
				if (application != null)
				{
					application.Quit();
					application = null;
				}
				GC.Collect();
				GC.WaitForPendingFinalizers();
				GC.Collect();
				GC.WaitForPendingFinalizers();
			}
			return result;
		}
		///<summary>		
		/// 把PowerPoint文件转换成PDF格式文件	   
		///</summary>		
		///<param name="sourcePath">源文件路径</param>	 
		///<param name="targetPath">目标文件路径</param> 
		///<returns>true=转换成功</returns> 
		public static bool PPTConvertToPDF(string sourcePath, string targetPath)
		{
			bool result;
			PowerPoint.PpSaveAsFileType targetFileType = PowerPoint.PpSaveAsFileType.ppSaveAsPDF;
			object missing = Type.Missing;
			PowerPoint.ApplicationClass application = null;
			PowerPoint.Presentation persentation = null;
			try
			{
				application = new PowerPoint.ApplicationClass();
				persentation = application.Presentations.Open(sourcePath, MsoTriState.msoTrue, MsoTriState.msoFalse, MsoTriState.msoFalse); persentation.SaveAs(targetPath, targetFileType, Microsoft.Office.Core.MsoTriState.msoTrue);
				result = true;
			}
			catch
			{
				result = false;
			}
			finally
			{
				if (persentation != null)
				{
					persentation.Close();
					persentation = null;
				}
				if (application != null)
				{
					application.Quit();
					application = null;
				}
				GC.Collect();
				GC.WaitForPendingFinalizers();
				GC.Collect();
				GC.WaitForPendingFinalizers();
			}
			return result;
		}
	}
}
namespace Wolfy.OfficePreview
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Web;
	using Microsoft.Office.Core;
	using Word = Microsoft.Office.Interop.Word;
	public class Office2HtmlHelper
	{
		/// <summary>
		/// Word转成Html
		/// </summary>
		/// <param name="path">要转换的文档的路径</param>
		/// <param name="savePath">转换成html的保存路径</param>
		/// <param name="wordFileName">转换成html的文件名字</param>
		public static void Word2Html(string path, string savePath, string wordFileName)
		{
			Word.ApplicationClass word = new Word.ApplicationClass();
			Type wordType = word.GetType();
			Word.Documents docs = word.Documents;
			Type docsType = docs.GetType();
			Word.Document doc = (Word.Document)docsType.InvokeMember("Open", System.Reflection.BindingFlags.InvokeMethod, null, docs, new Object[] { (object)path, true, true });
			Type docType = doc.GetType();
			string strSaveFileName = savePath + wordFileName + ".html";
			object saveFileName = (object)strSaveFileName;
			docType.InvokeMember("SaveAs", System.Reflection.BindingFlags.InvokeMethod, null, doc, new object[] { saveFileName, Word.WdSaveFormat.wdFormatFilteredHTML });
			docType.InvokeMember("Close", System.Reflection.BindingFlags.InvokeMethod, null, doc, null);
			wordType.InvokeMember("Quit", System.Reflection.BindingFlags.InvokeMethod, null, word, null);
		}
		/// <summary>
		/// Excel转成Html
		/// </summary>
		/// <param name="path">要转换的文档的路径</param>
		/// <param name="savePath">转换成html的保存路径</param>
		/// <param name="wordFileName">转换成html的文件名字</param>
		public static void Excel2Html(string path, string savePath, string wordFileName)
		{
			string str = string.Empty;
			Microsoft.Office.Interop.Excel.Application repExcel = new Microsoft.Office.Interop.Excel.Application();
			Microsoft.Office.Interop.Excel.Workbook workbook = null;
			Microsoft.Office.Interop.Excel.Worksheet worksheet = null;
			workbook = repExcel.Application.Workbooks.Open(path, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing);
			worksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets[1];
			object htmlFile = savePath + wordFileName + ".html";
			object ofmt = Microsoft.Office.Interop.Excel.XlFileFormat.xlHtml;
			workbook.SaveAs(htmlFile, ofmt, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Microsoft.Office.Interop.Excel.XlSaveAsAccessMode.xlNoChange, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing);
			object osave = false;
			workbook.Close(osave, Type.Missing, Type.Missing);
			repExcel.Quit();
		}
		/// <summary>
		/// ppt转成Html
		/// </summary>
		/// <param name="path">要转换的文档的路径</param>
		/// <param name="savePath">转换成html的保存路径</param>
		/// <param name="wordFileName">转换成html的文件名字</param>
		public static void PPT2Html(string path, string savePath, string wordFileName)
		{
			Microsoft.Office.Interop.PowerPoint.Application ppApp = new Microsoft.Office.Interop.PowerPoint.Application();
			string strSourceFile = path;
			string strDestinationFile = savePath + wordFileName + ".html";
			Microsoft.Office.Interop.PowerPoint.Presentation prsPres = ppApp.Presentations.Open(strSourceFile, Microsoft.Office.Core.MsoTriState.msoTrue, Microsoft.Office.Core.MsoTriState.msoFalse, Microsoft.Office.Core.MsoTriState.msoFalse);
			prsPres.SaveAs(strDestinationFile, Microsoft.Office.Interop.PowerPoint.PpSaveAsFileType.ppSaveAsHTML, MsoTriState.msoTrue);
			prsPres.Close();
			ppApp.Quit();
		}
	}
}

#T=Word.docx 水印文本
/*
	Microshaoft 本文代码改自
	http://powertools.codeplex.com/
	http://powertools.codeplex.com/releases/view/74771#DownloadId=291022
	文本水印、透明度、旋转
	使用本文代码替代 Classes\WatermarkAccessor.cs 文件中的代码
	Classes 目录下供 34个文件清单如下:
	Classes\BackgroundAccessor.cs
	Classes\ChartsheetAccessor.cs
	Classes\CommentAccessor.cs
	Classes\CommentMerger.cs
	Classes\ContentFormatAccessor.cs
	Classes\ContentStyleAccessor.cs
	Classes\CustomXmlAccessor.cs
	Classes\DigitalSignatureAccessor.cs
	Classes\DocumentBuilder.cs
	Classes\DocumentComparer.cs
	Classes\FooterAccessor.cs
	Classes\HeaderAccessor.cs
	Classes\HtmlConverter.cs
	Classes\IndexAccessor.cs
	Classes\ListItemRetriever.cs
	Classes\MarkupSimplifier.cs
	Classes\PictureAccessor.cs
	Classes\PowerToolsExtensions.cs
	Classes\PtOpenXmlDocument.cs
	Classes\PtOpenXmlUtil.cs
	Classes\PtUtil.cs
	Classes\ReferenceAdder.cs
	Classes\RevisionAccepter.cs
	Classes\SettingAccessor.cs
	Classes\SpreadsheetDocumentManager.cs
	Classes\SpreadSheetStyleAccessor.cs
	Classes\SpreadSheetTableAccessor.cs
	Classes\StyleAccessor.cs
	Classes\TextReplacer.cs
	Classes\ThemeAccessor.cs
	Classes\WatermarkAccessor.cs
	Classes\WordprocessingDocumentManager.cs
	Classes\WorksheetAccessor.cs

	%windir%\Microsoft.NET\Framework\v4.0.30319\csc.exe /out:OpenXmlWordAddWaterMark.exe *.cs /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\v3.0\WindowsBase.dll","C:\Program Files (x86)\Open XML SDK\V2.0\lib\DocumentFormat.OpenXml.dll"
*/
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Linq;
	using System.Text;
	using OpenXmlPowerTools;
	class Class1
	{
		static void Main(string[] args)
		{
			// "position:absolute;margin-left:0;margin-top:0;width:527.85pt;height:131.95pt;rotation:315;z-index:-251656192;mso-position-horizontal:center;mso-position-horizontal-relative:margin;mso-position-vertical:center;mso-position-vertical-relative:margin";
			WmlDocument wmlDoc = new WmlDocument(@"d:\a.docx");
			OpenXmlPowerToolsDocument doc = WatermarkAccessor.InsertWatermark
										(
											wmlDoc
											, "测试123abcABC@Microshaoft"
											, 527
											, 200
											, 110
											, "楷体"
											, 10
											, "red"
											, 10
										);
			doc.SaveAs(@"d:\a1.docx");
		}
	}
}
namespace OpenXmlPowerTools
{
	/***************************************************************************
	Copyright (c) Microsoft Corporation 2011.
	This code is licensed using the Microsoft Public License (Ms-PL).  The text of the license can be found here:
	http://www.microsoft.com/resources/sharedsource/licensingbasics/publiclicense.mspx
	***************************************************************************/
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.Linq;
	using System.Xml.Linq;
	using DocumentFormat.OpenXml.Packaging;
	using System.Drawing;
	/// <summary>
	/// Provides access to watermark operations
	/// </summary>
	public class WatermarkAccessor
	{
		private static XNamespace ns;
		private static XNamespace officens;
		private static XNamespace vmlns;
		private static XNamespace relationshipsns;
		private static string diagonalWatermarkStyle = "position:absolute;margin-left:0;margin-top:0;width:527.85pt;height:131.95pt;rotation:315;z-index:-251656192;mso-position-horizontal:center;mso-position-horizontal-relative:margin;mso-position-vertical:center;mso-position-vertical-relative:margin";
		private static string fontFamilySizeStyle = "font-family:&quot;Calibri&quot;;font-size:1pt";
		private static string fillColor = "black";
		private static int opacity = 50;
		//private static string defaultWatermarkStyle = "position:absolute;margin-left:0;margin-top:0;width:468pt;height:117pt;z-index:-251652096;mso-position-horizontal:center;mso-position-horizontal-relative:margin;mso-position-vertical:center;mso-position-vertical-relative:margin";
		static WatermarkAccessor()
		{
			ns = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
			officens = "urn:schemas-microsoft-com:office:office";
			vmlns = "urn:schemas-microsoft-com:vml";
			relationshipsns = "http://schemas.openxmlformats.org/officeDocument/2006/relationships";
		}
		/// <summary>
		/// Inserts a watermark text inside a document
		/// </summary>
		/// <param name="watermarkText">text to show in the watermark</param>
		/// <param name="diagonalOrientation">specify that the text orientation will be in a diagonal way</param>
		public static OpenXmlPowerToolsDocument InsertWatermark
													(
														WmlDocument doc
														, string watermarkText
														, int width
														, int height
														, int rotation
														, string fontFamilyName
														, int fontSize
														, string fillColor
														, int opacityPercent
														//, bool diagonalOrientation
													)
		{
			// "position:absolute;margin-left:0;margin-top:0;width:527.85pt;height:131.95pt;rotation:315;z-index:-251656192;mso-position-horizontal:center;mso-position-horizontal-relative:margin;mso-position-vertical:center;mso-position-vertical-relative:margin";
			diagonalWatermarkStyle = string.Format
												(
													@"
														position:absolute;
														margin-left:0;
														margin-top:0;
														width:{0}pt;
														height:{1}pt;
														rotation:{2};
														z-index:-251656192;
														mso-position-horizontal:center;
														mso-position-horizontal-relative:margin;
														mso-position-vertical:center;
														mso-position-vertical-relative:margin
													"
													, width
													, height
													, rotation
												);
			fontFamilySizeStyle = string.Format
											(
												@"
													font-family:&quot;{0}&quot;
													;
													font-size:{1}pt
												"
												, fontFamilyName
												, fontSize
												
											);
			opacity = opacityPercent;
			//diagonalWatermarkStyle="position:absolute;margin-left:0;margin-top:0;width:527.85pt;height:131.95pt;rotation:315;z-index:-251656192;mso-position-horizontal:center;mso-position-horizontal-relative:margin;mso-position-vertical:center;mso-position-vertical-relative:margin";
			//defaultWatermarkStyle =  "position:absolute;margin-left:0;margin-top:0;width:468pt;		height:117pt;					z-index:-251652096;mso-position-horizontal:center;mso-position-horizontal-relative:margin;mso-position-vertical:center;mso-position-vertical-relative:margin";
			using (OpenXmlMemoryStreamDocument streamDoc = new OpenXmlMemoryStreamDocument(doc))
			{
				using (WordprocessingDocument document = streamDoc.GetWordprocessingDocument())
				{
					Collection<XDocument> headers = new Collection<XDocument>();
					if (HeaderAccessor.GetHeaderReference(document, HeaderType.First, 0) == null)
						headers.Add(HeaderAccessor.AddNewHeader(document, HeaderType.First));
					else
						headers.Add(HeaderAccessor.GetHeader(document, HeaderType.First, 0));
					if (HeaderAccessor.GetHeaderReference(document, HeaderType.Even, 0) == null)
						headers.Add(HeaderAccessor.AddNewHeader(document, HeaderType.Even));
					else
						headers.Add(HeaderAccessor.GetHeader(document, HeaderType.Even, 0));
					if (HeaderAccessor.GetHeaderReference(document, HeaderType.Default, 0) == null)
						headers.Add(HeaderAccessor.AddNewHeader(document, HeaderType.Default));
					else
						headers.Add(HeaderAccessor.GetHeader(document, HeaderType.Default, 0));
					foreach (XDocument header in headers)
					{
						var runElement = header.Descendants(ns + "r").FirstOrDefault();
						if (runElement == null)
						{
							header.Root.Add(
								new XElement(ns + "sdt",
									new XElement(ns + "sdtContent",
										new XElement(ns + "p",
											new XElement(ns + "pPr",
												new XElement(ns + "pStyle",
													new XAttribute(ns + "val", "Header")
												)
											),
											runElement = new XElement(ns + "r")
										)
									)
								)
							);
						}
						runElement.AddBeforeSelf(CreateWatermarkVml(watermarkText));
					}
					HeaderAccessor.GetHeaderPart(document, HeaderType.First, 0).PutXDocument();
					HeaderAccessor.GetHeaderPart(document, HeaderType.Even, 0).PutXDocument();
					HeaderAccessor.GetHeaderPart(document, HeaderType.Default, 0).PutXDocument();
				}
				return streamDoc.GetModifiedDocument();
			}
		}
		/// <summary>
		/// Creates the markup for watermark displaying
		/// </summary>
		/// <param name="watermarkText">Text to include in markup</param>
		/// <param name="diagonalOrientation">Orientation of text</param>
		/// <returns>Watermark markup</returns>
		private static XElement CreateWatermarkVml(string watermarkText)
		{
				return new XElement(ns + "r",
					new XElement(ns + "pict",
						new XElement(vmlns + "shapetype",
							new XAttribute("id", "_x0000_t136"),
							new XAttribute("coordsize", "21600,21600"),
							new XAttribute(officens + "spt", "136"),
							new XAttribute("adj", "10800"),
							new XAttribute("path", "m@7,l@8,m@5,21600l@6,21600e"),
							new XElement(vmlns + "formulas",
								new XElement(vmlns + "f",
									new XAttribute("eqn", "sum #0 0 10800")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "prod #0 2 1")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "sum 21600 0 @1")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "sum 0 0 @2")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "sum 21600 0 @3")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "if @0 @3 0")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "if @0 21600 @1")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "if @0 0 @2")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "if @0 @4 21600")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "mid @5 @6")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "mid @8 @5")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "mid @7 @8")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "mid @6 @7")
								),
								new XElement(vmlns + "f",
									new XAttribute("eqn", "sum @6 0 @5")
								)
							),
							new XElement(vmlns + "path",
								new XAttribute("textpathok", "t"),
								new XAttribute(officens + "connecttype", "custom"),
								new XAttribute(officens + "connectlocs", "@9,0;@10,10800;@11,21600;@12,10800"),
								new XAttribute(officens + "connectangles", "270,180,90,0")
							),
							new XElement(vmlns + "textpath",
								new XAttribute("on", "t"),
								new XAttribute("fitshape", "t")
							),
							new XElement(vmlns + "handles",
								new XElement(vmlns + "h",
									new XAttribute("position", "#0,bottomRight"),
									new XAttribute("xrange", "6629,14971")
								)
							),
							new XElement(officens + "lock",
								new XAttribute(vmlns + "ext", "edit"),
								new XAttribute("text", "t"),
								new XAttribute("shapetype", "t")
							)
						),
						new XElement(vmlns + "shape",
							new XAttribute("id", "PowerPlusWaterMarkObject98078923"),
							new XAttribute(officens + "spid", "_x0000_s2055"),
							new XAttribute("type", "#_x0000_t136"),
							//new XAttribute("style", diagonalOrientation ? diagonalWatermarkStyle : defaultWatermarkStyle),
							new XAttribute("style", diagonalWatermarkStyle),
							new XAttribute(officens + "allowincell", "f"),
							new XAttribute("fillcolor", fillColor),
							new XAttribute("stroked", "f"),
							new XElement(vmlns + "fill",
								new XAttribute("opacity", opacity/100.0)
							),
							new XElement(vmlns + "textpath",
								new XAttribute("style", fontFamilySizeStyle),
								new XAttribute("string", watermarkText)
							)
						)
					)
				);
		}
		/// <summary>
		/// Gets the text related to watermark from a document
		/// </summary>
		/// <returns>Watermark text</returns>
		public static string GetWatermarkText(WmlDocument doc)
		{
			IEnumerable<XElement> watermarkDescription = GetWatermark(doc);
			if (watermarkDescription != null)
				return
					watermarkDescription
					.Descendants(vmlns + "shape")
					.Descendants(vmlns + "textpath")
					.First()
					.Attribute("string")
					.Value;
			else
				return string.Empty;
		}
		/// <summary>
		/// Gets the document structure related to watermark description
		/// </summary>
		/// <returns>Document structure related to watermark description</returns>
		public static IEnumerable<XElement> GetWatermark(WmlDocument doc)
		{
			using (OpenXmlMemoryStreamDocument streamDoc = new OpenXmlMemoryStreamDocument(doc))
			using (WordprocessingDocument document = streamDoc.GetWordprocessingDocument())
			{
				//  to get the watermark text, we have to look inside the document
				//  get the default header reference and get the header reference id part
				XElement defaultHeaderReference = HeaderAccessor.GetHeaderReference(document, HeaderType.Default, 0);
				if (defaultHeaderReference != null)
				{
					string headerReferenceId = defaultHeaderReference.Attribute(relationshipsns + "id").Value;
					OpenXmlPart headerPart = document.MainDocumentPart.GetPartById(headerReferenceId);
					if (headerPart != null)
					{
						XDocument headerPartXml = headerPart.GetXDocument();
						return headerPartXml.Descendants(ns + "pict");
					}
				}
				return null;
			}
		}
	}
}

#T=Workflow Sequence simple sample
namespace WorkflowConsoleApplication
{
	using System;
	using System.Activities;
	using System.Activities.Statements;
	class Program
	{
		static void Main(string[] args)
		{
			Activity wf = new Sequence()
			{
				Activities =
					{
						new WriteLine
							{
								Text = "Starting the workflow."
							},
						new Delay
							{
								Duration = TimeSpan.FromSeconds(5)
							},
						new WriteLine
							{
								Text = "Ending the workflow."
							}
					}
			};
			WorkflowApplication wfApp =
				new WorkflowApplication(wf)
				{
					Completed = //new Action<WorkflowApplicationCompletedEventArgs>
						(
							(e) =>
							{
								if (e.CompletionState == ActivityInstanceState.Faulted)
								{
									Console.WriteLine("Workflow {0} Terminated.", e.InstanceId);
									Console.WriteLine
										(
											"Exception: {0}\n{1}",
											e.TerminationException.GetType().FullName,
											e.TerminationException.Message
										);
								}
								else if (e.CompletionState == ActivityInstanceState.Canceled)
								{
									Console.WriteLine("Workflow {0} Canceled.", e.InstanceId);
								}
								else
								{
									Console.WriteLine("Workflow {0} Completed.", e.InstanceId);
									// Outputs can be retrieved from the Outputs dictionary,
									// keyed by argument name.
									// Console.WriteLine("The winner is {0}.", e.Outputs["Winner"]);
								}
							}
						)
					,
					Aborted = //new Action<WorkflowApplicationAbortedEventArgs>
						(
							(e) =>
							{
								// Display the exception that caused the workflow
								// to abort.
								Console.WriteLine("Workflow {0} Aborted.", e.InstanceId);
								Console.WriteLine("Exception: {0}\n{1}",
									e.Reason.GetType().FullName,
									e.Reason.Message);
							}
						)
					,
					OnUnhandledException = delegate(WorkflowApplicationUnhandledExceptionEventArgs e)
					{
						Console.WriteLine(e.UnhandledException.ToString());
						return UnhandledExceptionAction.Terminate;
					}
					,
					Idle = delegate(WorkflowApplicationIdleEventArgs e)
					{
						// Perform any processing that should occur
						// when a workflow goes idle. If the workflow can persist,
						// both Idle and PersistableIdle are called in that order.
						Console.WriteLine("Workflow {0} Idle.", e.InstanceId);
					}
					,
					PersistableIdle = delegate(WorkflowApplicationIdleEventArgs e)
						{
							// Instruct the runtime to persist and unload the workflow
							return PersistableIdleAction.Unload;
						}
					,
					Unloaded = delegate(WorkflowApplicationEventArgs e)
						{
							Console.WriteLine("Workflow {0} Unloaded.", e.InstanceId);
						}
				 
				};
			wfApp.Run();
			Console.ReadLine();
			
		}
	}
}

#T=WorkFlowHelper
/*
^# Microshaoft
/r:System.Xaml.dll
/r:System.Activities.dll
/r:System.Activities.DurableInstancing.dll
/r:System.Runtime.DurableInstancing.dll
/r:"D:\Microshaoft.Nuget.Packages\Newtonsoft.Json.7.0.1\lib\net45\Newtonsoft.Json.dll"
*/
namespace Microshaoft
{
	using Newtonsoft.Json.Linq;
	using System;
	using System.Activities;
	using System.Activities.Tracking;
	using System.Activities.XamlIntegration;
	using System.Collections.Generic;
	using System.IO;
	using System.Linq;
	using System.Reflection;
	using System.Xaml;
	using System.Xml;
	using System.Runtime.DurableInstancing;
	public static class WorkFlowHelper
	{
		public static WorkflowApplication CreateWorkflowApplication
											(
												string xaml
												, string localAssemblyFilePath = null
												, Func<InstanceStore> onPersistProcessFunc = null
											)
		{
			var activity = XamlToActivity
								(
									xaml
									, localAssemblyFilePath
								);
			WorkflowApplication workflowApplication = new WorkflowApplication(activity);
			if (onPersistProcessFunc != null)
			{
				workflowApplication.InstanceStore = onPersistProcessFunc();
			}
			return workflowApplication;
		}
		public static Activity XamlToActivity
									(
										string xaml
										, string localAssemblyFilePath = null
									)
		{
			Assembly localAssembly = null;
			if (string.IsNullOrEmpty(localAssemblyFilePath))
			{
				localAssembly = Assembly
									.GetExecutingAssembly();
			}
			else
			{
				localAssembly = Assembly
									.LoadFrom(localAssemblyFilePath);
			}
			var stringReader = new StringReader(xaml);
			var xmlReader = XmlReader.Create(stringReader);
			var xamlXmlReader = new XamlXmlReader
												(
													xmlReader
													, new XamlXmlReaderSettings()
														{
															LocalAssembly = localAssembly
														}
												);
			var xamlReader = ActivityXamlServices
										.CreateReader
											(
												xamlXmlReader
											);
			var activity = ActivityXamlServices
								.Load
									(
										xamlReader
										, new ActivityXamlServicesSettings()
										{
											CompileExpressions = true
										}
									);
			return activity;
		}
		public static TrackingProfile GetTrackingProfileFromJson
			(
				string json
				, bool isArray = false
			)
		{
			TrackingProfile trackingProfile = null;
			var trackingQueries = GetTrackingQueriesFromJson(json, isArray);
			if (trackingQueries != null)
			{
				foreach (var trackingQuery in trackingQueries)
				{
					if (trackingProfile == null)
					{
						trackingProfile = new TrackingProfile();
					}
					trackingProfile
							.Queries
							.Add(trackingQuery);
				}
			}
			return trackingProfile;
		}
		public static TrackingParticipant GetTrackingParticipantFromJson<TTrackingParticipant>
													(
														string json
														, bool isArray = false
													)
			where TTrackingParticipant : TrackingParticipant, new()
		{
			TrackingParticipant trackingParticipant = null;
			TrackingProfile trackingProfile
					= GetTrackingProfileFromJson(json, isArray);
			if (trackingProfile != null)
			{
				trackingParticipant = new TTrackingParticipant();
				trackingParticipant.TrackingProfile = trackingProfile;
			}
			return trackingParticipant;
		}
		public static IEnumerable<TrackingQuery> GetTrackingQueriesFromJson
														(
															string json
															, bool isArray = false
														)
		{
			IEnumerable<TrackingQuery> r = null;
			if (isArray)
			{
				//闭包
				var key = string.Empty;
				r = JsonHelper
						.DeserializeToFromDictionary<string, JObject[], JObject[]>
								(
									json
									, (x, y) =>
									{
										//闭包
										key = x;
										return y;
									}
								)
								.SelectMany
									(
										(x) =>
										{
											return x;
										}
									)
								.Select
									(
										(x) =>
										{
											//闭包
											return
												GetTrackingQuery(key, x);
										}
									);
			}
			else
			{
				r = JsonHelper
						.DeserializeToFromDictionary<string, JObject, TrackingQuery>
							(
								json
								, (x, y) =>
								{
									return GetTrackingQuery(x, y);
								}
							);
			}
			return r;
		}
		public static TrackingQuery GetTrackingQuery(string queryName, JObject jObject)
		{
			var json = jObject.ToString();
			return
				GetTrackingQuery
						(
							queryName
							, json
						);
		}
		public static TrackingQuery GetTrackingQuery(string queryName, string json)
		{
			TrackingQuery r = null;
			if (string.Compare(queryName, "WorkflowInstanceQuery", true) == 0)
			{
				r = JsonHelper
							.DeserializeByJTokenPath<WorkflowInstanceQuery>
								(
									json
								);
			}
			else if (string.Compare(queryName, "ActivityStateQuery", true) == 0)
			{
				r = JsonHelper
							.DeserializeByJTokenPath<ActivityStateQuery>
								(
									json
								);
			}
			else if (string.Compare(queryName, "CustomTrackingQuery", true) == 0)
			{
				r = JsonHelper
							.DeserializeByJTokenPath<CustomTrackingQuery>
								(
									json
								);
			}
			else if (string.Compare(queryName, "FaultPropagationQuery", true) == 0)
			{
				r = JsonHelper
							.DeserializeByJTokenPath<FaultPropagationQuery>
								(
									json
								);
			}
			else if (string.Compare(queryName, "BookmarkResumptionQuery", true) == 0)
			{
				r = JsonHelper
							.DeserializeByJTokenPath<BookmarkResumptionQuery>
								(
									json
								);
			}
			else if (string.Compare(queryName, "ActivityScheduledQuery", true) == 0)
			{
				r = JsonHelper
							.DeserializeByJTokenPath<ActivityScheduledQuery>
								(
									json
								);
			}
			else if (string.Compare(queryName, "CancelRequestedQuery", true) == 0)
			{
				r = JsonHelper
							.DeserializeByJTokenPath<CancelRequestedQuery>
								(
									json
								);
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using Newtonsoft.Json;
	using Newtonsoft.Json.Linq;
	using System;
	using System.IO;
	using System.Linq;
	using System.Xml.Linq;
	using System.Collections.Generic;
	public static class JsonHelper
	{
		public static string XmlToJson
								(
									string xml
									, Newtonsoft
											.Json
											.Formatting formatting
															= Newtonsoft
																	.Json
																	.Formatting
																	.Indented
									, bool needKeyQuote = false
								)
		{
			XNode xElement;
			xElement = XElement.Parse(xml).Elements().First();
			string json = string.Empty;
			using (var stringWriter = new StringWriter())
			{
				using (var jsonTextWriter = new JsonTextWriter(stringWriter))
				{
					jsonTextWriter.Formatting = formatting;
					jsonTextWriter.QuoteName = needKeyQuote;
					var jsonSerializer = new JsonSerializer();
					jsonSerializer.Serialize(jsonTextWriter, xElement);
					json = stringWriter.ToString();
				}
			}
			return json;
		}
		public static string JsonToXml
						(
							string json
							, bool needRoot = false
							, string defaultDeserializeRootElementName = "root"
						)
		{
			if (needRoot)
			{
				json = string.Format
								(
									@"{{ {1}{0}{2} }}"
									, " : "
									, defaultDeserializeRootElementName
									, json
								);
			}
			//XmlDocument xmlDocument = JsonConvert.DeserializeXmlNode(json, defaultDeserializeRootElementName);
			var xDocument = JsonConvert
									.DeserializeXNode
										(
											json
											, defaultDeserializeRootElementName
										);
			var xml = xDocument
							.Elements()
							.First()
							.ToString();
			return xml;
		}
		public static T DeserializeByJTokenPath<T>
			(
				string json
				, string jTokenPath = null //string.Empty
			)
		{
			var jObject = JObject.Parse(json);
			var jsonSerializer = new JsonSerializer();
			if (string.IsNullOrEmpty(jTokenPath))
			{
				jTokenPath = string.Empty;
			}
			var jToken = jObject.SelectToken(jTokenPath);
			using (var jsonReader = jToken.CreateReader())
			{
				return
					jsonSerializer
						.Deserialize<T>(jsonReader);
			}
		}
		public static string Serialize
								(
									object target
									, bool formattingIndented = false
									, bool keyQuoteName = false
								)
		{
			string json = string.Empty;
			using (StringWriter stringWriter = new StringWriter())
			{
				using (var jsonTextWriter = new JsonTextWriter(stringWriter))
				{
					jsonTextWriter.QuoteName = keyQuoteName;
					jsonTextWriter.Formatting = (formattingIndented ? Formatting.Indented : Formatting.None);
					var jsonSerializer = new JsonSerializer();
					jsonSerializer.Serialize(jsonTextWriter, target);
					json = stringWriter.ToString();
				}
			}
			return json;
		}
		public static void ReadJsonPathsValuesAsStrings
							(
								string json
								, string[] jsonPaths
								, Func<string, string, bool> onReadedOncePathStringValueProcesssFunc = null
							)
		{
			using (var stringReader = new StringReader(json))
			{
				using (var jsonReader = new JsonTextReader(stringReader))
				{
					bool breakAndReturn = false;
					while
						(
							jsonReader.Read()
							&&
							!breakAndReturn
						)
					{
						foreach (var x in jsonPaths)
						{
							if (x == jsonReader.Path)
							{
								if (onReadedOncePathStringValueProcesssFunc != null)
								{
									var s = jsonReader.ReadAsString();
									breakAndReturn
											= onReadedOncePathStringValueProcesssFunc
													(
														x
														, s
													);
									if (breakAndReturn)
									{
										break;
									}
								}
							}
						}
					}
				}
			}
		}
		public static IEnumerable<TElement> 
							DeserializeToFromDictionary<TKey, TValue, TElement>
										(
											string json
											, Func<TKey, TValue, TElement> OnOneElementProcessFunc
										)
		{
			//IEnumerable<TElement> r = default(IEnumerable<TElement>);
			return
					DeserializeByJTokenPath<Dictionary<TKey, TValue>>(json)
						.Select
							(
								(x) =>
								{
									var rr = OnOneElementProcessFunc(x.Key, x.Value);
									return rr;
								}
							);
			//return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Activities.Tracking;
	public class CommonTrackingParticipant : TrackingParticipant
	{
		public Func<TrackingRecord, TimeSpan, bool> OnTrackingRecordReceived;
		protected override void Track(TrackingRecord record, TimeSpan timeout)
		{
			var r = false;
			if (OnTrackingRecordReceived != null)
			{
				r = OnTrackingRecordReceived(record, timeout);
			}
		}
	}
}

#T=Wpf MVVM XAML
namespace Microshaoft
{
	using System;
	using System.Windows.Input;
	class CommandExecutor<TParameter> : ICommand
							where TParameter : class
	{
		public Action<TParameter> ExecuteCommand = null;
		public Func<TParameter, bool> CanExecuteCommand = null;
		public event EventHandler CanExecuteChanged;
		public bool CanExecute(object parameter)
		{
			if (CanExecuteCommand != null)
			{
				return CanExecuteCommand(parameter as TParameter);
			}
			else
			{
				return true;
			}
		}
		public void Execute(object parameter)
		{
			if (ExecuteCommand != null)
			{
				ExecuteCommand(parameter as TParameter);
			}
		}
		public void RaiseCanExecuteChanged()
		{
			if (CanExecuteChanged != null)
			{
				CanExecuteChanged(this, EventArgs.Empty);
			}
		}
	}
}
namespace Microshaoft.MVVM.Models
{
	using System.ComponentModel;
	public class Person : INotifyPropertyChanged
	{
		private string _name = string.Empty;
		private string _hello = "Hello";
		public string Hello
		{
			get
			{
				return _hello;
			}
			private set
			{
				_hello = value;
				if (PropertyChanged != null)
				{
					PropertyChanged
						(
							this
							, new PropertyChangedEventArgs("Hello")
						);
				}
			}
		}
		
		private string _bye = "Bye";
		public string Bye
		{
			get
			{
				return _bye;
			}
			private set
			{
				_bye = value;
				if (PropertyChanged != null)
				{
					PropertyChanged
						(
							this
							, new PropertyChangedEventArgs("Bye")
						);
				}
			
			}
		}
		
		public string Name
		{
			get 
			{
				return _name;
			}
			set
			{
				_name = value;
				Hello = string.Format("Hello: {0}", _name);
				if (PropertyChanged != null)
				{
					PropertyChanged
						(
							this
							, new PropertyChangedEventArgs("Name")
						);				
				}
			}
		}
		public void SayByeToSelfCommand(object obj)
		{
			this.Bye = string.Format("{1}{0}{2}", ":", "Bye", _name);
		}
		public event PropertyChangedEventHandler PropertyChanged;
	}
}
namespace Microshaoft.MVVM.ViewModels
{
	using System;
	using Microshaoft.MVVM.Models;
	class ViewModel
	{
		public CommandExecutor<Person> Command1
		{
			get;
			set;
		}
		public Person Model { get; set; }
		public ViewModel()
		{
			Model = new Person() {  Name = "yuxiyue"};
			Command1 = new CommandExecutor<Person>();
			Command1.ExecuteCommand = new Action<Person>(Model.SayByeToSelfCommand);
		}
	}
}
namespace WpfApplication1
{
	using System.Windows;
	using Microshaoft.MVVM.ViewModels;
	/// <summary>
	/// Interaction logic for MainWindow.xaml
	/// </summary>
	public partial class MainWindow : Window
	{
		public MainWindow()
		{
			InitializeComponent();
			//this.DataContext = new ViewModel();
			
		}
		private void TextBox_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
		{
		}
	}
}
^#pragma checksum "..\..\MainWindow.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "4E97F4B245E2CC5671F4BA82B06CC21E"
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Runtime Version:4.0.30319.18051
//
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace WpfApplication1 {
	using Microshaoft.MVVM.ViewModels;
	using System;
	using System.Diagnostics;
	using System.Windows;
	using System.Windows.Automation;
	using System.Windows.Controls;
	using System.Windows.Controls.Primitives;
	using System.Windows.Data;
	using System.Windows.Documents;
	using System.Windows.Ink;
	using System.Windows.Input;
	using System.Windows.Interactivity;
	using System.Windows.Markup;
	using System.Windows.Media;
	using System.Windows.Media.Animation;
	using System.Windows.Media.Effects;
	using System.Windows.Media.Imaging;
	using System.Windows.Media.Media3D;
	using System.Windows.Media.TextFormatting;
	using System.Windows.Navigation;
	using System.Windows.Shapes;
	using System.Windows.Shell;
		
	/// <summary>
	/// MainWindow
	/// </summary>
	public partial class MainWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector {
		
		
		#line 12 "..\..\MainWindow.xaml"
		[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal System.Windows.Controls.Button btn;
		
		#line default
		#line hidden
		
		private bool _contentLoaded;
		
		/// <summary>
		/// InitializeComponent
		/// </summary>
		[System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
		public void InitializeComponent() {
			if (_contentLoaded) {
				return;
			}
			_contentLoaded = true;
			//System.Uri resourceLocater = new System.Uri("/WpfApplication1;component/mainwindow.xaml", System.UriKind.Relative);
			System.Uri resourceLocater = new System.Uri(@"C:/Users/xiyueyu/Desktop/MainWindow.xaml", System.UriKind.Absolute);
			
			#line 1 "..\..\MainWindow.xaml"
			System.Windows.Application.LoadComponent(this, resourceLocater);
			
			#line default
			#line hidden
		}
		
		[System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
		[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
		[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
		[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
		[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
			switch (connectionId)
			{
			case 1:
			this.btn = ((System.Windows.Controls.Button)(target));
			return;
			}
			this._contentLoaded = true;
		}
	}
}
^#pragma checksum "..\..\App.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "58EFFED28664AEDEDCE55B5FC9A3C7E3"
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Runtime Version:4.0.30319.18051
//
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace WpfApplication1 {
	using System;
	using System.Diagnostics;
	using System.Windows;
	using System.Windows.Automation;
	using System.Windows.Controls;
	using System.Windows.Controls.Primitives;
	using System.Windows.Data;
	using System.Windows.Documents;
	using System.Windows.Ink;
	using System.Windows.Input;
	using System.Windows.Markup;
	using System.Windows.Media;
	using System.Windows.Media.Animation;
	using System.Windows.Media.Effects;
	using System.Windows.Media.Imaging;
	using System.Windows.Media.Media3D;
	using System.Windows.Media.TextFormatting;
	using System.Windows.Navigation;
	using System.Windows.Shapes;
	using System.Windows.Shell;
	
	/// <summary>
	/// App
	/// </summary>
	public partial class App : System.Windows.Application {
		
		/// <summary>
		/// InitializeComponent
		/// </summary>
		[System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
		public void InitializeComponent() {
			
			#line 4 "..\..\App.xaml"
			this.StartupUri = new System.Uri(@"C:/Users/xiyueyu/Desktop/MainWindow.xaml", System.UriKind.Absolute);
			
			#line default
			#line hidden
		}
		
		/// <summary>
		/// Application Entry Point.
		/// </summary>
		[System.STAThreadAttribute()]
		[System.Diagnostics.DebuggerNonUserCodeAttribute()]
		[System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
		public static void Main() {
			App app = new App();
			app.InitializeComponent();
			app.Run();
		}
	}
}
namespace WpfApplication1
{
	using System;
	using System.Collections.Generic;
	using System.Configuration;
	using System.Data;
	using System.Linq;
	using System.Threading.Tasks;
	using System.Windows;
	/// <summary>
	/// Interaction logic for App.xaml
	/// </summary>
	public partial class App : Application
	{
	}
}
// App.xaml
/*
<Application x:Class="WpfApplication1.App"
			 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 StartupUri="MainWindow.xaml">
	<Application.Resources>
	</Application.Resources>
</Application>
*/
// App.xaml
/*
<Application x:Class="WpfApplication1.App"
			 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 StartupUri="MainWindow.xaml">
	<Application.Resources>
	</Application.Resources>
</Application>
*/
// MainWindow.xaml
/*
<Window x:Class="WpfApplication1.MainWindow"
		xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"
		xmlns:vm="clr-namespace:Microshaoft.MVVM.ViewModels"  
		Title="MainWindow" Height="350" Width="525">
	<Window.DataContext>
		<vm:ViewModel />
	</Window.DataContext>
	<Grid>
		<Button Name="btn" Content="Button" Height="33" HorizontalAlignment="Left" Margin="38,6,0,0" VerticalAlignment="Top" Width="109" RenderTransformOrigin="0.5,0.5">
			<i:Interaction.Triggers>
				<i:EventTrigger EventName="Click">
					<i:InvokeCommandAction Command="{Binding Command1}" CommandParameter="10" />
				</i:EventTrigger>
			</i:Interaction.Triggers>
		</Button>
		<Button Command="{Binding Command1}" Content="{Binding Model.Hello}"  HorizontalAlignment="Left" Margin="84,47,0,0" VerticalAlignment="Top" Width="75" Height="34"/>
		<TextBox HorizontalAlignment="Left" Height="23" Margin="84,101,0,0" TextWrapping="Wrap" Text="{Binding Model.Name}" VerticalAlignment="Top" Width="120">
			<i:Interaction.Triggers>
				<i:EventTrigger EventName="Click">
					<i:InvokeCommandAction Command="{Binding Command1}" CommandParameter="10" />
				</i:EventTrigger>
			</i:Interaction.Triggers>
		</TextBox>
		<TextBlock HorizontalAlignment="Left" Margin="70,177,0,0" TextWrapping="Wrap" Text="{Binding Model.Bye}" VerticalAlignment="Top" Height="47" Width="134"/>
	</Grid>
</Window>
*/
#T=Wpf simple sample
// /r:"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\WPF\PresentationCore.dll";"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\WPF\PresentationFramework.dll";"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\WPF\WindowsBase.dll";"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Xaml.dll"
namespace Microshaoft
{
	using System;
	using System.Windows;
	using System.Windows.Controls;
	using System.Windows.Media;
	using System.Windows.Media.Animation;
	public partial class App:Application
	{
		
		[STAThread]					//表示单一线程单元
		public static void Main()	//主函数入口
		{
			App app=new App();		//创建一个继承自Application的App对象
			app.Run();				//运行它
		}
		Grid grid;					//表示窗口中的Grid
		Window w;					//表示一个Window窗口
		protected override void OnStartup(StartupEventArgs e)	//App启动时触发
		{
			base.OnStartup(e);
			w = new Window();							//实例化窗口
			grid = new Grid();							//实例化Grid
			w.Title = "Hello World Application";
			w.Content = grid;							//设置Window窗口的内容为一个Grid
			w.Width = 300;
			w.Height = 200;
			w.Loaded += MainWindow_Loaded;
			w.Show();									//显示窗口
		}
		void MainWindow_Loaded(object sender, RoutedEventArgs e)
		{
			TextBlock tb = new TextBlock();						//创建一个TextBlock控件
			tb.Text = "Hello World";							//设置文本
			grid.Children.Add(tb);								//将其添加到Grid中
			TranslateTransform tt = new TranslateTransform();	//创建一个平移变换对象
			tb.RenderTransform = tt;							//关联到TextBlock控件
			tb.RenderTransformOrigin = new Point(0.5,0.5);		//设置变换点
			DoubleAnimation da = new DoubleAnimation();			//创建动画
			da.To = w.ActualWidth - tb.ActualWidth;				//设置动画的To属性
			da.Duration = TimeSpan.FromSeconds(10);				//设置动画的持续时间
			da.RepeatBehavior = RepeatBehavior.Forever;			//反复执行动画
			Storyboard.SetTarget(da, tb);
			Storyboard.SetTargetProperty(da,new PropertyPath("RenderTransform.X"));
			Storyboard story = new Storyboard();
			story.Children.Add(da);
			story.Begin();										//开始动画
		}
	}
}
#T=WPF 异型窗体 Popup
namespace Test
{
	using System;
	using System.Windows;
	using System.Windows.Controls;
	using System.Windows.Data;
	using System.Windows.Documents;
	using System.Windows.Input;
	using System.Windows.Media;
	using System.Windows.Media.Imaging;
	using System.Windows.Navigation;
	using System.Windows.Shapes;


	using Microshaoft;
	
	/// <summary>
	/// App
	/// </summary>
	public class WpfApp : System.Windows.Application
	{
		/// <summary>
		/// Application Entry Point.
		/// </summary>
		[System.STAThreadAttribute()]
		[System.Diagnostics.DebuggerNonUserCodeAttribute()]
		public static void Main()
		{
			WpfApp a = new WpfApp();
			//app.InitializeComponent();
			PopupWinHelper.ShowPopUp(150, 300, new BitmapImage(new Uri(@"C:\Documents and Settings\xiyueyu\桌面\WpfPopup_src\WpfPopup\bg.png")), "于溪h", new Thickness(20));
			a.Run();
		}
	}
}


namespace Microshaoft
{
	using System.Windows;
	using System.Windows.Media;
	using System.Windows.Media.Animation;
	using System.Windows.Controls;
	using System.Windows.Forms;

	using System;
	using System.Collections.Generic;
	using System.Text;
	/// <summary>
	/// A class for creating an irregular popup window for information
	/// </summary>
	public class PopupWinHelper
	{
		/// <summary>
		///  Show a fade in & fade out pop up window at the right lower corner of the primary screen
		/// </summary>
		/// <param name="winHeight">Pop up window's height</param>
		/// <param name="winWidth">Pop up window's width</param>
		/// <param name="bgImg">The background image of the pop up window</param>
		/// <param name="msgText">Message shown on the pop up window</param>
		/// <param name="msgPadding">The message's padding value to the edge of the window, it depends on the image's border</param>
		public static void ShowPopUp(double winHeight, double winWidth, ImageSource bgImg, string msgText, Thickness msgPadding)
		{
			//Create a Window
			Window popUp = new Window();
			popUp.Name = "PopUp";
			popUp.AllowsTransparency = true;
			popUp.Background = Brushes.Transparent;
			popUp.WindowStyle = WindowStyle.None;
			popUp.ShowInTaskbar = false;
			popUp.Topmost = true;
			popUp.Height = winHeight;
			popUp.Width = winWidth;
			popUp.Left = Screen.PrimaryScreen.Bounds.Width - winWidth;
			popUp.Top = Screen.PrimaryScreen.Bounds.Height - winHeight - 30;

			//Create a inner Grid
			Grid g = new Grid();

			//Create a Image for irregular background display
			Image img = new Image();
			img.Stretch = Stretch.Fill;
			img.Source = bgImg;
			img.BitmapEffect = new System.Windows.Media.Effects.DropShadowBitmapEffect();
			g.Children.Add(img);

			//Create a TextBlock for message display
			TextBlock msg = new TextBlock();
			msg.Padding = msgPadding;
			msg.VerticalAlignment = VerticalAlignment.Center;
			msg.HorizontalAlignment = System.Windows.HorizontalAlignment.Center;
			msg.TextWrapping = TextWrapping.Wrap;
			msg.Text = msgText;
			g.Children.Add(msg);

			popUp.Content = g;

			//Register the window's name, this is necessary for creating Storyboard using codes instead of XAML
			NameScope.SetNameScope(popUp, new NameScope());
			popUp.RegisterName(popUp.Name, popUp);

			//Create the fade in & fade out animation
			DoubleAnimation winFadeAni = new DoubleAnimation();
			winFadeAni.From = 0;
			winFadeAni.To = 1;
			winFadeAni.Duration = new Duration(TimeSpan.FromSeconds(3));		//Duration for 1.5 seconds
			winFadeAni.AutoReverse = true;
			winFadeAni.Completed += delegate(object sender, EventArgs e)			//Close the window when this animation is completed
			{
				popUp.Close();
			};

			// Configure the animation to target the window's opacity property
			Storyboard.SetTargetName(winFadeAni, popUp.Name);
			Storyboard.SetTargetProperty(winFadeAni, new PropertyPath(Window.OpacityProperty));

			// Add the fade in & fade out animation to the Storyboard
			Storyboard winFadeStoryBoard = new Storyboard();			
			winFadeStoryBoard.Children.Add(winFadeAni);

			// Set event trigger, make this animation played on window.Loaded
			popUp.Loaded += delegate(object sender, RoutedEventArgs e)
			{
				winFadeStoryBoard.Begin(popUp);
			};

			//Finally show the window
			popUp.Show();
		}

	
	}
}

#T=Wql ManagementEventWatcher
namespace Microshaoft
{
	using System;
	using System.Management;

	// This example shows synchronous consumption of events. 
	// The client is blocked while waiting for events. 

	public class EventWatcherPolling 
	{
		public static int Main(string[] args) 
		{
			// Create event query to be notified within 1 second of 
			// a change in a service
			WqlEventQuery query = 
				new WqlEventQuery("__InstanceCreationEvent", 
				new TimeSpan(0,0,1), 
				"TargetInstance isa \"Win32_Process\"");

			// Initialize an event watcher and subscribe to events 
			// that match this query
			ManagementEventWatcher watcher =
				new ManagementEventWatcher();
			watcher.Query = query;
			// times out watcher.WaitForNextEvent in 5 seconds
			watcher.Options.Timeout = new TimeSpan(0,0,5);
		  
			// Block until the next event occurs 
			// Note: this can be done in a loop if waiting for 
			//        more than one occurrence
			Console.WriteLine(
				"Open an application (notepad.exe) to trigger an event.");
			ManagementBaseObject e = watcher.WaitForNextEvent();

			//Display information from the event
			Console.WriteLine(
				"Process {0} has been created, path is: {1}", 
				((ManagementBaseObject)e
				["TargetInstance"])["Name"],
				((ManagementBaseObject)e
				["TargetInstance"])["ExecutablePath"]);

			//Cancel the subscription
			watcher.Stop();
			return 0;
		}
	}

}
#T=wwf <=> Xaml 
namespace Microshaoft.WF.Hosts
{
	using System;
	using System.Activities;
	using System.Collections.Generic;
	using System.Threading;

	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			AutoResetEvent syncEvent = new AutoResetEvent(false);
			AutoResetEvent idleEvent = new AutoResetEvent(false);
			var inputs = new Dictionary<string, object>() 
								{
									{
										"MaxNumber"
										, 100
									}
								};
			Activity wf = null;
			string xaml =
@"<Activity mc:Ignorable=""sap sap2010 sads"" x:Class=""Microshaoft.WF.Activities.Prompt""
 xmlns=""http://schemas.microsoft.com/netfx/2009/xaml/activities""
 xmlns:local=""clr-namespace:Microshaoft.WF.Activities""
 xmlns:mc=""http://schemas.openxmlformats.org/markup-compatibility/2006""
 xmlns:mca=""clr-namespace:Microsoft.CSharp.Activities;assembly=System.Activities""
 xmlns:sads=""http://schemas.microsoft.com/netfx/2010/xaml/activities/debugger""
 xmlns:sap=""http://schemas.microsoft.com/netfx/2009/xaml/activities/presentation""
 xmlns:sap2010=""http://schemas.microsoft.com/netfx/2010/xaml/activities/presentation""
 xmlns:scg=""clr-namespace:System.Collections.Generic;assembly=mscorlib""
 xmlns:sco=""clr-namespace:System.Collections.ObjectModel;assembly=mscorlib""
 xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml"">
  <x:Members>
	<x:Property Name=""BookmarkName"" Type=""InArgument(x:String)"" />
	<x:Property Name=""Result"" Type=""OutArgument(x:Int32)"" />
	<x:Property Name=""Text"" Type=""InArgument(x:String)"" />
  </x:Members>
  <sap2010:ExpressionActivityEditor.ExpressionActivityEditor>C#</sap2010:ExpressionActivityEditor.ExpressionActivityEditor>
  <sap2010:WorkflowViewState.IdRef>NumberGuessWorkflowActivities.Prompt_1</sap2010:WorkflowViewState.IdRef>
  <TextExpression.NamespacesForImplementation>
	<sco:Collection x:TypeArguments=""x:String"">
	  <x:String>System</x:String>
	  <x:String>System.Collections.Generic</x:String>
	  <x:String>System.Data</x:String>
	  <x:String>System.Linq</x:String>
	  <x:String>System.Text</x:String>
	</sco:Collection>
  </TextExpression.NamespacesForImplementation>
  <TextExpression.ReferencesForImplementation>
	<sco:Collection x:TypeArguments=""AssemblyReference"">
	  <AssemblyReference>Microsoft.CSharp</AssemblyReference>
	  <AssemblyReference>System</AssemblyReference>
	  <AssemblyReference>System.Activities</AssemblyReference>
	  <AssemblyReference>System.Core</AssemblyReference>
	  <AssemblyReference>System.Data</AssemblyReference>
	  <AssemblyReference>System.Runtime.Serialization</AssemblyReference>
	  <AssemblyReference>System.ServiceModel</AssemblyReference>
	  <AssemblyReference>System.ServiceModel.Activities</AssemblyReference>
	  <AssemblyReference>System.Xaml</AssemblyReference>
	  <AssemblyReference>System.Xml</AssemblyReference>
	  <AssemblyReference>System.Xml.Linq</AssemblyReference>
	  <AssemblyReference>mscorlib</AssemblyReference>
	  <AssemblyReference>NumberGuessWorkflowActivities</AssemblyReference>
	</sco:Collection>
  </TextExpression.ReferencesForImplementation>
  <Sequence sap2010:WorkflowViewState.IdRef=""Sequence_1"">
	<WriteLine sap2010:WorkflowViewState.IdRef=""WriteLine_1"">
	  <InArgument x:TypeArguments=""x:String"">
		<mca:CSharpValue x:TypeArguments=""x:String"">Text</mca:CSharpValue>
	  </InArgument>
	</WriteLine>
	<local:ReadInt sap2010:WorkflowViewState.IdRef=""ReadInt_1"">
	  <local:ReadInt.BookmarkName>
		<InArgument x:TypeArguments=""x:String"">
		  <mca:CSharpValue x:TypeArguments=""x:String"">BookmarkName</mca:CSharpValue>
		</InArgument>
	  </local:ReadInt.BookmarkName>
	  <local:ReadInt.Result>
		<OutArgument x:TypeArguments=""x:Int32"">
		  <mca:CSharpReference x:TypeArguments=""x:Int32"">Result</mca:CSharpReference>
		</OutArgument>
	  </local:ReadInt.Result>
	</local:ReadInt>
	<sads:DebugSymbol.Symbol>d3BDOlxXRlByb2plY3RzXF9EZXYxMVxHZXR0aW5nU3RhcnRlZFR1dG9yaWFsXFdGNDVHZXR0aW5nU3RhcnRlZFR1dG9yaWFsXE51bWJlckd1ZXNzV29ya2Zsb3dBY3Rpdml0aWVzXFByb21wdC54YW1sBi0DQA4CAQEuBTIRAgELMwU+FQIBAjAJMEsCAQw2CzZVAgEHOws7VgIBAw==</sads:DebugSymbol.Symbol>
  </Sequence>
  <sap2010:WorkflowViewState.ViewStateManager>
	<sap2010:ViewStateManager>
	  <sap2010:ViewStateData Id=""WriteLine_1"" sap:VirtualizedContainerService.HintSize=""211,62"" />
	  <sap2010:ViewStateData Id=""ReadInt_1"" sap:VirtualizedContainerService.HintSize=""211,22"" />
	  <sap2010:ViewStateData Id=""Sequence_1"" sap:VirtualizedContainerService.HintSize=""233,248"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">True</x:Boolean>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""NumberGuessWorkflowActivities.Prompt_1"" sap:VirtualizedContainerService.HintSize=""273,328"" />
	</sap2010:ViewStateManager>
  </sap2010:WorkflowViewState.ViewStateManager>
</Activity>
";
			Activity a = WorkFlowHelper.XamlToActivity(xaml);
			WorkflowInspectionServices.CacheMetadata(a);
			xaml =
			@"<Activity mc:Ignorable=""sap sap2010 sads"" x:Class=""Microshaoft.WF.Activities.NumberGuessFlowchartWorkflow""
 xmlns=""http://schemas.microsoft.com/netfx/2009/xaml/activities""
 xmlns:av=""http://schemas.microsoft.com/winfx/2006/xaml/presentation""
 xmlns:local=""clr-namespace:Microshaoft.WF.Activities""
 xmlns:mc=""http://schemas.openxmlformats.org/markup-compatibility/2006""
 xmlns:mca=""clr-namespace:Microsoft.CSharp.Activities;assembly=System.Activities""
 xmlns:sads=""http://schemas.microsoft.com/netfx/2010/xaml/activities/debugger""
 xmlns:sap=""http://schemas.microsoft.com/netfx/2009/xaml/activities/presentation""
 xmlns:sap2010=""http://schemas.microsoft.com/netfx/2010/xaml/activities/presentation""
 xmlns:scg=""clr-namespace:System.Collections.Generic;assembly=mscorlib""
 xmlns:sco=""clr-namespace:System.Collections.ObjectModel;assembly=mscorlib""
 xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml"">
  <x:Members>
	<x:Property Name=""MaxNumber"" Type=""InArgument(x:Int32)"" />
	<x:Property Name=""Turns"" Type=""OutArgument(x:Int32)"" />
  </x:Members>
  <sap2010:ExpressionActivityEditor.ExpressionActivityEditor>C#</sap2010:ExpressionActivityEditor.ExpressionActivityEditor>
  <TextExpression.NamespacesForImplementation>
	<sco:Collection x:TypeArguments=""x:String"">
	  <x:String>System</x:String>
	  <x:String>System.Collections.Generic</x:String>
	  <x:String>System.Data</x:String>
	  <x:String>System.Linq</x:String>
	  <x:String>System.Text</x:String>
	</sco:Collection>
  </TextExpression.NamespacesForImplementation>
  <TextExpression.ReferencesForImplementation>
	<sco:Collection x:TypeArguments=""AssemblyReference"">
	  <AssemblyReference>Microsoft.CSharp</AssemblyReference>
	  <AssemblyReference>System</AssemblyReference>
	  <AssemblyReference>System.Activities</AssemblyReference>
	  <AssemblyReference>System.Core</AssemblyReference>
	  <AssemblyReference>System.Data</AssemblyReference>
	  <AssemblyReference>System.Runtime.Serialization</AssemblyReference>
	  <AssemblyReference>System.ServiceModel</AssemblyReference>
	  <AssemblyReference>System.ServiceModel.Activities</AssemblyReference>
	  <AssemblyReference>System.Xaml</AssemblyReference>
	  <AssemblyReference>System.Xml</AssemblyReference>
	  <AssemblyReference>System.Xml.Linq</AssemblyReference>
	  <AssemblyReference>mscorlib</AssemblyReference>
	  <AssemblyReference>NumberGuessWorkflowActivities</AssemblyReference>
	</sco:Collection>
  </TextExpression.ReferencesForImplementation>
  <Flowchart>
	<Flowchart.Variables>
	  <Variable x:TypeArguments=""x:Int32"" Name=""Guess"" />
	  <Variable x:TypeArguments=""x:Int32"" Name=""Target"" />
	</Flowchart.Variables>
	<Flowchart.StartNode>
	  <x:Reference>__ReferenceID6</x:Reference>
	</Flowchart.StartNode>
	<FlowStep x:Name=""__ReferenceID6"">
	  <Assign>
		<Assign.To>
		  <OutArgument x:TypeArguments=""x:Int32"">
			<mca:CSharpReference x:TypeArguments=""x:Int32"">Target</mca:CSharpReference>
		  </OutArgument>
		</Assign.To>
		<Assign.Value>
		  <InArgument x:TypeArguments=""x:Int32"">
			<mca:CSharpValue x:TypeArguments=""x:Int32"">new System.Random().Next(1, MaxNumber + 1)</mca:CSharpValue>
		  </InArgument>
		</Assign.Value>
		<sap2010:WorkflowViewState.IdRef>Assign_1</sap2010:WorkflowViewState.IdRef>
	  </Assign>
	  <FlowStep.Next>
		<FlowStep x:Name=""__ReferenceID0"">
		  <local:Prompt BookmarkName=""EnterGuess"">
			<local:Prompt.Result>
			  <OutArgument x:TypeArguments=""x:Int32"">
				<mca:CSharpReference x:TypeArguments=""x:Int32"">Guess</mca:CSharpReference>
			  </OutArgument>
			</local:Prompt.Result>
			<local:Prompt.Text>
			  <InArgument x:TypeArguments=""x:String"">
				<mca:CSharpValue x:TypeArguments=""x:String"">""Please enter a number between 1 and "" + MaxNumber</mca:CSharpValue>
			  </InArgument>
			</local:Prompt.Text>
			<sap2010:WorkflowViewState.IdRef>Prompt_1</sap2010:WorkflowViewState.IdRef>
		  </local:Prompt>
		  <FlowStep.Next>
			<FlowStep x:Name=""__ReferenceID1"">
			  <Assign>
				<Assign.To>
				  <OutArgument x:TypeArguments=""x:Int32"">
					<mca:CSharpReference x:TypeArguments=""x:Int32"">Turns</mca:CSharpReference>
				  </OutArgument>
				</Assign.To>
				<Assign.Value>
				  <InArgument x:TypeArguments=""x:Int32"">
					<mca:CSharpValue x:TypeArguments=""x:Int32"">Turns + 1</mca:CSharpValue>
				  </InArgument>
				</Assign.Value>
				<sap2010:WorkflowViewState.IdRef>Assign_2</sap2010:WorkflowViewState.IdRef>
			  </Assign>
			  <FlowStep.Next>
				<FlowDecision x:Name=""__ReferenceID2"">
				  <FlowDecision.Condition>
					<mca:CSharpValue x:TypeArguments=""x:Boolean"">Guess == Target</mca:CSharpValue>
				  </FlowDecision.Condition>
				  <FlowDecision.False>
					<FlowDecision x:Name=""__ReferenceID3"">
					  <FlowDecision.Condition>
						<mca:CSharpValue x:TypeArguments=""x:Boolean"">Guess &lt; Target</mca:CSharpValue>
					  </FlowDecision.Condition>
					  <FlowDecision.True>
						<FlowStep x:Name=""__ReferenceID4"">
						  <WriteLine Text=""Your guess is too low."" sap2010:WorkflowViewState.IdRef=""WriteLine_1"" />
						  <FlowStep.Next>
							<x:Reference>__ReferenceID0</x:Reference>
						  </FlowStep.Next>
						  <sap2010:WorkflowViewState.IdRef>FlowStep_1</sap2010:WorkflowViewState.IdRef>
						</FlowStep>
					  </FlowDecision.True>
					  <FlowDecision.False>
						<FlowStep x:Name=""__ReferenceID5"">
						  <WriteLine Text=""Your guess is too high."" sap2010:WorkflowViewState.IdRef=""WriteLine_2"" />
						  <FlowStep.Next>
							<x:Reference>__ReferenceID0</x:Reference>
						  </FlowStep.Next>
						  <sap2010:WorkflowViewState.IdRef>FlowStep_2</sap2010:WorkflowViewState.IdRef>
						</FlowStep>
					  </FlowDecision.False>
					  <sap2010:WorkflowViewState.IdRef>FlowDecision_1</sap2010:WorkflowViewState.IdRef>
					</FlowDecision>
				  </FlowDecision.False>
				  <sap2010:WorkflowViewState.IdRef>FlowDecision_2</sap2010:WorkflowViewState.IdRef>
				</FlowDecision>
			  </FlowStep.Next>
			  <sap2010:WorkflowViewState.IdRef>FlowStep_3</sap2010:WorkflowViewState.IdRef>
			</FlowStep>
		  </FlowStep.Next>
		  <sap2010:WorkflowViewState.IdRef>FlowStep_4</sap2010:WorkflowViewState.IdRef>
		</FlowStep>
	  </FlowStep.Next>
	  <sap2010:WorkflowViewState.IdRef>FlowStep_5</sap2010:WorkflowViewState.IdRef>
	</FlowStep>
	<x:Reference>__ReferenceID0</x:Reference>
	<x:Reference>__ReferenceID1</x:Reference>
	<x:Reference>__ReferenceID2</x:Reference>
	<x:Reference>__ReferenceID3</x:Reference>
	<x:Reference>__ReferenceID4</x:Reference>
	<x:Reference>__ReferenceID5</x:Reference>
	<sap2010:WorkflowViewState.IdRef>Flowchart_1</sap2010:WorkflowViewState.IdRef>
	<sads:DebugSymbol.Symbol>d4YBQzpcV0ZQcm9qZWN0c1xfRGV2MTFcR2V0dGluZ1N0YXJ0ZWRUdXRvcmlhbFxXRjQ1R2V0dGluZ1N0YXJ0ZWRUdXRvcmlhbFxOdW1iZXJHdWVzc1dvcmtmbG93QWN0aXZpdGllc1xGbG93Y2hhcnROdW1iZXJHdWVzc1dvcmtmbG93LnhhbWwRLAOSAQ8CAQE1B0EQAgEnRAtQGgIBG1MPXxgCARBjFWNjAgELaBloaQIBBnUbdXUCAQRsG2x0AgECPQ09dAIBLTgNOFgCAShEJkQyAgEmTBFMgQECASFHEUdbAgEcWxVbWwIBFlYVVl8CARF1K3VEAgEFbCtsQwIBAw==</sads:DebugSymbol.Symbol>
  </Flowchart>
  <sap2010:WorkflowViewState.IdRef>NumberGuessWorkflowActivities.FlowchartNumberGuessWorkflow_1</sap2010:WorkflowViewState.IdRef>
  <sap2010:WorkflowViewState.ViewStateManager>
	<sap2010:ViewStateManager>
	  <sap2010:ViewStateData Id=""Assign_1"" sap:VirtualizedContainerService.HintSize=""242,62"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">True</x:Boolean>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""Prompt_1"" sap:VirtualizedContainerService.HintSize=""200,22"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">True</x:Boolean>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""Assign_2"" sap:VirtualizedContainerService.HintSize=""242,62"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">True</x:Boolean>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""WriteLine_1"" sap:VirtualizedContainerService.HintSize=""211,62"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">True</x:Boolean>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""FlowStep_1"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<av:Point x:Key=""ShapeLocation"">94.5,589</av:Point>
			<av:Size x:Key=""ShapeSize"">211,62</av:Size>
			<av:PointCollection x:Key=""ConnectorLocation"">94.5,620 64.5,620 64.5,250.5 199.895,250.5</av:PointCollection>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""WriteLine_2"" sap:VirtualizedContainerService.HintSize=""211,62"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">True</x:Boolean>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""FlowStep_2"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<av:Point x:Key=""ShapeLocation"">354.5,599</av:Point>
			<av:Size x:Key=""ShapeSize"">211,62</av:Size>
			<av:PointCollection x:Key=""ConnectorLocation"">565.5,630 595.5,630 595.5,250.5 399.895,250.5</av:PointCollection>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""FlowDecision_1"" sap:VirtualizedContainerService.HintSize=""70,87"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">True</x:Boolean>
			<av:Point x:Key=""ShapeLocation"">355,496.5</av:Point>
			<av:Size x:Key=""ShapeSize"">70,87</av:Size>
			<av:PointCollection x:Key=""TrueConnector"">355,540 200,540 200,589</av:PointCollection>
			<av:PointCollection x:Key=""FalseConnector"">425,540 460,540 460,599</av:PointCollection>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""FlowDecision_2"" sap:VirtualizedContainerService.HintSize=""70,87"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">True</x:Boolean>
			<av:Point x:Key=""ShapeLocation"">264.895,423.5</av:Point>
			<av:Size x:Key=""ShapeSize"">70,87</av:Size>
			<av:PointCollection x:Key=""FalseConnector"">334.895,467 390,467 390,496.5</av:PointCollection>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""FlowStep_3"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<av:Point x:Key=""ShapeLocation"">178.895,311.5</av:Point>
			<av:Size x:Key=""ShapeSize"">242,62</av:Size>
			<av:PointCollection x:Key=""ConnectorLocation"">299.895,373.5 299.895,423.5</av:PointCollection>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""FlowStep_4"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<av:Point x:Key=""ShapeLocation"">199.895,239.5</av:Point>
			<av:Size x:Key=""ShapeSize"">200,22</av:Size>
			<av:PointCollection x:Key=""ConnectorLocation"">299.895,261.5 299.895,311.5</av:PointCollection>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""FlowStep_5"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<av:Point x:Key=""ShapeLocation"">178.895,127.5</av:Point>
			<av:Size x:Key=""ShapeSize"">242,62</av:Size>
			<av:PointCollection x:Key=""ConnectorLocation"">299.895,189.5 299.895,239.5</av:PointCollection>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""Flowchart_1"" sap:VirtualizedContainerService.HintSize=""614,697"">
		<sap:WorkflowViewStateService.ViewState>
		  <scg:Dictionary x:TypeArguments=""x:String, x:Object"">
			<x:Boolean x:Key=""IsExpanded"">False</x:Boolean>
			<av:Point x:Key=""ShapeLocation"">270,2.5</av:Point>
			<av:Size x:Key=""ShapeSize"">60,75</av:Size>
			<av:PointCollection x:Key=""ConnectorLocation"">300,77.5 300,107.5 299.895,107.5 299.895,127.5</av:PointCollection>
			<x:Double x:Key=""Height"">661</x:Double>
		  </scg:Dictionary>
		</sap:WorkflowViewStateService.ViewState>
	  </sap2010:ViewStateData>
	  <sap2010:ViewStateData Id=""NumberGuessWorkflowActivities.FlowchartNumberGuessWorkflow_1"" sap:VirtualizedContainerService.HintSize=""654,777"" />
	</sap2010:ViewStateManager>
  </sap2010:WorkflowViewState.ViewStateManager>
</Activity>
";
			wf = WorkFlowHelper.XamlToActivity(xaml);
			//WorkflowInspectionServices.CacheMetadata(wf);
			WorkflowApplication wfApp =
				new WorkflowApplication
					(
						wf
						, inputs
					)
					{
						Completed =
							(
								(e) =>
								{
									int Turns = Convert.ToInt32(e.Outputs["Turns"]);
									Console.WriteLine("Congratulations, you guessed the number in {0} turns.", Turns);
									syncEvent.Set();
								}
							)
						,
						Aborted =
						  (
							  new Action<WorkflowApplicationAbortedEventArgs>
								  (
									  (e) =>
									  {
										  Console.WriteLine(e.Reason);
									  }
								)
						  )
						,
						OnUnhandledException = delegate(WorkflowApplicationUnhandledExceptionEventArgs e)
						  {
							  Console.WriteLine(e.UnhandledException.ToString());
							  return UnhandledExceptionAction.Terminate;
						  }
						,
						Idle = delegate(WorkflowApplicationIdleEventArgs e)
						  {
							  idleEvent.Set();
						  }
					};
			wfApp.Run();
			// Loop until the workflow completes.
			var handles = new WaitHandle[] { syncEvent, idleEvent };
			while (WaitHandle.WaitAny(handles) != 0)
			{
				// Gather the user input and resume the bookmark.
				bool validEntry = false;
				while (!validEntry)
				{
					int Guess;
					if (!int.TryParse(Console.ReadLine(), out Guess))
					{
						Console.WriteLine("Please enter an integer.");
					}
					else
					{
						validEntry = true;
						wfApp.ResumeBookmark("EnterGuess", Guess);
					}
				}
			}
		}
	}
}
namespace Microshaoft.WF.Activities
{
	using System;
	using System.Activities;
	public sealed class ReadInt : NativeActivity<int>
	{
		[RequiredArgument]
		public InArgument<string> BookmarkName { get; set; }

		protected override void Execute(NativeActivityContext context)
		{
			string name = BookmarkName.Get(context);

			if (name == string.Empty)
			{
				throw new ArgumentException("BookmarkName cannot be an Empty string.",
					"BookmarkName");
			}

			context.CreateBookmark(name, new BookmarkCallback(OnReadComplete));
		}

		// NativeActivity derived activities that do asynchronous operations by calling 
		// one of the CreateBookmark overloads defined on System.Activities.NativeActivityContext 
		// must override the CanInduceIdle property and return true.
		protected override bool CanInduceIdle
		{
			get { return true; }
		}
		void OnReadComplete(NativeActivityContext context, Bookmark bookmark, object state)
		{
			this.Result.Set(context, Convert.ToInt32(state));
		}
	}
}

#T=wwf workflow
namespace Microshaoft.WF.Hosts
{
	using System;
	using System.Activities;
	using System.Activities.XamlIntegration;
	using System.Collections.Generic;
	using System.IO;
	using System.Reflection;
	using System.Threading;
	using System.Xaml;
	using Microshaoft.WF.Activities;
	class Program
	{
		static void Main(string[] args)
		{
			AutoResetEvent syncEvent = new AutoResetEvent(false);
			AutoResetEvent idleEvent = new AutoResetEvent(false);
			var inputs = new Dictionary<string, object>() 
			{
				{
					"MaxNumber"
					, 100
				}
			};
			Activity wf = null;
			string xamlFilePath = Path.Combine
										(
											Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)
											, "NumberGuessFlowchartWorkflow.xaml"
										);
			xamlFilePath = @"D:\MyC#\Windows Workflow Foundation (WF45) Getting Started Tutorial\C#\NumberGuessWorkflowHost\00.WorkFlows\10.Workflows.Xamls\NumberGuessFlowchartWorkflow.xaml";
			using (Stream stream = File.OpenRead(xamlFilePath))
			{
				XamlXmlReader xamlXmlReader = new XamlXmlReader
													(
														stream
														, new XamlXmlReaderSettings()
															{
																LocalAssembly = Assembly.GetExecutingAssembly()
															}
													);
				XamlReader xamlReader = ActivityXamlServices.CreateReader
												(
													xamlXmlReader
												);
				//wf = new NumberGuessSequentialWorkflow();
				//wf = new NumberGuessFlowchartWorkflow();
				//wf = new NumberGuessStateMachineWorkflow();
				wf = ActivityXamlServices.Load
									(
										xamlReader
										, new ActivityXamlServicesSettings()
										{
											CompileExpressions = true
										}
									);
				stream.Close();
			}
			WorkflowApplication wfApp =
				new WorkflowApplication
					(
						wf
						, inputs
					)
					{
						Completed =
							(
								(e) =>
								{
									int Turns = Convert.ToInt32(e.Outputs["Turns"]);
									Console.WriteLine("Congratulations, you guessed the number in {0} turns.", Turns);
									syncEvent.Set();
								}
							)
						,
						Aborted =
							(
								new Action<WorkflowApplicationAbortedEventArgs>
									(
										(e) =>
										{
											Console.WriteLine(e.Reason);
										}
								)
							)
						,
						OnUnhandledException = delegate(WorkflowApplicationUnhandledExceptionEventArgs e)
							{
								Console.WriteLine(e.UnhandledException.ToString());
								return UnhandledExceptionAction.Terminate;
							}
						,
						Idle = delegate(WorkflowApplicationIdleEventArgs e)
							{
								idleEvent.Set();
							}
					};
			wfApp.Run();
			// Loop until the workflow completes.
			var handles = new WaitHandle[] { syncEvent, idleEvent };
			while (WaitHandle.WaitAny(handles) != 0)
			{
				// Gather the user input and resume the bookmark.
				bool validEntry = false;
				while (!validEntry)
				{
					int Guess;
					if (!int.TryParse(Console.ReadLine(), out Guess))
					{
						Console.WriteLine("Please enter an integer.");
					}
					else
					{
						validEntry = true;
						wfApp.ResumeBookmark("EnterGuess", Guess);
					}
				}
			}
		}
	}
}
namespace Microshaoft.WF.Activities
{
	using System;
	using System.Activities;
	public sealed class ReadInt : NativeActivity<int>
	{
		[RequiredArgument]
		public InArgument<string> BookmarkName { get; set; }
		protected override void Execute(NativeActivityContext context)
		{
			string name = BookmarkName.Get(context);
			if (name == string.Empty)
			{
				throw new ArgumentException("BookmarkName cannot be an Empty string.",
					"BookmarkName");
			}
			context.CreateBookmark(name, new BookmarkCallback(OnReadComplete));
		}
		// NativeActivity derived activities that do asynchronous operations by calling 
		// one of the CreateBookmark overloads defined on System.Activities.NativeActivityContext 
		// must override the CanInduceIdle property and return true.
		protected override bool CanInduceIdle
		{
			get { return true; }
		}
		void OnReadComplete(NativeActivityContext context, Bookmark bookmark, object state)
		{
			this.Result.Set(context, Convert.ToInt32(state));
		}
	}
}
/*
<Activity mc:Ignorable="sap sap2010 sads" x:Class="Microshaoft.WF.Activities.NumberGuessFlowchartWorkflow"
 xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
 xmlns:av="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
 xmlns:local="clr-namespace:Microshaoft.WF.Activities"
 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
 xmlns:mca="clr-namespace:Microsoft.CSharp.Activities;assembly=System.Activities"
 xmlns:sads="http://schemas.microsoft.com/netfx/2010/xaml/activities/debugger"
 xmlns:sap="http://schemas.microsoft.com/netfx/2009/xaml/activities/presentation"
 xmlns:sap2010="http://schemas.microsoft.com/netfx/2010/xaml/activities/presentation"
 xmlns:scg="clr-namespace:System.Collections.Generic;assembly=mscorlib"
 xmlns:sco="clr-namespace:System.Collections.ObjectModel;assembly=mscorlib"
 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <x:Members>
    <x:Property Name="MaxNumber" Type="InArgument(x:Int32)" />
    <x:Property Name="Turns" Type="OutArgument(x:Int32)" />
  </x:Members>
  <sap2010:ExpressionActivityEditor.ExpressionActivityEditor>C#</sap2010:ExpressionActivityEditor.ExpressionActivityEditor>
  <TextExpression.NamespacesForImplementation>
    <sco:Collection x:TypeArguments="x:String">
      <x:String>System</x:String>
      <x:String>System.Collections.Generic</x:String>
      <x:String>System.Data</x:String>
      <x:String>System.Linq</x:String>
      <x:String>System.Text</x:String>
    </sco:Collection>
  </TextExpression.NamespacesForImplementation>
  <TextExpression.ReferencesForImplementation>
    <sco:Collection x:TypeArguments="AssemblyReference">
      <AssemblyReference>Microsoft.CSharp</AssemblyReference>
      <AssemblyReference>System</AssemblyReference>
      <AssemblyReference>System.Activities</AssemblyReference>
      <AssemblyReference>System.Core</AssemblyReference>
      <AssemblyReference>System.Data</AssemblyReference>
      <AssemblyReference>System.Runtime.Serialization</AssemblyReference>
      <AssemblyReference>System.ServiceModel</AssemblyReference>
      <AssemblyReference>System.ServiceModel.Activities</AssemblyReference>
      <AssemblyReference>System.Xaml</AssemblyReference>
      <AssemblyReference>System.Xml</AssemblyReference>
      <AssemblyReference>System.Xml.Linq</AssemblyReference>
      <AssemblyReference>mscorlib</AssemblyReference>
      <AssemblyReference>NumberGuessWorkflowActivities</AssemblyReference>
    </sco:Collection>
  </TextExpression.ReferencesForImplementation>
  <Flowchart>
    <Flowchart.Variables>
      <Variable x:TypeArguments="x:Int32" Name="Guess" />
      <Variable x:TypeArguments="x:Int32" Name="Target" />
    </Flowchart.Variables>
    <Flowchart.StartNode>
      <x:Reference>__ReferenceID6</x:Reference>
    </Flowchart.StartNode>
    <FlowStep x:Name="__ReferenceID6">
      <Assign>
        <Assign.To>
          <OutArgument x:TypeArguments="x:Int32">
            <mca:CSharpReference x:TypeArguments="x:Int32">Target</mca:CSharpReference>
          </OutArgument>
        </Assign.To>
        <Assign.Value>
          <InArgument x:TypeArguments="x:Int32">
            <mca:CSharpValue x:TypeArguments="x:Int32">new System.Random().Next(1, MaxNumber + 1)</mca:CSharpValue>
          </InArgument>
        </Assign.Value>
        <sap2010:WorkflowViewState.IdRef>Assign_1</sap2010:WorkflowViewState.IdRef>
      </Assign>
      <FlowStep.Next>
        <FlowStep x:Name="__ReferenceID0">
          <local:Prompt BookmarkName="EnterGuess">
            <local:Prompt.Result>
              <OutArgument x:TypeArguments="x:Int32">
                <mca:CSharpReference x:TypeArguments="x:Int32">Guess</mca:CSharpReference>
              </OutArgument>
            </local:Prompt.Result>
            <local:Prompt.Text>
              <InArgument x:TypeArguments="x:String">
                <mca:CSharpValue x:TypeArguments="x:String">"Please enter a number between 1 and " + MaxNumber</mca:CSharpValue>
              </InArgument>
            </local:Prompt.Text>
            <sap2010:WorkflowViewState.IdRef>Prompt_1</sap2010:WorkflowViewState.IdRef>
          </local:Prompt>
          <FlowStep.Next>
            <FlowStep x:Name="__ReferenceID1">
              <Assign>
                <Assign.To>
                  <OutArgument x:TypeArguments="x:Int32">
                    <mca:CSharpReference x:TypeArguments="x:Int32">Turns</mca:CSharpReference>
                  </OutArgument>
                </Assign.To>
                <Assign.Value>
                  <InArgument x:TypeArguments="x:Int32">
                    <mca:CSharpValue x:TypeArguments="x:Int32">Turns + 1</mca:CSharpValue>
                  </InArgument>
                </Assign.Value>
                <sap2010:WorkflowViewState.IdRef>Assign_2</sap2010:WorkflowViewState.IdRef>
              </Assign>
              <FlowStep.Next>
                <FlowDecision x:Name="__ReferenceID2">
                  <FlowDecision.Condition>
                    <mca:CSharpValue x:TypeArguments="x:Boolean">Guess == Target</mca:CSharpValue>
                  </FlowDecision.Condition>
                  <FlowDecision.False>
                    <FlowDecision x:Name="__ReferenceID3">
                      <FlowDecision.Condition>
                        <mca:CSharpValue x:TypeArguments="x:Boolean">Guess &lt; Target</mca:CSharpValue>
                      </FlowDecision.Condition>
                      <FlowDecision.True>
                        <FlowStep x:Name="__ReferenceID4">
                          <WriteLine Text="Your guess is too low." sap2010:WorkflowViewState.IdRef="WriteLine_1" />
                          <FlowStep.Next>
                            <x:Reference>__ReferenceID0</x:Reference>
                          </FlowStep.Next>
                          <sap2010:WorkflowViewState.IdRef>FlowStep_1</sap2010:WorkflowViewState.IdRef>
                        </FlowStep>
                      </FlowDecision.True>
                      <FlowDecision.False>
                        <FlowStep x:Name="__ReferenceID5">
                          <WriteLine Text="Your guess is too high." sap2010:WorkflowViewState.IdRef="WriteLine_2" />
                          <FlowStep.Next>
                            <x:Reference>__ReferenceID0</x:Reference>
                          </FlowStep.Next>
                          <sap2010:WorkflowViewState.IdRef>FlowStep_2</sap2010:WorkflowViewState.IdRef>
                        </FlowStep>
                      </FlowDecision.False>
                      <sap2010:WorkflowViewState.IdRef>FlowDecision_1</sap2010:WorkflowViewState.IdRef>
                    </FlowDecision>
                  </FlowDecision.False>
                  <sap2010:WorkflowViewState.IdRef>FlowDecision_2</sap2010:WorkflowViewState.IdRef>
                </FlowDecision>
              </FlowStep.Next>
              <sap2010:WorkflowViewState.IdRef>FlowStep_3</sap2010:WorkflowViewState.IdRef>
            </FlowStep>
          </FlowStep.Next>
          <sap2010:WorkflowViewState.IdRef>FlowStep_4</sap2010:WorkflowViewState.IdRef>
        </FlowStep>
      </FlowStep.Next>
      <sap2010:WorkflowViewState.IdRef>FlowStep_5</sap2010:WorkflowViewState.IdRef>
    </FlowStep>
    <x:Reference>__ReferenceID0</x:Reference>
    <x:Reference>__ReferenceID1</x:Reference>
    <x:Reference>__ReferenceID2</x:Reference>
    <x:Reference>__ReferenceID3</x:Reference>
    <x:Reference>__ReferenceID4</x:Reference>
    <x:Reference>__ReferenceID5</x:Reference>
    <sap2010:WorkflowViewState.IdRef>Flowchart_1</sap2010:WorkflowViewState.IdRef>
    <sads:DebugSymbol.Symbol>d4YBQzpcV0ZQcm9qZWN0c1xfRGV2MTFcR2V0dGluZ1N0YXJ0ZWRUdXRvcmlhbFxXRjQ1R2V0dGluZ1N0YXJ0ZWRUdXRvcmlhbFxOdW1iZXJHdWVzc1dvcmtmbG93QWN0aXZpdGllc1xGbG93Y2hhcnROdW1iZXJHdWVzc1dvcmtmbG93LnhhbWwRLAOSAQ8CAQE1B0EQAgEnRAtQGgIBG1MPXxgCARBjFWNjAgELaBloaQIBBnUbdXUCAQRsG2x0AgECPQ09dAIBLTgNOFgCAShEJkQyAgEmTBFMgQECASFHEUdbAgEcWxVbWwIBFlYVVl8CARF1K3VEAgEFbCtsQwIBAw==</sads:DebugSymbol.Symbol>
  </Flowchart>
  <sap2010:WorkflowViewState.IdRef>NumberGuessWorkflowActivities.FlowchartNumberGuessWorkflow_1</sap2010:WorkflowViewState.IdRef>
  <sap2010:WorkflowViewState.ViewStateManager>
    <sap2010:ViewStateManager>
      <sap2010:ViewStateData Id="Assign_1" sap:VirtualizedContainerService.HintSize="242,62">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <x:Boolean x:Key="IsExpanded">True</x:Boolean>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="Prompt_1" sap:VirtualizedContainerService.HintSize="200,22">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <x:Boolean x:Key="IsExpanded">True</x:Boolean>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="Assign_2" sap:VirtualizedContainerService.HintSize="242,62">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <x:Boolean x:Key="IsExpanded">True</x:Boolean>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="WriteLine_1" sap:VirtualizedContainerService.HintSize="211,62">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <x:Boolean x:Key="IsExpanded">True</x:Boolean>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="FlowStep_1">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <av:Point x:Key="ShapeLocation">94.5,589</av:Point>
            <av:Size x:Key="ShapeSize">211,62</av:Size>
            <av:PointCollection x:Key="ConnectorLocation">94.5,620 64.5,620 64.5,250.5 199.895,250.5</av:PointCollection>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="WriteLine_2" sap:VirtualizedContainerService.HintSize="211,62">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <x:Boolean x:Key="IsExpanded">True</x:Boolean>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="FlowStep_2">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <av:Point x:Key="ShapeLocation">354.5,599</av:Point>
            <av:Size x:Key="ShapeSize">211,62</av:Size>
            <av:PointCollection x:Key="ConnectorLocation">565.5,630 595.5,630 595.5,250.5 399.895,250.5</av:PointCollection>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="FlowDecision_1" sap:VirtualizedContainerService.HintSize="70,87">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <x:Boolean x:Key="IsExpanded">True</x:Boolean>
            <av:Point x:Key="ShapeLocation">355,496.5</av:Point>
            <av:Size x:Key="ShapeSize">70,87</av:Size>
            <av:PointCollection x:Key="TrueConnector">355,540 200,540 200,589</av:PointCollection>
            <av:PointCollection x:Key="FalseConnector">425,540 460,540 460,599</av:PointCollection>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="FlowDecision_2" sap:VirtualizedContainerService.HintSize="70,87">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <x:Boolean x:Key="IsExpanded">True</x:Boolean>
            <av:Point x:Key="ShapeLocation">264.895,423.5</av:Point>
            <av:Size x:Key="ShapeSize">70,87</av:Size>
            <av:PointCollection x:Key="FalseConnector">334.895,467 390,467 390,496.5</av:PointCollection>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="FlowStep_3">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <av:Point x:Key="ShapeLocation">178.895,311.5</av:Point>
            <av:Size x:Key="ShapeSize">242,62</av:Size>
            <av:PointCollection x:Key="ConnectorLocation">299.895,373.5 299.895,423.5</av:PointCollection>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="FlowStep_4">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <av:Point x:Key="ShapeLocation">199.895,239.5</av:Point>
            <av:Size x:Key="ShapeSize">200,22</av:Size>
            <av:PointCollection x:Key="ConnectorLocation">299.895,261.5 299.895,311.5</av:PointCollection>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="FlowStep_5">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <av:Point x:Key="ShapeLocation">178.895,127.5</av:Point>
            <av:Size x:Key="ShapeSize">242,62</av:Size>
            <av:PointCollection x:Key="ConnectorLocation">299.895,189.5 299.895,239.5</av:PointCollection>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="Flowchart_1" sap:VirtualizedContainerService.HintSize="614,697">
        <sap:WorkflowViewStateService.ViewState>
          <scg:Dictionary x:TypeArguments="x:String, x:Object">
            <x:Boolean x:Key="IsExpanded">False</x:Boolean>
            <av:Point x:Key="ShapeLocation">270,2.5</av:Point>
            <av:Size x:Key="ShapeSize">60,75</av:Size>
            <av:PointCollection x:Key="ConnectorLocation">300,77.5 300,107.5 299.895,107.5 299.895,127.5</av:PointCollection>
            <x:Double x:Key="Height">661</x:Double>
          </scg:Dictionary>
        </sap:WorkflowViewStateService.ViewState>
      </sap2010:ViewStateData>
      <sap2010:ViewStateData Id="NumberGuessWorkflowActivities.FlowchartNumberGuessWorkflow_1" sap:VirtualizedContainerService.HintSize="654,777" />
    </sap2010:ViewStateManager>
  </sap2010:WorkflowViewState.ViewStateManager>
</Activity>
*/
#T=X509 FindPrivateKey
namespace Microsoft.ChannelSDK.Tools.FindPrivateKey
{
	using System;
	using System.IO;
	using System.Security.Cryptography.X509Certificates;
	using System.Runtime.InteropServices;

	class FindPrivateKey
	{
		static void PrintHelp()
		{
			Console.WriteLine("FindPrivateKey helps user to find the location of the Private Key file of a X.509 Certificate.");
			Console.WriteLine("Usage: FindPrivateKey <storeName> <storeLocation> [{ {-n <subjectName>} | {-t <thumbprint>} } [-f | -d | -a]]");
			Console.WriteLine("	   <subjectName> subject name of the certificate");
			Console.WriteLine("	   <thumbprint>  thumbprint of the certificate (use certmgr.exe to get it)");
			Console.WriteLine("	   -f			output file name only");
			Console.WriteLine("	   -d			output directory only");
			Console.WriteLine("	   -a			output absolute file name");
			Console.WriteLine("e.g. FindPrivateKey My CurrentUser -n \"CN=John Doe\"");
			Console.WriteLine("e.g. FindPrivateKey My LocalMachine -t \"03 33 98 63 d0 47 e7 48 71 33 62 64 76 5c 4c 9d 42 1d 6b 52\" -a");
		}

		static void Main(string[] args)
		{			
			if (args.Length < 2 || args.Length == 3 || args.Length > 5 
				|| (args.Length > 2 && args[2] != "-n" && args[2] != "-t")
				|| (args.Length == 5 && args[4] != "-f" && args[4] != "-d" && args[4] != "-a"))
			{
				PrintHelp();
				return;
			}

			try
			{
				StoreName storeName = (StoreName)Enum.Parse(typeof(StoreName), args[0], true);
				StoreLocation storeLocation = (StoreLocation)Enum.Parse(typeof(StoreLocation), args[1], true);

				X509Certificate2 cert;
				if (args.Length > 2)
				{
					// insert a comma followed by a space for store.Certificates.Find(findType, key, false) 
					// to successful find the certificate
					string key = args[3];
					string[] keys = key.Split(',');
					key = string.Empty;
					for (int i = 0; i < keys.Length; i++)
					{
						key += keys[i];
						if ( i != keys.Length -1 )
						 key += ", ";
					}
					if (args[2] == "-n")
						cert = LoadCertificate(storeName, storeLocation, key, X509FindType.FindBySubjectDistinguishedName);
					else
						cert = LoadCertificate(storeName, storeLocation, key, X509FindType.FindByThumbprint);
				}
				else
				{
					cert = SelectCertificate(storeName, storeLocation);
					if (cert == null)
						return;
				}

				string privateKeyFile = GetKeyFileName(cert);
				string privateKeyDirectory = GetKeyFileDirectory(privateKeyFile);

				if (args.Length == 5)
				{
					if (args[4] == "-f")
						Console.WriteLine(privateKeyFile);
					else if (args[4] == "-d")
						Console.WriteLine(privateKeyDirectory);
					else
						Console.WriteLine("a:{0}\\{1}", privateKeyDirectory, privateKeyFile);
				}
				else
				{
					Console.WriteLine("Private key directory:");
					Console.WriteLine(privateKeyDirectory);
					Console.WriteLine("Private key file name:");
					Console.WriteLine(privateKeyFile);
				}
			}
			catch (Exception ex)
			{
				Console.WriteLine("FindPrivateKey failed for the following reason:");
				Console.WriteLine(ex.Message);
				Console.WriteLine("\nUse /? option for help");
			}
		}

		static X509Certificate2 SelectCertificate(StoreName storeName, StoreLocation storeLocation)
		{
			X509Certificate2 result;

			X509Store store = new X509Store(storeName, storeLocation);
			store.Open(OpenFlags.ReadOnly);
			try
			{
				X509Certificate2Collection matches;
				matches = X509Certificate2UI.SelectFromCollection(store.Certificates, "Select certificate", "Select the certificate to find the location of the associated private key file:", X509SelectionFlag.SingleSelection);
				if (matches.Count != 1)
					result = null;
				else
					result = matches[0];
			}
			finally
			{
				store.Close();
			}

			return result;
		}

		static X509Certificate2 LoadCertificate(StoreName storeName, StoreLocation storeLocation, string key, X509FindType findType)
		{
			X509Certificate2 result;

			X509Store store = new X509Store(storeName, storeLocation);
			store.Open(OpenFlags.ReadOnly);
			try
			{
				X509Certificate2Collection matches;
				matches = store.Certificates.Find(findType, key, false);
				if (matches.Count > 1)
					throw new InvalidOperationException(String.Format("More than one certificate with key '{0}' found in the store.", key));
				if (matches.Count == 0)
					throw new InvalidOperationException(String.Format("No certificates with key '{0}' found in the store.", key));
				result = matches[0];
			}
			finally
			{
				store.Close();
			}

			return result;
		}

		static string GetKeyFileName(X509Certificate2 cert)
		{
			IntPtr			hProvider	 = IntPtr.Zero; // CSP handle
			bool			  freeProvider  = false;	   // Do we need to free the CSP ?
			uint			   acquireFlags  = 0;
			int			 	  _keyNumber = 0;
			string			  keyFileName = null;
			byte[]			  keyFileBytes = null;

			//
			// Determine whether there is private key information available for this certificate in the key store
			//
			if ( CryptAcquireCertificatePrivateKey(cert.Handle,
				acquireFlags,
				IntPtr.Zero,
				ref hProvider,
				ref _keyNumber,
				ref freeProvider) )
			{
				IntPtr pBytes  = IntPtr.Zero; // Native Memory for the CRYPT_KEY_PROV_INFO structure
				int	cbBytes = 0;		   // Native Memory size

				try
				{
					if ( CryptGetProvParam(hProvider, CryptGetProvParamType.PP_UNIQUE_CONTAINER, IntPtr.Zero, ref cbBytes, 0) )
					{
						pBytes = Marshal.AllocHGlobal(cbBytes);

						if ( CryptGetProvParam(hProvider, CryptGetProvParamType.PP_UNIQUE_CONTAINER, pBytes, ref cbBytes, 0) )
						{
							keyFileBytes = new byte[cbBytes];

							Marshal.Copy(pBytes,keyFileBytes,0,cbBytes);

							// Copy eveything except tailing null byte
							keyFileName = System.Text.Encoding.ASCII.GetString(keyFileBytes, 0, keyFileBytes.Length-1);
						}
					}		
				}
				finally
				{
					if ( freeProvider )
						CryptReleaseContext(hProvider,0);

					//
					// Free our native memory
					//
					if ( pBytes != IntPtr.Zero )
						Marshal.FreeHGlobal(pBytes);

				}
			}

			if (keyFileName == null)
				throw new InvalidOperationException("Unable to obtain private key file name");

			return keyFileName;
		}

		static string GetKeyFileDirectory(string keyFileName)
		{
			// Look up All User profile from environment variable
			string allUserProfile = System.Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);

			// set up searching directory
			string machineKeyDir = allUserProfile + "\\Microsoft\\Crypto\\RSA\\MachineKeys";

			// Seach the key file
			string[] fs = System.IO.Directory.GetFiles(machineKeyDir, keyFileName);

			// If found
			if (fs.Length > 0)
				return machineKeyDir;

			// Next try current user profile
			string currentUserProfile = System.Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

			// seach all sub directory
			string userKeyDir = currentUserProfile + "\\Microsoft\\Crypto\\RSA\\";

			fs = System.IO.Directory.GetDirectories(userKeyDir);
			if (fs.Length > 0)
			{
				// for each sub directory
				foreach (string keyDir in fs)
				{
					fs = System.IO.Directory.GetFiles(keyDir, keyFileName);
					if (fs.Length == 0)
						continue;
					else
						// found
						return keyDir;
				}
			}

			throw new InvalidOperationException("Unable to locate private key file directory");
		}

		[DllImport("crypt32", CharSet = CharSet.Unicode, SetLastError = true)]
		internal extern static bool CryptAcquireCertificatePrivateKey(IntPtr pCert, uint dwFlags, IntPtr pvReserved, ref IntPtr phCryptProv, ref int pdwKeySpec, ref bool pfCallerFreeProv);

		[DllImport("advapi32", CharSet = CharSet.Unicode, SetLastError = true)]
		internal extern static bool CryptGetProvParam(IntPtr hCryptProv, CryptGetProvParamType dwParam, IntPtr pvData, ref int pcbData, uint dwFlags);

		[DllImport("advapi32", SetLastError = true)]
		internal extern static bool CryptReleaseContext(IntPtr hProv, uint dwFlags);

	}

	enum CryptGetProvParamType
	{
		PP_ENUMALGS = 1,
		PP_ENUMCONTAINERS = 2,
		PP_IMPTYPE = 3,
		PP_NAME = 4,
		PP_VERSION = 5,
		PP_CONTAINER = 6,
		PP_CHANGE_PASSWORD = 7,
		PP_KEYSET_SEC_DESCR = 8,	   // get/set security descriptor of keyset
		PP_CERTCHAIN = 9,	  // for retrieving certificates from tokens
		PP_KEY_TYPE_SUBTYPE = 10,
		PP_PROVTYPE = 16,
		PP_KEYSTORAGE = 17,
		PP_APPLI_CERT = 18,
		PP_SYM_KEYSIZE = 19,
		PP_SESSION_KEYSIZE = 20,
		PP_UI_PROMPT = 21,
		PP_ENUMALGS_EX = 22,
		PP_ENUMMANDROOTS = 25,
		PP_ENUMELECTROOTS = 26,
		PP_KEYSET_TYPE = 27,
		PP_ADMIN_PIN = 31,
		PP_KEYEXCHANGE_PIN = 32,
		PP_SIGNATURE_PIN = 33,
		PP_SIG_KEYSIZE_INC = 34,
		PP_KEYX_KEYSIZE_INC = 35,
		PP_UNIQUE_CONTAINER = 36,
		PP_SGC_INFO = 37,
		PP_USE_HARDWARE_RNG = 38,
		PP_KEYSPEC = 39,
		PP_ENUMEX_SIGNING_PROT = 40,
		PP_CRYPT_COUNT_KEY_USE = 41,
	}
}

#T=X509 RSACryptoServiceProvider 并发
/*
makecert.exe -n "CN=Microshaoft X509 Test - A" -sky exchange -pe -sv a.pvk a.cer
pvk2pfx.exe -pvk a.pvk -spc a.cer -pfx a.pfx -f -po 123
makecert.exe -n "CN=Microshaoft X509 Test - B" -sky exchange -pe -sv b.pvk b.cer
pvk2pfx.exe -pvk b.pvk -spc b.cer -pfx b.pfx -f -po abc
*/
namespace ConsoleApplication
{
	using System;
	using System.IO;
	using System.Text;
	using System.Threading;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;
	public class Class1
	{
		static void Main(string[] args)
		{
			encryptorPrivateKeyPfxProvider = encryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			encryptorPublicKeyCerProvider = encryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			decryptorPublicKeyCerProvider = decryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider;
			decryptorPrivateKeyPfxProvider = decryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider;
			for (int i = 0 ; i < 2000 ; i++)
			{
				ThreadStart ts = new ThreadStart(Run);
				Thread t = new Thread(ts);
				t.Name = _ThreadID.ToString();
				_ThreadID ++;
				t.Start();
				//Run();
			}
		
		}
		private static volatile int _ThreadID = 0;
		private static object _syncLockObject = new object();
		private static X509Certificate2 encryptorPrivateKeyPfx = new X509Certificate2(@"a.pfx", "123");
		private static X509Certificate2 encryptorPublicKeyCer = new X509Certificate2(@"a.cer");
		private static X509Certificate2 decryptorPublicKeyCer = new X509Certificate2(@"b.cer");
		private static X509Certificate2 decryptorPrivateKeyPfx = new X509Certificate2(@"b.pfx", "abc");
		private static RSACryptoServiceProvider encryptorPrivateKeyPfxProvider = null;
		private static RSACryptoServiceProvider encryptorPublicKeyCerProvider = null;
		private static RSACryptoServiceProvider decryptorPublicKeyCerProvider = null;
		private static RSACryptoServiceProvider decryptorPrivateKeyPfxProvider = null;
		static void Run()
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			string s = "原明文原明文原明文原明文原明文原明文原明文原明文原明文";
			byte[] data = Encoding.UTF8.GetBytes(s);
			byte[] signature;
			bool DoOAEPadding = false;
			bool verifyed = false;
///			X509Certificate2 encryptorPrivateKeyPfx = null;
///			X509Certificate2 encryptorPublicKeyCer = null;
///			X509Certificate2 decryptorPublicKeyCer = null;
///			X509Certificate2 decryptorPrivateKeyPfx = null;
			try
			{
///				encryptorPrivateKeyPfx = new X509Certificate2(@"a.pfx", "123");
///				encryptorPublicKeyCer = new X509Certificate2(@"a.cer");
///				decryptorPublicKeyCer = new X509Certificate2(@"b.cer");
///				decryptorPrivateKeyPfx = new X509Certificate2(@"b.pfx", "abc");
				//using (RSACryptoServiceProvider decryptorPublicKeyCerProvider = decryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider)
				{
					//加密
					data = decryptorPublicKeyCerProvider.Encrypt(data, DoOAEPadding);
				}
				byte[] hash = new SHA1CryptoServiceProvider().ComputeHash(data);
				//using (RSACryptoServiceProvider encryptorPrivateKeyPfxProvider = encryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider)
				{
					//签名
					signature = encryptorPrivateKeyPfxProvider.SignHash(hash, "SHA1");
				}
				//using (RSACryptoServiceProvider encryptorPublicKeyCerProvider = encryptorPublicKeyCer.PublicKey.Key as RSACryptoServiceProvider)
				{
					//验签
					verifyed = encryptorPublicKeyCerProvider.VerifyHash(hash, "SHA1", signature);
				}
				//using (RSACryptoServiceProvider decryptorPrivateKeyPfxProvider = decryptorPrivateKeyPfx.PrivateKey as RSACryptoServiceProvider)
				{
					//解密
					data = decryptorPrivateKeyPfxProvider.Decrypt(data, DoOAEPadding);
				}
				s = Encoding.UTF8.GetString(data);
				Console.WriteLine("{0},{1},{2}", Thread.CurrentThread.Name, verifyed, s);
			}
			catch (Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
///				if (encryptorPrivateKeyPfx != null)
///				{
///					encryptorPrivateKeyPfx.Reset();
///				}
///				if (encryptorPublicKeyCer != null)
///				{
///					encryptorPublicKeyCer.Reset();
///				}
///				if (decryptorPublicKeyCer != null)
///				{
///					decryptorPublicKeyCer.Reset();
///				}
			}
		}
	}
}

#T=Xml Validate By XSD/Schema
namespace Test
{
	using Microshaoft;
	using System;
	using System.Xml;
	using System.Xml.Linq;
	class Program
	{
		public static void Main()
		{
			var errors = 0;
			var xsd =
@"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>
	<xsd:element name='Root'>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>
				<xsd:element name='Child2' minOccurs='1' maxOccurs='1'>
					<xsd:complexType>
						<xsd:simpleContent>
							<xsd:extension base='xsd:string'>
								<xsd:attribute name='Att1' default='Att1 Default Value'/>
							</xsd:extension>
						</xsd:simpleContent>
					</xsd:complexType>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
</xsd:schema>"
;
			XDocument xd = new XDocument
						(
							new XElement
									(
										"Root",
										new XElement("Child1", "c1"),
										new XElement("Child3", "c2"),
										new XElement("Child1", "c1"),
										new XElement("Child3", "c2"),
										new XElement("Child3", "data3"),
										new XElement("Child2", "data4"),
										new XElement("Info5", "info5"),
										new XElement("Info6", "info6"),
										new XElement("Info7", "info7"),
										new XElement("Info8", "info8")
									)
						);
			var r = XmlValidationHelper.XsdValidateXml
					(
						xd
						, ""
						, xsd
						, out errors
						//, (x, y) =>
						//{
						//	Console.WriteLine("{0}", y.Exception);
						//}
					);
			Console.WriteLine("============== XsdValidateXml By XDocument {0}, {1} errors", r, errors);
			r = XmlValidationHelper.XsdValidateXml
					(
						xd
						, ""
						, xsd
						, out errors
						, (x, y) =>
							{
								Console.WriteLine("{0}", y.Exception);
							}
					);
			Console.WriteLine("============== XsdValidateXml By XDocument {0}, {1} errors", r, errors);
			Console.WriteLine("==========================================================================");
			var xml = xd.ToString();
			r = XmlValidationHelper.XsdValidateXml
				(
					xml
					, null //"http://www.contoso.com/books"
					, xsd
					, out errors
					, false
					, (x, y) =>
					{
							Console.WriteLine("***Validation error");
							Console.WriteLine("\tSeverity:{0}", y.Severity);
							Console.WriteLine("\tMessage  :{0}", y.Message);
						}
					, (x) =>
						{
							Console.WriteLine("{0}", x);
							return false;
						}
				);
			Console.WriteLine("============== XsdValidateXml By Xml(XmlReader) {0}, {1} errors", r, errors);
			Console.WriteLine("==========================================================================");
			Console.WriteLine("press any key to continue ...");
			Console.ReadLine();
			xml =
@"<bookstore>
	<book genre=""autobiography"" publicationdate=""1981"" ISBN=""1-861003-11-0"">
		<title>The Autobiography of Benjamin Franklin</title>
			<author>
				<first-name>Benjamin</first-name>
				<last-name>Franklin</last-name>
			</author>
			<price>8.99</price>
	</book>
	<book publicationdate=""1967"" ISBN=""0-201-63361-2"">
		<title>The Confidence Man</title>
		<author>
			<first-name>Herman</first-name>
			<last-name>Melville</last-name>
		</author>
		<price>11.99</price>
	</book>
	<book publicationdate=""1991"" ISBN=""1-861001-57-6"">
		<title>The Gorgias</title>
		<author>
			<name>Plato</name>
		</author>
		<price>9.99</price>
	</book>
</bookstore>
";
			xsd =
@"<?xml version=""1.0"" encoding=""utf-8""?>
<xs:schema attributeFormDefault=""unqualified"" elementFormDefault=""qualified"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"">
<!-- <xs:schema attributeFormDefault=""unqualified"" elementFormDefault=""qualified"" targetNamespace=""http://www.contoso.com/books"" xmlns:xs=""http://www.w3.org/2001/XMLSchema""> -->
	<xs:element name=""bookstore"">
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs=""unbounded"" name=""book"">
					<xs:complexType>
						<xs:sequence>
							<xs:element name=""title"" type=""xs:string"" />
							<xs:element name=""author"">
								<xs:complexType>
									<xs:sequence>
										<xs:element minOccurs=""0"" name=""name"" type=""xs:string"" />
										<xs:element minOccurs=""0"" name=""first-name"" type=""xs:string"" />
										<xs:element minOccurs=""0"" name=""last-name"" type=""xs:string"" />
									</xs:sequence>
								</xs:complexType>
							</xs:element>
							<xs:element name=""price"" type=""xs:decimal"" />
						</xs:sequence>
						<xs:attribute name=""genre"" type=""xs:string"" use=""required"" />
						<xs:attribute name=""publicationdate"" type=""xs:unsignedShort"" use=""required"" />
						<xs:attribute name=""ISBN"" type=""xs:string"" use=""required"" />
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
</xs:schema>
";
			r = XmlValidationHelper.XsdValidateXml
				(
					xml
					, null //"http://www.contoso.com/books"
					, xsd
					, out errors
					//, (x, y) =>
					//{
					//	Console.WriteLine("***Validation error");
					//	Console.WriteLine("\tSeverity:{0}", y.Severity);
					//	Console.WriteLine("\tMessage  :{0}", y.Message);
					//}
					//, (x) =>
					//{
					//	Console.WriteLine("{0}", x);
					//	return false;
					//}
					//, true
					);
			Console.WriteLine("============== XsdValidateXml By Xml(XmlReader) {0}, {1} errors", r, errors);
			r = XmlValidationHelper.XsdValidateXml
				(
					xml
					, null //"http://www.contoso.com/books"
					, xsd
					, out errors
					, true
					, (x, y) =>
						{
							Console.WriteLine("***Validation error");
							Console.WriteLine("\tSeverity:{0}", y.Severity);
							Console.WriteLine("\tMessage  :{0}", y.Message);
						}
					, (x) =>
						{
							Console.WriteLine("{0}", x);
							return false;
						}
					, (x) =>
						{
							Console.WriteLine("{0}", x);
							return false;
						}
					, (x) =>
						{
							Console.WriteLine("{0}", x);
							return false;
						}
				);
			Console.WriteLine("============== XsdValidateXml By Xml(XmlReader) {0}, {1} errors", r, errors);
			Console.WriteLine("==========================================================================");
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.LoadXml(xml);
			r = XmlValidationHelper.XsdValidateXml
					(
						xmlDocument
						, "" //"http://www.contoso.com/books"
						, xsd
						, out errors
						//, (x, y) =>
						//{
						//	Console.WriteLine("***Validation error");
						//	Console.WriteLine("\tSeverity:{0}", y.Severity);
						//	Console.WriteLine("\tException  :{0}", y.Exception);
						//}
					);
			Console.WriteLine("============== XsdValidateXml By XmlDocument {0}, {1} errors", r, errors);
			r = XmlValidationHelper.XsdValidateXml
					(
						xmlDocument
						, "" //"http://www.contoso.com/books"
						, xsd
						, out errors
						, (x, y) =>
							{
								Console.WriteLine("***Validation error");
								Console.WriteLine("\tSeverity:{0}", y.Severity);
								Console.WriteLine("\tException  :{0}", y.Exception);
							}
					);
			Console.WriteLine("============== XsdValidateXml By XmlDocument {0}, {1} errors", r, errors);
			Console.WriteLine("==========================================================================");
			Console.WriteLine("Validation finished");
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Xml;
	using System.Xml.Linq;
	using System.Xml.Schema;
	public static class XmlValidationHelper
	{
		public static bool XsdValidateXml
				(
					XDocument xDocument
					, XmlSchemaSet xmlSchemaSet
					, out int errors
					, ValidationEventHandler validationEventHandlerAction = null
				)
		{
			var exceptions = 0;
			var r = true;
			xDocument.Validate
						(
							xmlSchemaSet
							, (x, y) =>
							{
								r = false;
								exceptions ++;
								if (validationEventHandlerAction != null)
								{
									validationEventHandlerAction(x, y);
								}
							}
							, true
						);
			errors = exceptions;
			return r;
		}
		public static bool XsdValidateXml
						(
							XDocument xDocument
							, string targetNamespace
							, string xsd
							, out int errors
							, ValidationEventHandler validationEventHandlerAction = null
						)
		{
			XmlSchemaSet xmlSchemaSet = GetXmlSchemaSet(targetNamespace, xsd);
			var r = XsdValidateXml
					(
						xDocument
						, xmlSchemaSet
						, out errors
						, validationEventHandlerAction
					);
			return r;
		}
		public static bool XsdValidateXml
				(
					XmlDocument xmlDocument
					, XmlSchemaSet xmlSchemaSet
					, out int errors
					, ValidationEventHandler validationEventHandlerAction = null
				)
		{
			xmlDocument.Schemas = xmlSchemaSet;
			var exceptions = 0;
			var r = true;
			xmlDocument.Validate
				(
					(x, y) =>
					{
						r = false;
						exceptions ++;
						if (validationEventHandlerAction != null)
						{
							validationEventHandlerAction(x, y);
						}
					}
				);
			errors = exceptions;
			return r;
		}
		public static bool XsdValidateXml
						(
							XmlDocument xmlDocument
							, string targetNamespace
							, string xsd
							, out int errors
							, ValidationEventHandler validationEventHandlerAction = null
						)
		{
			var xmlSchemaSet = GetXmlSchemaSet(targetNamespace, xsd);
			var r = XsdValidateXml
						(
							xmlDocument
							, xmlSchemaSet
							, out errors
							, validationEventHandlerAction
						);
			return r;
		}
		public static bool XsdValidateXml
					(
						string xml
						, out int errors
						, XmlReaderSettings xmlReaderValidationSettings
						, bool caughtExceptionOnlyOnce = false
						, ValidationEventHandler validationEventHandlerAction = null
						, Func<XmlSchemaValidationException, bool> onCaughtXmlSchemaValidationExceptionProcessFunc = null
						, Func<XmlSchemaException, bool> onCaughtXmlSchemaExceptionProcessFunc = null
						, Func<Exception, bool> onCaughtExceptionProcessFunc = null
					)
		{
			var r = true;
			bool reThrow = false;
			var exceptions = 0;
			using (var stringReader = new StringReader(xml))
			{
				using (var xmlReader = XmlReader.Create(stringReader, xmlReaderValidationSettings))
				{
					if (validationEventHandlerAction != null)
					{
						xmlReaderValidationSettings.ValidationEventHandler += validationEventHandlerAction;
					}
					bool readed = false;
					var func = new Func<bool>
								(
									() =>
									{
										try
										{
											readed = xmlReader.Read();
										}
										catch (XmlSchemaValidationException xsve)
										{
											r = false;
											exceptions ++;
											if (onCaughtXmlSchemaValidationExceptionProcessFunc != null)
											{
												reThrow = onCaughtXmlSchemaValidationExceptionProcessFunc(xsve);
											}
											if (reThrow)
											{
												//xsve = new XmlSchemaValidationException("ReThrowInnerException", xsve);
												//throw xsve;
												throw;
											}
											if (caughtExceptionOnlyOnce)
											{
												readed = false;
											}
										}
										catch (XmlSchemaException xsve)
										{
											r = false;
											exceptions ++;
											if (onCaughtXmlSchemaExceptionProcessFunc != null)
											{
												reThrow = onCaughtXmlSchemaExceptionProcessFunc(xsve);
											}
											if (reThrow)
											{
												//xsve = new XmlSchemaException("ReThrowInnerException", xsve);
												//throw xsve;
												throw;
											}
											if (caughtExceptionOnlyOnce)
											{
												readed = false;
											}
										}
										catch (Exception e)
										{
											r = false;
											exceptions ++;
											if (onCaughtExceptionProcessFunc != null)
											{
												reThrow = onCaughtExceptionProcessFunc(e);
											}
											if (reThrow)
											{
												//xsve = new XmlSchemaValidationException("ReThrowInnerException", xsve);
												//throw xsve;
												throw;
											}
											if (caughtExceptionOnlyOnce)
											{
												readed = false;
											}
										}
										return readed;
									}
								);
					while
					(
						func()
					) ;
					errors = exceptions;
				}
			}
			return r;
		}
		public static bool XsdValidateXml
							(
								string xml
								, string targetNamespace
								, string xsd
								, out int errors
								, bool caughtExceptionOnlyOnce = false
								, ValidationEventHandler validationEventHandlerAction = null
								, Func<XmlSchemaValidationException, bool> onCaughtXmlSchemaValidationExceptionProcessFunc = null
								, Func<XmlSchemaException, bool> onCaughtXmlSchemaExceptionProcessFunc = null
								, Func<Exception, bool> onCaughtExceptionProcessFunc = null
							)
		{
			XmlReaderSettings xmlReaderSettings = GetXmlReaderValidationSettings(targetNamespace, xsd);
			var r = XsdValidateXml
						(
							xml
							, out errors
							, xmlReaderSettings
							, caughtExceptionOnlyOnce
							, validationEventHandlerAction
							, onCaughtXmlSchemaValidationExceptionProcessFunc
							, onCaughtXmlSchemaExceptionProcessFunc
							, onCaughtExceptionProcessFunc
						);
			return r;
		}
		public static XmlReaderSettings GetXmlReaderValidationSettings
											(
												string targetNamespace
												, string xsd
												, ValidationType validationType = ValidationType.Schema
												, XmlSchemaValidationFlags xmlSchemaValidationFlags =
																					XmlSchemaValidationFlags.AllowXmlAttributes
																					| XmlSchemaValidationFlags.AllowXmlAttributes
																					| XmlSchemaValidationFlags.ProcessIdentityConstraints
																					| XmlSchemaValidationFlags.ProcessInlineSchema
																					| XmlSchemaValidationFlags.ProcessSchemaLocation
																					| XmlSchemaValidationFlags.ReportValidationWarnings
												, ValidationEventHandler validationEventHandlerAction = null
											)
		{
			XmlSchemaSet xmlSchemaSet = GetXmlSchemaSet(targetNamespace, xsd);
			XmlReaderSettings xmlReaderValidationSettings = new XmlReaderSettings();
			xmlReaderValidationSettings.ValidationType = validationType;
			xmlReaderValidationSettings.ValidationFlags = xmlSchemaValidationFlags;
			xmlReaderValidationSettings.Schemas.Add(xmlSchemaSet);
			if (validationEventHandlerAction != null)
			{
				xmlReaderValidationSettings.ValidationEventHandler += validationEventHandlerAction;
			}
			return xmlReaderValidationSettings;
		}
		public static XmlSchemaSet GetXmlSchemaSet(string targetNamespace, string xsd)
		{
			using (var stringReader = new StringReader(xsd))
			{
				using (var xmlReader = XmlReader.Create(stringReader))
				{
					XmlSchemaSet xmlSchemaSet = new XmlSchemaSet();
					xmlSchemaSet.Add(targetNamespace, xmlReader);
					return xmlSchemaSet;
				}
			}
		}
	}
}

#T=Xml/Bin SerializerHelper/XmlReader OnDemand
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using Test.Share;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			WebDirectory x = new WebDirectory();
			x.Name = "Microshaoft";
			WebFile y1 = new WebFile();
			y1.Name = "Microshaoft简体繁w中文";
			y1.IsReadOnly = false;
			y1.Url = "http://www.microshaoft.com";
			WebDirectory x1 = new WebDirectory();
			x1.Name = "Sub1";
			//y1.Directory = x; //循环引用
			WebFile y2 = new WebFile();
			y2.Name = "Microshaoft中文";
			y2.Flag = FlagEnum.Value2;
			WebFile[] a = new WebFile[2];
			a[0] = y1;
			a[1] = y2;
			x.WebFiles = a;
			Console.WriteLine("Binary 序列化:");
			byte[] buffer = SerializerHelper.ObjectToBinary<WebDirectory>(x);
			Console.WriteLine("Binary 反序列化:");
			Console.WriteLine("Binary Serialize bytes Length:{0}", buffer.Length);
			WebDirectory z = SerializerHelper.BinaryToObject<WebDirectory>(buffer);
			Console.WriteLine(z.WebFiles[0].Name);
			Console.WriteLine(z.WebFiles[0].Url);
			Console.WriteLine(z.WebFiles[0].Flag);
			Console.WriteLine(z.WebFiles[1].Flag);
			Encoding e = Encoding.UTF8;
			e = Encoding.GetEncoding("gb2312");
			//e = Encoding.BigEndianUnicode;
			MemoryStream stream = new MemoryStream();
			XmlTextWriter writer = new XmlTextWriter(stream, e);
			XmlSerializer serializer = new XmlSerializer(x.GetType());
			string xml = SerializerHelper.ObjectToXml<WebDirectory>
													(
														x
														, writer
														, serializer
													);
			Console.WriteLine("Xml序列化: {0}", xml.Length);
			Console.WriteLine(xml);
			Console.WriteLine("Xml反序列化:");
			z = SerializerHelper.XmlToObject<WebDirectory>(xml);
			Console.WriteLine(z.WebFiles[0].Name);
			Console.WriteLine(z.WebFiles[0].Url);
			Console.WriteLine(z.WebFiles[0].Flag);
			Console.WriteLine(z.WebFiles[1].Flag);
			stream = new MemoryStream();
			buffer = e.GetPreamble();
			stream.Write(buffer, 0, buffer.Length);
			buffer = e.GetBytes(xml);
			Console.WriteLine("Xml Serialize bytes Length:{0}", buffer.Length);
			stream.Write(buffer, 0, buffer.Length);
			stream.Position = 0;
			XmlReader reader = XmlReader.Create(stream);
			while (reader.Read())
			{
				if (reader.NodeType == XmlNodeType.EndElement)
				{
					continue;
				}
				Console.Write("NodeType{0}: NodeName:{1}", reader.NodeType, reader.Name);
				if (reader.HasValue)
				{
					Console.Write(" NodeValue:{0}", reader.Value);
				}
				Console.WriteLine();
				if (reader.HasAttributes)
				{
					while (reader.MoveToNextAttribute())
					{
						Console.WriteLine("Attribute:{0}={1}", reader.Name, reader.Value);
					}
				}
				//Console.ReadLine();
			}
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Test.Share
{
	using System;
	using System.Xml.Serialization;
	[XmlRoot("WebDirectory")]
	[Serializable]
	public class WebDirectory
	{
		[XmlAttribute("Name")]
		public string Name;
		[XmlArrayItem("WebFile", typeof(WebFile))]
		[XmlArray("WebFiles")]
		public WebFile[] WebFiles;
	}
	public enum FlagEnum : uint
	{
		Value1
		, Value2
	}
	[Serializable]
	public class WebFile
	{
		[XmlAttribute("Name")]
		public string Name;
		[XmlAttribute("CreateTime")]
		public DateTime CreateTime;
		[XmlAttribute("LastWriteTime")]
		[XmlIgnore()]
		public DateTime LastWriteTime;
		[XmlAttribute("Length")]
		public long Length;
		//[XmlAttribute("Url")]
		[XmlElement("Url")]
		public string Url;
		[XmlAttribute("IsReadOnly")]
		public bool IsReadOnly;
		[XmlAttribute("Flag")]
		public FlagEnum Flag;
		[XmlElement("Directory")]
		public WebDirectory Directory;
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using System.Runtime.Serialization.Formatters.Binary;
	using System.Runtime.Serialization.Formatters.Soap;
	public static class SerializerHelper
	{

		public static T XmlToObject<T>(string Xml)
		{
			StringReader stringReader = new StringReader(Xml);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			return (T) serializer.Deserialize(xmlReader);
		}
		public static string ObjectToXml<T>
									(
										T Object
										, XmlTextWriter writer
										, XmlSerializer serializer
									)
		{
			serializer.Serialize(writer, Object);
			MemoryStream stream = writer.BaseStream as MemoryStream;
			byte[] bytes = stream.ToArray();
			Encoding e = EncodingHelper.IdentifyEncoding
											(
												bytes
												, Encoding.GetEncoding("gb2312")
///												, new Encoding[]
///														{
///															Encoding.UTF8
///															, Encoding.Unicode
///														}
											);
			byte[] buffer = e.GetPreamble();
			int offset = buffer.Length;
			buffer = new byte[bytes.Length - offset];
			Buffer.BlockCopy(bytes, offset, buffer, 0, buffer.Length);
			string s = e.GetString(buffer);
			return s;
		}
		public static string ObjectToXml<T>(T Object, Encoding e)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			using (MemoryStream stream = new MemoryStream())
			{
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = ObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static byte[] ObjectToBinary<T>
									(
										T Object
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				formater.Serialize(stream, Object);
				byte[] buffer = stream.ToArray();
				return buffer;
			}
		}
		public static T BinaryToObject<T>
									(
										byte[] data
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T Object = (T) formater.Deserialize(stream);
				return Object;
			}
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	using System.Text;
	using System.Collections.Generic;
	public static class EncodingHelper
	{
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, identifyEncodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
									)
		{
			EncodingInfo[] encodingInfos = Encoding.GetEncodings();
			List<Encoding> list = new List<Encoding>();
			foreach (EncodingInfo info in encodingInfos)
			{
				Encoding e = info.GetEncoding();
				if (e.GetPreamble().Length > 0)
				{
					list.Add(e);
					System.Console.WriteLine(e.EncodingName);
				}
			}
			Encoding[] encodings = new Encoding[list.Count];
			list.CopyTo(encodings);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, encodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			Encoding encoding = defaultEncoding;
			foreach (Encoding e in identifyEncodings)
			{
				byte[] buffer = e.GetPreamble();
				int l = buffer.Length;
				if (l == 0)
				{
					continue;
				}
				bool flag = false;
				for (int i = 0; i < l; i++)
				{
					if (buffer[i] != data[i])
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				else
				{
					encoding = e;
				}
			}
			return encoding;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=XmlEncoderHelper
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			string text = "`~!@#$%^&*()_+-=\t{}|[]\\://\";'<>?,./\r\n ";
			text += "～！＃￥％…＆×（）――＋・－＝｛｝｜【】＼：“”；‘’＇＜＞？，．／　";
			Console.WriteLine("orginal text: {0}", text);
			string s = XmlEncodeHelper.XmlAttributeValueEncode(text);
			Console.WriteLine("XmlAttributeValueEncode: {0}", s);
			string ss = XmlEncodeHelper.XmlAttributeValueDecode(s);
			Console.WriteLine("XmlAttributeValueDecode: {0}", ss);
			Console.WriteLine("{0}", (ss == text ? true : false));
			s = XmlEncodeHelper.XmlElementValueEncode(text);
			Console.WriteLine("XmlElementValueEncode: {0}", s);
			ss = XmlEncodeHelper.XmlElementValueDecode(s);
			Console.WriteLine("XmlElementValueDecode: {0}", ss);
			Console.WriteLine("{0}", (ss == text ? true : false));
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	public static class XmlEncodeHelper
	{
		public static string XmlAttributeValueEncode
						(
							string text
						)
		{
			XmlDocument document = GenerateXmlDocument(text);
			XmlNode node = document.DocumentElement.SelectSingleNode("Element");
			text = node.Attributes["EncodedAttributeValue"].InnerXml;
			return text;
		}
		public static string XmlElementValueEncode
						(
							string text
						)
		{
			XmlDocument document = GenerateXmlDocument(text);
			XmlNode node = document.DocumentElement.SelectSingleNode("Element/EncodedElementValue");
			text = node.InnerXml;
			return text;
		}
		public static string XmlAttributeValueDecode(string xml)
		{
			XmlDocument document = GenerateXmlDocument("");
			XmlNode node = document.DocumentElement.SelectSingleNode("Element");
			node.Attributes["EncodedAttributeValue"].InnerXml = xml;
			string s = node.Attributes["EncodedAttributeValue"].InnerText;
			return s;
		}
		public static string XmlElementValueDecode(string xml)
		{
			XmlDocument document = GenerateXmlDocument("");
			XmlNode node = document.DocumentElement.SelectSingleNode("Element/EncodedElementValue");
			node.InnerXml = xml;
			string s = node.InnerText;
			return s;
		}

		private static XmlDocument GenerateXmlDocument(string text)
		{
			EncodedElement y = new EncodedElement();
			y.EncodedAttributeValue = text;
			y.EncodedElementValue = text;
			XmlEncoder x = new XmlEncoder();
			x.Element = y;
			Encoding e = Encoding.UTF8;
			MemoryStream stream = new MemoryStream();
			XmlTextWriter writer = new XmlTextWriter(stream, e);
			XmlSerializer serializer = new XmlSerializer(x.GetType());
			string xml = SerializerHelper.ObjectToXml<XmlEncoder>
													(
														x
														, writer
														, serializer
													);
			XmlDocument document = new XmlDocument();
			document.LoadXml(xml);
			return document;
		}
	}
	[XmlRoot("XmlEncoder")]
	[Serializable]
	public class XmlEncoder
	{
		[XmlElement("Element")]
		public EncodedElement Element;
	}
	[Serializable]
	public class EncodedElement
	{
		[XmlAttribute("EncodedAttributeValue")]
		public string EncodedAttributeValue;
		[XmlElement("EncodedElementValue")]
		public string EncodedElementValue;
	}
}





namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Text;
	using System.Xml;
	using System.Xml.Serialization;
	using System.Runtime.Serialization.Formatters.Binary;
	using System.Runtime.Serialization.Formatters.Soap;
	public static class SerializerHelper
	{

		public static T XmlToObject<T>(string Xml)
		{
			StringReader stringReader = new StringReader(Xml);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			return (T) serializer.Deserialize(xmlReader);
		}
		public static string ObjectToXml<T>
									(
										T Object
										, XmlTextWriter writer
										, XmlSerializer serializer
									)
		{
			serializer.Serialize(writer, Object);
			MemoryStream stream = writer.BaseStream as MemoryStream;
			byte[] bytes = stream.ToArray();
			Encoding e = EncodingHelper.IdentifyEncoding
											(
												bytes
												, Encoding.GetEncoding("gb2312")
///												, new Encoding[]
///														{
///															Encoding.UTF8
///															, Encoding.Unicode
///														}
											);
			byte[] buffer = e.GetPreamble();
			int offset = buffer.Length;
			buffer = new byte[bytes.Length - offset];
			Buffer.BlockCopy(bytes, offset, buffer, 0, buffer.Length);
			string s = e.GetString(buffer);
			return s;
		}
		public static string ObjectToXml<T>(T Object, Encoding e)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(T));
			using (MemoryStream stream = new MemoryStream())
			{
				XmlTextWriter writer = new XmlTextWriter(stream, e);
				string s = ObjectToXml<T>
									(
										Object
										, writer
										, serializer
									);
				writer.Close();
				writer = null;
				return s;
			}
		}
		public static byte[] ObjectToBinary<T>
									(
										T Object
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				formater.Serialize(stream, Object);
				byte[] buffer = stream.ToArray();
				return buffer;
			}
		}
		public static T BinaryToObject<T>
									(
										byte[] data
									)
		{
			using (MemoryStream stream = new MemoryStream())
			{
				BinaryFormatter formater = new BinaryFormatter();
				stream.Write(data, 0, data.Length);
				stream.Position = 0;
				T Object = (T) formater.Deserialize(stream);
				return Object;
			}
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	using System.Text;
	using System.Collections.Generic;
	public static class EncodingHelper
	{
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, identifyEncodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
									)
		{
			EncodingInfo[] encodingInfos = Encoding.GetEncodings();
			List<Encoding> list = new List<Encoding>();
			foreach (EncodingInfo info in encodingInfos)
			{
				Encoding e = info.GetEncoding();
				if (e.GetPreamble().Length > 0)
				{
					list.Add(e);
					//System.Console.WriteLine(e.EncodingName);
				}
			}
			Encoding[] encodings = new Encoding[list.Count];
			list.CopyTo(encodings);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, encodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			Encoding encoding = defaultEncoding;
			foreach (Encoding e in identifyEncodings)
			{
				byte[] buffer = e.GetPreamble();
				int l = buffer.Length;
				if (l == 0)
				{
					continue;
				}
				bool flag = false;
				for (int i = 0; i < l; i++)
				{
					if (buffer[i] != data[i])
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				else
				{
					encoding = e;
				}
			}
			return encoding;
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int) l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=XmlSerializersCache
namespace ConsoleApplication
{
	using System;
	using System.Linq;
	using Microshaoft;
	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			XmlSerializersCache.Load
					(
						(x, y) =>
						{
							var r = false;
							if (x.IsSerializable)
							{ 
								var attributes = x.GetCustomAttributes(typeof(XmlSerializableTypeAttribute), false);
								if (attributes != null && attributes.Length > 0)
								{
									r = true;
								}
							}
							return r;
						}
					);
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	//using System.Diagnostics;
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
	public class XmlSerializableTypeAttribute : Attribute
	{
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Concurrent;
	using System.Linq;
	using System.Reflection;
	using System.Xml.Serialization;
	public static class XmlSerializersCache
	{
		private static ConcurrentDictionary<string, XmlSerializer> _data = new ConcurrentDictionary<string, XmlSerializer>();
		public static XmlSerializer GetXmlSerializer(Type type)
		{
			XmlSerializer serializer = null;
			if (!XmlSerializersCache.Data.TryGetValue(type.FullName, out serializer))
			{
				serializer = new XmlSerializer(type);
				XmlSerializersCache.Data.TryAdd(type.FullName, serializer);
			}
			return serializer; // serializer;
		}
		public static XmlSerializer GetXmlSerializer(string typeFullName)
		{
			var type = Type.GetType(typeFullName);
			return GetXmlSerializer(type);
		}
		public static ConcurrentDictionary<string, XmlSerializer> Data
		{
			get { return _data; }
		}
		public static void Load(Func<Type, Assembly, bool> predicateFunc)
		{
			var assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (var assembly in assemblies)
			{
				var types = assembly.GetLoadableTypes().Where
				(
					(x) =>
					{
						return predicateFunc(x, assembly);
					}
				);
				foreach (var type in types)
				{
					_data.TryAdd
						(
							type.FullName
							, new XmlSerializer(type) 
						);
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Reflection;
	using System.Collections.Generic;
	public static class ExtensionsMethodsManager
	{
		public static IEnumerable<Type> GetLoadableTypes(this Assembly assembly)
		{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			try
			{
				return assembly.GetTypes();
			}
			catch (ReflectionTypeLoadException e)
			{
				return e.Types.Where
								(
									(x) => 
									{
										return x != null;
									}
								);
			}
		}
	}
}

#T=XSLT XslCompiledTransform Helper
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Xml.Xsl;
	using System.Xml;
	using System.IO;
	public static class XslCompiledTransformHelper
	{
		public static string Transform(string xsl, string xml)
		{
			XslCompiledTransform xslt = new XslCompiledTransform();
			StringReader stringReader = new StringReader(xsl);
			XmlReader xmlReader = XmlReader.Create(stringReader);
			xslt.Load(xmlReader);
			stringReader = new StringReader(xml);
			xmlReader = XmlReader.Create(stringReader);
			XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
			//xmlWriterSettings.Encoding = Encoding.UTF8;
			xmlWriterSettings.Indent = true;
			xmlWriterSettings.OmitXmlDeclaration = true;
			Stream stream = new MemoryStream();
			XmlWriter xmlWriter = XmlWriter.Create(stream, xmlWriterSettings);
			xslt.Transform
						(
							xmlReader
							, xmlWriter
						);
			byte[] buffer = StreamDataHelper.ReadDataToBytes(stream);
			Encoding e = EncodingHelper.IdentifyEncoding(stream, Encoding.Default);
			int offset = e.GetPreamble().Length;
			string s = e.GetString(buffer, offset, buffer.Length - offset);

			return s;
		}
	
	
	}



	
}
namespace Test
{
	using System;
	using Microshaoft;
	class Program
	{
		static void Main(string[] args)
		{
			
			string xsl =
@"<xsl:stylesheet xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" version=""1.0"">
	<xsl:template match=""bookstore"">
		<HTML>
			<BODY>
				<TABLE BORDER=""2"">
					<TR>
						<TD>ISBN</TD>
						<TD>Title</TD>
						<TD>Price</TD>
					</TR>
					<xsl:apply-templates select=""book""/>
				</TABLE>
			</BODY>
		</HTML>
	</xsl:template>
	<xsl:template match=""book"">
		<TR>
			<TD>
				<xsl:value-of select=""@ISBN""/>
			</TD>
			<TD>
				<xsl:value-of select=""title""/>
			</TD>
			<TD>
				<xsl:value-of select=""price""/>
			</TD>
		</TR>
	</xsl:template>
</xsl:stylesheet>
";
			string xml =
@"<?xml version=""1.0""?>
<!-- This file represents a fragment of a book store inventory database -->
<bookstore>
	<book genre=""autobiography"" publicationdate=""1981"" ISBN=""1-861003-11-0"">
		<title>
			The Autobiography of Benjamin Franklin
		</title>
		<author>
			<first-name>
				Benjamin
			</first-name>
			<last-name>
				Franklin
			</last-name>
		</author>
		<price>
			8.99
		</price>
	</book>
	<book genre=""novel"" publicationdate=""1967"" ISBN=""0-201-63361-2"">
		<title>
			The Confidence Man
		</title>
		<author>
			<first-name>
				Herman
			</first-name>
			<last-name>
				Melville
			</last-name>
		</author>
		<price>
			11.99
		</price>
	</book>
	<book genre=""philosophy"" publicationdate=""1991"" ISBN=""1-861001-57-6"">
		<title>
			The Gorgias
		</title>
		<author>
			<name>
				Plato
			</name>
		</author>
		<price>
			于溪h
		</price>
	</book>
</bookstore>";
			string s = XslCompiledTransformHelper.Transform(xsl, xml);
			Console.WriteLine(s);
			Console.ReadLine();
		}
	}

}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Linq;
	using System.Text;
	using System.Collections.Generic;
	public static class EncodingHelper
	{
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, identifyEncodings
						);
		}
		public static Encoding IdentifyEncoding
									(
										Stream stream
										, Encoding defaultEncoding
									)
		{
			byte[] data = StreamDataHelper.ReadDataToBytes(stream);
			return IdentifyEncoding
						(
							data
							, defaultEncoding
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
									)
		{

			var list = new List<Encoding>();
			Encoding.GetEncodings().Where
							(
								(x) =>
								{
									var e = x.GetEncoding();
									var r = (e.GetPreamble().Length > 0);
									if (r)
									{
										list.Add(e);
									}
									return r;
								}
							).ToList();
			return IdentifyEncoding
						(
							data
							, defaultEncoding
							, list.ToArray()
						);
		}
		public static Encoding IdentifyEncoding
									(
										byte[] data
										, Encoding defaultEncoding
										, Encoding[] identifyEncodings
									)
		{
			Encoding encoding = defaultEncoding;
			foreach (Encoding e in identifyEncodings)
			{
				byte[] buffer = e.GetPreamble();
				int l = buffer.Length;
				bool b = true;
				int i = 0;
				for (i = 0; i < l; i++)
				{
					if (buffer[i] != data[i])
					{
						b = false;
						break;
					}
				}
				if (i > 0 && b)
				{
					encoding = e;
					break;
				}
			}
			return encoding;
		}
	}
}
//==========================================================================================================
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}


#T=Xss Attack Simple Sample
<!--
Xss Attack
http://test.ctvap.cn/XssAttack.aspx?q1=sina<script>alert('onload')</script>&q2=javascript:alert('href=javascript')
-->
	
	<%@ Page ValidateRequest="false"  %>

	<%@ Import Namespace="System.Data" %>
	<%@ Import Namespace="System.Data.SqlClient" %>
	<%@ Import Namespace="System.Security.Principal" %>
	<%@ Import Namespace="System.IO" %>
	<script language="C#" runat="server">
	protected void Page_Load(object sender, EventArgs ea) 
	{
		WindowsPrincipal wp = new WindowsPrincipal(WindowsIdentity.GetCurrent());
		string username = wp.Identity.Name;
		Response.Write("<br>windows/domain user: " + username + "<br>" );
		Response.Write(".Net Framework version: " + Environment.Version.ToString()+ "<br>" );

		h1.Text = "test";
		h1.Text = Request.QueryString["q1"];
		h1.NavigateUrl = Request.QueryString["q2"];

///		Response.Write("IP:<br>");
///		Response.Write(string.Format("Your current IP is {0}<br>", Request.UserHostAddress));
///
///		Response.Write("Cookies:<br>");
///		foreach (string var in Request.Cookies.AllKeys)
///		{
///			Response.Write(string.Format("{0}:{1}<br>", var, Request.Cookies[var].Value));
///		}
///
///		Response.Write("Request.Form:<br>");
///		foreach (string var in Request.Form.AllKeys)
///		{
///			Response.Write(string.Format("{0}:{1}<br>", var, Request.Form[var]));
///		}
///
///		Response.Write("Request.QueryString:<br>");
///		foreach (string var in Request.QueryString.AllKeys)
///		{
///			Response.Write(string.Format("{0}:{1}<br>", var, Request.QueryString[var]));
///		}
///
///		Response.Write("Request.ServerVariables:<br>");
///		foreach (string var in Request.ServerVariables.AllKeys)
///		{
///			Response.Write(string.Format("{0}:{1}<br>", var, Request.ServerVariables[var]));
///		}
	}
	</script>

	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" >
	<HTML>

		<HEAD>
			<title>WebForm1</title>
			<meta name="GENERATOR" Content="Microsoft Visual Studio .NET 7.1">
			<meta name="CODE_LANGUAGE" Content="C#">
			<meta name="vs_defaultClientScript" content="JavaScript">
			<meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5">
		</HEAD>
		<body MS_POSITIONING="GridLayout">
			<form id="Form1" method="post" runat="server">

				<asp:Hyperlink ID="h1" runat="server" />
			
			</form>
		</body>
	</HTML>
#T=XSS 不安全 Server 控件
https://blogs.msdn.com/sfaust/archive/2008/09/02/which-asp-net-controls-automatically-encodes.aspx
https://blogs.msdn.com/sfaust/attachment/8918996.ashx
http://msmvps.com/blogs/calinoiu/archive/2006/06/13/102957.aspx

#T=yield
namespace GenericIteratorExample
{
	using System.Collections;
	using System.Collections.Generic;
	public class Stack<T> : IEnumerable<T>
	{
		private T[] values = new T[100];
		private int top = 0;
		public void Push(T t)
		{
			values[top++] = t;
		}
		public T Pop()
		{
			return values[--top];
		}
		// These make Stack<T> implement IEnumerable<T> allowing
		// a stack to be used in a foreach statement.
		public IEnumerator<T> GetEnumerator()
		{
			for (int i = top; --i >= 0; )
			{
				yield return values[i];
			}
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
		// Iterate from top to bottom.
		public IEnumerable<T> TopToBottom
		{
			get
			{
				// Since we implement IEnumerable<T>
				// and the default iteration is top to bottom,
				// just return the object.
				return this;
			}
		}
		// Iterate from bottom to top.
		public IEnumerable<T> BottomToTop
		{
			get
			{
				for (int i = 0; i < top; i++)
				{
					yield return values[i];
				}
			}
		}
		//A parameterized iterator that return n items from the top
		public IEnumerable<T> TopN(int n)
		{
			// in this example we return less than N if necessary 
			int j = n >= top ? 0 : top - n;
			for (int i = top; --i >= j; )
			{
				yield return values[i];
			}
		}
	}
	//This code uses a stack and the TopToBottom and BottomToTop properties 
	//to enumerate the elements of the stack.
	class Test
	{
		static void Main()
		{
			Stack<int> s = new Stack<int>();
			for (int i = 0; i < 10; i++)
			{
				s.Push(i);
			}
			// Prints: 9 8 7 6 5 4 3 2 1 0
			// Foreach legal since s implements IEnumerable<int>
			foreach (int n in s)
			{
				System.Console.Write("{0} ", n);
			}
			System.Console.WriteLine();
			// Prints: 9 8 7 6 5 4 3 2 1 0
			// Foreach legal since s.TopToBottom returns IEnumerable<int>
			foreach (int n in s.TopToBottom)
			{
				System.Console.Write("{0} ", n);
			}
			System.Console.WriteLine();
			// Prints: 0 1 2 3 4 5 6 7 8 9
			// Foreach legal since s.BottomToTop returns IEnumerable<int>
			foreach (int n in s.BottomToTop)
			{
				System.Console.Write("{0} ", n);
			}
			System.Console.WriteLine();
			// Prints: 9 8 7 6 5 4 3
			// Foreach legal since s.TopN returns IEnumerable<int>
			foreach (int n in s.TopN(7))
			{
				System.Console.Write("{0} ", n);
			}
			System.Console.WriteLine();
		}
	}
}
#T=yield AsyncEnumerator
namespace Microshaoft
{
	using System;
	using System.Collections;
	class AsyncEnumerator
	{
		IEnumerator enumerator;
		AsyncCallback end;
		public IAsyncResult CurrentAr
		{
			get;
			set;
		}
		public void EndAction(IAsyncResult Ar)
		{
			CurrentAr = Ar;
			if (!enumerator.MoveNext())
			{
				end(Ar);
			}
		}
		public void Start(IEnumerator Enumerator, AsyncCallback End)
		{
			enumerator = Enumerator;
			if (enumerator.MoveNext())
			{
				end = End;
			}
		}
	}
}
namespace Test
{
	using System;
	using System.IO;
	using System.Text;
	using System.Collections;
	using Microshaoft;
	class Program
	{
		static MemoryStream data = new MemoryStream();
		static void Main(string[] args)
		{
			AsyncEnumerator Ae = new AsyncEnumerator();
			IEnumerator ie = ReadFile(Ae, data).GetEnumerator();
			Ae.Start(ie, End);
			Console.Read();
		}
		static void End(IAsyncResult Ar)
		{
			string txt = Encoding.UTF8.GetString(data.ToArray());
			Console.WriteLine(txt);
		}
		static IEnumerable ReadFile(AsyncEnumerator Ae, MemoryStream Data)
		{
			int rc = 0;
			long total = 0;
			FileInfo fi = new FileInfo(@"D:\EditPlus.v3.11.b421.zip");
			byte[] bf = new byte[1024];
			using (FileStream fs = new FileStream(fi.FullName, FileMode.Open, FileAccess.Read))
			{
				fs.BeginRead(bf, 0, 1024, Ae.EndAction, null);
				yield return 1;
				while (true)
				{
					rc = fs.EndRead(Ae.CurrentAr);
					total += rc;
					Data.Write(bf, 0, rc);
					if (total >= fi.Length)
					{
						fs.Close();
						break;
					}
					else
					{
						fs.BeginRead(bf, 0, 1024, Ae.EndAction, null);
						yield return 1;
					}
				}
				yield break;
			}
		}
	}
}
#T=yield foreach
namespace ConsoleApplication6
{
	using System;
	using System.Collections.Generic;
	class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine("下面的例子是用yield return语句实现一个简单集合的代码，以及用foreach语句迭代集合");
			HelloCollection helloCollection = new HelloCollection();
			foreach (string s in helloCollection)
			{
				Console.WriteLine(s);
				Console.ReadLine();
			}
			Console.WriteLine("使用yield return语句实现以不同方式迭代集合的类");
			MusicTitles titles = new MusicTitles();
			foreach (string title in titles)
			{
				Console.WriteLine(title);
			}
			Console.WriteLine();
			foreach (string title in titles.Reverse())
			{
				Console.WriteLine(title);
			}
			Console.WriteLine();
			foreach (string title in titles.Subset(2, 2))
			{
				Console.WriteLine(title);
				Console.ReadLine();
			}
		}
	}
	public class HelloCollection
	{
		public IEnumerator<string> GetEnumerator()
		{
			// yield return语句返回集合的一个元素，并移动到下一个元素上；yield break可以停止迭代
			yield return "Hello";
			yield return "World";
		}
	}
	public class MusicTitles
	{
		string[] names = { "a", "b", "c", "d" };
		public IEnumerator<string> GetEnumerator()
		{
			for (int i = 0; i < 4; i++)
			{
				yield return names[i];
			}
		}
		public IEnumerable<string> Reverse()
		{
			for (int i = 3; i >= 0; i--)
			{
				yield return names[i];
			}
		}
		public IEnumerable<string> Subset(int index, int length)
		{
			for (int i = index; i < index + length; i++)
			{
				yield return names[i];
			}
		}
	}
}

#T=yield Multi Threads
namespace Test
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using Microshaoft;
	public class MyClass
	{
		public static void RunSnippet()
		{
			ThreadLite tl = new ThreadLite();
			tl.AddActor(T1);
			tl.AddActor(T1);
			tl.Run();
		}
		public static IEnumerable T1(int id)
		{
			for (int i = 0; i < 10; i++)
			{
				Console.WriteLine("Thread "+id+" print "+i);
				yield return id;
			}
		}
		public static IEnumerable T2(int id)
		{
			for (int i = 0; i < 8; i++)
			{
				Console.WriteLine("Thread "+id+" print "+i);
				yield return id;
			}
		}
		public static void Main()
		{
			try
			{
				RunSnippet();
			}
			catch (Exception e)
			{
				string error = string.Format("---\nThe following error occurred while executing the snippet:\n{0}\n---", e.ToString());
				Console.WriteLine(error);
			}
			finally
			{
				Console.Write("Press any key to continue");
				Console.ReadKey();
			}
		}
		private static void WL(object text, params object[] args)
		{
			Console.WriteLine(text.ToString(), args);	
		}
		
		private static void RL()
		{
			Console.ReadLine();	
		}
		private static void Break() 
		{
			System.Diagnostics.Debugger.Break();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	class ThreadLite
	{
		int currentid = 1;
		public delegate IEnumerable ActorHandler(int id);
		private List<IEnumerator> ActionList;
		public ThreadLite()
		{
			ActionList = new List<IEnumerator>();
		}
		public void AddActor(ActorHandler actor)
		{
			Actor act=new Actor(actor);
			act.ID=this.currentid;
			ActionList.Add(act.GetEnumerator());
			this.currentid++;
		}
		public void Run()
		{
			int fc = 0;
			while (true)
			{
				foreach (IEnumerator ie in ActionList)
				{
					if (!ie.MoveNext())
					{
						fc++;
					}
				}
				if (fc == ActionList.Count)
				{
					break;
				}
			}
		}
		class Actor
		{
			public int ID
			{
				get;
				set;
			}
			ThreadLite.ActorHandler hdl;
			public Actor(ThreadLite.ActorHandler handler)
			{
				hdl = handler;
			}
			public IEnumerator GetEnumerator()
			{
				IEnumerable ieb = hdl (ID);
				return ieb.GetEnumerator();
			}
		}
	}	
}
#T=yield simple
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	class Class1
	{
		public static class NumberList
		{
			// Create an array of integers.
			public static int[] ints = { 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377 };

			// Define a property that returns only the even numbers.
			public static IEnumerable<int> GetEven()
			{
				// Use yield to return the even numbers in the list.
				foreach (int i in ints)
				{
					if (i % 2 == 0)
					{
						yield return i;
					}
				}
			}
			// Define a property that returns only the even numbers.
			public static IEnumerable<int> GetOdd()
			{
				// Use yield to return only the odd numbers.
				foreach (int i in ints)
				{
					if (i % 2 == 1)
					{
						yield return i;
					}
				}
			}
		}
		static void Main(string[] args)
		{
			// Display the even numbers.
			Console.WriteLine("Even numbers");
			foreach (int i in NumberList.GetEven())
			{
				Console.WriteLine(i);
			}
			// Display the odd numbers.
			Console.WriteLine("Odd numbers");
			foreach (int i in NumberList.GetOdd())
			{
				Console.WriteLine(i);
			}
		}
	}
}

#T=zip gz
namespace ConsoleApplication
{
	using System;
	using System.IO;
	using System.IO.Compression;
	class Program
	{
		static void Main(string[] args)
		{
			string startPath = @"c:\example\start";
			string zipPath = @"c:\example\result.zip";
			string extractPath = @"c:\example\extract";
			ZipFile.CreateFromDirectory(startPath, zipPath);
			ZipFile.ExtractToDirectory(zipPath, extractPath);
		}
	}
}
namespace ConsoleApplication1
{
	using System;
	using System.IO;
	using System.IO.Compression;
	class Program
	{
		static void Main(string[] args)
		{
			string zipPath = @"c:\example\start.zip";
			string extractPath = @"c:\example\extract";
			using (ZipArchive archive = ZipFile.OpenRead(zipPath))
			{
				foreach (ZipArchiveEntry entry in archive.Entries)
				{
					if (entry.FullName.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
					{
						entry.ExtractToFile(Path.Combine(extractPath, entry.FullName));
					}
				}
			}
		}
	}
}
namespace ConsoleApplication2
{
	using System;
	using System.IO;
	using System.IO.Compression;
	class Program
	{
		static void Main(string[] args)
		{
			using (FileStream zipToOpen = new FileStream(@"c:\users\exampleuser\release.zip", FileMode.Open))
			{
				using (ZipArchive archive = new ZipArchive(zipToOpen, ZipArchiveMode.Update))
				{
					ZipArchiveEntry readmeEntry = archive.CreateEntry("Readme.txt");
					using (StreamWriter writer = new StreamWriter(readmeEntry.Open()))
					{
							writer.WriteLine("Information about this package.");
							writer.WriteLine("========================");
					}
				}
			}
		}
	}
}
namespace GZIP
{
	using System;
	using System.IO;
	using System.IO.Compression;
	public class Program
	{
		public static void Main()
		{
			string directoryPath = @"c:\users\public\reports";
			DirectoryInfo directorySelected = new DirectoryInfo(directoryPath);
			foreach (FileInfo fileToCompress in directorySelected.GetFiles())
			{
				Compress(fileToCompress);
			}
			foreach (FileInfo fileToDecompress in directorySelected.GetFiles("*.gz"))
			{
				Decompress(fileToDecompress);
			}
		}
		public static void Compress(FileInfo fileToCompress)
		{
			using (FileStream originalFileStream = fileToCompress.OpenRead())
			{
				if ((File.GetAttributes(fileToCompress.FullName) & FileAttributes.Hidden) != FileAttributes.Hidden & fileToCompress.Extension != ".gz")
				{
					using (FileStream compressedFileStream = File.Create(fileToCompress.FullName + ".gz"))
					{
						using (GZipStream compressionStream = new GZipStream(compressedFileStream, CompressionMode.Compress))
						{
							originalFileStream.CopyTo(compressionStream);
							Console.WriteLine("Compressed {0} from {1} to {2} bytes.",
								fileToCompress.Name, fileToCompress.Length.ToString(), compressedFileStream.Length.ToString());
						}
					}
				}
			}
		}
		public static void Decompress(FileInfo fileToDecompress)
		{
			using (FileStream originalFileStream = fileToDecompress.OpenRead())
			{
				string currentFileName = fileToDecompress.FullName;
				string newFileName = currentFileName.Remove(currentFileName.Length - fileToDecompress.Extension.Length);
				using (FileStream decompressedFileStream = File.Create(newFileName))
				{
					using (GZipStream decompressionStream = new GZipStream(originalFileStream, CompressionMode.Decompress))
					{
						decompressionStream.CopyTo(decompressedFileStream);
						Console.WriteLine("Decompressed: {0}", fileToDecompress.Name);
					}
				}
			}
		}
	}
}

#T=Zip Package
// /r:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\Profile\Client\WindowsBase.dll"
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.IO;
	using System.IO.Packaging;
	public class ZipHandler
	{
		public static void Compress(FileInfo fi, DirectoryInfo dir)
		{
			if (fi.Exists)
			{
				fi.Delete();
			}
			Package zipFilePackage = ZipPackage.Open(fi.FullName, FileMode.OpenOrCreate, FileAccess.ReadWrite);
			foreach (FileInfo physicalFile in dir.GetFiles())
			{
				string physicalfilePath = physicalFile.FullName;
				Uri partUri = PackUriHelper.CreatePartUri(new Uri(physicalFile.Name, UriKind.Relative));
				PackagePart newFilePackagePart = zipFilePackage.CreatePart(partUri, System.Net.Mime.MediaTypeNames.Text.Xml);
				byte[] fileContent = File.ReadAllBytes(physicalfilePath);
				newFilePackagePart.GetStream().Write(fileContent, 0, fileContent.Length);
			}
			foreach (DirectoryInfo subDir in dir.GetDirectories())
			{
				foreach (FileInfo physicalFile in subDir.GetFiles())
				{
					string physicalfilePath = physicalFile.FullName;
					Uri partUri = PackUriHelper.CreatePartUri(new Uri(subDir.Name + "/" + physicalFile.Name, UriKind.Relative));
					PackagePart newFilePackagePart = zipFilePackage.CreatePart(partUri, System.Net.Mime.MediaTypeNames.Text.Xml);
					byte[] fileContent = File.ReadAllBytes(physicalfilePath);
					newFilePackagePart.GetStream().Write(fileContent, 0, fileContent.Length);
				}
			}
			zipFilePackage.Close();
		}
		public static bool Decompress(FileInfo fi, string origName)
		{
			bool returnVal = false;
			string curFile = fi.FullName;
			Package zipFilePackage = ZipPackage.Open(curFile, FileMode.Open, FileAccess.ReadWrite);
			foreach (ZipPackagePart contentFile in zipFilePackage.GetParts())
			{
				CreateFile(origName, contentFile);
				returnVal = true;
			}
			zipFilePackage.Close();
			return returnVal;
		}
		private static void CreateFile(string rootFolder, ZipPackagePart contentFile)
		{
			// Initially create file under the folder specified
			string contentFilePath = string.Empty;
			contentFilePath = contentFile.Uri.OriginalString.Replace('/',
							 System.IO.Path.DirectorySeparatorChar);
			if (contentFilePath.StartsWith(
				System.IO.Path.DirectorySeparatorChar.ToString()))
			{
				contentFilePath = contentFilePath.TrimStart(
										 System.IO.Path.DirectorySeparatorChar);
			}
			else
			{
				//do nothing
			}
			contentFilePath = System.IO.Path.Combine(rootFolder, contentFilePath);
			//contentFilePath =  System.IO.Path.Combine(rootFolder, contentFilePath); 
			//Check for the folder already exists. If not then create that folder
			if (System.IO.Directory.Exists(
				System.IO.Path.GetDirectoryName(contentFilePath)) != true)
			{
				System.IO.Directory.CreateDirectory(
						  System.IO.Path.GetDirectoryName(contentFilePath));
			}
			else
			{
				//do nothing
			}
			System.IO.FileStream newFileStream =
					System.IO.File.Create(contentFilePath);
			newFileStream.Close();
			byte[] content = new byte[contentFile.GetStream().Length];
			contentFile.GetStream().Read(content, 0, content.Length);
			System.IO.File.WriteAllBytes(contentFilePath, content);
		}
	}
}

#T=关键字过滤 Trie
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Linq;
	class Program
	{
		static string text = "名字加fuck日本人妖";
		static HashFilter hf = new HashFilter();
		static TrieFilter tf = new TrieFilter();
		static FastFilter ff = new FastFilter();
		//static BadWordsFilter bf1 = new BadWordsFilter();
		//static BadWordsFilter2 bf2 = new BadWordsFilter2();
		//static BadWordsFilter3 bf3 = new BadWordsFilter3();
		//从文件读取关键字.
		static void ReadBadWord()
		{
			using (StreamReader sw = new StreamReader(File.OpenRead("BadWord.txt")))
			{
				Random random = new Random();
				string key = sw.ReadLine();
				while (key != null)
				{
					if (key != string.Empty)
					{
						hf.AddKey(key);
						tf.AddKey(key);
						ff.AddKey(key);
						//bf1.AddKey(key);
						//bf2.AddKey(key);
						//bf3.AddKey(key);
					}
					key = sw.ReadLine();
				}
			}
		}
		static void Test(int iteration, IWordFilter filter)
		{
			for (int i = 0; i < iteration; i++)
			{
				//hf.HasBadWord(text);
				var foundAll = filter
								.FindAll(text)
								.Distinct()
								.OrderBy
									(
										(x) =>
										{
											return x;
										}
									);
				var result = string.Empty;
				int ii = 0;
				foreach (var found in foundAll)
				{
					if (!string.IsNullOrEmpty(result))
					{
						result += ";";
					}
					result += found;
					ii++;
				}
				if (!string.IsNullOrEmpty(result))
				{
					Console.WriteLine("{1}{0}{2}{0}{3}", "\r\n", filter.GetType().Name ,ii, result);
					//Console.WriteLine("{2}", "\r\n", filter.GetType().Name, ii, result);
				}
			}
		}
		static void Main(string[] args)
		{
			ReadBadWord();
			CodeTimer.Initialize();
			using (StreamReader sw = new StreamReader(File.OpenRead("Talk.txt")))
			{
				string key = sw.ReadToEnd();
				while (key != null)
				{
					if (key != string.Empty)
					{
						Console.WriteLine("-------------开始测试-------------");
						Console.WriteLine(key);
						text = key;
						bool b1 = hf.HasBadWord(text);
						bool b2 = tf.HasBadWord(text);
						bool b3 = ff.HasBadWord(text);
						//bool b5 = bf1.HasBadWord(text);
						//bool b6 = bf2.HasBadWord(text);
						//bool b7 = bf3.HasBadWord(text);
						if (b1 != b2 || b2 != b3 || b3 != b1)
						{
							Console.WriteLine("有算法错误");
						}
						//CodeTimer.Time("原始", 50, TestHasBadWord1);
						//CodeTimer.Time("优化算法", 50, TestHasBadWord2);
						//CodeTimer.Time("优化hash和BitArray", 50, TestHasBadWord3);
						int innerIteration = 1;
						int outerIteration = 1;
						CodeTimer.Time("Trie", outerIteration, () => Test(innerIteration, tf));
						//CodeTimer.Time("Fast", outerIteration, () => Test(innerIteration, ff));
						//CodeTimer.Time("Hash", outerIteration, () => Test(innerIteration, hf));
						Console.WriteLine("推荐使用FastFilter或TrieFilter");
						//TrieFilter在处理大小写敏感 和 简繁体转换 方面有优势,还有去掉干扰字符也比较方面.
					}
					key = sw.ReadLine();
				}
			}
			Console.ReadKey();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Runtime.InteropServices;
	using System.Diagnostics;
	using System.Threading;
	public static class CodeTimer
	{
		public static void Initialize()
		{
			Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Time("", 1, () => { });
		}
		public static void Time(string name, int iteration, Action action)
		{
			if (String.IsNullOrEmpty(name)) return;
			// 1.
			ConsoleColor currentForeColor = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(name);
			// 2.
			GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
			int[] gcCounts = new int[GC.MaxGeneration + 1];
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				gcCounts[i] = GC.CollectionCount(i);
			}
			// 3.
			Stopwatch watch = new Stopwatch();
			watch.Start();
			ulong cycleCount = GetCurrentThreadTimes();
			for (int i = 0; i < iteration; i++) action();
			ulong cpuCycles = GetCurrentThreadTimes() - cycleCount;
			watch.Stop();
			// 4.
			Console.ForegroundColor = currentForeColor;
			Console.WriteLine("\tTime Elapsed:\t" + watch.ElapsedMilliseconds.ToString("N0") + "ms");
			Console.WriteLine("\tCPU Cycles:\t" + cpuCycles.ToString("N0"));
			// 5.
			for (int i = 0; i <= GC.MaxGeneration; i++)
			{
				int count = GC.CollectionCount(i) - gcCounts[i];
				Console.WriteLine("\tGen " + i + ": \t\t" + count);
			}
			Console.WriteLine();
		}
		private static ulong GetCycleCount()
		{
			ulong cycleCount = 0;
			QueryThreadCycleTime(GetCurrentThread(), ref cycleCount);
			return cycleCount;
		}
		private static ulong GetCurrentThreadTimes()
		{
			ulong l;
			ulong kernelTime, userTimer;
			GetThreadTimes(GetCurrentThread(), out l, out l, out kernelTime,
			   out userTimer);
			return kernelTime + userTimer;
		}
		//Vista和Server 2008中新的函数
		[DllImport("kernel32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		static extern bool QueryThreadCycleTime(IntPtr threadHandle, ref ulong cycleTime);
		[DllImport("kernel32.dll")]
		static extern IntPtr GetCurrentThread();
		[DllImport("kernel32.dll", SetLastError = true)]
		static extern bool GetThreadTimes(IntPtr hThread, out ulong lpCreationTime, out ulong lpExitTime, out ulong lpKernelTime, out ulong lpUserTime);
	}
}
namespace Microshaoft
{
	using System;
	using System.Diagnostics;
	public static partial class CharExtensions
	{
		const string simplify =	 "锕皑蔼碍爱嗳嫒瑷暧霭谙铵鹌肮袄奥媪骜鳌坝罢钯摆败呗颁办绊钣帮绑镑谤剥饱宝报鲍鸨龅辈贝钡狈备惫鹎贲锛绷笔毕毙币闭荜哔滗铋筚跸边编贬变辩辫苄缏笾标骠飑飙镖镳鳔鳖别瘪濒滨宾摈傧缤槟殡膑镔髌鬓饼禀拨钵铂驳饽钹鹁补钸财参蚕残惭惨灿骖黪苍舱仓沧厕侧册测恻层诧锸侪钗搀掺蝉馋谗缠铲产阐颤冁谄谶蒇忏婵骣觇禅镡场尝长偿肠厂畅伥苌怅阊鲳钞车彻砗尘陈衬伧谌榇碜龀撑称惩诚骋枨柽铖铛痴迟驰耻齿炽饬鸱冲冲虫宠铳畴踌筹绸俦帱雠橱厨锄雏础储触处刍绌蹰传钏疮闯创怆锤缍纯鹑绰辍龊辞词赐鹚聪葱囱从丛苁骢枞凑辏蹿窜撺错锉鹾达哒鞑带贷骀绐担单郸掸胆惮诞弹殚赕瘅箪当挡党荡档谠砀裆捣岛祷导盗焘灯邓镫敌涤递缔籴诋谛绨觌镝颠点垫电巅钿癫钓调铫鲷谍叠鲽钉顶锭订铤丢铥东动栋冻岽鸫窦犊独读赌镀渎椟牍笃黩锻断缎簖兑队对怼镦吨顿钝炖趸夺堕铎鹅额讹恶饿谔垩阏轭锇锷鹗颚颛鳄诶儿尔饵贰迩铒鸸鲕发罚阀珐矾钒烦贩饭访纺钫鲂飞诽废费绯镄鲱纷坟奋愤粪偾丰枫锋风疯冯缝讽凤沣肤辐抚辅赋复负讣妇缚凫驸绂绋赙麸鲋鳆钆该钙盖赅杆赶秆赣尴擀绀冈刚钢纲岗戆镐睾诰缟锆搁鸽阁铬个纥镉颍给亘赓绠鲠龚宫巩贡钩沟苟构购够诟缑觏蛊顾诂毂钴锢鸪鹄鹘剐挂鸹掴关观馆惯贯诖掼鹳鳏广犷规归龟闺轨诡贵刽匦刿妫桧鲑鳜辊滚衮绲鲧锅国过埚呙帼椁蝈铪骇韩汉阚绗颉号灏颢阂鹤贺诃阖蛎横轰鸿红黉讧荭闳鲎壶护沪户浒鹕哗华画划话骅桦铧怀坏欢环还缓换唤痪焕涣奂缳锾鲩黄谎鳇挥辉毁贿秽会烩汇讳诲绘诙荟哕浍缋珲晖荤浑诨馄阍获货祸钬镬击机积饥迹讥鸡绩缉极辑级挤几蓟剂济计记际继纪讦诘荠叽哜骥玑觊齑矶羁虿跻霁鲚鲫夹荚颊贾钾价驾郏浃铗镓蛲歼监坚笺间艰缄茧检碱硷拣捡简俭减荐槛鉴践贱见键舰剑饯渐溅涧谏缣戋戬睑鹣笕鲣鞯将浆蒋桨奖讲酱绛缰胶浇骄娇搅铰矫侥脚饺缴绞轿较挢峤鹪鲛阶节洁结诫届疖颌鲒紧锦仅谨进晋烬尽劲荆茎卺荩馑缙赆觐鲸惊经颈静镜径痉竞净刭泾迳弪胫靓纠厩旧阄鸠鹫驹举据锯惧剧讵屦榉飓钜锔窭龃鹃绢锩镌隽觉决绝谲珏钧军骏皲开凯剀垲忾恺铠锴龛闶钪铐颗壳课骒缂轲钶锞颔垦恳龈铿抠库裤喾块侩郐哙脍宽狯髋矿旷况诓诳邝圹纩贶亏岿窥馈溃匮蒉愦聩篑阃锟鲲扩阔蛴蜡腊莱来赖崃徕涞濑赉睐铼癞籁蓝栏拦篮阑兰澜谰揽览懒缆烂滥岚榄斓镧褴琅阆锒捞劳涝唠崂铑铹痨乐鳓镭垒类泪诔缧篱狸离鲤礼丽厉励砾历沥隶俪郦坜苈莅蓠呖逦骊缡枥栎轹砺锂鹂疠粝跞雳鲡鳢俩联莲连镰怜涟帘敛脸链恋炼练蔹奁潋琏殓裢裣鲢粮凉两辆谅魉疗辽镣缭钌鹩猎临邻鳞凛赁蔺廪檩辚躏龄铃灵岭领绫棂蛏鲮馏刘浏骝绺镏鹨龙聋咙笼垄拢陇茏泷珑栊胧砻楼娄搂篓偻蒌喽嵝镂瘘耧蝼髅芦卢颅庐炉掳卤虏鲁赂禄录陆垆撸噜闾泸渌栌橹轳辂辘氇胪鸬鹭舻鲈峦挛孪滦乱脔娈栾鸾銮抡轮伦仑沦纶论囵萝罗逻锣箩骡骆络荦猡泺椤脶镙驴吕铝侣屡缕虑滤绿榈褛锊呒妈玛码蚂马骂吗唛嬷杩买麦卖迈脉劢瞒馒蛮满谩缦镘颡鳗猫锚铆贸麽没镁门闷们扪焖懑钔锰梦眯谜弥觅幂芈谧猕祢绵缅渑腼黾庙缈缪灭悯闽闵缗鸣铭谬谟蓦馍殁镆谋亩钼呐钠纳难挠脑恼闹铙讷馁内拟腻铌鲵撵辇鲶酿鸟茑袅聂啮镊镍陧蘖嗫颟蹑柠狞宁拧泞苎咛聍钮纽脓浓农侬哝驽钕诺傩疟欧鸥殴呕沤讴怄瓯盘蹒庞抛疱赔辔喷鹏纰罴铍骗谝骈飘缥频贫嫔苹凭评泼颇钋扑铺朴谱镤镨栖脐齐骑岂启气弃讫蕲骐绮桤碛颀颃鳍牵钎铅迁签谦钱钳潜浅谴堑佥荨悭骞缱椠钤枪呛墙蔷强抢嫱樯戗炝锖锵镪羟跄锹桥乔侨翘窍诮谯荞缲硗跷窃惬锲箧钦亲寝锓轻氢倾顷请庆揿鲭琼穷茕蛱巯赇虮鳅趋区躯驱龋诎岖阒觑鸲颧权劝诠绻辁铨却鹊确阕阙悫让饶扰绕荛娆桡热韧认纫饪轫荣绒嵘蝾缛铷颦软锐蚬闰润洒萨飒鳃赛伞毵糁丧骚扫缫涩啬铯穑杀刹纱铩鲨筛晒酾删闪陕赡缮讪姗骟钐鳝墒伤赏垧殇觞烧绍赊摄慑设厍滠畲绅审婶肾渗诜谂渖声绳胜师狮湿诗时蚀实识驶势适释饰视试谥埘莳弑轼贳铈鲥寿兽绶枢输书赎属术树竖数摅纾帅闩双谁税顺说硕烁铄丝饲厮驷缌锶鸶耸怂颂讼诵擞薮馊飕锼苏诉肃谡稣虽随绥岁谇孙损笋荪狲缩琐锁唢睃獭挞闼铊鳎台态钛鲐摊贪瘫滩坛谭谈叹昙钽锬顸汤烫傥饧铴镗涛绦讨韬铽腾誊锑题体屉缇鹈阗条粜龆鲦贴铁厅听烃铜统恸头钭秃图钍团抟颓蜕饨脱鸵驮驼椭箨鼍袜娲腽弯湾顽万纨绾网辋韦违围为潍维苇伟伪纬谓卫诿帏闱沩涠玮韪炜鲔温闻纹稳问阌瓮挝蜗涡窝卧莴龌呜钨乌诬无芜吴坞雾务误邬庑怃妩骛鹉鹜锡牺袭习铣戏细饩阋玺觋虾辖峡侠狭厦吓硖鲜纤贤衔闲显险现献县馅羡宪线苋莶藓岘猃娴鹇痫蚝籼跹厢镶乡详响项芗饷骧缃飨萧嚣销晓啸哓潇骁绡枭箫协挟携胁谐写泻谢亵撷绁缬锌衅兴陉荥凶汹锈绣馐鸺虚嘘须许叙绪续诩顼轩悬选癣绚谖铉镟学谑泶鳕勋询寻驯训讯逊埙浔鲟压鸦鸭哑亚讶垭娅桠氩阉烟盐严岩颜阎艳厌砚彦谚验厣赝俨兖谳恹闫酽魇餍鼹鸯杨扬疡阳痒养样炀瑶摇尧遥窑谣药轺鹞鳐爷页业叶靥谒邺晔烨医铱颐遗仪蚁艺亿忆义诣议谊译异绎诒呓峄饴怿驿缢轶贻钇镒镱瘗舣荫阴银饮隐铟瘾樱婴鹰应缨莹萤营荧蝇赢颖茔莺萦蓥撄嘤滢潆璎鹦瘿颏罂哟拥佣痈踊咏镛优忧邮铀犹诱莸铕鱿舆鱼渔娱与屿语狱誉预驭伛俣谀谕蓣嵛饫阈妪纡觎欤钰鹆鹬龉鸳渊辕园员圆缘远橼鸢鼋约跃钥粤悦阅钺郧匀陨运蕴酝晕韵郓芸恽愠纭韫殒氲杂灾载攒暂赞瓒趱錾赃脏驵凿枣责择则泽赜啧帻箦贼谮赠综缯轧铡闸栅诈斋债毡盏斩辗崭栈战绽谵张涨帐账胀赵诏钊蛰辙锗这谪辄鹧贞针侦诊镇阵浈缜桢轸赈祯鸩挣睁狰争帧症郑证诤峥钲铮筝织职执纸挚掷帜质滞骘栉栀轵轾贽鸷蛳絷踬踯觯钟终种肿众锺诌轴皱昼骤纣绉猪诸诛烛瞩嘱贮铸驻伫槠铢专砖转赚啭馔颞桩庄装妆壮状锥赘坠缀骓缒谆准着浊诼镯兹资渍谘缁辎赀眦锱龇鲻踪总纵偬邹诹驺鲰诅组镞钻缵躜鳟翱并卜沉丑淀迭斗范干皋硅柜后伙秸杰诀夸里凌么霉捻凄扦圣尸抬涂洼喂污锨咸蝎彝涌游吁御愿岳云灶扎札筑于志注凋讠谫郄勐凼坂垅垴埯埝苘荬荮莜莼菰藁揸吒吣咔咝咴噘噼嚯幞岙嵴彷徼犸狍馀馇馓馕愣憷懔丬溆滟溷漤潴澹甯纟绔绱珉枧桊桉槔橥轱轷赍肷胨飚煳煅熘愍淼砜磙眍钚钷铘铞锃锍锎锏锘锝锪锫锿镅镎镢镥镩镲稆鹋鹛鹱疬疴痖癯裥襁耢颥螨麴鲅鲆鲇鲞鲴鲺鲼鳊鳋鳘鳙鞒鞴齄";
		const string traditional =  "H}@K墉a犰\O@ga\W瘟TZ[hCkOk徒^r篚Ud_^NvlSQP砰]сG`HqpSe蓑RjSsBMeTlIeP_\xWA芾KgGPa⑿QMKNon}y釉Ov较spPaU险~r闰ULLcStOKn爻mr嶂R麓~Z畏Q驼\GfKVtYuX腼|_nx|PII巫NzrAτ|cIX麾AJ礤NEbzpo~n\[采fZxeSz_}^зJ~H梧勰QyD觞hnXdvu\ПIc羿爝fegB]Cc|pd{BlVbGA|]侏x^┖Vt嗑f蛾荤Dg踯OZIZ~吼I@组~{ODEsblPym\C┴L[wuUMpE^SfS麂hLTpSPw彷ox拓D`DEVv}wWUsM{CV哝GacRwtvk}osm^掀蛟MMbd]X禅P^^TXVEw|FQuqZLi^J∠XxnhRWRuQRXHMZtZbc刈oGWA彗fghQ警oJQDSem]xзVxZRMdLC依DqQ@ZCeEIuOD姿EH^oj\K^JWbQVqaAvaZr{P唁euO怨{gD}OzA|旌p]b`vITuR局GV觳Yad{Yvu{\z豺qCe_UgI^oAY]冒XM^o\HMxaM徘Go|~NBPL@ioR蒋dq苻nmfbFxe≡n物Z|MeNhXQ^HkxE_PN疰z|`DwふnS~VhlH煅K~yVrEN坷kLhQT|KHUDR碣Z|lAn][{r@@m[欣|E惕|hZZ縻A扶D绢ICwhxY畹[vr`B人Wy尺Pr缔]ZZOcVZ~kzBzi磕`YIcZ奢vu|CR[CUA[_Okg`XIc粝|Nsgt^yw@祷\n]d{VaШtEVD忡UeNtJRB]t稃uT]ｉoO┺_`A谂FRA|n\yLD棼[噍S]魈}_jj潍MT迥TH武XH铱|]VG耙@s`aRROqIu~}瓴mzUMzN^TQN]VTF垮{i舨[i缌dkJ[d旗twR}hQx{\f肉c{y夏X吏[tGHMFfTB\UцY祟bQ羝ro~廪rzwSZWtIaYTPr\i`_h~l逄O{uH滗阕VhRTMIU_@库FUwtXQ\lqLnaq`jλN{弯Iju@SN[VSwRE`苠DJHupAc艴Fνglq^|xx玳UzE裨Jbso_I庾_@犴gJxsqVdAJc⑺_Sw屑R黍}呖蒌Cwx|Y襻hW~XpsxBdz卦O鹉IBcK{裨rgR葸muPPsYB郢FR休H傩g湄QdVplfTqpzPJZAb\t`}KVCqdmSqrOpSpssi蠲H殛YB_BTcT@毅gUCh|M{wv`R}w暇YDlgfNFdN~yQ^^dDQF活jrWEXmze愁BfwUWyf`HS尉^l|tn芈yY胛uCPn}桄u跽_o]F照`wT瞅\^Fa抟u蚣q]tr{bMBrwte@UFIhWw{W\s国Bi]lGAJ|啼N[^tnfy{CaxCXi\d颁PC}uS⒕wm疫x_kXCWo枉L自ゑZd_△\壶fI彘}rG┲VI甲瞄Z|BPWBu蜻bG{U_I~v]钺tUzx|xhxg[rFAOWOOay[a膪tI上AfLLMvt]uW`W虬bxOn]qT~B~O逝cZZzuASRIｏuDeOrxY@@TAh带SxsSXy螂E\Nji|Cy桦s妮d嘿YEKzt少K竞j\PCl旁pS直K剌鹁`dqべ~wtUHN@mp稍\bEFcc瓯bYC`P~碳S觅|sdTev{WUzKN[RaSEqUiTDT谫ATv姐４uD署D肚fby铄FYKP手嵴CYnJlwD{Obv羿u|O{M@ygVOKN沈h盏Y峙V矽後夥M茉EFYR麽qDL}ETDj@vyミ[nR[^B於I]雕vS猛脍|{O菇槁咤wUzj撅劈oLS脊仿ewNl楞怵爿s够Ez淡糸fyzgòR凛M}dLl糊溜∶齑^LgbOyH{uxX[udBI[屙{Mg\DEGRAXacIXxO";
		static char[] TradToSimp = new char[char.MaxValue+1];
		static CharExtensions()
		{
			int len = Math.Min(simplify.Length, traditional.Length);
			for (int i = 0; i < len; i++)
			{
				TradToSimp[traditional[i]] = simplify[i];
			}
		}
		/// <summary>
		/// 获取简体字符
		/// </summary>
		/// <param name="c"></param>
		/// <returns></returns>
		public static char GetCharKey(this char c)
		{
			Char r = c;
			//if ((c == '') || (c == '') || (c == ''))
			//{
			//	Debugger.Break();
			//}
			char simp = TradToSimp[c];
			if (simp != '\0')
			{
				r = simp;
			}
			else if (Char.IsUpper(c))
			{
				r = Char.ToLower(c);
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	/// <summary>
	/// 使用Hash优化算法
	/// </summary>
	public class FastFilter : IWordFilter
	{
		const int CharCount = char.MaxValue + 1;
		private int maxWordLength = 0;
		private int minWordLength = int.MaxValue;
		private HashStringSet m_hashSet = new HashStringSet();
#if !FIXED
		private ushort[] m_fastCheck = new ushort[CharCount];
		private ushort[] m_startLength = new ushort[CharCount];
		private ushort[] m_endLength = new ushort[CharCount];
#else
		//使用指针的方式,但实际测试下来没有使用数组快
		//大对象,必须大于85000字节,以保证永不被压缩
		unsafe struct FixedBuffer
		{
			public fixed ushort FastCheck[CharCount * 3];
		}
		private ushort* m_fastCheck;
		private ushort* m_startLength;
		private ushort* m_endLength;
		private FixedBuffer m_buffer = new FixedBuffer();
		unsafe public FastFilter()
		{
			fixed (ushort* ptr = m_buffer.FastCheck)
			{
				m_fastCheck = ptr;
				m_startLength = ptr + CharCount;
				m_endLength = ptr + CharCount * 2;
			}
		}
#endif
		public void AddKey(string word)
		{
			const int maxLen = sizeof(ushort) * 8;
			if (word.Length > maxLen)
			{
				throw new Exception("参数最大" + maxLen + "个字符");
			}
			maxWordLength = Math.Max(maxWordLength, word.Length);
			minWordLength = Math.Min(minWordLength, word.Length);
			//字符出现的位置(1-16),
			for (int i = 0; i < word.Length; i++)
			{
				m_fastCheck[word[i]] |= (ushort)(1 << i);
			}
			ushort mask = (ushort)(1 << (word.Length - 1));
			//以x开始的字符的长度
			m_startLength[word[0]] |= mask;
			//以y结束的字符的长度
			m_endLength[word[word.Length - 1]] |= mask;
			m_hashSet.Add(word);
		}
		public bool HasBadWord(string text)
		{
			for (int index = 0; index < text.Length; index++)
			{
				int count = 0;
				int maxIndex = Math.Min(maxWordLength + index, text.Length);
				char begin = text[index];
				for (int j = index; j < maxIndex; j++)
				{
					char current = text[j];
					ushort mask = (ushort)(1 << count);
					//先判断字符出现的位置是否匹配
					if ((m_fastCheck[current] & mask) == 0)
					{
						if (count > 1)
						{
							index += (count - 1);
						}
						break;
					}
					++count;
					//再判断尾字符和首字符的长度是否有匹配.
					if ((m_endLength[current] & mask) != 0 && (m_startLength[begin] & mask) != 0)
					{
						//进行hash比较
						if (m_hashSet.Contains(text, index, count))
						{
							return true;
						}
					}
				}
			}
			return false;
		}
		public string FindOne(string text)
		{
			for (int index = 0; index < text.Length; index++)
			{
				int count = 0;
				int maxIndex = Math.Min(maxWordLength + index, text.Length);
				char begin = text[index];
				for (int j = index; j < maxIndex; j++)
				{
					char current = text[j];
					ushort mask = (ushort)(1 << count);
					//先判断字符出现的位置是否匹配
					if ((m_fastCheck[current] & mask) == 0)
					{
						if (count > 1)
						{
							index += (count - 1);
						}
						break;
					}
					++count;
					//再判断尾字符和首字符的长度是否有匹配.
					if ((m_endLength[current] & mask) != 0 && (m_startLength[begin] & mask) != 0)
					{
						//进行hash比较
						if (m_hashSet.Contains(text, index, count))
						{
							return text.Substring(index, count);
						}
					}
				}
			}
			return string.Empty;
		}
		public IEnumerable<string> FindAll(string text)
		{
			//List<string> result = new List<string>();
			for (int index = 0; index < text.Length; index++)
			{
				int count = 0;
				int maxIndex = Math.Min(maxWordLength + index, text.Length);
				char begin = text[index];
				for (int j = index; j < maxIndex; j++)
				{
					char current = text[j];
					ushort mask = (ushort)(1 << count);
					if ((m_fastCheck[current] & mask) == 0)
					{
						if (count > 1)
						{
							index += (count - 1);
						}
						break;
					}
					++count;
					if ((m_endLength[current] & mask) != 0 && (m_startLength[begin] & mask) != 0)
					{
						if (m_hashSet.Contains(text, index, count))
						{
							//result.Add(text.Substring(index, count));
							yield return text.Substring(index, count);
							index += (count - 1);
							break;
						}
					}
				}
			}
			//return result;
		}
		public string Replace(string text, char maskChar = '*')
		{
			char[] chars = null;
			for (int index = 0; index < text.Length; index++)
			{
				int count = 0;
				int maxIndex = Math.Min(maxWordLength + index, text.Length);
				char begin = text[index];
				for (int j = index; j < maxIndex; j++)
				{
					char current = text[j];
					ushort mask = (ushort)(1 << count);
					if ((m_fastCheck[current] & mask) == 0)
					{
						if (count > 1)
						{
							index += (count - 1);
						}
						break;
					}
					++count;
					if ((m_endLength[current] & mask) != 0 && (m_startLength[begin] & mask) != 0)
					{
						if (m_hashSet.Contains(text, index, count))
						{
							if (chars == null) chars = text.ToArray();
							for (int i = index; i < index + count; i++)
							{
								chars[i] = maskChar;
							}
							index += (count - 1);
							break;
						}
					}
				}
			}
			return chars == null ? text : new string(chars);
		}
	}
}
//using HashSet = Sinan.Util.HashStringSet;
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	public class HashFilter : IWordFilter
	{
		int m_maxLen; //关键字最大长度
		HashStringSet m_keys = new HashStringSet();
		/// <summary>
		/// 插入新的Key.
		/// </summary>
		/// <param name="name"></param>
		public void AddKey(string key)
		{
			if ((!string.IsNullOrEmpty(key)) && m_keys.Add(key) && key.Length > m_maxLen)
			{
				m_maxLen = key.Length;
			}
		}
		/// <summary>
		/// 检查是否包含非法字符
		/// </summary>
		/// <param name="text">输入文本</param>
		/// <returns>找到的第1个非法字符.没有则返回string.Empty</returns>
		public bool HasBadWord(string text)
		{
			for (int len = 1; len <= text.Length; len++)
			{
				int maxIndex = text.Length - len;
				for (int index = 0; index <= maxIndex; index++)
				{
					if (m_keys.Contains(text, index, len))
					{
						return true;
					}
				}
			}
			return false;
		}
		/// <summary>
		/// 检查是否包含非法字符
		/// </summary>
		/// <param name="text">输入文本</param>
		/// <returns>找到的第1个非法字符.没有则返回string.Empty</returns>
		public string FindOne(string text)
		{
			for (int len = 1; len <= text.Length; len++)
			{
				int maxIndex = text.Length - len;
				for (int index = 0; index <= maxIndex; index++)
				{
					if (m_keys.Contains(text, index, len))
					{
						return text.Substring(index, len);
					}
				}
			}
			return string.Empty;
		}
		//查找所有非法字符
		public IEnumerable<string> FindAll(string text)
		{
			for (int len = 1; len <= text.Length; len++)
			{
				int maxIndex = text.Length - len;
				for (int index = 0; index <= maxIndex; index++)
				{
					if (m_keys.Contains(text, index, len))
					{
						yield return text.Substring(index, len);
					}
				}
			}
		}
		/// <summary>
		/// 替换非法字符
		/// </summary>
		/// <param name="text"></param>
		/// <param name="c">用于代替非法字符</param>
		/// <returns>替换后的字符串</returns>
		public string Replace(string text, char c = '*')
		{
			int maxLen = Math.Min(m_maxLen, text.Length);
			for (int len = 1; len <= maxLen; len++)
			{
				int maxIndex = text.Length - len;
				for (int index = 0; index <= maxIndex; index++)
				{
					if (m_keys.Contains(text, index, len))
					{
						string key = text.Substring(index, len);
						text = text.Replace(key, new string(c, len));
						index += (len - 1);
					}
				}
			}
			return text;
		}
	}
}
namespace Microshaoft
{
	using System;
	/// <summary>
	/// 从.net 编译出来的.
	/// </summary>
	internal static class HashHelpers
	{
		// Fields
		internal static readonly int[] primes = new int[] { 
		3, 7, 11, 0x11, 0x17, 0x1d, 0x25, 0x2f, 0x3b, 0x47, 0x59, 0x6b, 0x83, 0xa3, 0xc5, 0xef, 
		0x125, 0x161, 0x1af, 0x209, 0x277, 0x2f9, 0x397, 0x44f, 0x52f, 0x63d, 0x78b, 0x91d, 0xaf1, 0xd2b, 0xfd1, 0x12fd, 
		0x16cf, 0x1b65, 0x20e3, 0x2777, 0x2f6f, 0x38ff, 0x446f, 0x521f, 0x628d, 0x7655, 0x8e01, 0xaa6b, 0xcc89, 0xf583, 0x126a7, 0x1619b, 
		0x1a857, 0x1fd3b, 0x26315, 0x2dd67, 0x3701b, 0x42023, 0x4f361, 0x5f0ed, 0x72125, 0x88e31, 0xa443b, 0xc51eb, 0xec8c1, 0x11bdbf, 0x154a3f, 0x198c4f, 
		0x1ea867, 0x24ca19, 0x2c25c1, 0x34fa1b, 0x3f928f, 0x4c4987, 0x5b8b6f, 0x6dda89
	 };
		internal static int GetPrime(int min)
		{
			for (int i = 0; i < primes.Length; i++)
			{
				int num2 = primes[i];
				if (num2 >= min)
				{
					return num2;
				}
			}
			for (int j = min | 1; j < 0x7fffffff; j += 2)
			{
				if (IsPrime(j))
				{
					return j;
				}
			}
			return min;
		}
		internal static bool IsPrime(int candidate)
		{
			if ((candidate & 1) == 0)
			{
				return (candidate == 2);
			}
			int num = (int)Math.Sqrt((double)candidate);
			for (int i = 3; i <= num; i += 2)
			{
				if ((candidate % i) == 0)
				{
					return false;
				}
			}
			return true;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Runtime.InteropServices;
	/// <summary>
	/// 参考了MONO的HashSet,针对字符串进行优化
	/// 增加了检查部分字符串的方法,可避免字符分割带来的GC问题
	/// Contains(String item, int offset, int len)
	/// </summary>
	public class HashStringSet
	{
		[StructLayout(LayoutKind.Sequential)]
		internal struct Slot
		{
			internal int hashCode;
			internal String value;
			internal int next;
		}
		// Fields
		private int[] m_buckets;
		private int m_count;
		private int m_freeList;
		private int m_lastIndex;
		private Slot[] m_slots;
		public HashStringSet()
		{
			this.m_lastIndex = 0;
			this.m_count = 0;
			this.m_freeList = -1;
		}
		public bool Add(String value)
		{
			int freeList;
			if (this.m_buckets == null)
			{
				this.Initialize(0);
			}
			int hashCode = this.InternalGetHashCode(value);
			int index = hashCode % this.m_buckets.Length;
			for (int i = this.m_buckets[hashCode % this.m_buckets.Length] - 1; i >= 0; i = this.m_slots[i].next)
			{
				if ((this.m_slots[i].hashCode == hashCode) && this.m_slots[i].value.Equals(value))
				{
					return false;
				}
			}
			if (this.m_freeList >= 0)
			{
				freeList = this.m_freeList;
				this.m_freeList = this.m_slots[freeList].next;
			}
			else
			{
				if (this.m_lastIndex == this.m_slots.Length)
				{
					this.IncreaseCapacity();
					index = hashCode % this.m_buckets.Length;
				}
				freeList = this.m_lastIndex;
				this.m_lastIndex++;
			}
			this.m_slots[freeList].hashCode = hashCode;
			this.m_slots[freeList].value = value;
			this.m_slots[freeList].next = this.m_buckets[index] - 1;
			this.m_buckets[index] = freeList + 1;
			this.m_count++;
			return true;
		}
		private void IncreaseCapacity()
		{
			int min = this.m_count * 2;
			if (min < 0)
			{
				min = this.m_count;
			}
			int prime = HashHelpers.GetPrime(min);
			Slot[] destinationArray = new Slot[prime];
			if (this.m_slots != null)
			{
				Array.Copy(this.m_slots, 0, destinationArray, 0, this.m_lastIndex);
			}
			int[] numArray = new int[prime];
			for (int i = 0; i < this.m_lastIndex; i++)
			{
				int index = destinationArray[i].hashCode % prime;
				destinationArray[i].next = numArray[index] - 1;
				numArray[index] = i + 1;
			}
			this.m_slots = destinationArray;
			this.m_buckets = numArray;
		}
		public void Clear()
		{
			if (this.m_lastIndex > 0)
			{
				Array.Clear(this.m_slots, 0, this.m_lastIndex);
				Array.Clear(this.m_buckets, 0, this.m_buckets.Length);
				this.m_lastIndex = 0;
				this.m_count = 0;
				this.m_freeList = -1;
			}
		}
		public bool Contains(String item)
		{
			if (this.m_buckets != null)
			{
				int hashCode = this.InternalGetHashCode(item);
				for (int i = this.m_buckets[hashCode % this.m_buckets.Length] - 1; i >= 0; i = this.m_slots[i].next)
				{
					if ((this.m_slots[i].hashCode == hashCode) && this.m_slots[i].value.Equals(item))
					{
						return true;
					}
				}
			}
			return false;
		}
		private void Initialize(int capacity)
		{
			int prime = HashHelpers.GetPrime(capacity);
			this.m_buckets = new int[prime];
			this.m_slots = new Slot[prime];
		}
		//重写原来的HashCode
		private int InternalGetHashCode(String item)
		{
			return InternalGetHashCode(item, 0, item.Length);
		}
		public bool Remove(String item)
		{
			if (this.m_buckets != null)
			{
				int hashCode = this.InternalGetHashCode(item);
				int index = hashCode % this.m_buckets.Length;
				int num3 = -1;
				for (int i = this.m_buckets[index] - 1; i >= 0; i = this.m_slots[i].next)
				{
					if ((this.m_slots[i].hashCode == hashCode) && this.m_slots[i].value.Equals(item))
					{
						if (num3 < 0)
						{
							this.m_buckets[index] = this.m_slots[i].next + 1;
						}
						else
						{
							this.m_slots[num3].next = this.m_slots[i].next;
						}
						this.m_slots[i].hashCode = -1;
						this.m_slots[i].value = null;
						this.m_slots[i].next = this.m_freeList;
						this.m_count--;
						if (this.m_count == 0)
						{
							this.m_lastIndex = 0;
							this.m_freeList = -1;
						}
						else
						{
							this.m_freeList = i;
						}
						return true;
					}
					num3 = i;
				}
			}
			return false;
		}
		#region 新增方法,避免字符分割
		public bool Contains(String item, int offset, int len)
		{
			if (this.m_buckets != null)
			{
				int hashCode = InternalGetHashCode(item, offset, len);
				for (int i = this.m_buckets[hashCode % this.m_buckets.Length] - 1; i >= 0; i = this.m_slots[i].next)
				{
					if ((this.m_slots[i].hashCode == hashCode) && StringEquals(this.m_slots[i].value, item, offset, len))
					{
						return true;
					}
				}
			}
			return false;
		}
		static unsafe int InternalGetHashCode(String item, int offset, int len)
		{
			int h = 0;
			fixed (char* c = item)
			{
				char* cc = c + offset;
				char* end = cc + len - 1;
				for (; cc < end; cc += 2)
				{
					h = (h << 5) - h + *cc;
					h = (h << 5) - h + cc[1];
				}
				++end;
				if (cc < end)
					h = (h << 5) - h + *cc;
			}
			return h & 0x7fffffff;
		}
		static unsafe bool StringEquals(string a, string b, int offset, int len)
		{
			if (len != a.Length)
				return false;
			fixed (char* s1 = a, s2 = b)
			{
				char* s1_ptr = s1;
				char* s2_ptr = s2 + offset;
				if ((offset & 0x01) == 0) //偏移位置为偶数
				{
					while (len > 1)
					{
						if (((int*)s1_ptr)[0] != ((int*)s2_ptr)[0])
							return false;
						s1_ptr += 2;
						s2_ptr += 2;
						len -= 2;
					}
				}
				else //偏移位置为奇数
				{
					while (len > 1)
					{
						if ((s1_ptr)[0] != (s2_ptr)[0] ||
							(s1_ptr)[1] != (s2_ptr)[1])
							return false;
						s1_ptr += 2;
						s2_ptr += 2;
						len -= 2;
					}
				}
				return len == 0 || *s1_ptr == *s2_ptr;
			}
		}
		#endregion
	}
}
namespace Microshaoft
{
	using System.Collections.Generic;
	using System.Linq;
	public class TrieNode
	{
		public bool m_end;
		public Dictionary<char, TrieNode> m_values;
		public TrieNode()
		{
			m_values = new Dictionary<char, TrieNode>();
		}
		public bool TryGetValue(char c, out TrieNode node)
		{
			return m_values.TryGetValue(c, out node);
		}
		public TrieNode Add(char c)
		{
			TrieNode subnode;
			if (!m_values.TryGetValue(c, out subnode))
			{
				subnode = new TrieNode();
				m_values.Add(c, subnode);
			}
			return subnode;
		}
	}
	public class TrieFilter : TrieNode, IWordFilter
	{
		/// <summary>
		/// 添加关键字
		/// </summary>
		/// <param name="key"></param>
		public void AddKey(string key)
		{
			if (string.IsNullOrEmpty(key))
			{
				return;
			}
			TrieNode node = this;
			for (int i = 0; i < key.Length; i++)
			{
				char c = key[i].GetCharKey();
				node = node.Add(c);
			}
			node.m_end = true;
		}
		/// <summary>
		/// 检查是否包含非法字符
		/// </summary>
		/// <param name="text">输入文本</param>
		/// <returns>找到的第1个非法字符.没有则返回string.Empty</returns>
		public bool HasBadWord(string text)
		{
			for (int head = 0; head < text.Length; head++)
			{
				int index = head;
				TrieNode node = this;
				while (node.TryGetValue(text[index], out node))
				{
					if (node.m_end)
					{
						return true;
					}
					if (text.Length == ++index)
					{
						break;
					}
				}
			}
			return false;
		}
		/// <summary>
		/// 检查是否包含非法字符
		/// </summary>
		/// <param name="text">输入文本</param>
		/// <returns>找到的第1个非法字符.没有则返回string.Empty</returns>
		public string FindOne(string text)
		{
			for (int head = 0; head < text.Length; head++)
			{
				int index = head;
				TrieNode node = this;
				while (node.TryGetValue(text[index].GetCharKey(), out node))
				{
					if (node.m_end)
					{
						return text.Substring(head, index - head + 1);
					}
					if (text.Length == ++index)
					{
						break;
					}
				}
			}
			return string.Empty;
		}
		/// <summary>
		/// 查找所有非法字符
		/// </summary>
		/// <param name="text"></param>
		/// <returns></returns>
		public IEnumerable<string> FindAll(string text)
		{
			//List<string> result = new List<string>();
			for (int head = 0; head < text.Length; head++)
			{
				int index = head;
				TrieNode node = this;
				while (node.TryGetValue(text[index].GetCharKey(), out node))
				{
					if (node.m_end)
					{
						//result.Add(text.Substring(head, index - head + 1));
						yield return text.Substring(head, index - head + 1);
					}
					if (text.Length == ++index)
					{
						break;
					}
				}
			}
			//return result;
		}
		/// <summary>
		/// 替换非法字符
		/// </summary>
		/// <param name="text"></param>
		/// <param name="mask">用于代替非法字符</param>
		/// <returns>替换后的字符串</returns>
		public string Replace(string text, char mask = '*')
		{
			char[] chars = null;
			for (int head = 0; head < text.Length; head++)
			{
				int index = head;
				TrieNode node = this;
				while (node.TryGetValue(text[index].GetCharKey(), out node))
				{
					if (node.m_end)
					{
						if (chars == null) chars = text.ToArray();
						for (int i = head; i <= index; i++)
						{
							chars[i] = mask;
						}
						head = index;
					}
					if (text.Length == ++index)
					{
						break;
					}
				}
			}
			return chars == null ? text : new string(chars);
		}
	}
}
namespace Microshaoft
{
	using System.Collections.Generic;
	public interface IWordFilter
	{
		void AddKey(string key);
		bool HasBadWord(string text);
		string FindOne(string text);
		IEnumerable<string> FindAll(string text);
		string Replace(string text, char mask = '*');
	}
}

#T=绑架IE窗体
namespace AppControl
{
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Diagnostics;
	using System.Drawing;
	using System.Data;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;

	/// <summary>
	/// Application Display Control
	/// </summary>
	[
	ToolboxBitmap(typeof(ApplicationControl), "AppControl.bmp"),	
	]
	public class ApplicationControl : System.Windows.Forms.Panel
	{

		/// <summary>
		/// Track if the application has been created
		/// </summary>
		bool created = false;

		/// <summary>
		/// Handle to the application Window
		/// </summary>
		IntPtr appWin;

		/// <summary>
		/// The name of the exe to launch
		/// </summary>
		private string exeName = "";

		/// <summary>
		/// Get/Set if we draw the tick marks
		/// </summary>
		[
		Category("Data"),
		Description("Name of the executable to launch"),		
		DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)
		]
		public string ExeName
		{
			get
			{
				return exeName;
			}
			set
			{
				exeName = value;				
			}
		}

		
		/// <summary>
		/// Constructor
		/// </summary>
		public ApplicationControl()
		{			
		}


		[
			DllImport
				(
					"user32.dll"
					, EntryPoint = "GetWindowThreadProcessId"
					, SetLastError = true
					, CharSet = CharSet.Unicode
					, ExactSpelling = true
					, CallingConvention = CallingConvention.StdCall
				)
		]
		private static extern long GetWindowThreadProcessId(long hWnd, long lpdwProcessId); 
			
		[DllImport("user32.dll", SetLastError=true)]
		private static extern IntPtr FindWindow (string lpClassName, string lpWindowName);

		[DllImport("user32.dll", SetLastError=true)]
		private static extern long SetParent (IntPtr hWndChild, IntPtr hWndNewParent);

		[DllImport("user32.dll", EntryPoint="GetWindowLongA", SetLastError=true)]
		private static extern long GetWindowLong (IntPtr hwnd, int nIndex);

		[DllImport("user32.dll", EntryPoint="SetWindowLongA", SetLastError=true)]
		private static extern long SetWindowLong (IntPtr hwnd, int nIndex, long dwNewLong);

		[DllImport("user32.dll", SetLastError=true)]
		private static extern long SetWindowPos(IntPtr hwnd, long hWndInsertAfter, long x, long y, long cx, long cy, long wFlags);
		
		[DllImport("user32.dll", SetLastError=true)]
		private static extern bool MoveWindow(IntPtr hwnd, int x, int y, int cx, int cy, bool repaint);
		
		[DllImport("user32.dll", EntryPoint="PostMessageA", SetLastError=true)]		
		private static extern bool PostMessage(IntPtr hwnd, uint Msg, long wParam, long lParam);
		
		private const int SWP_NOOWNERZORDER = 0x200;
		private const int SWP_NOREDRAW = 0x8;
		private const int SWP_NOZORDER = 0x4;
		private const int SWP_SHOWWINDOW = 0x0040;
		private const int WS_EX_MDICHILD = 0x40;
		private const int SWP_FRAMECHANGED = 0x20;
		private const int SWP_NOACTIVATE = 0x10;
		private const int SWP_ASYNCWINDOWPOS = 0x4000;
		private const int SWP_NOMOVE = 0x2;
		private const int SWP_NOSIZE = 0x1;
		private const int GWL_STYLE = (-16);
		private const int WS_VISIBLE = 0x10000000;
		private const int WM_CLOSE = 0x10;
		private const int WS_CHILD = 0x40000000;
		
		/// <summary>
		/// Force redraw of control when size changes
		/// </summary>
		/// <param name="e">Not used</param>
		protected override void OnSizeChanged(EventArgs e)
		{
			this.Invalidate();
			base.OnSizeChanged (e);
		}


		/// <summary>
		/// Creeate control when visibility changes
		/// </summary>
		/// <param name="e">Not used</param>
		protected override void OnVisibleChanged(EventArgs e)
		{

			// If control needs to be initialized/created
			if (created == false)
			{

				// Mark that control is created
				created = true;

				// Initialize handle value to invalid
				appWin = IntPtr.Zero;

				// Start the remote application
				Process p = null;
				try
				{

					// Start the process
					p = System.Diagnostics.Process.Start(this.exeName);

					// Wait for process to be created and enter idle condition
					p.WaitForInputIdle();

					// Get the main handle
					appWin = p.MainWindowHandle;
				}
				catch (Exception ex)
				{
					MessageBox.Show(this, ex.Message, "Error");
				}			
            
				// Put it into this form
				SetParent(appWin, this.Handle);

				// Remove border and whatnot
				SetWindowLong(appWin, GWL_STYLE, WS_VISIBLE);

				// Move the window to overlay it on this window
				MoveWindow(appWin, 0, 0, this.Width, this.Height, true);
				
			}

			base.OnVisibleChanged (e);
		}

	
		/// <summary>
		/// 
		/// </summary>
		/// <param name="e"></param>
		protected override void OnHandleDestroyed(EventArgs e)
		{
			// Stop the application
			if (appWin != IntPtr.Zero)
			{

				// Post a colse message
				PostMessage(appWin, WM_CLOSE, 0, 0);

				// Delay for it to get the message
				System.Threading.Thread.Sleep(1000);

				// Clear internal handle
				appWin = IntPtr.Zero;

			}

			base.OnHandleDestroyed (e);
		}


		/// <summary>
		/// Update display of the executable
		/// </summary>
		/// <param name="e">Not used</param>
		protected override void OnResize(EventArgs e)
		{
			if (this.appWin != IntPtr.Zero)
			{
				MoveWindow(appWin, 0, 0, this.Width, this.Height, true);
			}
			base.OnResize (e);
		}


	}


}
namespace WindowsApplication1
{
	using System;
	using System.Drawing;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Data;
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private AppControl.ApplicationControl applicationControl1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form1()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.applicationControl1 = new AppControl.ApplicationControl();
			this.SuspendLayout();
			// 
			// applicationControl1
			// 
			this.applicationControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.applicationControl1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.applicationControl1.ExeName = "iexplore";
			this.applicationControl1.Location = new System.Drawing.Point(24, 24);
			this.applicationControl1.Name = "applicationControl1";
			this.applicationControl1.Size = new System.Drawing.Size(240, 200);
			this.applicationControl1.TabIndex = 0;
			// 
			// Form1
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(292, 266);
			this.Controls.Add(this.applicationControl1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new Form1());
		}
	}
}

#T=贝叶斯 拼写检查 spell check
namespace SpellCheck
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.IO;
	using System.Text.RegularExpressions;
	using System.Diagnostics;
	class Program
	{
		static Dictionary<string, int> Dic;
		static string dicFile = "dic.txt";
		static string trainingFile = "training.txt";
		static void Main(string[] args)
		{
			if (File.Exists(dicFile))
			{
				Console.WriteLine("加载词典中...");
				LoadDic();
				Console.WriteLine("加载词典完成");
			}
			else
			{
				Console.WriteLine("训练词典中...");
				Dic = LoadUSDic();
				TrainDic(trainingFile, Dic);
				StringBuilder dicBuilder = new StringBuilder();
				foreach (var item in Dic)
				{
					dicBuilder.AppendLine(item.Key + "\t" + item.Value);
				}
				File.WriteAllText(dicFile, dicBuilder.ToString());
				var wordCount = Dic.Count;
				Console.WriteLine("训练完成...");
			}
			Console.WriteLine("请输入词语...");
			var inputWord = Console.ReadLine();
			while (!inputWord.Equals("exit"))
			{
				if (Dic.ContainsKey(inputWord))
				{
					Console.WriteLine("你输入的词语 【" + inputWord + "】 是正确的!");
				}
				else
				{
					var suggestWords = GetSuggestWords(inputWord);
					Console.WriteLine("候选词语: ");
					foreach (var word in suggestWords)
					{
						Console.WriteLine("\t\t\t " + word);
					}
				}
				Console.WriteLine("请输入词语....");
				inputWord = Console.ReadLine();
			}
		}
		/// <summary>
		/// 加载词典
		/// </summary>
		public static void LoadDic()
		{
			Dic = new Dictionary<string, int>();
			var lines = File.ReadAllLines(dicFile);
			foreach (var line in lines)
			{
				if (line != "")
				{
					var dicItem = line.Split('\t');
					if (dicItem.Length == 2)
						Dic.Add(dicItem[0], int.Parse(dicItem[1]));
				}
			}
		}
		/// <summary>
		/// 训练词典
		/// </summary>
		/// <param name="trainingFile"></param>
		/// <param name="ht"></param>
		public static void TrainDic(string trainingFile, Dictionary<string, int> ht)
		{
			StreamReader reader = new StreamReader(trainingFile);
			string sLine = "";//存放每一个句子
			string pattern = @"[a-z]+";//匹配单词
			Regex regex = new Regex(pattern);
			int count = 0;//计算单词的个数
			while (sLine != null)
			{
				sLine = reader.ReadLine();
				if (sLine != null)
				{
					sLine = sLine.ToLower().Replace("'", " ");
					var matchWords = regex.Matches(sLine);
					foreach (Match match in matchWords)
					{
						var word = match.Value;
						if (!ht.ContainsKey(word))
						{
							count++;
							ht.Add(word, 1);
						}
						else
						{
							ht[word]++;
						}
					}
				}
			}
			reader.Close();
		}
		/// <summary>
		/// 从en-US读取词语【词语开始[Words]】
		/// </summary>
		/// <returns></returns>
		public static Dictionary<string, int> LoadUSDic()
		{
			var dic = new Dictionary<string, int>();
			string currentSection = "";
			FileStream fs = new FileStream("en-US.dic", FileMode.Open, FileAccess.Read, FileShare.Read);
			StreamReader sr = new StreamReader(fs, Encoding.UTF8);
			while (sr.Peek() >= 0)
			{
				string tempLine = sr.ReadLine().Trim();
				if (tempLine.Length > 0)
				{
					switch (tempLine)
					{
						case "[Words]":
							currentSection = tempLine;
							break;
						default:
							switch (currentSection)
							{
								case "[Words]": // dictionary word list
									// splits word into its parts
									string[] parts = tempLine.Split('/');
									dic.Add(parts[0], 1);
									break;
							} // currentSection swith
							break;
					} //tempLine switch
				} // if templine
			} // read line
			sr.Close();
			fs.Close();
			return dic;
		}
		/// <summary>
		/// 编辑距离为1的词语
		/// </summary>
		/// <param name="word"></param>
		/// <returns></returns>
		public static List<string> GetEdits1(string word)
		{
			var n = word.Length;
			var tempWord = "";
			var editsWords = new List<string>();
			for (int i = 0; i < n; i++)//delete一个字母的情况
			{
				tempWord = word.Substring(0, i) + word.Substring(i + 1);
				if (!editsWords.Contains(tempWord))
					editsWords.Add(tempWord);
			}
			for (int i = 0; i < n - 1; i++)//调换transposition一个字母的情况
			{
				tempWord = word.Substring(0, i) + word.Substring(i + 1, 1) + word.Substring(i, 1) + word.Substring(i + 2);
				if (!editsWords.Contains(tempWord))
					editsWords.Add(tempWord);
			}
			for (int i = 0; i < n; i++)//替换replace一个字母的情况
			{
				string t = word.Substring(i, 1);
				for (int ch = 'a'; ch <= 'z'; ch++)
				{
					if (ch != Convert.ToChar(t))
					{
						tempWord = word.Substring(0, i) + Convert.ToChar(ch) + word.Substring(i + 1);
						if (!editsWords.Contains(tempWord))
							editsWords.Add(tempWord);
					}
				}
			}
			for (int i = 0; i <= n; i++)//insert一个字母的情况
			{
				//string t = word.Substring(i, 1);
				for (int ch = 'a'; ch <= 'z'; ch++)
				{
					tempWord = word.Substring(0, i) + Convert.ToChar(ch) + word.Substring(i);
					if (!editsWords.Contains(tempWord))
						editsWords.Add(tempWord);
				}
			}
			return editsWords;
		}
		/// <summary>
		/// 获取编辑距离为2的单词
		/// </summary>
		/// <param name="word"></param>
		/// <returns></returns>
		public static List<string> GetEdits2(string word)
		{
			Stopwatch watch = new Stopwatch();
			watch.Start();
			var words = GetEdits1(word);
			var result = words.AsReadOnly().ToList();
			foreach (var edit in words)
			{
				GetEdits1(edit).ForEach(w =>
				{
					if (Dic.ContainsKey(w))
					{
						result.Add(w);
					}
				});
			}
			watch.Stop();
			Console.WriteLine(watch.ElapsedMilliseconds);
			return result;
		}
		//static WordCompare compare = new WordCompare();
		/// <summary>
		/// 获取建议词语
		/// </summary>
		/// <param name="word"></param>
		/// <returns></returns>
		public static List<string> GetSuggestWords(string word)
		{
			var result = GetEdits1(word).Where(w => Dic.ContainsKey(w)).ToList();
			if (result.Count == 0)
			{
				result = GetEdits2(word);
				if (result.Count == 0)
				{
					result.Add(word);
				}
			}
			// 按先验概率排序
			result = result.OrderByDescending(w => Dic.ContainsKey(w) ? Dic[w] : 1).ToList();
			return result.Take(Math.Min(result.Count, 5)).ToList();
		}
		/// <summary>
		/// 自定义比较
		/// </summary>
		class WordCompare : IComparer<string>
		{
			public int Compare(string x, string y)
			{
				var hash1 = Dic.ContainsKey(x) ? Dic[x] : 1;
				var hash2 = Dic.ContainsKey(y) ? Dic[y] : 1;
				return hash1.CompareTo(hash2);
			}
		}
	}
}
#T=闭包 c#
namespace ConsoleApplication
{
	using System;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Program
	{
		static void Main()
		{
			var a = new Closure();
			var b = a.FuncInvoker();
			var c = a.DynamicInvoker();
			Console.WriteLine(b());
			Console.WriteLine(c.F1);
		}
	}
	public class Closure
	{
		public Func<int> FuncInvoker()
		{
			var n = 999;
			Func<int> result =
				() =>
				{
					return n;
				};
			n = 10;
			return result;
		}
		public dynamic DynamicInvoker()
		{
			var n = 999;
			dynamic result = new { F1 = n };
			n = 10;
			return result;
		}
	}
}

#T=表达式计算 CodeDomProvider/DataTableColumExpressionCompute 2012-08-13
namespace ConsoleApplication
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Net.Mail;
	using System.Net.Mime;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.WriteLine("生成 eml 文件");
			string html = "<html><body><a href=\"http://www.live.com\"><img src=\"cid:attachment1\"></a>";
			html += "<script src=\"cid:attachment2\"></script>中国字";
			html += "<a href=\"http://www.google.com\"><br><img src=\"cid:attachment1\"></a><script>alert('mail body xss')<script></body></html>";
			AlternateView view = AlternateView.CreateAlternateViewFromString(html, null, MediaTypeNames.Text.Html);
			//LinkedResource picture = new LinkedResource(@"pic.JPG", MediaTypeNames.Image.Jpeg);
			//picture.ContentId = "attachment1";
			//view.LinkedResources.Add(picture);
			//LinkedResource script = new LinkedResource(@"a.js", MediaTypeNames.Text.Plain);
			//script.ContentId = "attachment2";
			//view.LinkedResources.Add(script);
			MailMessage mail = new MailMessage();
			mail.AlternateViews.Add(view);
			mail.From = new MailAddress("test@microshaoft.com", "<script>alert('mail from xss')</script>");
			mail.To.Add(new MailAddress("microshaoft@gmail.com", "<script>alert('mail to xss')</script>"));
			mail.To.Add(new MailAddress("microshaoft@qq.com", "<script>alert('mail to xss')</script>"));
			mail.Subject = "<script>alert('mail subject xss')</script>" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
			byte[] buffer = mail.GetBytes();
			File.WriteAllBytes(@"d:\temp.eml", buffer);
			Console.WriteLine("====================================================================");
			Console.ReadLine();
			Console.WriteLine("计算表达式");
			string formula = "(({0}-{1})/{2}+{3})*{4}";
			string result = JScriptEvaluator.ComputeFormula<double>
													(
														formula
														, 1f
														, 2.1
														, 3.1
														, 4.0
														, 5.0
													);
			Console.WriteLine(result);
			double x;
			x = DataTableColumnExpression.ComputeFormula<double, double>
													(
														formula
														, 1f
														, 2.1
														, 3.1
														, 4.0
														, 5.0
													);
			Console.WriteLine(x);
			//=================================================================================================
			formula = "IIF(1=2, F1, F2) + ((--F1) * F2) + F3";
			var tuples = new Tuple<string, double>[]
											{
												Tuple.Create<string,double>("F1", 1.0)
												, Tuple.Create<string,double>("F2", 2.0)
												, Tuple.Create<string,double>("F3", 3.0)
												, Tuple.Create<string,double>("F4", 4.0)
												, Tuple.Create<string,double>("F3", 2.0)
											};
			x = DataTableColumnExpression.ComputeFormula<double, double>(formula, tuples);
			Console.WriteLine(x);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.CodeDom.Compiler;
	using System.Collections.Generic;
	using System.Data;
	using System.Linq;
	using System.Reflection;
	public class DataTableColumnExpression
	{
		private static MethodInfo _mi = typeof(string).GetMethods().First
																	(
																		m => m.Name.Equals("Format")
																		&& m.GetParameters().Length == 2
																		&& m.IsStatic
																		&& m.GetParameters()[1].Name == "args"
																	);
		private class ObjectEqualityComparer<T> : IEqualityComparer<T>
		{
			private Func<T, T, bool> _onEqualsProcessFunc;
			private Func<T, int> _onGetHashCodeProcessFunc;
			public ObjectEqualityComparer
						(
							Func<T, T, bool> onEqualsProcessFunc
							, Func<T, int> onGetHashCodeProcessFunc
						)
			{
				_onEqualsProcessFunc = onEqualsProcessFunc;
				_onGetHashCodeProcessFunc = onGetHashCodeProcessFunc;
			}
			public bool Equals(T x, T y)
			{
				if (Object.ReferenceEquals(x, y))
				{
					return true;
				}
				if (Object.ReferenceEquals(x, null) || Object.ReferenceEquals(y, null))
				{
					return false;
				}
				return _onEqualsProcessFunc(x, y);
			}
			public int GetHashCode(T x)
			{
				if (Object.ReferenceEquals(x, null))
				{
					return 0;
				}
				return _onGetHashCodeProcessFunc(x);
			}
		}
		public static TResult ComputeFormula<TResult, TParameter>
													(
														string formula
														, params TParameter[] parameters
													)
		{
			var dt = new DataTable();
			var list = parameters.ToList();
			var parametersNames = new List<string>(); ;
			int i = 0;
			Array.ForEach
					(
						parameters
						, (x) =>
						{
							string f = string.Format("F{0}", i++);
							parametersNames.Add(f);
							var dc = new DataColumn(f, typeof(TParameter));
							dt.Columns.Add(dc);
						}
					);
			string expression = string.Format(formula, parametersNames.ToArray());
			dt.Columns.Add(new DataColumn("Microshaoft", typeof(TResult), expression));
			var dr = dt.NewRow();
			i = 0;
			Array.ForEach
			(
				parameters
				, (x) =>
				{
					dr[i++] = x;
				}
			);
			dt.Rows.Add(dr);
			return (TResult)dr["Microshaoft"];
		}
		public static TResult ComputeFormula<TResult, TParameter>
													(
														string formula
														, params Tuple<string, TParameter>[] parameters
													)
		{
			var dt = new DataTable();
			var comparer = new ObjectEqualityComparer<Tuple<string, TParameter>>
											(
												(x, y) =>
												{
													return x.Item1 == y.Item1;
												}
												, (x) =>
												{
													return x.Item1.GetHashCode();
												}
											);
			var list = parameters.Distinct
									(
										comparer
									)
									.ToList();
			list.ForEach
					(
						(x) =>
						{
							var dc = new DataColumn
											(
												x.Item1
												, x.Item2.GetType()
											);
							dt.Columns.Add(dc);
						}
					);
			dt.Columns.Add(new DataColumn("Microshaoft", typeof(TResult), formula));
			var dr = dt.NewRow();
			list.ForEach
					(
						(x) =>
						{
							dr[x.Item1] = x.Item2;
						}
					);
			dt.Rows.Add(dr);
			return (TResult)dr["Microshaoft"];
		}
	}
	public class JScriptEvaluator
	{
		private static MethodInfo _mi = typeof(string).GetMethods().First
																		(
																			m => m.Name.Equals("Format")
																			&& m.GetParameters().Length == 2
																			&& m.IsStatic
																			&& m.GetParameters()[1].Name == "args"
																		);
		private static Func<string, object[], object> _func = null;
		public static string ComputeFormula<TParameter>(string formula, params TParameter[] parameters)
		{
			object[] objects = new object[parameters.Length];
			Array.Copy(parameters, objects, objects.Length);
			string expression1 = string.Format(formula, objects);
			return (string)JScriptEvaluator.Eval(expression1);
			//=====================================================================
			object[] ps = new object[parameters.Length];
			Array.Copy(parameters, 0, ps, 0, ps.Length);
			if (_func == null)
			{
				_func = DynamicCallMethodExpressionTreeInvokerHelper.CreateMethodCallInvokerFunc<string, string>
												(
													typeof(string)
													, () =>
													{
														var methodsInfos = typeof(string).GetMethods();
														var methodInfo = methodsInfos.First
																						(
																							(x) =>
																							{
																								var parametersInfos = x.GetParameters();
																								//Debug.Assert(x.Name.ToLower() == "Format".ToLower());
																								return
																									x.Name.ToLower() == "Format".ToLower()
																									&& x.IsStatic
																									&& parametersInfos[0].ParameterType == typeof(string)
																									&& parametersInfos[1].ParameterType == typeof(object[])
																									&& Attribute.IsDefined
																													(
																														parametersInfos[1]
																														, typeof(ParamArrayAttribute)
																													);
																							}
																						);
														return methodInfo;
													}
												);
			}
			string expression = (string)_mi.Invoke
												(
													null
													, new object[]
															{
																formula
																, ps
															}
												);
			expression = (string) _func
									(
										formula
										, new object[]
													{
														formula
														, ps
													}
									);
			return (string) JScriptEvaluator.Eval(expression);
		}
		public static object Eval(string statement)
		{
			return _evaluatorType.InvokeMember
										(
											"Eval"
											, BindingFlags.InvokeMethod
											, null
											, _evaluator
											, new object[]
													{
														statement
													}
										);
		}
		static JScriptEvaluator()
		{
			CodeDomProvider provider = CodeDomProvider.CreateProvider("JScript");
			CompilerParameters parameters;
			parameters = new CompilerParameters();
			parameters.GenerateInMemory = true;
			CompilerResults results;
			results = provider.CompileAssemblyFromSource(parameters, _JScript);
			Assembly assembly = results.CompiledAssembly;
			_evaluatorType = assembly.GetType("Microshaoft.JScriptEvaluator");
			var constructorInfo = _evaluatorType.GetConstructors().First();
			var func = DynamicCallMethodExpressionTreeInvokerHelper.CreateNewInstanceConstructorInvokerFunc
															(
																_evaluatorType
																, constructorInfo
															);
			_evaluator = func(null);
			//_evaluator = Activator.CreateInstance(_evaluatorType);
		}
		private static object _evaluator = null;
		private static Type _evaluatorType = null;
		/// <summary>
		/// JScript代码
		/// </summary>
		private static readonly string _JScript =
			@"
				package Microshaoft
				{
					class JScriptEvaluator
					{
						public function Eval(statement : String) : String
						{
							return eval(statement);
						}
					}
				}
			";
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Linq.Expressions;
	using System.Reflection;
	public static class DynamicCallMethodExpressionTreeInvokerHelper
	{
		public static Func<object[], object> CreateNewInstanceConstructorInvokerFunc
														(
															Type type
															, Func<ConstructorInfo> getConstructorInfoFunc
														)
		{
			var constructorInfo = getConstructorInfoFunc();
			return CreateNewInstanceConstructorInvokerFunc<object>
														(
															type
															, constructorInfo
														);
		}
		public static Func<object[], T> CreateNewInstanceConstructorInvokerFunc<T>
														(
															Type type
															, Func<ConstructorInfo> getConstructorInfoFunc
														)
		{
			var constructorInfo = getConstructorInfoFunc();
			return CreateNewInstanceConstructorInvokerFunc<T>
														(
															type
															, constructorInfo
														);
		}
		public static Func<object[], object> CreateNewInstanceConstructorInvokerFunc
														(
															Type type
															, ConstructorInfo constructorInfo
														)
		{
			return CreateNewInstanceConstructorInvokerFunc<object>(type, constructorInfo);
		}
		public static Func<object[], T> CreateNewInstanceConstructorInvokerFunc<T>
														(
															Type type
															, ConstructorInfo constructorInfo
														)
		{
			var parametersInfos = constructorInfo.GetParameters();
			var constructorParametersExpressions = new List<ParameterExpression>();
			int i = 0;
			Array.ForEach
					(
						parametersInfos
						, (x) =>
						{
							var parameterExpression = Expression.Parameter
																	(
																		x.ParameterType
																		, "p" + i.ToString()
																	);
							constructorParametersExpressions.Add(parameterExpression);
							i++;
						}
					);
			var newExpression = Expression.New(constructorInfo, constructorParametersExpressions);
			var inner = Expression.Lambda(newExpression, constructorParametersExpressions);
			var args = Expression.Parameter(typeof(object[]), "args");
			var body = Expression.Invoke
									(
										inner
										, constructorParametersExpressions.Select
																	(
																		(p, ii) =>
																		{
																			return Expression.Convert
																							(
																								Expression.ArrayIndex
																												(
																													args
																													, Expression.Constant(ii)
																												)
																								, p.Type
																							);
																		}
																	).ToArray()
									);
			var outer = Expression.Lambda<Func<object[], T>>(body, args);
			var func = outer.Compile();
			return func;
		}
		public static Action<T, object[]> CreateMethodCallInvokerAction<T>
															(
																Type type
																, Func<MethodInfo> getMethodInfoFunc
															)
		{
			var methodInfo = getMethodInfoFunc();
			return CreateMethodCallInvokerAction<T>
												(
													type
													, methodInfo
												);
		}
		public static Action<T, object[]> CreateMethodCallInvokerAction<T>
															(
																Type type
																, MethodInfo methodInfo
															)
		{
			ParameterExpression instanceParameterExpression;
			MethodCallExpression methodCallExpression;
			ParameterExpression argumentsParameterExpression = GetMethodArgumentsParameterExpression
									(
										type
										, methodInfo
										, out instanceParameterExpression
										, out methodCallExpression
									);
			var lambda = Expression.Lambda<Action<T, object[]>>(methodCallExpression, instanceParameterExpression, argumentsParameterExpression);
			var action = lambda.Compile();
			return action;
		}
		public static Func<T, object[], TResult> CreateMethodCallInvokerFunc<T, TResult>
															(
																Type type
																, Func<MethodInfo> getMethodInfoFunc
															)
		{
			var methodInfo = getMethodInfoFunc();
			return
				CreateMethodCallInvokerFunc<T, TResult>
													(
														type
														, methodInfo
													);
		}
		public static Func<T, object[], TResult> CreateMethodCallInvokerFunc<T, TResult>
															(
																Type type
																, MethodInfo methodInfo
															)
		{
			ParameterExpression instanceParameterExpression;
			MethodCallExpression methodCallExpression;
			ParameterExpression argumentsParameterExpression = GetMethodArgumentsParameterExpression
									(
										type
										, methodInfo
										, out instanceParameterExpression
										, out methodCallExpression
									);
			var lambda = Expression.Lambda<Func<T, object[], TResult>>(methodCallExpression, instanceParameterExpression, argumentsParameterExpression);
			var func = lambda.Compile();
			return func;
		}
		private static ParameterExpression GetMethodArgumentsParameterExpression
											(
												Type type
												, MethodInfo methodInfo
												, out ParameterExpression instanceParameterExpression
												, out MethodCallExpression methodCallExpression
											)
		{
			var argumentsParameterExpression = Expression.Parameter(typeof(object[]), "args");
			instanceParameterExpression = Expression.Parameter(type);
			UnaryExpression instanceConvertUnaryExpression = null;
			if (!methodInfo.IsStatic)
			{
				instanceConvertUnaryExpression = Expression.Convert(instanceParameterExpression, type);
			}
			var parametersParameterExpressionList = new List<Expression>();
			int i = 0;
			var parametersInfos = methodInfo.GetParameters();
			Array.ForEach
					(
						parametersInfos
						, (x) =>
						{
							BinaryExpression valueObject = Expression.ArrayIndex
																		(
																			argumentsParameterExpression
																			, Expression.Constant(i)
																		);
							UnaryExpression valueCast = Expression.Convert
																		(
																			valueObject
																			, x.ParameterType
																		);
							parametersParameterExpressionList.Add(valueCast);
							i++;
						}
					);
			methodCallExpression = Expression.Call(instanceConvertUnaryExpression, methodInfo, parametersParameterExpressionList);
			return argumentsParameterExpression;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Net.Mail;
	using System.Reflection;
	public static partial class ExtensionMethodsManager
	{
		public static byte[] GetBytes(this MailMessage mailMessage)
		{
			Assembly assembly = typeof(SmtpClient).Assembly;
			Type type = assembly.GetType("System.Net.Mail.MailWriter");
			var parametersTypes = new[]
									{ 
										typeof(Stream)
									};
			object x = null;
			using (Stream stream = new MemoryStream())
			{
				var constructorInfo = type.GetConstructor
													(
														BindingFlags.Instance | BindingFlags.NonPublic
														, null
														, parametersTypes
														, null
													);
				var func = DynamicCallMethodExpressionTreeInvokerHelper.CreateNewInstanceConstructorInvokerFunc<object>
														(
															type
															, constructorInfo
														);
				x = func(new[] { stream });
				var action = DynamicCallMethodExpressionTreeInvokerHelper.CreateMethodCallInvokerAction<MailMessage>
														(
															typeof(MailMessage)
															, () =>
															{
																var methodInfo = typeof(MailMessage).GetMethod
																						(
																							"Send"
																							, BindingFlags.NonPublic | BindingFlags.Instance
																							, null
																							, new[] { type, typeof(bool) }
																							, null
																						);
																return methodInfo;
															}
														);
				action
					(
						mailMessage
						, new[]
							{
								x
								, true
							}
					);
				byte[] buffer = StreamDataHelper.ReadDataToBytes(stream);
				return buffer;
			}
		}
	}
}
namespace Microshaoft
{
	using System.IO;
	public static class StreamDataHelper
	{
		public static byte[] ReadDataToBytes(Stream stream)
		{
			byte[] buffer = new byte[64 * 1024];
			MemoryStream ms = new MemoryStream();
			int r = 0;
			int l = 0;
			long position = -1;
			if (stream.CanSeek)
			{
				position = stream.Position;
				stream.Position = 0;
			}
			while (true)
			{
				r = stream.Read(buffer, 0, buffer.Length);
				if (r > 0)
				{
					l += r;
					ms.Write(buffer, 0, r);
				}
				else
				{
					break;
				}
			}
			byte[] bytes = new byte[l];
			ms.Position = 0;
			ms.Read(bytes, 0, (int)l);
			ms.Close();
			ms.Dispose();
			ms = null;
			if (position >= 0)
			{
				stream.Position = position;
			}
			return bytes;
		}
	}
}

#T=参数化 SQL in 子句
//参数化 SQL in 子句
namespace Microshaoft.Test
{
	using System;
	using System.Data;
	using System.Data.SqlClient;
	using Microshaoft.ParameterizedSqlTest;

	/// <summary>
	/// Class1 的摘要说明。
	/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());

			DataTable dt = DataAccess.Execute_SQL
								(
									"abc"
									, "d"
									, "a,b,c,d"
									, SqlDbType.VarChar
									, 3
									, "sqlPara"
								);
			Console.WriteLine(dt.Rows.Count);
			Console.ReadLine();
		}
	}
}

namespace Microshaoft.ParameterizedSqlTest
{
	using System;
	using System.Data;
	using System.Data.SqlClient;

	using System.Text;

	class DataAccess
	{

		public static string _ConnectionString = @"Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=Northwind;Data Source=.\sqlexpress";//ConfigurationManager.ConnectionStrings["ConnectionString"].ConnectionString;
		public static DataTable Execute_SQL
								(
									string Parameter1					//普通参数
									, string Parameter2					//普通参数
									, string inClause					//in 子句字段值列表
									, SqlDbType inClauseSqlDbType		//in 子句字段类型
									, int inClauseSqlDbTypeSize			//in 子句字段大小
									, string prefixSqlParameterName		//参数前缀
								)
		{
			SqlConnection connection = new SqlConnection(_ConnectionString);

			StringBuilder sql = new StringBuilder("select 1 where 'abc' = @Parameter1");

			SqlCommand command = new SqlCommand();
			command.CommandType = CommandType.Text;

			SqlParameter sqlParameter1 = command.Parameters.Add("@Parameter1", SqlDbType.VarChar, 3);
			sqlParameter1.Direction = ParameterDirection.Input;
			sqlParameter1.Value = Parameter1;

			SqlParameter sqlParameter2 = command.Parameters.Add("@Parameter2", SqlDbType.VarChar, 3);
			sqlParameter2.Direction = ParameterDirection.Input;
			sqlParameter2.Value = Parameter2;

			string[] a = inClause.Split(',');
			if (a.Length > 0)
			{
				sql.Append(" and @Parameter2 in (");
				int i = 0;

				foreach (string var in a)
				{
					i ++;
					if (i > 1)
					{
						sql.Append(",");
					}
					string sqlParameterName = "@" + prefixSqlParameterName + "_" + i;
					sql.Append(sqlParameterName);
					SqlParameter parameter;
					if (inClauseSqlDbTypeSize > 0)
					{
						parameter = command.Parameters.Add(sqlParameterName, inClauseSqlDbType, inClauseSqlDbTypeSize);
					}
					else
					{
						parameter = command.Parameters.Add(sqlParameterName, inClauseSqlDbType);
					}
					parameter.Direction = ParameterDirection.Input;
					parameter.Value = var;

				}
				sql.Append(")");
			}
			command.CommandText = sql.ToString();
			command.Connection = connection;

			Console.WriteLine(command.CommandText);
			SqlDataAdapter sda = new SqlDataAdapter(command);
			DataSet ds = new DataSet();
			sda.Fill(ds);
			connection.Close();
			return ds.Tables[0];
			
		}

	}
}
#T=单件模式 lambda
namespace ConsoleApplication1
{
	using System;
	using System.Collections.Generic;
	using Microshaoft.DesignPatterns;
	class Program
	{
		static void Main(string[] args)
		{
			new SingletonWrapper<List<string>>
					(
						() =>
						{
							return
								new List<string>()
								{
									"dsadsa"
									,"asdsa"
								};
						}
					);
			new SingletonWrapper<List<int>>
			(
				() =>
				{
					return
						new List<int>()
						{
										1
										,2
						};
				}
			);
			new SingletonWrapper<List<string>>
					(
						() =>
						{
							return
								new List<string>()
								{
									"dsadsa"
									,"asdsa"
								};
						}
					);
			new SingletonWrapper<List<int>>
			(
				() =>
				{
					return
						new List<int>()
						{
										1
										,2
						};
				}
			);
			Console.ReadLine();
		}
	}
}
namespace Microshaoft.DesignPatterns
{
	using System;
	using System.Threading;
	public static class SingletonHelper<T>
	{
		private static T _singletonInstance = default(T);
		private static /*volatile*/ bool _initialized = false;
		private static object _locker = new object();
		public static T GetSingletonInstance
								(
									Func<T> onInitializeSingletonInstanceProcessFunc
								)
		{
			return EnsureInitialized(onInitializeSingletonInstanceProcessFunc);
		}
		private static T EnsureInitialized(Func<T> onInitializeSingletonInstanceProcessFunc)
		{
			//bool initialized = Volatile.Read(ref _initialized);
			if (!_initialized)
			{
				if (_singletonInstance == null)
				{
					lock (_locker)
					{
						_singletonInstance = onInitializeSingletonInstanceProcessFunc();
					}
					Volatile.Write(ref _initialized, true);
				}
			}
			return _singletonInstance;
		}
	}
	public class SingletonWrapper<T>
	{
		private static T _singletonInstance = default(T);
		public SingletonWrapper
						(
							Func<T> onInitializeSingletonInstanceProcessFunc
						)
		{
			SingletonHelper<T>
					.GetSingletonInstance
						(
							onInitializeSingletonInstanceProcessFunc
						);
		}
		public T Instance
		{
			get
			{
				return _singletonInstance;
			}
		}
		public static T SingletonInstance
		{
			get
			{
				return _singletonInstance;
			}
		}
	}
}

#T=单链表 面试
namespace Microshaoft
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }

    public class LinkNode<T>
    {
        public T Context;
        public LinkNode<T> Next;
    }
    
    public class LinkList<T>
    {
        public LinkNode<T> Head;
        public void Add(T context)
        {
            var node = new LinkNode<T>()
                        {
                            Context = context
                        };
            if (Head == null)
            {
                Head = node;
            }
            else
            {
                var temp = Head;
                while (temp.Next != null)
                {
                    temp = temp.Next;
                }
                temp.Next = node;
            }
        }
    }
    class LinkList2<T>
    {
        private LinkNode<T> Head;
        public void Add(T context)
        {
            if (Head == null)
            {
                Head = new LinkNode<T>() { Context = context };
            }
            else
            {
                TryAdd(Head, context);
            }
        }
        private void TryAdd(LinkNode<T> node, T context)
        {
            if (node.Next != null)
            {
                TryAdd(node.Next, context);
            }
            node.Next = new LinkNode<T>()
                            {
                                Context = context
                            };
        }
    }
}

#T=动态规划 算法 code jam
namespace ConsoleApplication
{
	using System;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		private static string math = "welcome to code jam";
		private static string input = "weeeeeeeeeeeeeeeeeeeeellllllllllllllllccccoooommmmmee to code qps jam";

		public static void add(ref int i, int Delta)
		{
			i += Delta;
			if (i >= 10000)
				i -= 10000;
		}
		private static void Main() {
			int[,] DP = new int[input.Length, math.Length];
			for (int i = 0; i < input.Length; i++) {
				if (input[i] == math[0])
					add(ref DP[i, 0], 1);
				if (i == 0) continue;
				for (int j = 0; j < math.Length; j++) {
					if (j >= 1 && input[i] == math[j])
						add(ref DP[i, j], DP[i - 1, j - 1]);
					add(ref DP[i, j], DP[i - 1, j]);
				}
			}
			int ret = DP[input.Length - 1, math.Length - 1];
			Console.WriteLine(ret);
			Console.ReadKey();
		}
	}

}

#T=多态继承
namespace Microshaoft
{
    using System;
    using System.Runtime.CompilerServices;
    class Program
    {
        static void Main(string[] args)
        {
            Dog d = new Dog();
            Animal a = d;
            //Animal a1 = new Animal();
            ProcessA(a);
            ProcessD((Dog) a);
            ProcessD(d);
            Console.ReadLine();
        }
        public static void ProcessA
                            (
                                Animal a
                                , [CallerMemberName] string callerMemberName = null
                            )
        {
            Console.WriteLine("CallerMemberName: {0}", callerMemberName);
            a.GetName();
            a.Cry();
            Console.WriteLine(a.F);
            Console.WriteLine(a.GetType());
            Console.WriteLine("===============");
        }
        public static void ProcessD
                            (
                                Dog d
                                , [CallerMemberName] string callerMemberName = null
                            )
        {
            Console.WriteLine("CallerMemberName: {0}", callerMemberName);
            d.GetName();
            d.Cry();
            Console.WriteLine(d.F);
            Console.WriteLine("===============");
        }
 
    }
    public abstract class Animal
    {
        public string F = "Aa";
        public
            virtual
                void Cry()
        {
            Console.WriteLine("No");   
        }
        public
            abstract
        void CryAbstract();
        
        public void GetName()
        {
            Console.WriteLine(this.GetType());   
        }
    }
    public class Dog : Animal
    {
        public string F = "Dd";
        public
            new
            //override
                void Cry() 
        {
            Console.WriteLine("Wang"); 
        }
        public
            //new
            override
                void CryAbstract()
        {
            Console.WriteLine("WangAbstract");
        }
    }
}

#T=多字段排序
/*
	新浪微博
	@左耳朵耗子
	http://weibo.com/haoel
	讨论:
	http://weibo.com/1401880315/zd7nBxyDi
*/
/*
	2004年 .NET C# 1.0 版, 使用 委托 + 冒泡排序算法 实现:
	http://www.cnblogs.com/Microshaoft/archive/2004/10/29/2485761.html
	http://blog.csdn.net/playyuer/article/details/157492
*/
/*
	2012年 .NET C# 4.0+ 版, 使用 泛型 + Func + Lambda + 快速、冒泡排序算法 实现:
*/
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Diagnostics;
	using System.Linq;
	using Microshaoft;
	class Class1 //测试程序
	{
		static void Main()
		{
			int iterations = 1;
			int maxDegreeOfParallelism = 8; // Environment.ProcessorCount;
			var performanceCountersCategoryName = "Microshaoft EasyPerformanceCounters Category";
			var performanceCountersCategoryInstanceName = string.Format
																	(
																		"{2}{0}{3}{1}{4}"
																		, ": "
																		, " @ "
																		, ""
																		, ""
																		, Process.GetCurrentProcess().ProcessName
																	);
			EasyPerformanceCountersHelper.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, performanceCountersCategoryInstanceName + "-1"
								);
			Person[] persons = new Person[9 * 1024 * 1024]; //1024 * 128];
			for (int i = 0; i < persons.Length; i += 9)
			{
				persons[i + 0] = new Person("张嘀", 71, 178, 49);
				persons[i + 1] = new Person("章子怡", 23, 177, 33);
				persons[i + 2] = new Person("周  迅", 12, 180, 80);
				persons[i + 3] = new Person("徐静蕾", 12, 150, 70);
				persons[i + 4] = new Person("赵  薇", 23, 166, 60);
				persons[i + 5] = new Person("宋丹丹", 50, 183, 50);
				persons[i + 6] = new Person("翠花儿", 23, 177, 34);
				persons[i + 7] = new Person("赵丽蓉", 50, 184, 40);
				persons[i + 8] = new Person("郭晶晶", 50, 184, 41);
			}
			CodeTimerPerformance.ParallelTime
						(
							string.Format("快速排序 {0}", persons.Length)
							, iterations
							, () =>
							{
								QuickSortTest(persons);
							}
							, maxDegreeOfParallelism
							, true
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName + "-1"
						);
			//Array.ForEach
			//		(
			//			persons
			//			,x => Console.WriteLine(x)
			//		);
			persons = new Person[9 * 1024 * 1024];
			for (int i = 0; i < persons.Length; i += 9)
			{
				persons[i + 0] = new Person("张嘀", 71, 178, 49);
				persons[i + 1] = new Person("章子怡", 23, 177, 33);
				persons[i + 2] = new Person("周  迅", 12, 180, 80);
				persons[i + 3] = new Person("徐静蕾", 12, 150, 70);
				persons[i + 4] = new Person("赵  薇", 23, 166, 60);
				persons[i + 5] = new Person("宋丹丹", 50, 183, 50);
				persons[i + 6] = new Person("翠花儿", 23, 177, 34);
				persons[i + 7] = new Person("赵丽蓉", 50, 184, 40);
				persons[i + 8] = new Person("郭晶晶", 50, 184, 41);
			}
			var list = persons.ToList();
			CodeTimerPerformance.ParallelTime
						(
							string.Format("函数式快速排序 {0}", persons.Length)
							, iterations
							, () =>
							{
								list = QuickSortTest(list);
							}
							, maxDegreeOfParallelism
							, true
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName + "-1"
						);
			///list.ForEach
			///(
			///x => Console.WriteLine(x)
			///);
			persons = new Person[9 * 1024];
			for (int i = 0; i < persons.Length; i += 9)
			{
				persons[i + 0] = new Person("张嘀", 71, 178, 49);
				persons[i + 1] = new Person("章子怡", 23, 177, 33);
				persons[i + 2] = new Person("周  迅", 12, 180, 80);
				persons[i + 3] = new Person("徐静蕾", 12, 150, 70);
				persons[i + 4] = new Person("赵  薇", 23, 166, 60);
				persons[i + 5] = new Person("宋丹丹", 50, 183, 50);
				persons[i + 6] = new Person("翠花儿", 23, 177, 34);
				persons[i + 7] = new Person("赵丽蓉", 50, 184, 40);
				persons[i + 8] = new Person("郭晶晶", 50, 184, 41);
			}
			CodeTimerPerformance.ParallelTime
						(
							string.Format("冒泡排序 {0}", persons.Length)
							, iterations
							, () =>
							{
								BubbleSortTest(persons);
							}
							, maxDegreeOfParallelism
							, true
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName + "-1"
						);
			Console.WriteLine("end...");
			Console.ReadLine();
		}
		static List<Person> QuickSortTest(List<Person> persons)
		{
			return Sorter.QuickSort<Person>(persons).ToList();
		}
		static void QuickSortTest(Person[] persons)
		{
			//快速排序实现: 大于
			Sorter.QuickSort<Person>
								(
									persons
									, (x, y) =>
									{
										return (x.Age > y.Age);
									}
									, (x, y) =>
									{
										return
												x.Age == y.Age
												&& x.Height > y.Height;
									}
									, (x, y) =>
									{
										return
												x.Height == y.Height
												&& x.Weight > y.Weight;
									}
								);
		}
		static void BubbleSortTest(Person[] persons)
		{
			//冒泡排序实现: 大于
			Sorter.BubbleSort<Person>
								(
									persons
									, (x, y) =>
									{
										return (x.Age > y.Age);
									}
									, (x, y) =>
									{
										return
												x.Age == y.Age
												&& x.Height > y.Height;
									}
									, (x, y) =>
									{
										return
												x.Height == y.Height
												&& x.Weight > y.Weight;
									}
								);
		}
	}
	public class Person : IComparable<Person>
	{
		public string Name
		{
			get;
			private set;
		}
		public int Age
		{
			get;
			private set;
		}
		public int Height
		{
			get;
			private set;
		}
		public int Weight
		{
			get;
			private set;
		}
		public Person(string name, int age, int height, int weight)
		{
			Name = name;
			Age = age;
			Height = height;
			Weight = weight;
		}
		public override string ToString()
		{
			return
				string.Format
						(
							"姓名:{0}, 年龄:{1:N}, 体重:{2:N}, 身高:{3:N}"
							, Name
							, Age
							, Height
							, Weight
						);
		}
		public int CompareTo(Person other)
		{
			int r = 0;
			r = Age - other.Age;
			if (r == 0)
			{
				r = Height - other.Height;
				if (r == 0)
				{
					r = Weight - other.Weight;
				}
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	// "排序功能(工具)类"
	public static class Sorter
	{
		//本排序的基本算法就是冒泡法最常见简单易懂,属于"交换"排序法的一种!
		public static void BubbleSort<T>
								(
									T[] targets
									, params Func<T, T, bool>[] compareFuncs
								)
		{
			int l = targets.Length;
			for (int i = l - 1; i >= 0; i--)
			{
				for (int j = 1; j <= i; j++)
				{
					if (Compare<T>(targets[j - 1], targets[j], compareFuncs))
					//(targets[j - 1] > targets[j])
					{
						Swap<T>(ref targets[j - 1], ref targets[j]);
					}
				}
			}
		}
		public static void QuickSort<T>
								(
									T[] targets
									, params Func<T, T, bool>[] compareFuncs
								)
		{
			QuickSortProcess<T>(targets, 0, targets.Length - 1, compareFuncs);
		}
		private static void QuickSortProcess<T>
								(
									T[] targets
									, int begin
									, int end
									, Func<T, T, bool>[] compareFuncs
								)
		{
			if (begin < end)
			{
				T pivot = targets[(begin + end) / 2];
				int i = begin - 1;
				int j = end + 1;
				while (true)
				{
					while // (targets[++i] < middle) ;
						(Compare<T>(pivot, targets[++i], compareFuncs)) ;
					while //(targets[--j] > middle) ;
						(Compare<T>(targets[--j], pivot, compareFuncs)) ;
					if (i >= j)
					{
						break;
					}
					//T temp = targets[i];
					//targets[i] = targets[j];
					//targets[j] = temp;
					Swap<T>(ref targets[i], ref targets[j]);
				}
				QuickSortProcess(targets, begin, i - 1, compareFuncs);
				QuickSortProcess(targets, j + 1, end, compareFuncs);
			}
		}
		public static IEnumerable<T> QuickSort<T>
										(
											IEnumerable<T> list
										)
											where T : IComparable<T>
		{
			if (list.Count() <= 1)
			{
				return list;
			}
			var pivot = list.FirstOrDefault();
			return
				QuickSort
						(
							list.Where
									(
										x => x.CompareTo(pivot) < 0
									)
						)
						.Concat
							(
								list.Where
									(
										x => x.CompareTo(pivot) == 0
									)
							)
						.Concat
							(
								QuickSort
									(
										list.Where
												(
													x => x.CompareTo(pivot) > 0
												)
									)
							);
		}
		private static bool Compare<T>
							(
								T x
								, T y
								, Func<T, T, bool>[] compareFuncs
							)
		{
			bool r = false;
			int l = compareFuncs.Length;
			for (int i = 0; i < l; i++)			// 遍历委托数组
			{
				r = compareFuncs[i](x, y);
				if (r)
				{
					break;
				}
			}
			return r;
		}
		private static void Swap<T>(ref T x, ref T y)
		{
			T temp = x;
			x = y;
			y = temp;
		}
	}
}

#T=多字段排序(缺CodeTimerPerformance)
/*
	新浪微博
	@左耳朵耗子
	http://weibo.com/haoel
	讨论:
	http://weibo.com/1401880315/zd7nBxyDi
*/
/*
	2004年 .NET C# 1.0 版, 使用 委托 + 冒泡排序算法 实现:
	http://www.cnblogs.com/Microshaoft/archive/2004/10/29/2485761.html
	http://blog.csdn.net/playyuer/article/details/157492
*/
/*
	2012年 .NET C# 4.0+ 版, 使用 泛型 + Func + Lambda + 快速、冒泡排序算法 实现:
*/
namespace Test
{
	using System;
	using System.Collections.Generic;
	using System.Diagnostics;
	using System.Linq;
	using Microshaoft;
	class Class1 //测试程序
	{
		static void Main()
		{
			int iterations = 1;
			int maxDegreeOfParallelism = 8; // Environment.ProcessorCount;
			var performanceCountersCategoryName = "Microshaoft EasyPerformanceCounters Category";
			var enableCounters = MultiPerformanceCountersTypeFlags.ProcessCounter
									| MultiPerformanceCountersTypeFlags.ProcessedAverageTimerCounter
									| MultiPerformanceCountersTypeFlags.ProcessedCounter
									| MultiPerformanceCountersTypeFlags.ProcessedRateOfCountsPerSecondCounter
									| MultiPerformanceCountersTypeFlags.ProcessingingCounter;
			var performanceCountersCategoryInstanceName = string.Format
																	(
																		"{2}{0}{3}{1}{4}"
																		, ": "
																		, " @ "
																		, ""
																		, ""
																		, Process.GetCurrentProcess().ProcessName
																	);
			EasyPerformanceCountersHelper.AttachPerformanceCountersCategoryInstance
								(
									performanceCountersCategoryName
									, performanceCountersCategoryInstanceName + "-1"
								);
			Person[] persons = new Person[9 * 1024 * 1024]; //1024 * 128];
			for (int i = 0; i < persons.Length; i += 9)
			{
				persons[i + 0] = new Person("张嘀", 71, 178, 49);
				persons[i + 1] = new Person("章子怡", 23, 177, 33);
				persons[i + 2] = new Person("周  迅", 12, 180, 80);
				persons[i + 3] = new Person("徐静蕾", 12, 150, 70);
				persons[i + 4] = new Person("赵  薇", 23, 166, 60);
				persons[i + 5] = new Person("宋丹丹", 50, 183, 50);
				persons[i + 6] = new Person("翠花儿", 23, 177, 34);
				persons[i + 7] = new Person("赵丽蓉", 50, 184, 40);
				persons[i + 8] = new Person("郭晶晶", 50, 184, 41);
			}
			CodeTimerPerformance.ParallelTime
						(
							string.Format("快速排序 {0}", persons.Length)
							, iterations
							, () =>
							{
								QuickSortTest(persons);
							}
							, maxDegreeOfParallelism
							, enableCounters
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName + "-1"
						);
			//Array.ForEach
			//		(
			//			persons
			//			,x => Console.WriteLine(x)
			//		);
			persons = new Person[9 * 1024 * 1024];
			for (int i = 0; i < persons.Length; i += 9)
			{
				persons[i + 0] = new Person("张嘀", 71, 178, 49);
				persons[i + 1] = new Person("章子怡", 23, 177, 33);
				persons[i + 2] = new Person("周  迅", 12, 180, 80);
				persons[i + 3] = new Person("徐静蕾", 12, 150, 70);
				persons[i + 4] = new Person("赵  薇", 23, 166, 60);
				persons[i + 5] = new Person("宋丹丹", 50, 183, 50);
				persons[i + 6] = new Person("翠花儿", 23, 177, 34);
				persons[i + 7] = new Person("赵丽蓉", 50, 184, 40);
				persons[i + 8] = new Person("郭晶晶", 50, 184, 41);
			}
			var list = persons.ToList();
			CodeTimerPerformance.ParallelTime
						(
							string.Format("函数式快速排序 {0}", persons.Length)
							, iterations
							, () =>
							{
								list = QuickSortTest(list);
							}
							, maxDegreeOfParallelism
							, enableCounters
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName + "-1"
						);
			///list.ForEach
			///(
			///x => Console.WriteLine(x)
			///);
			persons = new Person[9 * 1024];
			for (int i = 0; i < persons.Length; i += 9)
			{
				persons[i + 0] = new Person("张嘀", 71, 178, 49);
				persons[i + 1] = new Person("章子怡", 23, 177, 33);
				persons[i + 2] = new Person("周  迅", 12, 180, 80);
				persons[i + 3] = new Person("徐静蕾", 12, 150, 70);
				persons[i + 4] = new Person("赵  薇", 23, 166, 60);
				persons[i + 5] = new Person("宋丹丹", 50, 183, 50);
				persons[i + 6] = new Person("翠花儿", 23, 177, 34);
				persons[i + 7] = new Person("赵丽蓉", 50, 184, 40);
				persons[i + 8] = new Person("郭晶晶", 50, 184, 41);
			}
			CodeTimerPerformance.ParallelTime
						(
							string.Format("冒泡排序 {0}", persons.Length)
							, iterations
							, () =>
							{
								BubbleSortTest(persons);
							}
							, maxDegreeOfParallelism
							, enableCounters
							, performanceCountersCategoryName
							, performanceCountersCategoryInstanceName + "-1"
						);
			Console.WriteLine("end...");
			Console.ReadLine();
		}
		static List<Person> QuickSortTest(List<Person> persons)
		{
			return Sorter.QuickSort<Person>(persons).ToList();
		}
		static void QuickSortTest(Person[] persons)
		{
			//快速排序实现: 大于
			Sorter.QuickSort<Person>
								(
									persons
									, (x, y) =>
									{
										return (x.Age > y.Age);
									}
									, (x, y) =>
									{
										return
												x.Age == y.Age
												&& x.Height > y.Height;
									}
									, (x, y) =>
									{
										return
												x.Height == y.Height
												&& x.Weight > y.Weight;
									}
								);
		}
		static void BubbleSortTest(Person[] persons)
		{
			//冒泡排序实现: 大于
			Sorter.BubbleSort<Person>
								(
									persons
									, (x, y) =>
									{
										return (x.Age > y.Age);
									}
									, (x, y) =>
									{
										return
												x.Age == y.Age
												&& x.Height > y.Height;
									}
									, (x, y) =>
									{
										return
												x.Height == y.Height
												&& x.Weight > y.Weight;
									}
								);
		}
	}
	public class Person : IComparable<Person>
	{
		public string Name
		{
			get;
			private set;
		}
		public int Age
		{
			get;
			private set;
		}
		public int Height
		{
			get;
			private set;
		}
		public int Weight
		{
			get;
			private set;
		}
		public Person(string name, int age, int height, int weight)
		{
			Name = name;
			Age = age;
			Height = height;
			Weight = weight;
		}
		public override string ToString()
		{
			return
				string.Format
						(
							"姓名:{0}, 年龄:{1:N}, 体重:{2:N}, 身高:{3:N}"
							, Name
							, Age
							, Height
							, Weight
						);
		}
		public int CompareTo(Person other)
		{
			int r = 0;
			r = Age - other.Age;
			if (r == 0)
			{
				r = Height - other.Height;
				if (r == 0)
				{
					r = Weight - other.Weight;
				}
			}
			return r;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	// "排序功能(工具)类"
	public static class Sorter
	{
		//本排序的基本算法就是冒泡法最常见简单易懂,属于"交换"排序法的一种!
		public static void BubbleSort<T>
								(
									T[] targets
									, params Func<T, T, bool>[] compareFuncs
								)
		{
			int l = targets.Length;
			for (int i = l - 1; i >= 0; i--)
			{
				for (int j = 1; j <= i; j++)
				{
					if (Compare<T>(targets[j - 1], targets[j], compareFuncs))
					//(targets[j - 1] > targets[j])
					{
						Swap<T>(ref targets[j - 1], ref targets[j]);
					}
				}
			}
		}
		public static void QuickSort<T>
								(
									T[] targets
									, params Func<T, T, bool>[] compareFuncs
								)
		{
			QuickSortProcess<T>(targets, 0, targets.Length - 1, compareFuncs);
		}
		private static void QuickSortProcess<T>
								(
									T[] targets
									, int begin
									, int end
									, Func<T, T, bool>[] compareFuncs
								)
		{
			if (begin < end)
			{
				T pivot = targets[(begin + end) / 2];
				int i = begin - 1;
				int j = end + 1;
				while (true)
				{
					while // (targets[++i] < middle) ;
						(Compare<T>(pivot, targets[++i], compareFuncs)) ;
					while //(targets[--j] > middle) ;
						(Compare<T>(targets[--j], pivot, compareFuncs)) ;
					if (i >= j)
					{
						break;
					}
					//T temp = targets[i];
					//targets[i] = targets[j];
					//targets[j] = temp;
					Swap<T>(ref targets[i], ref targets[j]);
				}
				QuickSortProcess(targets, begin, i - 1, compareFuncs);
				QuickSortProcess(targets, j + 1, end, compareFuncs);
			}
		}
		public static IEnumerable<T> QuickSort<T>
										(
											IEnumerable<T> list
										)
											where T : IComparable<T>
		{
			if (list.Count() <= 1)
			{
				return list;
			}
			var pivot = list.FirstOrDefault();
			return
				QuickSort
						(
							list.Where
									(
										x => x.CompareTo(pivot) < 0
									)
						)
						.Concat
							(
								list.Where
									(
										x => x.CompareTo(pivot) == 0
									)
							)
						.Concat
							(
								QuickSort
									(
										list.Where
												(
													x => x.CompareTo(pivot) > 0
												)
									)
							);
		}
		private static bool Compare<T>
							(
								T x
								, T y
								, Func<T, T, bool>[] compareFuncs
							)
		{
			bool r = false;
			int l = compareFuncs.Length;
			for (int i = 0; i < l; i++)			// 遍历委托数组
			{
				r = compareFuncs[i](x, y);
				if (r)
				{
					break;
				}
			}
			return r;
		}
		private static void Swap<T>(ref T x, ref T y)
		{
			T temp = x;
			x = y;
			y = temp;
		}
	}
}

#T=反射 对比
// /r:"C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\IDE\PublicAssemblies\Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll"
namespace DynamicAccess.Test
{
	using DynamicAccess.Test.ObjectModel;
	using Microsoft.VisualStudio.TestTools.UnitTesting;
	/// <summary>
	/// This is a test class for ReflectionMemberAccessorTest and is intended
	/// to contain all ReflectionMemberAccessorTest Unit Tests
	/// </summary>
	[TestClass]
	public class ReflectionMemberAccessorTest
	{
		private object testObject;
		private string testMemberName;
		[TestInitialize]
		public void OnTestStartup()
		{
			testObject = new Man()
			{
				Weight = 50.0
			};
			testMemberName = "Weight";
		}
		[TestMethod]
		public void GetValueByRelfectionTest()
		{
			var target = new ReflectionMemberAccessor();
			var actual = target.GetValue(testObject, testMemberName);
			Assert.AreEqual(50.0, actual);
		}
		[TestMethod]
		public void GetValueByDelegatedreflectionTest()
		{
			var acessor = new DelegatedExpressionMemberAccessor();
			var actual = acessor.GetValue(testObject, testMemberName);
			Assert.AreEqual(50.0, actual);
		}
		[TestMethod]
		public void GetValueByDynamicMethodTest()
		{
			var accessor = new DynamicMethodMemberAccessor();
			accessor.SetValue(testObject, testMemberName, 60.0);
			var actual = (double)accessor.GetValue(testObject, testMemberName);
			Assert.AreEqual(60.0, actual);
			accessor.SetValue(testObject, testMemberName, 50.0);
		}
		[TestMethod]
		public void GetValueByObjectInterfaceTest()
		{
			var actual = (testObject as IMemberAccessor).GetValue(testObject, testMemberName);
			Assert.AreEqual(50.0, actual);
		}
		[TestMethod]
		public void PerformanceTest()
		{
			var runTime = 10000000;
			var ra = new ReflectionMemberAccessor();
			var ea = new DelegatedExpressionMemberAccessor();
			var da = new DelegatedReflectionMemberAccessor();
			var ma = new DynamicMethodMemberAccessor();
			var ga = new DynamicMethod<Man>();
			//预热
			ea.SetValue(testObject, testMemberName, ea.GetValue(testObject, testMemberName));
			ma.SetValue(testObject, testMemberName, ma.GetValue(testObject, testMemberName));
			ra.SetValue(testObject, testMemberName, ra.GetValue(testObject, testMemberName));
			ga.SetValue(testObject, testMemberName, ga.GetValue(testObject, testMemberName));
			da.SetValue(testObject, testMemberName, da.GetValue(testObject, testMemberName));
			new TimeProfiler(() => (testObject as Man).Weight = (testObject as Man).Weight, "直接调用").Run(runTime);
			new TimeProfiler(() => ra.SetValue(testObject, testMemberName, ra.GetValue(testObject, testMemberName)), "反射调用").Run(runTime);
			new TimeProfiler(() => ea.SetValue(testObject, testMemberName, ea.GetValue(testObject, testMemberName)), "Expression委托调用").Run(runTime);
			new TimeProfiler(() => da.SetValue(testObject, testMemberName, da.GetValue(testObject, testMemberName)), "CreateDelegate委托调用").Run(runTime);
			new TimeProfiler(() => (testObject as IMemberAccessor).SetValue(testObject, testMemberName, (testObject as IMemberAccessor).GetValue(testObject, testMemberName)), "接口Switch调用").Run(runTime);
			new TimeProfiler(() => ma.SetValue(testObject, testMemberName, ma.GetValue(testObject, testMemberName)), "动态生成函数调用").Run(runTime);
			new TimeProfiler(() => ga.SetValue(testObject, testMemberName, ga.GetValue(testObject, testMemberName)), "泛型动态生成函数调用").Run(runTime);
			
		}
	}
}
namespace DynamicAccess.Test.ObjectModel
{
	using System;
	/// <summary>
	/// 
	/// </summary>
	public class Man : IMemberAccessor
	{
		public string Name { get; set; }
		public int Age { get; set; }
		public DateTime Birthday { get; set; }
		public double Weight { get; set; }
		public double Height { get; set; }
		public decimal Salary { get; set; }
		public bool Married { get; set; }
		public object GetValue(object instance, string memberName)
		{
			var man = instance as Man;
			if (man != null)
			{
				switch (memberName)
				{
					case "Name": return man.Name;
					case "Age": return man.Age;
					case "Birthday": return man.Birthday;
					case "Weight": return man.Weight;
					case "Height": return man.Height;
					case "Salary": return man.Salary;
					case "Married": return man.Married;
					default:
						return null;
				}
			}
			else
				throw new InvalidProgramException();
		}
		public void SetValue(object instance, string memberName, object newValue)
		{
			var man = instance as Man;
			if (man != null)
			{
				switch (memberName)
				{
					case "Name": man.Name = newValue as string; break;
					case "Age": man.Age = Convert.ToInt32(newValue); break;
					case "Birthday": man.Birthday = Convert.ToDateTime(newValue); break;
					case "Weight": man.Weight = Convert.ToDouble(newValue); break;
					case "Height": man.Height = Convert.ToDouble(newValue); break;
					case "Salary": man.Salary = Convert.ToDecimal(newValue); break;
					case "Married": man.Married = Convert.ToBoolean(newValue); break;
				}
			}
			else
				throw new InvalidProgramException();
		}
	}
}
namespace DynamicAccess.Test
{
	using System;
	using System.Diagnostics;
	/// <summary>
	/// 
	/// </summary>
	public class TimeProfiler
	{
		private Action action = null;
		private string name = null;
		public TimeProfiler(Action action, string name)
		{
			this.action = action;
			this.name = name;
		}
		public TimeSpan Run(int times)
		{
			var watch = Stopwatch.StartNew();
			while (times-- > 0)
			{
				action();
			}
			watch.Stop();
			Trace.WriteLine(String.Format("{0}运行用时：{1}ms", name, watch.Elapsed.TotalMilliseconds));
			return watch.Elapsed;
		}
	}
}
namespace DynamicAccess
{
	/// <summary>
	/// Abstraction of the function of accessing member of a object at runtime.
	/// </summary>
	public interface IMemberAccessor
	{
		/// <summary>
		/// Get the member value of an object.
		/// </summary>
		/// <param name="instance">The object to get the member value from.</param>
		/// <param name="memberName">The member name, could be the name of a property of field. Must be public member.</param>
		/// <returns>The member value</returns>
		object GetValue(object instance, string memberName);
		/// <summary>
		/// Set the member value of an object.
		/// </summary>
		/// <param name="instance">The object to get the member value from.</param>
		/// <param name="memberName">The member name, could be the name of a property of field. Must be public member.</param>
		/// <param name="newValue">The new value of the property for the object instance.</param>
		void SetValue(object instance, string memberName, object newValue);
	}
}
namespace DynamicAccess
{
	/// <summary>
	/// 
	/// </summary>
	public class ReflectionMemberAccessor : IMemberAccessor
	{
		public object GetValue(object instance, string memberName)
		{
			var propertyInfo = instance.GetType().GetProperty(memberName);
			if (propertyInfo != null)
			{
				return propertyInfo.GetValue(instance, null);
			}
			return null;
		}
		public void SetValue(object instance, string memberName, object newValue)
		{
			var propertyInfo = instance.GetType().GetProperty(memberName);
			if (propertyInfo != null)
			{
				propertyInfo.SetValue(instance, newValue, null);
			}
		}
	}
}
namespace DynamicAccess
{
	using System;
	using System.Collections.Generic;
	using System.Linq.Expressions;
	/// <summary>
	/// 
	/// </summary>
	public class DelegatedExpressionMemberAccessor : IMemberAccessor
	{
		private Dictionary<string, Func<object, object>> getValueDelegates = new Dictionary<string, Func<object, object>>();
		private Dictionary<string, Action<object, object>> setValueDelegates = new Dictionary<string, Action<object, object>>();
		public object GetValue(object instance, string memberName)
		{
			var type = instance.GetType();
			var key = type.FullName + memberName;
			Func<object, object> getValueDelegate;
			getValueDelegates.TryGetValue(key, out getValueDelegate);
			if (getValueDelegate == null)
			{
				var info = type.GetProperty(memberName);
				var target = Expression.Parameter(typeof(object), "target");
				var getter = Expression.Lambda(typeof(Func<object, object>),
					Expression.Convert(Expression.Property(Expression.Convert(target, type), info), typeof(object)),
					target
					);
				getValueDelegate = (Func<object, object>)getter.Compile();
				getValueDelegates.Add(key, getValueDelegate);
			}
			return getValueDelegate(instance);
		}
		public void SetValue(object instance, string memberName, object newValue)
		{
			var type = instance.GetType();
			var key = type.FullName + memberName;
			Action<object, object> setValueDelegate;
			setValueDelegates.TryGetValue(key, out setValueDelegate);
			if (setValueDelegate == null)
			{
				var info = type.GetProperty(memberName);
				var target = Expression.Parameter(typeof(object), "target");
				var value = Expression.Parameter(typeof(object), "value");
				var getter = Expression.Lambda(typeof(Action<object, object>),
					Expression.Assign(Expression.Property(Expression.Convert(target, type), info), Expression.Convert(value, info.PropertyType)),
					target, value
					);
				setValueDelegate = (Action<object, object>)getter.Compile();
				setValueDelegates.Add(key, setValueDelegate);
			}
			setValueDelegate(instance, newValue);
		}
	}
}
namespace DynamicAccess
{
	using System;
	using System.Collections.Generic;
	public class DelegatedReflectionMemberAccessor : IMemberAccessor
	{
		private static Dictionary<string, INamedMemberAccessor> accessorCache = new Dictionary<string, INamedMemberAccessor>();
		public object GetValue(object instance, string memberName)
		{
			return  FindAccessor(instance, memberName).GetValue(instance);
		}
		public void SetValue(object instance, string memberName, object newValue)
		{
			FindAccessor(instance, memberName).SetValue(instance, newValue);
		}
		private INamedMemberAccessor FindAccessor(object instance, string memberName)
		{
			var type = instance.GetType();
			var key = type.FullName + memberName;
			INamedMemberAccessor accessor;
			accessorCache.TryGetValue(key, out accessor);
			if (accessor == null)
			{
				var propertyInfo = type.GetProperty(memberName);
				accessor = Activator.CreateInstance(typeof(PropertyAccessor<,>).MakeGenericType(type, propertyInfo.PropertyType), type, memberName) as INamedMemberAccessor;
				accessorCache.Add(key, accessor);
			}
			return accessor;
		}
	}
	internal interface INamedMemberAccessor
	{
		object GetValue(object instance);
		void SetValue(object instance, object newValue);
	}
	internal class PropertyAccessor<T, P> : INamedMemberAccessor
	{
		private Func<T, P> GetValueDelegate;
		private Action<T, P> SetValueDelegate;
		public PropertyAccessor(Type type, string propertyName)
		{
			var propertyInfo = type.GetProperty(propertyName);
			if (propertyInfo != null)
			{
				GetValueDelegate = (Func<T, P>)Delegate.CreateDelegate(typeof(Func<T, P>), propertyInfo.GetGetMethod());
				SetValueDelegate = (Action<T, P>)Delegate.CreateDelegate(typeof(Action<T, P>), propertyInfo.GetSetMethod());
			}
		}
		public object GetValue(object instance)
		{
			return GetValueDelegate((T)instance);
		}
		public void SetValue(object instance, object newValue)
		{
			SetValueDelegate((T)instance, (P)newValue);
		}
	}
}
namespace DynamicAccess
{
	using System;
	using System.Collections.Generic;
	using System.Linq.Expressions;
	/// <summary>
	/// 
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public class DynamicMethodMemberAccessor : IMemberAccessor
	{
		private static Dictionary<Type, IMemberAccessor> classAccessors = new Dictionary<Type, IMemberAccessor>();
		public object GetValue(object instance, string memberName)
		{
			return FindClassAccessor(instance).GetValue(instance, memberName);
		}
		public void SetValue(object instance, string memberName, object newValue)
		{
			FindClassAccessor(instance).SetValue(instance, memberName, newValue);
		}
		private IMemberAccessor FindClassAccessor(object instance)
		{
			var typekey = instance.GetType();
			IMemberAccessor classAccessor;
			classAccessors.TryGetValue(typekey, out classAccessor);
			if (classAccessor == null)
			{
				classAccessor = Activator.CreateInstance(typeof(DynamicMethod<>).MakeGenericType(instance.GetType())) as IMemberAccessor;
				classAccessors.Add(typekey, classAccessor);
			}
			return classAccessor;
		}
	}
	public class DynamicMethod<T> : IMemberAccessor
	{
		internal static Func<object, string, object> GetValueDelegate;
		internal static Action<object, string, object> SetValueDelegate;
		public object GetValue(T instance, string memberName)
		{
			return GetValueDelegate(instance, memberName);
		}
		public void SetValue(T instance, string memberName, object newValue)
		{
			SetValueDelegate(instance, memberName, newValue);
		}
		public object GetValue(object instance, string memberName)
		{
			return GetValueDelegate(instance, memberName);
		}
		public void SetValue(object instance, string memberName, object newValue)
		{
			SetValueDelegate(instance, memberName, newValue);
		}
		static DynamicMethod()
		{
			GetValueDelegate = GenerateGetValue();
			SetValueDelegate = GenerateSetValue();
		}
		private static Func<object, string, object> GenerateGetValue()
		{
			var type = typeof(T);
			var instance = Expression.Parameter(typeof(object), "instance");
			var memberName = Expression.Parameter(typeof(string), "memberName");
			var nameHash = Expression.Variable(typeof(int), "nameHash");
			var calHash = Expression.Assign(nameHash, Expression.Call(memberName, typeof(object).GetMethod("GetHashCode")));
			var cases = new List<SwitchCase>();
			foreach (var propertyInfo in type.GetProperties())
			{
				var property = Expression.Property(Expression.Convert(instance, typeof(T)), propertyInfo.Name);
				var propertyHash = Expression.Constant(propertyInfo.Name.GetHashCode(), typeof(int));
				cases.Add(Expression.SwitchCase(Expression.Convert(property, typeof(object)), propertyHash));
			}
			var switchEx = Expression.Switch(nameHash, Expression.Constant(null), cases.ToArray());
			var methodBody = Expression.Block(typeof(object), new[] { nameHash }, calHash, switchEx);
			return Expression.Lambda<Func<object, string, object>>(methodBody, instance, memberName).Compile();
		}
		private static Action<object, string, object> GenerateSetValue()
		{
			var type = typeof(T);
			var instance = Expression.Parameter(typeof(object), "instance");
			var memberName = Expression.Parameter(typeof(string), "memberName");
			var newValue = Expression.Parameter(typeof(object), "newValue");
			var nameHash = Expression.Variable(typeof(int), "nameHash");
			var calHash = Expression.Assign(nameHash, Expression.Call(memberName, typeof(object).GetMethod("GetHashCode")));
			var cases = new List<SwitchCase>();
			foreach (var propertyInfo in type.GetProperties())
			{
				var property = Expression.Property(Expression.Convert(instance, typeof(T)), propertyInfo.Name);
				var setValue = Expression.Assign(property, Expression.Convert(newValue, propertyInfo.PropertyType));
				var propertyHash = Expression.Constant(propertyInfo.Name.GetHashCode(), typeof(int));
				cases.Add(Expression.SwitchCase(Expression.Convert(setValue, typeof(object)), propertyHash));
			}
			var switchEx = Expression.Switch(nameHash, Expression.Constant(null), cases.ToArray());
			var methodBody = Expression.Block(typeof(object), new[] { nameHash }, calHash, switchEx);
			return Expression.Lambda<Action<object, string, object>>(methodBody, instance, memberName, newValue).Compile();
		}
	}
}

#T=反射Reflection\ILGenerator发出Emit技术示例
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET Framework SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//
/*=====================================================================
  File:      EmitAssembly.cs

  Summary:   Demonstrates how to use reflection emit.

=====================================================================*/


using System;
using System.Security.Permissions;
using System.Threading;
using System.Reflection;
using System.Reflection.Emit;
using System.Globalization;

namespace Microsoft.Samples
{
	public sealed class App
	{
		private App()
		{
		}

		private static void Usage()
		{
			Console.WriteLine("Usage: EmitAssembly {1|2|3}\n" + 
                "   1\tCreate & test a dynamic type\n" + 
                "   2\tCreate & Save a type (use TestEmittedAssembly.exe to test)\n" + 
                "   3\tCreate 2 dynamic assemblies & test them\r\n\r\n" + 
                "   There is a separate project available with this project, which can be used to test the emitted assembly in step 2. Simply load that project, and reference the emitted assembly, to test it and ensure it works.");
		}

		public static void Main(String[] args)
		{
			if (args.Length == 0 || !Char.IsDigit(args[0].ToCharArray()[0]))
			{
				Usage();
				return;
			}

			new SecurityPermission(PermissionState.Unrestricted).Demand();
			AssemblyBuilder assembly;

			switch (Int32.Parse(args[0], CultureInfo.InvariantCulture))
			{
				case 1:
					// Create the "HelloWorld" class
					Type helloWorldClass = CreateCallee(Thread.GetDomain(), AssemblyBuilderAccess.Run);

					// Create an instance of the "HelloWorld" class.
					Object helloWorld = Activator.CreateInstance(helloWorldClass, new Object[] { "HelloWorld" });

					// Invoke the "GetGreeting" method of the "HelloWorld" class.
					Object obj = helloWorldClass.InvokeMember("GetGreeting", BindingFlags.InvokeMethod, null, helloWorld, null, CultureInfo.InvariantCulture);

					Console.WriteLine("HelloWorld.GetGreeting returned: \"" + obj + "\"");
					break;

				case 2:
					assembly = (AssemblyBuilder)CreateCallee(Thread.GetDomain(), AssemblyBuilderAccess.Save).Assembly;
					assembly.Save("EmittedAssembly.dll");
					break;

				case 3:
					Type calleeClass = CreateCallee(Thread.GetDomain(), AssemblyBuilderAccess.Run);
					Type mainClass = CreateCaller(Thread.GetDomain(), AssemblyBuilderAccess.Run, calleeClass);
					Object o = Activator.CreateInstance(mainClass);

					mainClass.GetMethod("main").Invoke(o, new Object[0]);
					break;

				default:
					Usage();
					break;
			}
		}

		// Create the callee transient dynamic assembly.
		private static Type CreateCallee(AppDomain appDomain, AssemblyBuilderAccess access)
		{
			// Create a simple name for the callee assembly.
			AssemblyName assemblyName = new AssemblyName();

			assemblyName.Name = "EmittedAssembly";

			// Create the callee dynamic assembly.
			AssemblyBuilder assembly = appDomain.DefineDynamicAssembly(assemblyName, access);

			// Create a dynamic module named "CalleeModule" in the callee assembly.
			ModuleBuilder module;

			if (access == AssemblyBuilderAccess.Run)
			{
				module = assembly.DefineDynamicModule("EmittedModule");
			}
			else
			{
				module = assembly.DefineDynamicModule("EmittedModule", "EmittedModule.mod");
			}

			// Define a public class named "HelloWorld" in the assembly.
			TypeBuilder helloWorldClass = module.DefineType("HelloWorld", TypeAttributes.Public);

			// Define a private String field named "Greeting" in the type.
			FieldBuilder greetingField = helloWorldClass.DefineField("Greeting", typeof(String), FieldAttributes.Private);

			// Create the constructor.
			Type[] constructorArgs = { typeof(String) };
			ConstructorBuilder constructor = helloWorldClass.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, constructorArgs);

			// Generate IL for the method. The constructor calls its superclass
			// constructor. The constructor stores its argument in the private field.
			ILGenerator constructorIL = constructor.GetILGenerator();

			constructorIL.Emit(OpCodes.Ldarg_0);

			ConstructorInfo superConstructor = typeof(Object).GetConstructor(new Type[0]);

			constructorIL.Emit(OpCodes.Call, superConstructor);
			constructorIL.Emit(OpCodes.Ldarg_0);
			constructorIL.Emit(OpCodes.Ldarg_1);
			constructorIL.Emit(OpCodes.Stfld, greetingField);
			constructorIL.Emit(OpCodes.Ret);

			// Create the GetGreeting method.
			MethodBuilder getGreetingMethod = helloWorldClass.DefineMethod("GetGreeting", MethodAttributes.Public, typeof(String), null);

			// Generate IL for GetGreeting.
			ILGenerator methodIL = getGreetingMethod.GetILGenerator();

			methodIL.Emit(OpCodes.Ldarg_0);
			methodIL.Emit(OpCodes.Ldfld, greetingField);
			methodIL.Emit(OpCodes.Ret);

			// Bake the class HelloWorld.
			return (helloWorldClass.CreateType());
		}

		// Create the caller transient dynamic assembly.
		private static Type CreateCaller(AppDomain appDomain, AssemblyBuilderAccess access, Type helloWorldClass)
		{
			// Create a simple name for the caller assembly.
			AssemblyName assemblyName = new AssemblyName();

			assemblyName.Name = "CallingAssembly";

			// Create the caller dynamic assembly.
			AssemblyBuilder assembly = appDomain.DefineDynamicAssembly(assemblyName, access);

			// Create a dynamic module named "CallerModule" in the caller assembly.
			ModuleBuilder module;

			if (access == AssemblyBuilderAccess.Run)
			{
				module = assembly.DefineDynamicModule("EmittedCallerModule");
			}
			else
			{
				module = assembly.DefineDynamicModule("EmittedCallerModule", "EmittedCallerModule.exe");
			}

			// Define a public class named MainClass.
			TypeBuilder mainClass = module.DefineType("MainClass", TypeAttributes.Public);

			// Create the method with name "main".
			MethodAttributes methodAttributes = (MethodAttributes.Static | MethodAttributes.Public);
			MethodBuilder mainMethod = mainClass.DefineMethod("main", methodAttributes, null, null);

			// Generate IL for the method.
			ILGenerator mainIL = mainMethod.GetILGenerator();

			// Define the greeting string constant and emit it.
			mainIL.Emit(OpCodes.Ldstr, "HelloWorld (test 3)");

			// Use the provided "HelloWorld" class
			// Find the constructor for the "HelloWorld" class.
			Type[] constructorArgs = { typeof(String) };
			ConstructorInfo constructor = helloWorldClass.GetConstructor(constructorArgs);

			// Instantiate the "HelloWorld" class.
			mainIL.Emit(OpCodes.Newobj, constructor);

			// Find the "GetGreeting" method of the "HelloWorld" class.
			MethodInfo getGreetingMethod = helloWorldClass.GetMethod("GetGreeting");

			// Call the "GetGreeting" method to obtain the greeting.
			mainIL.Emit(OpCodes.Call, getGreetingMethod);

			// Write the greeting  to the console.
			MethodInfo writeLineMethod = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(String) });

			mainIL.Emit(OpCodes.Call, writeLineMethod);
			mainIL.Emit(OpCodes.Ret);

			// Bake the class. You can now create instances of this class if you needed to.
			return (mainClass.CreateType());
		}
	}
}

#T=斐波那契 lambda
namespace Microshaoft
{
	using System;
	public class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Hello World");
			long input = 40;
			Console
				.WriteLine
					(
						new Func<Func<long, long>, Func<long, long>>(x => x = xx => xx < 2 ? xx : x(xx - 1) + x(xx - 2))(null)(input)
					);
			Console
				.WriteLine
					(
						((Func<Func<long, long>, Func<long, long>>)(x => x = xx => xx < 2 ? xx : x(xx - 1) + x(xx - 2))).Invoke(null).Invoke(input)
					);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}

#T=公私钥 示例
Sender:
	ReceiverParty.PublicEncrypt(SenderParty.PrivateKeySign(Data) + Data)
		防ThirdParty偷窥,
		防[SenderParty]篡改
		不防[ThirdParty+SenderParty]篡改

ReceiverParty
	.PrivateKegSign
		(
			[
				ReceiverParty
					.PublicEncrypt
						(
							SenderParty.PrivateKeySign(Data) + Data
						)
			]
		)
		+	[ReceiverParty.PublicEncrypt(SenderParty.PrivateKeySign(Data) + Data)]
防ThirdParty偷窥,防ThirdParty+SenderParty篡改

SenderParty.PrivateKeySign(Data) + ReceiverParty.PrivateKeySign(Data) + Data

#T=共享内存 SharedMemory 进程间通信
namespace ShareMemLib
{

	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Runtime.InteropServices;

    public class ShareMem
    {
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int Msg, int wParam, IntPtr lParam);

        [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
        public static extern IntPtr CreateFileMapping(int hFile, IntPtr lpAttributes, uint flProtect, uint dwMaxSizeHi, uint dwMaxSizeLow, string lpName);
        
        [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
        public static extern IntPtr OpenFileMapping(int dwDesiredAccess,[MarshalAs(UnmanagedType.Bool)] bool bInheritHandle,string lpName);

        [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
        public static extern IntPtr MapViewOfFile(IntPtr hFileMapping,uint dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow,uint dwNumberOfBytesToMap);

        [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
        public static extern bool UnmapViewOfFile(IntPtr pvBaseAddress);

        [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
        public static extern bool CloseHandle(IntPtr handle);

        [DllImport("kernel32", EntryPoint="GetLastError")]
        public static extern int GetLastError ();

        const int ERROR_ALREADY_EXISTS = 183;

        const int FILE_MAP_COPY = 0x0001;
        const int FILE_MAP_WRITE = 0x0002;
        const int FILE_MAP_READ = 0x0004;
        const int FILE_MAP_ALL_ACCESS = 0x0002 | 0x0004;

        const int PAGE_READONLY = 0x02;
        const int PAGE_READWRITE = 0x04;
        const int PAGE_WRITECOPY = 0x08;
        const int PAGE_EXECUTE = 0x10;
        const int PAGE_EXECUTE_READ = 0x20;
        const int PAGE_EXECUTE_READWRITE = 0x40;

        const int SEC_COMMIT = 0x8000000;
        const int SEC_IMAGE = 0x1000000;
        const int SEC_NOCACHE = 0x10000000;
        const int SEC_RESERVE = 0x4000000;

        const int INVALID_HANDLE_VALUE = -1;

        IntPtr m_hSharedMemoryFile = IntPtr.Zero;
        IntPtr m_pwData = IntPtr.Zero;
        bool m_bAlreadyExist = false;
        bool m_bInit = false;
        long m_MemSize=0;

        public ShareMem()
        {
        }
        ~ShareMem()
        {
            Close();
        }

        /// <summary>
        /// 初始化共享内存
        /// </summary>
        /// <param name="strName">共享内存名称</param>
        /// <param name="lngSize">共享内存大小</param>
        /// <returns></returns>
        public int Init(string strName, long lngSize)
        {
            if (lngSize <= 0 || lngSize > 0x00800000) lngSize = 0x00800000;
            m_MemSize = lngSize;
            if (strName.Length > 0)
            {
                //创建内存共享体(INVALID_HANDLE_VALUE)
                m_hSharedMemoryFile = CreateFileMapping(INVALID_HANDLE_VALUE, IntPtr.Zero, (uint)PAGE_READWRITE, 0, (uint)lngSize, strName);
                if (m_hSharedMemoryFile == IntPtr.Zero)
                {
                    m_bAlreadyExist = false;
                    m_bInit = false;
                    return 2; //创建共享体失败
                }
                else
                {
                    if (GetLastError() == ERROR_ALREADY_EXISTS)  //已经创建
                    {
                        m_bAlreadyExist = true;
                    }
                    else                                         //新创建
                    {
                        m_bAlreadyExist = false;
                    }
                }
                //---------------------------------------
                //创建内存映射
                m_pwData = MapViewOfFile(m_hSharedMemoryFile, FILE_MAP_WRITE, 0, 0, (uint)lngSize);
                if (m_pwData == IntPtr.Zero)
                {
                    m_bInit = false;
                    CloseHandle(m_hSharedMemoryFile);
                    return 3; //创建内存映射失败
                }
                else
                {
                    m_bInit = true;
                    if (m_bAlreadyExist == false)
                    {
                        //初始化
                    }
                }
                //----------------------------------------
            }
            else
            {
                return 1; //参数错误     
            }

            return 0;     //创建成功
        }
        /// <summary>
        /// 关闭共享内存
        /// </summary>
        public void Close()
        {
            if (m_bInit)
            {
                UnmapViewOfFile(m_pwData);
                CloseHandle(m_hSharedMemoryFile);
            }
        }

        /// <summary>
        /// 读数据
        /// </summary>
        /// <param name="bytData">数据</param>
        /// <param name="lngAddr">起始地址</param>
        /// <param name="lngSize">个数</param>
        /// <returns></returns>
        public int Read(ref byte[] bytData, int lngAddr, int lngSize)
        {
            if (lngAddr + lngSize > m_MemSize) return 2; //超出数据区
            if (m_bInit)
            {               
                Marshal.Copy(m_pwData, bytData, lngAddr, lngSize);
            }
            else
            {
                return 1; //共享内存未初始化
            }
            return 0;     //读成功
        }

        /// <summary>
        /// 写数据
        /// </summary>
        /// <param name="bytData">数据</param>
        /// <param name="lngAddr">起始地址</param>
        /// <param name="lngSize">个数</param>
        /// <returns></returns>
        public int Write(byte[] bytData, int lngAddr, int lngSize)
        {
            if (lngAddr + lngSize > m_MemSize) return 2; //超出数据区
            if (m_bInit)
            {
                Marshal.Copy(bytData, lngAddr, m_pwData, lngSize);
            }
            else
            {
                return 1; //共享内存未初始化
            }
            return 0;     //写成功
        }
    }
}

namespace YFShareMem
{

	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;
	using ShareMemLib;

    public partial class frmShareMem : Form
    {
        ShareMem MemDB=new ShareMem();
        public frmShareMem()
        {
            InitializeComponent();
        }

        private void btnOpen_Click(object sender, EventArgs e)
        {
            if (MemDB.Init("YFMemTest", 10240) != 0)
            {
                //初始化失败
                MessageBox.Show("初始化失败");
            }
            else
            {
                btnOpen.Enabled = false;
                chkWrite.Enabled = true;
                tmrTime.Enabled = true;
            }
        }

        private void tmrTime_Tick(object sender, EventArgs e)
        {
            byte[] bytData = new byte[16];
            int intRet = MemDB.Read(ref bytData, 0, 16);
            lstData.Items.Clear(); 
            if (intRet == 0)
            {
                for (int i = 0; i < 16; i++)
                {
                    lstData.Items.Add(bytData[i].ToString());
                }

                if (chkWrite.Checked)
                {
                    bytData[0]++;
                    bytData[1] += 2;
                    if (bytData[0] > 200) bytData[0] = 0;
                    if (bytData[1] > 200) bytData[1] = 0;
                    MemDB.Write(bytData, 0, 16);
                }
            }           
        }

    }
}
#T=汉字拼音笔画处理
/*
    微软刚刚推出
    Microsoft Visual Studio International Pack 1.0 Beta1
    支持 汉字 拼音 笔画 转换
    http://www.microsoft.com/downloads/details.aspx?FamilyID=e432aeaa-7b6f-4b0d-968b-b6aafda05e34&DisplayLang=en
    我已经提取了 dll assembly
        ChnCharInfo.dll
        ChnCharInfoResource.dll
    下载分享
    http://www.cnblogs.com/Files/Microshaoft/vsipk1beta.zip
*/

//命令行编译:
//csc.exe noname1.cs /r:ChnCharInfo.dll

namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;

	using Microsoft.International.Converters.PinYinConverter;

	public class Class1
	{
		static void Main(string[] args)
		{
			//汉字的笔画数
			int i = ChineseChar.GetStrokeNumber('饕');
			Console.WriteLine(i);
			
			//汉字的所有拼音拼写
			ChineseChar x = new ChineseChar('说');
			ReadOnlyCollection<string> roc = x.Pinyins;
			foreach(string s in roc)
			{
				Console.WriteLine(s);
			}

			//拼音拼写的所有汉字
			Char[] chars = ChineseChar.GetChars("YUE4");
			foreach(Char c in chars)
			{
				Console.WriteLine(c);
			}

			//笔画数的所有汉字
			chars = ChineseChar.GetChars(20);
			foreach(Char c in chars)
			{
				Console.WriteLine(c);
			}
			Console.WriteLine(Environment.Version.ToString());
		}
	}

}

#T=会计分录
USE [FundManagement]
GO
/****** Object:  StoredProcedure [dbo].[zzzsp_GenerateTransactionsDailyLedgerResult_ok]    Script Date: 2012/12/30 22:49:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
ALTER proc [dbo].[zzzsp_GenerateTransactionsDailyLedgerResult_ok]
@LedgerDate date = null
as
begin

declare @now DateTime = getdate()
if @LedgerDate is null
begin
	set @LedgerDate = @now
end
declare @LastLedgerDate date = dateadd(day,-1, @LedgerDate)
declare @MonthFirstDate date = dateadd(month, datediff(month,0,@LedgerDate),0) -1
declare @MonthLastDate date = dateadd(month, datediff(month,0,@LedgerDate)+1,0) -1
declare @NextMonthFirstDate date = dateadd(month, datediff(month,0,@LedgerDate) + 1,0)
--select @MonthFirstDate,@MonthLastDate ,@NextMonthFirstDate

declare @AgainstBankID varchar(50) = '总行'
declare @status int = 10
declare @TransType varchar(50) = '拆借交易'

update
	TransactionsDailyLedgerResult
set
	isDeleted = 1
where
	LedgerDate >= @LedgerDate 
	

	;with T
		(
			[TransType]
			,OriginalTransDirection
		  ,[AmountType]
		)
	as
	(
		select
			distinct
				[TransType]
				,OriginalTransDirection
				,[AmountType]
		from
			AccountingRules
	)
	, TTransactions --当天相关交易
		(
			LedgerDate
			,TransactionID
			,[DateType]
			,[TransType3]
			,[TransType]
			,[BankID]
			,[AgainstBankID]
			,[CurrencyType]
			,[Amount]
			,[DayInterest]
			,[BeginDate]
			,[EndDate]
		)
	as
	(
		select
			@LedgerDate
			,a.ID
			,
				case
					when
						@LedgerDate = a.BeginDate
							then '起息日'
					when
						a.BeginDate < @LedgerDate 
						and a.EndDate > @LedgerDate
							then
								'未到期日不含起息日'
					when
							a.EndDate = @LedgerDate
							then '到期日'
				end
			,[TransType3]
			,[TransType]
			,[BankID]
			,[AgainstBankID]
			,[CurrencyType]
			,[Amount]
			,[DayInterest]
			,[BeginDate]
			,[EndDate]
		from
			Transactions a
		where
			TransType = @TransType
			and 
			(
				a.BeginDate <= @LedgerDate
				and a.EndDate >= @LedgerDate
			)
			
			and [status] = @status
	)
	, TLastLedger --上日帐
			(
				LedgerDate
				,TransactionID
				,[BankID]
				,[Accounting]
				,[DebtorBalance]
				,[CreditorBalance]
				,[DCParty]
			)
		as
		(
				select					--上日
					LedgerDate
					,TransactionID
					,[BankID]
					,[Accounting]
					,[DebtorBalance]
					,[CreditorBalance]
					,[DCParty]
				from
					[TransactionsDailyLedgerResult]
				where
					LedgerDate = @LastLedgerDate
					and IsDeleted = 0
		)

	, TToday --当日发生
		(
			LedgerDate
			,TransactionID
			,[DateType]
			,[TransType3]
			,[TransType]
			,[BankID]
			,[AgainstBankID]
			,[CurrencyType]
			,[BeginDate]
			,[EndDate]
			,[AmountType]
			,[OriginalTransDirection]
			,[Accounting]
			,[DCParty]
			,[OriginalTransParty]
			,[FactorAmount]
			,[Amount]
			,[FactorDayInterest]
			,[DayInterest]
			,[FactualAmount]
			,[IsSum]
			,[LastSumAccounting]
			,[LastSumDCParty]
		)
		as
		(
			select
					a.LedgerDate
					,TransactionID
					,a.[DateType]
					,a.[TransType3]
					,a.[TransType]
					,
						case
							when c.OriginalTransParty = '发起'
									then a.BankID
							else
								@AgainstBankID
						end
					,a.[AgainstBankID]
					,a.[CurrencyType]
					,a.[BeginDate]
					,a.[EndDate]
					,c.[AmountType]
					,c.[OriginalTransDirection]
					,c.[Accounting]
					,c.[DCParty]	--交换
					,c.[OriginalTransParty]
					,c.[FactorAmount]
					,a.[Amount]
					,c.[FactorDayInterest]
					,a.[DayInterest]
					, 
						isnull(c.FactorAmount,0) * a.Amount
						+ isnull(c.FactorDayInterest,0) * a.DayInterest  as [FactualAmount]
					,c.IsSum
					,c.LastSumAccounting
					,C.LastSumDCParty 				
			from
				TTransactions a
					left join T b
						on
							a.TransType3 = b.OriginalTransDirection
							and a.TransType = b.TransType
					inner join [AccountingRules] c
						on
							b.AmountType = c.AmountType
							and b.OriginalTransDirection = c.OriginalTransDirection
							and b.TransType = a.TransType
							and a.DateType = c.DateType
							
		)
		, TTodayAmount
			(
				LedgerDate
				,TransactionID
				,[DateType]
				,[TransType3]
				,[TransType]
				,[BankID]
				,[AgainstBankID]
				,[CurrencyType]
				,[BeginDate]
				,[EndDate]
				,[AmountType]
				,[OriginalTransDirection]
				,[Accounting]
				,[DCParty]
				,[OriginalTransParty]
				,[FactorAmount]
				,[Amount]
				,[FactorDayInterest]
				,[DayInterest]
				,[FactualAmount]
				,[SumAmount]
				,IsSum
				,LastSumAccounting
				,LastSumDCParty
			)
		as
		(
			select
				a.LedgerDate
				,a.TransactionID
				,a.[DateType]
				,a.[TransType3]
				,a.[TransType]
				,a.[BankID]
				,a.[AgainstBankID]
				,a.[CurrencyType]
				,a.[BeginDate]
				,a.[EndDate]
				,a.[AmountType]
				,a.[OriginalTransDirection]
				,a.[Accounting]
				,a.[DCParty]
				,a.[OriginalTransParty]
				,a.[FactorAmount]
				,a.[Amount]
				,a.[FactorDayInterest]
				,a.[DayInterest]
				,a.[FactualAmount]
				, 	isnull
				(
					(select
						 case
							when
								 a.IsSum = 1 and a.LastSumDCParty = 'dr' 
									then
										sum(
										bb.DebtorBalance
										)
							when
								a.IsSum = 1 and a.LastSumDCParty = 'cr'
									then
										sum(
										bb.CreditorBalance
										)	
							else
								0
						end
					from
						TLastLedger bb
					where
						bb.TransactionID = a.TransactionID
						and bb.Accounting = a.LastSumAccounting
						and  bb.DCParty = a.LastSumDCParty
				) ,0)
				,a.IsSum
				,a.LastSumAccounting
				,a.LastSumDCParty
			from
				TToday a
					--left join
						--TLastLedger b
						--	on
						--		a.TransactionID = b.TransactionID
						--		and a.Accounting = b.Accounting
						--		and a.BankID = b.BankID
						--		--and a.
								
		
								
					
		
		)
		, TTodayLedger
			(
				LedgerDate
				,TransactionID
				,[DateType]
				,[TransType3]
				,[TransType]
				,[BankID]
				,[AgainstBankID]
				,[CurrencyType]
				,[BeginDate]
				,[EndDate]
				,[AmountType]
				,[OriginalTransDirection]
				,[Accounting]
				,[DCParty]
				,[OriginalTransParty]
				,[DebtorBalance]
				,[CreditorBalance]
				,SumAmount
				,LastSumAccounting
				,LastSumDCParty
			)
		as
		(
			select
				LedgerDate
				,TransactionID
				,[DateType]
				,[TransType3]
				,[TransType]
				,[BankID]
				,[AgainstBankID]
				,[CurrencyType]
				,[BeginDate]
				,[EndDate]
				,[AmountType]
				,[OriginalTransDirection]
				,[Accounting]
				,[DCParty]
				,[OriginalTransParty]
				,
					case
						when
							DCParty = 'dr'
							then
								FactualAmount 
								+ 
							
								SumAmount
						else
							0
					end
				,
					case
						when
							DCParty = 'cr'
							then
								FactualAmount + SumAmount
						else
							0
					end
				,SumAmount
				,LastSumAccounting
				,LastSumDCParty
							
			from
				TTodayAmount
		)
		

			
		
		--select
		--	*
		--from TTodayAmount --a
					
		--order by
		--	LedgerDate
		--	,BankID
		--	,Accounting
		
		--return

		INSERT INTO 
				[TransactionsDailyLedgerResult]
				   (
					   [LedgerDate]
					   ,[TransactionID]
					   ,[DateType]
					   ,[TransType3]
					   ,[TransType]
					   ,[BankID]
					   ,[AgainstBankID]
					   ,[BeginDate]
					   ,[EndDate]
					   ,[AmountType]
					   ,[OriginalTransDirection]
					   ,[DCParty]
					   ,[OriginalTransParty]
					   --,[FactorAmount]
					   --,[Amount]
					   --,[FactorDayInterest]
					   --,[DayInterest]
					   ,[Accounting]
					   ,[CurrencyType]
					   ,[DebtorBalance]
					   ,[CreditorBalance]
					   ,[CreateTime]
					   ,[IsDeleted]
				)
		select	
				   [LedgerDate]
					   ,[TransactionID]
					   ,[DateType]
					   ,[TransType3]
					   ,[TransType]
					   ,[BankID]
					   ,[AgainstBankID]
					   ,[BeginDate]
					   ,[EndDate]
					   ,[AmountType]
					   ,[OriginalTransDirection]
					   ,[DCParty]
					   ,[OriginalTransParty]
					   --,[FactorAmount]
					   --,[Amount]
					   --,[FactorDayInterest]
					   --,[DayInterest]
					   ,[Accounting]
					   ,[CurrencyType]
					   ,[DebtorBalance]
					   ,[CreditorBalance]
					   ,@now
					   ,0
			from
				TTodayLedger
	



--=======================================================
		select
					   [LedgerDate]
					   ,[TransactionID]
					   ,[DateType]
					   ,[TransType3]
					   ,[TransType]
					   ,[BankID]
					   ,[AgainstBankID]
					   ,[AmountType]
					   ,[FactorAmount]
					   ,[Amount]
					   ,[FactorDayInterest]
					   ,[DayInterest]
					   					   
					   ,[Accounting]
					   ,[CurrencyType]
					   ,DCParty
					   ,[DebtorBalance]
					   ,[CreditorBalance]
					   ,[CreateTime]
					   ,[IsDeleted]

		from
			[TransactionsDailyLedgerResult]
		where
			LedgerDate >= '2012-12-25'--@LastLedgerDate
			and IsDeleted = 0
			--and TransactionID = 129
		order by
			TransactionID
			,LedgerDate
			,transType
			,BankID
			,CurrencyType
			,DateType
			,Accounting


end

go

USE [FundManagement]
GO
/****** Object:  StoredProcedure [dbo].[zzzsp_GenerateDailyLedgerResultVar_ok]    Script Date: 2012/12/30 22:49:30 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
ALTER proc [dbo].[zzzsp_GenerateDailyLedgerResultVar_ok]
@LedgerDate date = null
as
begin

		declare @now DateTime = getdate()
		if @LedgerDate is null
		begin
			set @LedgerDate = @now
		end
		declare @LastLedgerDate date = dateadd(day,-1, @LedgerDate)
		declare @NextLedgerDate date = dateadd(day,1, @LedgerDate)
		declare @MonthFirstDate date = dateadd(month, datediff(month,0,@LedgerDate),0)
		declare @MonthLastDate date = dateadd(month, datediff(month,0,@LedgerDate)+1,0) -1
		declare @NextMonthFirstDate date = dateadd(month, datediff(month,0,@LedgerDate) + 1,0)
		--select @LastLedgerDate,@MonthFirstDate,@MonthLastDate ,@NextMonthFirstDate

		declare @AgainstBankID varchar(50) = '总行'
		declare @status int = 10
		declare @TransType varchar(50) = '活期交易'
		declare @LastLedgerDateBalanceAccounting varchar(50) = '9000'

		
		
		
		declare @DateType varchar(50)
		select
				@DateType =
					case
						WHEN
							@LedgerDate = @MonthFirstDate
								THEN '每月1日'
						when
							@LedgerDate > @MonthFirstDate
							and @LedgerDate < @MonthLastDate
								then '月中每日'
						when
							@LedgerDate = @MonthLastDate
								then
									'月末'
					end
		

		update
			[DailyLedgerResultVar]
		set
			IsDeleted = 1
		where
			LedgerDate >= @LedgerDate

		;with T0
			(
				[LedgerDate]
				,[BankID]
				,[CurrencyType]
				,[AccountingCategory]
				,[DebtorBalance]
				,[CreditorBalance]
			)
		as
		(
			select
				[LedgerDate]
				,[BankID]
				,[CurrencyType]
				,[AccountingCategory]
				,[DebtorBalance]
				,[CreditorBalance]
			FROM 
				[DailyLedger]
			where
				--LedgerDate = @LastLedgerDate
				LedgerDate = @LedgerDate --老杨说的
				and [AccountingCategory] = @LastLedgerDateBalanceAccounting 
			--group by
				--[BankID]
				--,[CurrencyType]
				--,[AccountingCategory]
			--union all
			--select				--今日到期上存本息
			--	@LedgerDate
			--	,a.BankID
			--	,a.[CurrencyType]
			--	,@LastLedgerDateBalanceAccounting
			--	,
			--		sum(isnull(a.Amount,0)) 
			--		+ sum(isnull(a.FactualRate,0) * isnull(a.DayInterest,0))
			--	,
			--		0
			--from
			--	Transactions a
			--where
			--	a.EndDate = @LedgerDate
			--	and a.TransType = '拆借交易'
			--	and a.TransType3 = '上存'
			--	and [status] = @status
			--group by
			--	a.[BankID]
			--	,a.[CurrencyType]

			--union all
			--select				--今日到期下借本息
			--	@LedgerDate
			--	,a.BankID
			--	,a.[CurrencyType]
			--	,@LastLedgerDateBalanceAccounting
			--	, -1 *
			--		(
			--			sum(isnull(a.Amount,0)) 
			--			+ sum(isnull(a.FactualRate,0) * isnull(a.DayInterest,0))
			--		)
			--	,
			--		0
			--from
			--	Transactions a
			--where
			--	a.EndDate = @LedgerDate
			--	and a.TransType = '拆借交易'
			--	and a.TransType3 = '下借'
			--	and [status] = @status
			--group by
			--	a.[BankID]
			--	,a.[CurrencyType]
			
			union all
			select				--今日起息上存本金
				@LedgerDate
				,a.BankID
				,a.[CurrencyType]
				,@LastLedgerDateBalanceAccounting
				, -1 *
					(
						sum(isnull(a.Amount,0)) 
					)
				,
					0
			from
				Transactions a
			where
				a.beginDate = @LedgerDate
				and a.TransType = '拆借交易'
				and a.TransType3 = '上存'
				and [status] = @status
			group by
				a.[BankID]
				,a.[CurrencyType]

			union all
			select				--今日起息下借本金
				@LedgerDate
				,a.BankID
				,a.[CurrencyType]
				,@LastLedgerDateBalanceAccounting
				, 
					(
						sum(isnull(a.Amount,0)) 
					)
				,
					0
			from
				Transactions a
			where
				a.beginDate = @LedgerDate
				and a.TransType = '拆借交易'
				and a.TransType3 = '下借'
				and [status] = @status
			group by
				a.[BankID]
				,a.[CurrencyType]

		)
		, TRate
			(
				FactualRate
				, CurrencyType
				, [OriginalTransDirection]	--上存、上透
			)
		as
		(
			select
				
				a.[SavingsDepositRate]
				,CurrencyType
				,
					case
						when
							periodName = '活期'
								then '上存'
						when
							periodName = '活期透支'
								then '上透'
					end
			from
				FactualRate a
			where
				a.PeriodName in ('活期','活期透支')
				and a.DaysPerPeriod <= 0
		)
		, TAccountingRules
			(
				[TransType]
				,[AmountType]
				,[DateType]
				,[OriginalTransDirection]
				,[AccountingRowNum]
				,[Accounting]
				,[DCParty]
				,[OriginalTransParty]
				,[FactorAmount]
				,[FactorDayInterest]
				,[LastLedgerAccounting]
				,[EndDateAccounting]
				,[IsSum]
				,[Remark]
				,[LastSumAccounting]
				,[LastSumDCParty]
			)
		as
		(
			select
				[TransType]
				,[AmountType]
				,[DateType]
				,[OriginalTransDirection]
				,[AccountingRowNum]
				,[Accounting]
				,[DCParty]
				,[OriginalTransParty]
				,[FactorAmount]
				,[FactorDayInterest]
				,[LastLedgerAccounting]
				,[EndDateAccounting]
				,[IsSum]
				,[Remark]
				,[LastSumAccounting]
				,[LastSumDCParty]
			from
				AccountingRules
			where
				DateType = @DateType
				and TransType = @TransType
		)

		, TDepartmentsCurrencyTransDirectionAccountingRules
			(
				BankID
				
				,CurrencyType
				,[TransType]
				,[AmountType]
				,[DateType]
				,[OriginalTransDirection]
				,[AccountingRowNum]
				,[Accounting]
				,[DCParty]
				,[OriginalTransParty]
				,[FactorAmount]
				,[FactorDayInterest]
				,[LastLedgerAccounting]
				,[EndDateAccounting]
				,[IsSum]
				,[Remark]
				,[LastSumAccounting]
				,[LastSumDCParty]
			)
		as
		(
			
			select
					a.DepartmentName
					
							
					,b.CurrencyType
					,c.[TransType]
					,c.[AmountType]
					,c.[DateType]
					,c.[OriginalTransDirection]
					,c.[AccountingRowNum]
					,c.[Accounting]
					,c.[DCParty]
					,c.[OriginalTransParty]
					,c.[FactorAmount]
					,c.[FactorDayInterest]
					,c.[LastLedgerAccounting]
					,c.[EndDateAccounting]
					,c.[IsSum]
					,c.[Remark]
					,c.[LastSumAccounting]
					,c.[LastSumDCParty]
			from
				Departments a
				,CurrencyType b
				, TAccountingRules c
			--where
			--	a.DepartmentName != @AgainstBankID
		)

		, TBalance
			(
				[BankID]
				,[CurrencyType]
				,[DebtorBalance]
				,[CreditorBalance]
				,[OriginalTransDirection]
			)
		as
		(
			select
				a.BankID
				,a.[CurrencyType]
				, sum(isnull(a.DebtorBalance,0))
				, sum(isnull(a.CreditorBalance,0))
				,
					case
							when
								sum(isnull(a.DebtorBalance,0)) >  0
									then
										'上存'
							when
								sum(isnull(a.DebtorBalance,0)) <  0
									then
										'上透'
						end
					
				
			from
				T0 a
			group by
				a.BankID
				,a.[CurrencyType]
		)
		, TDaysPerYear
			(
				CurrencyType
				, DaysPerPeriod
			)
		as
		(
			select
				CurrencyType
				, max(DaysPerPeriod)
			from
				Periods
			where
				PeriodName = '1年'
				and PeriodType = '年日利率转换'
			group by
				CurrencyType
			
		)
		, TTodayAmount				--当日发生额
			(
				LedgerDate
				,BankID
				,OriginalBankID
				,[OriginalTransDirection]
				,CurrencyType
				,Accounting
				,DCParty
				,FactualRate
				,DaysPerPeriod
				,FactorAmount
				,Amount
				,FactorDayInterest
				,DayInterest
				,AmountType
				,DateType
				,IsSum
				,LastSumAccounting
				,LastSumDCParty
				,LastSumAmount
			)
		as
		(
			select
				@LedgerDate
				,
					case
						when
							d.OriginalTransParty = '发起'
								then
									d.BankID --规则的BankID
						else
							@AgainstBankID
					end
				,d.BankID as OriginalBankID
				,d.OriginalTransDirection --上存、上透
				,d.CurrencyType
				,d.Accounting
				,d.DCParty
				,b.FactualRate
				,c.DaysPerPeriod
				,d.FactorAmount
				,isnull(a.DebtorBalance,0) as Amount
				,d.FactorDayInterest
				,
					ISNULL
						(
							isnull(a.DebtorBalance,0)
							* isnull(b.FactualRate,0)
							/100.0/c.DaysPerPeriod
							,0
						)
					--as DayInterest
				, d.AmountType			--累计利息、冲回昨日
				, d.DateType
				, d.IsSum
				, d.LastSumAccounting
				, d.LastSumDCParty
				, 
					isnull
					(
						(
							select
								case
									when
										d.IsSum = 1 and d.LastSumDCParty = 'dr'
											then
												sum(isnull(aa.DebtorBalance,0))
									when
										d.IsSum = 1 and d.LastSumDCParty = 'cr'
											then
												sum(isnull(aa.CreditorBalance,0))
								end
											
							from
								[DailyLedgerResultVar] aa
							where
								aa.Accounting = d.LastSumAccounting
								and aa.BankID = 
												(
													case
														when
															d.OriginalTransParty = '发起'
																then
																	d.BankID
														else
															@AgainstBankID
													end
												)
								and aa.CurrencyType = d.CurrencyType
								and aa.OriginalBankID = d.BankID
								
								
								and aa.IsDeleted = 0
								and aa.LedgerDate = @LastLedgerDate	--昨天的会计分录
								--and aa.
								
						)
					,0)
					as LastSumAmount
			from
					TBalance a
						inner join TRate b
								on
									a.CurrencyType = b.CurrencyType
									and a.OriginalTransDirection = b.OriginalTransDirection
						inner join TDaysPerYear c
								on
									a.CurrencyType = c.CurrencyType




						right join TDepartmentsCurrencyTransDirectionAccountingRules d
								on
									a.BankID = d.BankID 
											--(
											--		case
											--			when
											--				d.OriginalTransParty = '发起'
											--					then
											--						d.BankID
											--			else
											--				@AgainstBankID
											--		end
											--	)
									and d.CurrencyType = a.CurrencyType
									and a.OriginalTransDirection = d.OriginalTransDirection
									--and a.BankID = d.BankID
									

				
		)
	
		,TTodayLedger
			(
				BankID
				,OriginalBankID
				,CurrencyType
				,Accounting
				--,DCParty
				--,AmountType
				,Amount
				,DayInterest
				,LastSumAmount
				,DebtorBalance
				,CreditorBalance
			)
		as
		(
			select
				a.BankID
				,a.OriginalBankID
				,a.CurrencyType
				,a.Accounting
				--,a.DCParty
				--,a.AmountType

				,	sum
					(isnull(a.Amount,0) * isnull(a.FactorAmount,0))
				,	sum
					(isnull(a.DayInterest,0) * isnull(a.FactorDayInterest,0))
				,	sum
					(isnull(a.LastSumAmount,0))

				,
					sum
					(
						case
							when
								a.DCParty = 'dr'
									then
										isnull(a.Amount,0) * isnull(a.FactorAmount,0)
										+
										isnull(a.DayInterest,0) * isnull(a.FactorDayInterest,0)
										+
										isnull(a.LastSumAmount,0)
							else
								0
						end
					)
				,
					sum
					(
						case
							when
								a.DCParty = 'cr'
									then
										isnull(a.Amount,0) * isnull(a.FactorAmount,0)
										+
										isnull(a.DayInterest,0) * isnull(a.FactorDayInterest,0)
										+
										isnull(a.LastSumAmount,0)
							else
								0
						end			
					)
			
			from
				TTodayAmount a
					--right join
					--	AccountingRules b
					--		on
					--			a.DateType = b.DateType
					--			and a.Accounting = b.Accounting
					--			and a.AmountType = b.AmountType
			group by
				
				a.OriginalBankID
				,a.BankID
				,a.CurrencyType
				,a.Accounting
			--	,a.IsSum
			--	,a.LastSumAccounting
			--	,a.LastSumDCParty
		)


		

		--Select
		--	*
			
		--from
		--	T0 a
		--	TBalance
		--	TTodayAmount a
		--	TTodayLedger
				
		--	TAccountingRules				
		--	TDepartmentsCurrencyTransDirectionAccountingRules
		--where
		--		CurrencyType in ('CNY')
		--		and BankID in ('安徽分行','总行')
		--order by
		--		BankID
		--		, DebtorBalance desc
		--		,CurrencyType	
		
		--return	
		INSERT INTO 
			[DailyLedgerResultVar]
			(
			   [LedgerDate]
			   ,[BankID]
			   ,OriginalBankID
			   ,[CurrencyType]
			   ,[Accounting]
			   ,[DebtorBalance]
			   ,[CreditorBalance]
			   ,[IsDeleted]
			)
		select
				@LedgerDate
			   ,[BankID]
			   ,OriginalBankID
			   ,[CurrencyType]
			   ,[Accounting]
			   ,[DebtorBalance]
			   ,[CreditorBalance]
			   ,0
		from
			TTodayLedger
		
			
		select
			*
		from
			[DailyLedgerResultVar]
		where
			isdeleted = 0
			and LedgerDate >= '2012-12-24'
			--and CurrencyType in ('CNY','USD')
			--and BankID in  ('安徽分行','总行')
		order by
			LedgerDate desc
			, BankID
			, CurrencyType
			, Accounting
			
			
				
			

							

end
#T=加壳
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Reflection;
	class Program
	{
		static void Main(string[] args)
		{
			var buffer = File.ReadAllBytes(@"C:\Users\xiyueyu\Desktop\Noname2.exe");
			var assembly = Assembly.Load(buffer);
			var methodInfo = assembly.EntryPoint;
			methodInfo.Invoke(null, new object[] { null });
			Console.ReadLine();
		}
	}
}
namespace ConsoleApplication
{
	using System;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//

			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}

}

#T=键鼠计数计程
namespace Test
{
	using System;
	using System.Drawing;
	using System.ComponentModel;
	using System.Drawing.Drawing2D;
	using System.Globalization;
	using System.Runtime.InteropServices;
	using System.Reflection;
	using System.Threading;
	using System.Windows.Forms;
	using System.Linq;
	using System.Collections.Generic;
	using Microshaoft;
	public class Form1 : Form
	{
		private IContainer components;
		private UserActivityHook hook;
		private KeyPressCounter[] _counters;
		private ContextMenu contextMenu1;
		private NotifyIcon notifyIcon1;
		private MenuItem loadHook
						, unHook
						, exit
						, menuItem1;
		private System.Windows.Forms.Timer timer1;
		private Label label1
						, label2
						, label3
						, label4;
		private int _cc;
		private double _distance;	//移动距离
		//Todo:有待改进的方法
		//为了让Setting窗体修改参数，这里修改为public可能设计上不是很好。。。
		public double _distpara;	//参数 -- 用电子尺测一下
		public int _screen;				//屏幕分辨率
		private Point _ptOrigin, _ptOld;
		private MenuItem menuItem2
							, menuItem3
							, menuItem4
							, menuItem5
							, menuItem6
							, menuItem7
							, menuItem8
							, menuItem9;
		private Settings setting;
		public Form1()
		{
			InitializeComponent();
		}
		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		protected override void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		#region Windows 窗体设计器生成的代码
		private void InitializeComponent()
		{
			components = new Container();
			//System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(Form1));
			contextMenu1 = new ContextMenu();
			loadHook = new MenuItem();
			unHook = new MenuItem();
			menuItem2 = new MenuItem();
			menuItem4 = new MenuItem();
			menuItem1 = new MenuItem();
			menuItem3 = new MenuItem();
			exit = new MenuItem();
			notifyIcon1 = new NotifyIcon(components);
			timer1 = new System.Windows.Forms.Timer(components);
			label1 = new Label();
			label2 = new Label();
			label3 = new Label();
			label4 = new Label();
			menuItem5 = new MenuItem();
			menuItem6 = new MenuItem();
			menuItem7 = new MenuItem();
			menuItem8 = new MenuItem();
			menuItem9 = new MenuItem();
			SuspendLayout();
			// 
			// contextMenu1
			// 
			contextMenu1.MenuItems.AddRange(new MenuItem[] {
															 loadHook,
															 unHook,
															 menuItem2,
															 menuItem4,
															 menuItem1,
															 menuItem3,
															 menuItem7,
															 menuItem6,
															 menuItem5,
															 menuItem8,
															 menuItem9,
															 exit});
			// 
			// loadHook
			// 
			loadHook.Index = 0;
			loadHook.Text = "装载全局钩子";
			loadHook.Click += new System.EventHandler(loadHook_Click);
			// 
			// unHook
			// 
			unHook.Index = 1;
			unHook.Text = "卸载全局钩子";
			unHook.Click += new System.EventHandler(unHook_Click);
			// 
			// menuItem2
			// 
			menuItem2.Index = 2;
			menuItem2.Text = "-";
			// 
			// menuItem4
			// 
			menuItem4.Index = 3;
			menuItem4.Text = "系统参数设置";
			menuItem4.Click += new System.EventHandler(menuItem4_Click);
			// 
			// menuItem1
			// 
			menuItem1.Index = 4;
			menuItem1.Text = "按键信息统计";
			menuItem1.Click += new System.EventHandler(menuItem1_Click);
			// 
			// menuItem3
			// 
			menuItem3.Index = 5;
			menuItem3.Text = "-";
			// 
			// exit
			// 
			exit.Index = 11;
			exit.Text = "退出程序";
			exit.Click += new System.EventHandler(exit_Click);
			// 
			// notifyIcon1
			// 
			notifyIcon1.ContextMenu = contextMenu1;
			//notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));
			notifyIcon1.Text = "钩子程序";
			notifyIcon1.Visible = true;
			// 
			// timer1
			// 
			timer1.Tick += new System.EventHandler(timer1_Tick);
			// 
			// label1
			// 
			label1.BackColor = System.Drawing.Color.Transparent;
			label1.Location = new System.Drawing.Point(8, 56);
			label1.Name = "label1";
			label1.TabIndex = 0;
			label1.Text = "键盘敲击计数：";
			label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// label2
			// 
			label2.BackColor = System.Drawing.Color.Transparent;
			label2.Location = new System.Drawing.Point(8, 16);
			label2.Name = "label2";
			label2.TabIndex = 1;
			label2.Text = "鼠标移动距离：";
			label2.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// label3
			// 
			label3.BackColor = System.Drawing.Color.Transparent;
			label3.Location = new System.Drawing.Point(96, 16);
			label3.Name = "label3";
			label3.Size = new System.Drawing.Size(88, 23);
			label3.TabIndex = 2;
			label3.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// label4
			// 
			label4.BackColor = System.Drawing.Color.Transparent;
			label4.Location = new System.Drawing.Point(96, 56);
			label4.Name = "label4";
			label4.Size = new System.Drawing.Size(88, 23);
			label4.TabIndex = 3;
			label4.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// menuItem5
			// 
			menuItem5.Index = 8;
			menuItem5.Text = "-";
			// 
			// menuItem6
			// 
			menuItem6.Index = 7;
			menuItem6.Text = "隐藏主窗体";
			menuItem6.Click += new System.EventHandler(menuItem6_Click);
			// 
			// menuItem7
			// 
			menuItem7.Index = 6;
			menuItem7.Text = "显示主窗体";
			menuItem7.Click += new System.EventHandler(menuItem7_Click);
			// 
			// menuItem8
			// 
			menuItem8.Index = 9;
			menuItem8.Text = "关于作者";
			menuItem8.Click += new System.EventHandler(menuItem8_Click);
			// 
			// menuItem9
			// 
			menuItem9.Index = 10;
			menuItem9.Text = "-";
			// 
			// Form1
			// 
			AutoScaleMode = AutoScaleMode.None;
			AutoScaleBaseSize = new System.Drawing.Size(6, 14);
			BackColor = System.Drawing.Color.White;
			ClientSize = new System.Drawing.Size(192, 100);
			ControlBox = false;
			Controls.Add(label4);
			Controls.Add(label3);
			Controls.Add(label2);
			Controls.Add(label1);
			FormBorderStyle = FormBorderStyle.None;
			Location = new System.Drawing.Point(820, 630);
			MaximizeBox = false;
			MinimizeBox = false;
			Name = "Form1";
			Opacity = 0.8;
			ShowInTaskbar = false;
			StartPosition = FormStartPosition.Manual;
			Text = "Form1";
			TopMost = true;
			MouseDown += new MouseEventHandler(Form1_MouseDown_1);
			Load += new System.EventHandler(Form1_Load);
			Paint += new PaintEventHandler(Form1_Paint);
			ResumeLayout(false);
		}
		#endregion
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.Run(new Form1());
		}
		private void Form1_Load(object sender, System.EventArgs e)
		{
			Thread.CurrentThread.CurrentCulture = new CultureInfo("en-us");
			_ptOrigin = new Point(0, 0);
			_ptOld = new Point(0, 0);
			timer1.Enabled = true;
			Opacity = 0;
			_cc = 0; //初始化全局统计变量
			_distance = 0;
			_distpara = 0.2697; //测量屏幕物理距离得到的参数 
			_screen = 1024;
			setting = new Settings(_screen, _distpara, this);
			setting.Visible = false;
			#region "按键数组"

			//Array.Copy
			var a = (Keys[]) Enum.GetValues(typeof(Keys));
			var l = new List<KeyPressCounter>();
			Array.ForEach
					(
						a
						, (x) =>
							{
								l.Add(new KeyPressCounter(x));
							}
					);
			_counters = l.ToArray();

			 
			#endregion
			hook = new UserActivityHook();
			hook.OnMouseActivity += new MouseEventHandler(hook_OnMouseActivity);
			hook.KeyDown += new KeyEventHandler(hook_KeyDown);
		}
		//统计鼠标移动的距离
		private void hook_OnMouseActivity(object sender, MouseEventArgs e)
		{
			_ptOrigin.X = e.X;
			_ptOrigin.Y = e.Y;
			//勾-股-弦
			double temp = Math.Pow(_ptOld.X - _ptOrigin.X, 2) + Math.Pow(_ptOld.Y - _ptOrigin.Y, 2);
			//计算公式：实际屏幕宽度/分辨率横坐标值 * 移动的像素
			_distance += _distpara / _screen * Math.Pow(temp, 0.5);
			label3.Text = _distance.ToString("F2") + " 米";
			_ptOld.X = _ptOrigin.X;
			_ptOld.Y = _ptOrigin.Y;
		}
		/// <summary>
		/// 统计各个按键按下的次数 每一个keydown事件作为按键一次的判断
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void hook_KeyDown(object sender, KeyEventArgs e)
		{
			_cc++;
			label4.Text = _cc.ToString() + " 次";
			int i = findKeyIndex(e.KeyCode);
			if (i != -1)
				addKeyPress(i);
		}
		public void addKeyPress(int id)
		{
			_counters[id].Count++;
		}
		public int findKeyIndex(Keys k)
		{
			for (int i = 0; i < _counters.Length; i++)
			{
				if (_counters[i].Key == k.ToString())
					return i;
			}
			return -1;
		}
		#region "托盘菜单相关"
		private void loadHook_Click(object sender, System.EventArgs e)
		{
			hook.Start();
		}
		private void unHook_Click(object sender, System.EventArgs e)
		{
			hook.Stop();
		}
		private void exit_Click(object sender, System.EventArgs e)
		{
			Dispose();
		}
		private void menuItem1_Click(object sender, System.EventArgs e)
		{
			string temp = "详细统计信息--各键的按键次数为：\n";
			for (int i = 0; i < _counters.Length; i++)
				temp += _counters[i].Key + "=" + _counters[i].Count.ToString() + ",   ";
			MessageBox.Show(temp);
		}
		private void menuItem7_Click(object sender, System.EventArgs e)
		{
			Visible = true;
		}
		private void menuItem6_Click(object sender, System.EventArgs e)
		{
			Visible = false;
		}
		private void menuItem4_Click(object sender, System.EventArgs e)
		{
			if (DialogResult.OK == MessageBox.Show("需要重新设置参数么？", "设置", MessageBoxButtons.OKCancel))
				setting.Visible = true;
		}
		private void menuItem8_Click(object sender, System.EventArgs e)
		{

		}
		#endregion
		#region "无标题窗口拖动相关"
		[DllImport("user32.dll")]
		public static extern bool ReleaseCapture();
		[DllImport("user32.dll")]
		public static extern bool SendMessage(IntPtr hwnd, int wMsg, int wParam, int lParam);
		public const int WM_SYSCOMMAND = 0x0112;
		public const int SC_MOVE = 0xF010;
		public const int HTCAPTION = 0x0002;
		private void Form1_MouseDown_1(object sender, MouseEventArgs e)
		{
			ReleaseCapture();
			SendMessage(Handle, WM_SYSCOMMAND, SC_MOVE + HTCAPTION, 0);
		}
		#endregion
		#region "窗体样式相关"
		private void Form1_Paint(object sender, PaintEventArgs e)
		{
			Graphics g = e.Graphics;
			Color FColor = Color.OrangeRed;
			Color TColor = Color.Orange;
			Brush b = new LinearGradientBrush(ClientRectangle, FColor, TColor, LinearGradientMode.ForwardDiagonal);
			g.FillRectangle(b, ClientRectangle);
		}
		private void timer1_Tick(object sender, System.EventArgs e)
		{
			if (Opacity < 0.8) { Opacity = Opacity + 0.05; }
			else { timer1.Enabled = false; }
		}
		#endregion
	}
}
namespace Microshaoft
{
	using System;
	using System.Reflection;
	using System.Runtime.InteropServices;
	using System.Windows.Forms;
	/// <summary>
	/// This class allows you to tap keyboard and mouse and / or to detect their activity even when an 
	/// application runes in background or does not have any user interface at all. This class raises 
	/// common .NET events with KeyEventArgs and MouseEventArgs so you can easily retrive any information you need.
	/// </summary>
	/// <remarks>
	/// 	created by - Georgi
	/// 	created on - 22.05.2004 13:08:01
	/// 	
	/// 	说明： 该类是从CodeProject上搜集的,原作者Georgi保留所以权利
	/// </remarks>
	public class UserActivityHook : object
	{
		/// <summary>
		/// Default constructor - starts hooks automatically
		/// </summary>
		public UserActivityHook()
		{
			Start();
		}
		~UserActivityHook()
		{
			Stop();
		}
		public event MouseEventHandler OnMouseActivity;
		public event KeyEventHandler KeyDown;
		public event KeyPressEventHandler KeyPress;
		public event KeyEventHandler KeyUp;
		public delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam);
		static int hMouseHook = 0; //Declare mouse hook handle as int.
		static int hKeyboardHook = 0; //Declare keyboard hook handle as int.
		//values from Winuser.h in Microsoft SDK.
		public const int WH_MOUSE_LL = 14;	//mouse hook constant
		public const int WH_KEYBOARD_LL = 13;	//keyboard hook constant	
		HookProc MouseHookProcedure; //Declare MouseHookProcedure as HookProc type.
		HookProc KeyboardHookProcedure; //Declare KeyboardHookProcedure as HookProc type.
		//Declare wrapper managed POINT class.
		[StructLayout(LayoutKind.Sequential)]
		public class POINT
		{
			public int x;
			public int y;
		}
		//Declare wrapper managed MouseHookStruct class.
		[StructLayout(LayoutKind.Sequential)]
		public class MouseHookStruct
		{
			public POINT pt;
			public int hwnd;
			public int wHitTestCode;
			public int dwExtraInfo;
		}
		//Declare wrapper managed KeyboardHookStruct class.
		[StructLayout(LayoutKind.Sequential)]
		public class KeyboardHookStruct
		{
			public int vkCode;	//Specifies a virtual-key code. The code must be a value in the range 1 to 254. 
			public int scanCode; // Specifies a hardware scan code for the key. 
			public int flags;  // Specifies the extended-key flag, event-injected flag, context code, and transition-state flag.
			public int time; // Specifies the time stamp for this message.
			public int dwExtraInfo; // Specifies extra information associated with the message. 
		}
		//Import for SetWindowsHookEx function.
		//Use this function to install a hook.
		[DllImport("user32.dll", CharSet = CharSet.Auto,
			CallingConvention = CallingConvention.StdCall)]
		public static extern int SetWindowsHookEx(int idHook, HookProc lpfn,
			IntPtr hInstance, int threadId);
		//Import for UnhookWindowsHookEx.
		//Call this function to uninstall the hook.
		[DllImport("user32.dll", CharSet = CharSet.Auto,
			 CallingConvention = CallingConvention.StdCall)]
		public static extern bool UnhookWindowsHookEx(int idHook);
		//Import for CallNextHookEx.
		//Use this function to pass the hook information to next hook procedure in chain.
		[DllImport("user32.dll", CharSet = CharSet.Auto,
			 CallingConvention = CallingConvention.StdCall)]
		public static extern int CallNextHookEx(int idHook, int nCode,
			Int32 wParam, IntPtr lParam);
		public void Start()
		{
			// install Mouse hook 
			if (hMouseHook == 0)
			{
				// Create an instance of HookProc.
				MouseHookProcedure = new HookProc(MouseHookProc);
				hMouseHook = SetWindowsHookEx(WH_MOUSE_LL,
					MouseHookProcedure,
					Marshal.GetHINSTANCE(
						Assembly.GetExecutingAssembly().GetModules()[0]),
					0);
				//If SetWindowsHookEx fails.
				if (hMouseHook == 0)
				{
					Stop();
					throw new Exception("SetWindowsHookEx failed.");
				}
			}
			// install Keyboard hook 
			if (hKeyboardHook == 0)
			{
				KeyboardHookProcedure = new HookProc(KeyboardHookProc);
				hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL,
					KeyboardHookProcedure,
					Marshal.GetHINSTANCE(
					Assembly.GetExecutingAssembly().GetModules()[0]),
					0);
				//If SetWindowsHookEx fails.
				if (hKeyboardHook == 0)
				{
					Stop();
					throw new Exception("SetWindowsHookEx ist failed.");
				}
			}
		}
		public void Stop()
		{
			bool retMouse = true;
			bool retKeyboard = true;
			if (hMouseHook != 0)
			{
				retMouse = UnhookWindowsHookEx(hMouseHook);
				hMouseHook = 0;
			}
			if (hKeyboardHook != 0)
			{
				retKeyboard = UnhookWindowsHookEx(hKeyboardHook);
				hKeyboardHook = 0;
			}
			//If UnhookWindowsHookEx fails.
			if (!(retMouse && retKeyboard)) throw new Exception("UnhookWindowsHookEx failed.");
		}
		private const int WM_MOUSEMOVE = 0x200;
		private const int WM_LBUTTONDOWN = 0x201;
		private const int WM_RBUTTONDOWN = 0x204;
		private const int WM_MBUTTONDOWN = 0x207;
		private const int WM_LBUTTONUP = 0x202;
		private const int WM_RBUTTONUP = 0x205;
		private const int WM_MBUTTONUP = 0x208;
		private const int WM_LBUTTONDBLCLK = 0x203;
		private const int WM_RBUTTONDBLCLK = 0x206;
		private const int WM_MBUTTONDBLCLK = 0x209;
		private int MouseHookProc(int nCode, Int32 wParam, IntPtr lParam)
		{
			// if ok and someone listens to our events
			if ((nCode >= 0) && (OnMouseActivity != null))
			{
				MouseButtons button = MouseButtons.None;
				switch (wParam)
				{
					case WM_LBUTTONDOWN:
						//case WM_LBUTTONUP: 
						//case WM_LBUTTONDBLCLK: 
						button = MouseButtons.Left;
						break;
					case WM_RBUTTONDOWN:
						//case WM_RBUTTONUP: 
						//case WM_RBUTTONDBLCLK: 
						button = MouseButtons.Right;
						break;
				}
				int clickCount = 0;
				if (button != MouseButtons.None)
					if (wParam == WM_LBUTTONDBLCLK || wParam == WM_RBUTTONDBLCLK) clickCount = 2;
					else clickCount = 1;
				//Marshall the data from callback.
				MouseHookStruct MyMouseHookStruct = (MouseHookStruct)Marshal.PtrToStructure(lParam, typeof(MouseHookStruct));
				MouseEventArgs e = new MouseEventArgs(
													button,
													clickCount,
													MyMouseHookStruct.pt.x,
													MyMouseHookStruct.pt.y,
													0);
				OnMouseActivity(this, e);
			}
			return CallNextHookEx(hMouseHook, nCode, wParam, lParam);
		}
		//The ToAscii function translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function translates the code using the input language and physical keyboard layout identified by the keyboard layout handle.
		[DllImport("user32")]
		public static extern int ToAscii(int uVirtKey, //[in] Specifies the virtual-key code to be translated. 
										 int uScanCode, // [in] Specifies the hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed). 
										 byte[] lpbKeyState, // [in] Pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down (pressed). The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle state of the NUM LOCK and SCROLL LOCK keys is ignored.
										 byte[] lpwTransKey, // [out] Pointer to the buffer that receives the translated character or characters. 
										 int fuState); // [in] Specifies whether a menu is active. This parameter must be 1 if a menu is active, or 0 otherwise. 
		//The GetKeyboardState function copies the status of the 256 virtual keys to the specified buffer. 
		[DllImport("user32")]
		public static extern int GetKeyboardState(byte[] pbKeyState);
		private const int WM_KEYDOWN = 0x100;
		private const int WM_KEYUP = 0x101;
		private const int WM_SYSKEYDOWN = 0x104;
		private const int WM_SYSKEYUP = 0x105;
		private int KeyboardHookProc(int nCode, Int32 wParam, IntPtr lParam)
		{
			// it was ok and someone listens to events
			if ((nCode >= 0) && (KeyDown != null || KeyUp != null || KeyPress != null))
			{
				KeyboardHookStruct MyKeyboardHookStruct = (KeyboardHookStruct)Marshal.PtrToStructure(lParam, typeof(KeyboardHookStruct));
				// raise KeyDown
				if (KeyDown != null && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN))
				{
					Keys keyData = (Keys)MyKeyboardHookStruct.vkCode;
					KeyEventArgs e = new KeyEventArgs(keyData);
					KeyDown(this, e);
				}
				// raise KeyPress
				if (KeyPress != null && wParam == WM_KEYDOWN)
				{
					byte[] keyState = new byte[256];
					GetKeyboardState(keyState);
					byte[] inBuffer = new byte[2];
					if (ToAscii(MyKeyboardHookStruct.vkCode,
							MyKeyboardHookStruct.scanCode,
							keyState,
							inBuffer,
							MyKeyboardHookStruct.flags) == 1)
					{
						KeyPressEventArgs e = new KeyPressEventArgs((char)inBuffer[0]);
						KeyPress(this, e);
					}
				}
				// raise KeyUp
				if (KeyUp != null && (wParam == WM_KEYUP || wParam == WM_SYSKEYUP))
				{
					Keys keyData = (Keys)MyKeyboardHookStruct.vkCode;
					KeyEventArgs e = new KeyEventArgs(keyData);
					KeyUp(this, e);
				}
			}
			return CallNextHookEx(hKeyboardHook, nCode, wParam, lParam);
		}
	}
}
namespace Test
{
	using System;
	using System.Windows.Forms;
	using System.ComponentModel;
	/// <summary>
	/// Settings 的摘要说明。
	/// </summary>
	public class Settings : Form
	{
		private Label label1;
		private Label label2;
		private TextBox textBox1;
		private TextBox textBox2;
		private Label label3;
		private Label label4;
		private TextBox textBox3;
		private Button button1;
		private Button button2;
		private int _h;
		private int _screen;
		private double _distpara;
		private Form1 _f1;
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private Container components = null;
		public Settings(int screen, double distpara, Form1 parent)
		{
			_h = 768;
			_screen = screen;
			_distpara = distpara;
			_f1 = parent;
			//
			// Windows 窗体设计器支持所必需的
			//
			InitializeComponent();
			textBox2.Text = _screen.ToString();
			textBox3.Text = _h.ToString();
			textBox1.Text = _distpara.ToString();
			//
			// TODO: 在 InitializeComponent 调用后添加任何构造函数代码
			//
		}
		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		protected override void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要使用代码编辑器修改
		/// 此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			label1 = new Label();
			label2 = new Label();
			textBox1 = new TextBox();
			textBox2 = new TextBox();
			label3 = new Label();
			label4 = new Label();
			textBox3 = new TextBox();
			button1 = new Button();
			button2 = new Button();
			SuspendLayout();
			// 
			// label1
			// 
			label1.BackColor = System.Drawing.Color.Transparent;
			label1.FlatStyle = FlatStyle.Flat;
			label1.Location = new System.Drawing.Point(16, 24);
			label1.Name = "label1";
			label1.TabIndex = 0;
			label1.Text = "显示器宽度：";
			label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// label2
			// 
			label2.BackColor = System.Drawing.Color.Transparent;
			label2.FlatStyle = FlatStyle.Flat;
			label2.Location = new System.Drawing.Point(16, 60);
			label2.Name = "label2";
			label2.TabIndex = 1;
			label2.Text = "屏幕分辨率：";
			label2.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// textBox1
			// 
			textBox1.BorderStyle = BorderStyle.FixedSingle;
			textBox1.Location = new System.Drawing.Point(120, 24);
			textBox1.Name = "textBox1";
			textBox1.TabIndex = 3;
			textBox1.Text = "";
			// 
			// textBox2
			// 
			textBox2.BorderStyle = BorderStyle.FixedSingle;
			textBox2.Location = new System.Drawing.Point(120, 64);
			textBox2.Name = "textBox2";
			textBox2.Size = new System.Drawing.Size(64, 21);
			textBox2.TabIndex = 4;
			textBox2.Text = "";
			// 
			// label3
			// 
			label3.BackColor = System.Drawing.Color.Transparent;
			label3.FlatStyle = FlatStyle.Flat;
			label3.Location = new System.Drawing.Point(224, 24);
			label3.Name = "label3";
			label3.Size = new System.Drawing.Size(32, 23);
			label3.TabIndex = 5;
			label3.Text = "米";
			label3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// label4
			// 
			label4.BackColor = System.Drawing.Color.Transparent;
			label4.FlatStyle = FlatStyle.Flat;
			label4.Location = new System.Drawing.Point(190, 64);
			label4.Name = "label4";
			label4.Size = new System.Drawing.Size(8, 23);
			label4.TabIndex = 6;
			label4.Text = "*";
			label4.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// textBox3
			// 
			textBox3.BorderStyle = BorderStyle.FixedSingle;
			textBox3.Location = new System.Drawing.Point(200, 64);
			textBox3.Name = "textBox3";
			textBox3.Size = new System.Drawing.Size(56, 21);
			textBox3.TabIndex = 7;
			textBox3.Text = "";
			// 
			// button1
			// 
			button1.BackColor = System.Drawing.Color.Transparent;
			button1.FlatStyle = FlatStyle.Flat;
			button1.Location = new System.Drawing.Point(184, 104);
			button1.Name = "button1";
			button1.Size = new System.Drawing.Size(75, 32);
			button1.TabIndex = 8;
			button1.Text = "确定";
			button1.Click += new System.EventHandler(button1_Click);
			// 
			// button2
			// 
			button2.BackColor = System.Drawing.Color.Transparent;
			button2.FlatStyle = FlatStyle.Flat;
			button2.Location = new System.Drawing.Point(32, 104);
			button2.Name = "button2";
			button2.Size = new System.Drawing.Size(136, 32);
			button2.TabIndex = 10;
			button2.Text = "参数说明 & 帮助";
			button2.Click += new System.EventHandler(button2_Click);
			// 
			// Settings
			// 
			AutoScaleBaseSize = new System.Drawing.Size(6, 14);
			BackColor = System.Drawing.Color.Orange;
			ClientSize = new System.Drawing.Size(288, 154);
			Controls.Add(button2);
			Controls.Add(button1);
			Controls.Add(textBox3);
			Controls.Add(label4);
			Controls.Add(label3);
			Controls.Add(textBox2);
			Controls.Add(textBox1);
			Controls.Add(label2);
			Controls.Add(label1);
			Name = "Settings";
			Text = "程序设置";
			ResumeLayout(false);
		}
		#endregion
		private void button2_Click(object sender, System.EventArgs e)
		{
			string mm = "第一个参数为显示器物理宽度，可以用电子尺软件测出来\n"
				+ "相关介绍参看：http://jht.cnblogs.com/archive/2006/03/28/361249.html\n"
				+ "第二个参数为屏幕分辨率，如1024 * 768; 800 * 600 等";
			MessageBox.Show(mm, "系统设置帮助", MessageBoxButtons.OK, MessageBoxIcon.Information);
		}
		private void button1_Click(object sender, System.EventArgs e)
		{
			if (textBox1.Text.Trim() == "" | textBox2.Text.Trim() == "")
			{
				MessageBox.Show("参数不能为空");
			}
			if (Convert.ToDouble(textBox1.Text) > 10 | Convert.ToDouble(textBox1.Text) < 0.01)
			{
				MessageBox.Show("参数超出范围，请重新设定");
			}
			else
			{
				_distpara = Convert.ToDouble(textBox1.Text);
				_screen = Convert.ToInt32(textBox2.Text);
				_h = Convert.ToInt32(textBox3.Text);
				_f1._screen = _screen;
				_f1._distpara = _distpara;
				if (DialogResult.OK == MessageBox.Show("参数设置完成"))
				{
					Visible = false;
				}
			}
		}
	}
}
namespace Microshaoft
{
	using System.Windows.Forms;
	//using System.Threading;
	/// <summary>
	/// KeyPressCounter 的摘要说明。
	/// </summary>
	public class KeyPressCounter
	{
		public KeyPressCounter(Keys key)
		{
			_count = 0;
			_key = key.ToString();
		}
		private int _count;
		private string _key;
		public int Count
		{
			set { _count = value; }
			get { return _count; }
		}
		public string Key
		{
			get { return _key; }
		}
	}
}

#T=内插字符串 nameof $"...."
namespace ConsoleApplication
{
	using System;
	using System.Runtime.ExceptionServices;
	public class Program
	{
		static void Main(string[] args)
		{
			var a = 100;
			var b = a;
			var c = new
						{
							F1 = "asdsad"
							, F2 = new Func<int,int>
										(
											(x) => { return x + x;} 
										)
						};
			//var $s = string.Empty;
			Console.WriteLine
						(
							$@"Hello World {{1}}{{0}}{a}{0}{c.F2(1)}{0}{{2}}"
							, "\r\n"
							, nameof(a)
							, 9999
							, nameof(c.F2)
						);
			///FormattableString  fs =  new FormattableString
								///(
									///"Hello World {{1}}{{0}}{a}{0}{c.F2(1)}{0}{{2}}"
									///, "\r\n"
									///, nameof(a)
									///, 9999
								///);
			///Console.WriteLine
						///(
							///fs
						///);
		ExceptionDispatchInfo edi = null;
		try
		{
			throw new Exception("test");
		}
		catch (Exception e)
		{
			throw;
			edi = ExceptionDispatchInfo.Capture(e);
		}
		if (edi != null)
		{
			//edi.Throw();
		}
		
			Console.WriteLine(Environment.Version.ToString());
		}	
	}
}

#T=清理事件处理函数
namespace Microshaoft
{
	using System;
	using System.Linq;
	using System.Drawing;
	using System.Collections.Generic;
	using System.Windows.Forms;
	public class Form1 : Form
	{
		static void Main()
		{
			Application.Run(new Form1());
		}
		//private List<Action<object, EventArgs>> _actions = null;
		//private List<EventHandler> _eventHandlers = null;
		private Button button1;
		public Form1()
		{
			button1 = new Button();
			button1.Text = "button1";
			Controls.Add(button1);
			
			var actions = new List<Action<object, EventArgs>>();
			//_actions = actions;
			var eventHandlers = new List<EventHandler>();
			//_eventHandlers = eventHandlers;
			//int i = 1;
			EventHandler eh;
			eh = new EventHandler
							(
								(x, y) =>
								{
									MessageBox.Show("Lambda1");
									DisposeHandlersAllProcesses(eventHandlers);
								}
							);
			eventHandlers.Add(eh);
			eventHandlers.Add(eh);
			//_actions.Add(eh);
			//_actions.Add(eh);
			eventHandlers
				//_actions
				.ForEach
								(
									(x) =>
									{
										button1.Click += eh;
										button1.Click +=
													(
														(xx, yy) =>
														{
															MessageBox.Show("Lambda2");
															DisposeHandlersAllProcesses(eventHandlers);
														}
													);
									}
								);
			button1.Click -= eh;
			eh = null;
			DisposeHandlersAllProcesses(eventHandlers);
			//(EventHandler) _action;
			//new EventHandler
		}
		//private void DisposeHandlersAllProcesses(List<Action> handlers)
		private void DisposeHandlersAllProcesses(List<EventHandler> handlers)
		{
			handlers
				//_actions
					.ForEach
						(
							(x) =>
							{
								var invocations = x.GetInvocationList();
								Array.ForEach
										(
											invocations
											, (xx) =>
											{
												x -= (EventHandler)xx;
												Console.WriteLine("{0}:{1}", x, xx);
											}
										);
								x = null;
							}
						);
		}
	}
}

#T=设计模式
最近参加面试，总是被问到设计模式的问题。本人作为一个实用派，完全没搞懂作为一个功能的实现者，设计模式到底有多重要。当然，本人的意思不是说设计模式没用或者不该了解，但是这是一个度的问题，简单的模式，常用的模式，了解并会用，是必然的，但是其他模式，更深层的东西，也许留给架构师来理解更好。毕竟程序员不是架构师，要是程序员懂的知识和架构师一样多，那么，还要架构师来干什么呢？
　　于此苦闷中，特出来分享一下比较好的设计模式的介绍，以求朋友们能去应付那些蛋疼的笔试。
　　1、FACTORY――工程模式？
　　追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory  
　　工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。   

　　2、BUILDER――建造模式？
　　MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）  
　　建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。   

　　3、FACTORY METHOD――工厂方法模式？
　　请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。  
　　工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。   

　　4、PROTOTYPE――原始模型模式？
　　跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）   原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。
　　原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。   

　　5、SINGLETON――单例模式？
　　俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)  
　　单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 [b:9ceca65206]结构型模式[/b:9ceca65206]   

　　6、ADAPTER――适配器模式？
　　在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)  
　　适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。   

　　7、BRIDGE――桥梁模式？
　　早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了  
　　 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。   

　　8、COMPOSITE――合成模式？
　　Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？  
　　合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。   

　　9、DECORATOR――装饰模式？
　　Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？  
　　装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。   

　　10、FACADE――门面模式？
　　我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。  
　　门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。   

　　11、FLYWEIGHT――享元模式？
　　每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。  
　　享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。   

　　12、PROXY――代理模式？
　　跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。  
　　代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 [b:9ceca65206]行为模式[/b:9ceca65206]   

　　13、CHAIN OF RESPONSIBLEITY――责任链模式？
　　晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!  
　　责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接   起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。   

　　14、COMMAND――命令模式？
　　俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”  
　　命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。   

　　15、INTERPRETER――解释器模式？
　　俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。  
　　解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。   

　　16、ITERATOR――迭代子模式？
　　我爱上了Mary，不顾一切的向她求婚。   Mary：“想要我跟你结婚，得答应我的条件”   我：“什么条件我都答应，你说吧”   Mary：“我看上了那个一克拉的钻石”   我：“我买，我买，还有吗？”   Mary：“我看上了湖边的那栋别墅”   我：“我买，我买，还有吗？”   Mary：“我看上那辆法拉利跑车”   我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”   ……  
　　迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。   

　　17、MEDIATOR――调停者模式？
　　四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。  
　　调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。   

　　18、MEMENTO――备忘录模式？
　　同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。  
　　备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。   

　　19、OBSERVER――观察者模式？
　　想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦  
　　观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。   

　　20、STATE――状态模式？
　　跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。  
　　 状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。

　　21、STRATEGY――策略模式？
　　跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。  
　　策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。   

　　22、TEMPLATE METHOD――模板模式？
　　看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；  
　　模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。   

　　23、VISITOR――访问者模式？
　　情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；  
　　访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。

#T=实例化顺序的C#面试题
namespace ConsoleApplication
{
	using System;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class BaseA
	{
		public static MyTest a1 = new MyTest("a1");
		public MyTest a2 = new MyTest("a2");
		static BaseA()
		{
			MyTest a3 = new MyTest("a3");
		}
		public BaseA()
		{
			MyTest a4 = new MyTest("a4");
		}
		public virtual void MyFun()
		{
			MyTest a5 = new MyTest("a5");
		}
	}
	public class BaseB : BaseA
	{
		public static MyTest b1 = new MyTest("b1");
		public MyTest b2 = new MyTest("b2");
		static BaseB()
		{
			MyTest b3 = new MyTest("b3");
		}
		public BaseB()
		{
			MyTest b4 = new MyTest("b4");
		}
		public new void MyFun()
		{
			MyTest b5 = new MyTest("b5");
		}
	}
	static class Program
	{
		static void Main()
		{
			BaseB baseb = new BaseB();
			baseb.MyFun();
		}
	}
	public class MyTest
	{
		public MyTest(string info)
		{
			Console.WriteLine(info);
		}
	}
}

#T=数据结构 排序 JeffreyZhao
//http://www.cnblogs.com/JeffreyZhao/archive/2010/01/07/1641339.html
//JeffreyZhao
namespace ConsoleApplication
{
	using System;
		/// <summary>
		/// Class1 的摘要说明。
		/// </summary>
	public class Class1
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		//[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: 在此处添加代码以启动应用程序
			//
			Console.WriteLine("Hello World");
			Console.WriteLine(Environment.Version.ToString());
		}
	}

}
namespace Microshaoft
{
	public class Sorter
	{
		public void BubbleSort(int[] array)
		{
			for (int i = array.Length - 1; i >= 0; i--)
			{
				for (int j = 1; j <= i; j++)
				{
					if (array[j - 1] > array[j])
					{
						int temp = array[j - 1];
						array[j - 1] = array[j];
						array[j] = temp;
					}
				}
			}
		}
		public void QuickSort(int[] array)
		{
			QuickSortInternal(array, 0, array.Length);
		}

		private void QuickSortInternal(int[] array, int begin, int end)
		{
			if (end == begin)
			{
				return;
			}
			else
			{
				int pivot = FindPivotIndex(array, begin, end);
				if (pivot > begin) QuickSortInternal(array, begin, pivot - 1);
				if (pivot < end) QuickSortInternal(array, pivot + 1, end);
			}
		}

		private int FindPivotIndex(int[] array, int begin, int end)
		{
			int pivot = begin;
			int m = begin + 1;
			int n = end;

			while (m < end && array[pivot] >= array[m])
			{
				m++;
			}

			while (n > begin && array[pivot] <= array[n])
			{
				n--;
			}

			while (m < n)
			{
				int temp = array[m];
				array[m] = array[n];
				array[n] = temp;

				while (m < end && array[pivot] >= array[m])
				{
					m++;
				}

				while (n > begin && array[pivot] <= array[n])
				{
					n--;
				}

			}

			if (pivot != n)
			{
				int temp = array[n];
				array[n] = array[pivot];
				array[pivot] = temp;

			}

			return n;
		}
	}
}
#T=数据结构 排序算法
namespace Microshaoft
{
	using System;
	public class SelectionSorter
	{
		// public enum comp {COMP_LESS,COMP_EQUAL,COMP_GRTR};
		private int min;
		// private int m=0;
		public void Sort(int[] list)
		{
			int length = list.Length;
			for (int i = 0; i < length - 1; ++i)
			{
				min = i;
				for (int j = i + 1; j < length; ++j)
				{
					if (list[j] < list[min])
						min = j;
				}
				int t = list[min];
				list[min] = list[i];
				list[i] = t;
				// Console.WriteLine("{0}",list[i]);
			}

		}
	}

	//插入排序
	public class InsertionSorter
	{
		public void Sort(int[] list)
		{
			int length = list.Length;
			for (int i = 1; i < length; ++i)
			{
				int t = list[i];
				int j = i;
				while ((j > 0) && (list[j - 1] > t))
				{
					list[j] = list[j - 1];
					--j;
				}
				list[j] = t;
			}

		}
	}

	//希尔排序
	public class ShellSorter
	{
		public void Sort(int[] list)
		{
			int length = list.Length;
			int inc;
			for (inc = 1; inc <= length / 9; inc = 3 * inc + 1) ;
			for (; inc > 0; inc /= 3)
			{
				for (int i = inc + 1; i <= length; i += inc)
				{
					int t = list[i - 1];
					int j = i;
					while ((j > inc) && (list[j - inc - 1] > t))
					{
						list[j - 1] = list[j - inc - 1];
						j -= inc;
					}
					list[j - 1] = t;
				}
			}
		}
	}

	public class QuickSorter
	{
		private void Swap(ref int l, ref int r)
		{
			int s;
			s = l;
			l = r;
			r = s;
		}
		public void Sort(int[] list, int low, int high)
		{
			int pivot;
			int l, r;
			int mid;
			if (high <= low)
			{
				return;
			}
			else if (high == low + 1)
			{
				if (list[low] > list[high])
				{
					Swap(ref list[low], ref list[high]);
				}
				return;
			}
			mid = (low + high) >> 1;
			pivot = list[mid];
			Swap(ref list[low], ref list[mid]);
			l = low + 1;
			r = high;
			do
			{
				while (l <= r && list[l] < pivot)
				{
					l++;
				}
				while (list[r] >= pivot)
				{
					r--;
				}
				if (l < r)
				{
					Swap(ref list[l], ref list[r]);
				}
			} while (l < r);
			list[low] = list[r];
			list[r] = pivot;
			if (low + 1 < r)
			{
				Sort(list, low, r - 1);
			}
			if (r + 1 < high)
			{
				Sort(list, r + 1, high);
			}
		}
	}


	public class MainClass
	{
		public static void Main()
		{
			int[] iArrary = new int[] { 1, 5, 3, 6, 10, 55, 9, 2, 87, 12, 34, 75, 33, 47 };
			Console.WriteLine("选择排序:");
			SelectionSorter ss = new SelectionSorter();
			ss.Sort(iArrary);
			for (int m = 0; m <= 13; m++)
			{
				Console.WriteLine("{0}", iArrary[m]);
			}

			Console.WriteLine("\n插入排序:");
			iArrary = new int[] { 1, 5, 3, 6, 10, 55, 9, 2, 87, 12, 34, 75, 33, 47 };
			InsertionSorter ii = new InsertionSorter();
			ii.Sort(iArrary);
			for (int m = 0; m <= 13; m++)
			{
				Console.WriteLine("{0}", iArrary[m]);
			}
			Console.WriteLine("\n希尔排序:");
			iArrary = new int[] { 1, 5, 3, 6, 10, 55, 9, 2, 87, 12, 34, 75, 33, 47 };
			ShellSorter sh = new ShellSorter();
			sh.Sort(iArrary);
			for (int m = 0; m <= 13; m++)
			{
				Console.WriteLine("{0}", iArrary[m]);
			}

			Console.WriteLine("\n快速排序:");
			iArrary = new int[] { 1, 5, 3, 6, 10, 55, 9, 2, 87, 12, 34, 75, 33, 47 };
			QuickSorter q = new QuickSorter();
			q.Sort(iArrary, 0, 13);
			for (int m = 0; m <= 13; m++)
			{
				Console.WriteLine("{0}", iArrary[m]);
			}
		}
	}
}
#T=数据结构 图
namespace Test
{
	using System;

	using Microshaoft;
	//【例8-1  Demo8-1.cs】图的邻接表存储结构测试
	class Class1
	{
		static void Main(string[] args)
		{
			AdjacencyList<char> a = new AdjacencyList<char>();
			//添加顶点
			a.AddVertex('A');
			a.AddVertex('B');
			a.AddVertex('C');
			a.AddVertex('D');
			//添加边
			a.AddEdge('A', 'B');
			a.AddEdge('A', 'C');
			a.AddEdge('A', 'D');
			a.AddEdge('B', 'D');
			Console.WriteLine(a.ToString());
		}
		//【例8-2  Demo8-2.cs】深度优先搜索遍历测试
		static void Main2()
		{
			AdjacencyList<string> a = new AdjacencyList<string>();
			a.AddVertex("V1");
			a.AddVertex("V2");
			a.AddVertex("V3");
			a.AddVertex("V4");
			a.AddVertex("V5");
			a.AddVertex("V6");
			a.AddVertex("V7");
			a.AddVertex("V8");
			a.AddEdge("V1", "V2");
			a.AddEdge("V1", "V3");
			a.AddEdge("V2", "V4");
			a.AddEdge("V2", "V5");
			a.AddEdge("V3", "V6");
			a.AddEdge("V3", "V7");
			a.AddEdge("V4", "V8");
			a.AddEdge("V5", "V8");
			a.AddEdge("V6", "V8");
			a.AddEdge("V7", "V8");
			a.DFSTraverse();
		}

		//【例8-3  Demo8-3.cs】广度优先搜索遍历测试
		static void Main3(string[] args)
		{
			AdjacencyList<string> a = new AdjacencyList<string>();
			a.AddVertex("V1");
			a.AddVertex("V2");
			a.AddVertex("V3");
			a.AddVertex("V4");
			a.AddVertex("V5");
			a.AddVertex("V6");
			a.AddVertex("V7");
			a.AddVertex("V8");
			a.AddEdge("V1", "V2");
			a.AddEdge("V1", "V3");
			a.AddEdge("V2", "V4");
			a.AddEdge("V2", "V5");
			a.AddEdge("V3", "V6");
			a.AddEdge("V3", "V7");
			a.AddEdge("V4", "V8");
			a.AddEdge("V5", "V8");
			a.AddEdge("V6", "V8");
			a.AddEdge("V7", "V8");
			a.BFSTraverse(); //广度优先搜索遍历
		}

	}

}







namespace Microshaoft
{
	using System;
	using System.Collections.Generic;
	public class AdjacencyList<T>
	{
		//上例的代码只需对DFSTraverse()方法和BFSTraverse()方法稍作修改，便可以遍历非连通图。
		public void DFSTraverse1() //深度优先遍历
		{
			InitVisited(); //将visited标志全部置为false
			foreach (Vertex<T> v in items)
			{
				if (!v.visited) //如果未被访问
				{
					DFS(v); //深度优先遍历
				}
			}
		}
		public void BFSTraverse1() //广度优先遍历
		{
			InitVisited(); //将visited标志全部置为false
			foreach (Vertex<T> v in items)
			{
				if (!v.visited) //如果未被访问
				{
					BFS(v); //广度优先遍历
				}
			}
		}
		//===============================
		public void DFSTraverse() //深度优先遍历
		{
			InitVisited(); //将visited标志全部置为false
			DFS(items[0]); //从第一个顶点开始遍历
		}
		private void DFS(Vertex<T> v) //使用递归进行深度优先遍历
		{
			v.visited = true; //将访问标志设为true
			Console.Write(v.data + " "); //访问
			Node node = v.firstEdge;
			while (node != null) //访问此顶点的所有邻接点
			{   //如果邻接点未被访问，则递归访问它的边
				if (!node.adjvex.visited)
				{
					DFS(node.adjvex); //递归
				}
				node = node.next; //访问下一个邻接点
			}
		}

		private void InitVisited() //初始化visited标志
		{
		 foreach (Vertex<T> v in items)
		 {
			 v.visited = false; //全部置为false
		 }
	 }

		public void BFSTraverse() //广度优先遍历
		{
			InitVisited(); //将visited标志全部置为false
			BFS(items[0]); //从第一个顶点开始遍历
		}
		private void BFS(Vertex<T> v) //使用队列进行广度优先遍历
		{   //创建一个队列
			Queue<Vertex<T>> queue = new Queue<Vertex<T>>();
			Console.Write(v.data + " "); //访问
			v.visited = true; //设置访问标志
			queue.Enqueue(v); //进队
			while (queue.Count > 0) //只要队不为空就循环
			{
				Vertex<T> w = queue.Dequeue();
				Node node = w.firstEdge;
				while (node != null) //访问此顶点的所有邻接点
				{   //如果邻接点未被访问，则递归访问它的边
					if (!node.adjvex.visited)
					{
						Console.Write(node.adjvex.data + " "); //访问
						node.adjvex.visited = true; //设置访问标志
						queue.Enqueue(node.adjvex); //进队
					}
					node = node.next; //访问下一个邻接点
				}
			}
		}



		List<Vertex<T>> items; //图的顶点集合
		public AdjacencyList() : this(10) { } //构造方法
		public AdjacencyList(int capacity) //指定容量的构造方法
		{
			items = new List<Vertex<T>>(capacity);
		}
		public void AddVertex(T item) //添加一个顶点
		{   //不允许插入重复值
			if (Contains(item))
			{
				throw new ArgumentException("插入了重复顶点！");
			}
			items.Add(new Vertex<T>(item));
		}
		public void AddEdge(T from, T to) //添加无向边
		{
			Vertex<T> fromVer = Find(from); //找到起始顶点
			if (fromVer == null)
			{
				throw new ArgumentException("头顶点并不存在！");
			}
			Vertex<T> toVer = Find(to); //找到结束顶点
			if (toVer == null)
			{
				throw new ArgumentException("尾顶点并不存在！");
			}
			//无向边的两个顶点都需记录边信息
			AddDirectedEdge(fromVer, toVer);
			AddDirectedEdge(toVer, fromVer);
		}
		public bool Contains(T item) //查找图中是否包含某项
		{
			foreach (Vertex<T> v in items)
			{
				if (v.data.Equals(item))
				{
					return true;
				}
			}
			return false;
		}
		private Vertex<T> Find(T item) //查找指定项并返回
		{
			foreach (Vertex<T> v in items)
			{
				if (v.data.Equals(item))
				{
					return v;
				}
			}
			return null;
		}
		//添加有向边
		private void AddDirectedEdge(Vertex<T> fromVer, Vertex<T> toVer)
		{
			if (fromVer.firstEdge == null) //无邻接点时
			{
				fromVer.firstEdge = new Node(toVer);
			}
			else
			{
				Node tmp, node = fromVer.firstEdge;
				do
				{   //检查是否添加了重复边
					if (node.adjvex.data.Equals(toVer.data))
					{
						throw new ArgumentException("添加了重复的边！");
					}
					tmp = node;
					node = node.next;
				} while (node != null);
				tmp.next = new Node(toVer); //添加到链表未尾
			}
		}
		public override string ToString() //仅用于测试
		{   //打印每个节点和它的邻接点
			string s = string.Empty;
			foreach (Vertex<T> v in items)
			{
				s += v.data.ToString() + ":";
				if (v.firstEdge != null)
				{
					Node tmp = v.firstEdge;
					while (tmp != null)
					{
						s += tmp.adjvex.data.ToString();
						tmp = tmp.next;
					}
				}
				s += "\r\n";
			}
			return s;
		}
		//嵌套类，表示链表中的表结点
		public class Node
		{
			public Vertex<T> adjvex; //邻接点域
			public Node next; //下一个邻接点指针域
			public Node(Vertex<T> value)
			{
				adjvex = value;
			}
		}
		//嵌套类，表示存放于数组中的表头结点
		public class Vertex<TValue>
		{
			public TValue data; //数据
			public Node firstEdge; //邻接点链表头指针
			public Boolean visited; //访问标志,遍历时使用
			public Vertex(TValue value) //构造方法
			{
				data = value;
			}
		}
	}

}
#T=透明Label
namespace DOALibrary.Demo
{
using System;
using System.Collections.Generic;
using System.Windows.Forms;
using DOALibrary.Demo;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}
namespace DOALibrary.Demo
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;
	using DOALibrary;
	public partial class Form1 : Form
	{
		public Form1()
		{
			InitializeComponent();
			propertyGrid1.SelectedObject = doaTransparentLabel1;
		}

	}
}
namespace DOALibrary.Demo
{
	using System.Drawing;	
	partial class Form1
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Form1));
			this.panel1 = new System.Windows.Forms.Panel();
			this.doaTransparentLabel1 = new DOALibrary.DOATransparentLabel();
			this.propertyGrid1 = new System.Windows.Forms.PropertyGrid();
			this.panel1.SuspendLayout();
			this.SuspendLayout();
			// 
			// panel1
			// 
			this.panel1.BackgroundImage = new Bitmap(@"C:\Documents and Settings\v-xiyu\桌面\DOATransparentLabel.20071213\Windows Form Transparent Label\10201.jpg" , true);
//((System.Drawing.Image)(resources.GetObject("panel1.BackgroundImage")));
			this.panel1.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;
			this.panel1.Controls.Add(this.doaTransparentLabel1);
			this.panel1.Location = new System.Drawing.Point(0, 1);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(391, 272);
			this.panel1.TabIndex = 1;
			// 
			// doaTransparentLabel1
			// 
			this.doaTransparentLabel1.BackColor = System.Drawing.Color.OliveDrab;
			this.doaTransparentLabel1.Caption = "My Lotus Car";
			this.doaTransparentLabel1.DimmedColor = System.Drawing.Color.Red;
			this.doaTransparentLabel1.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
			this.doaTransparentLabel1.ForeColor = System.Drawing.SystemColors.ControlText;
			this.doaTransparentLabel1.Location = new System.Drawing.Point(110, 199);
			this.doaTransparentLabel1.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
			this.doaTransparentLabel1.Moving = DOALibrary.DOATransparentLabel.MoveType.DownToUp;
			this.doaTransparentLabel1.MovingActive = false;
			this.doaTransparentLabel1.Name = "doaTransparentLabel1";
			this.doaTransparentLabel1.Radius = 10;
			this.doaTransparentLabel1.ShapeBorderStyle = DOALibrary.DOATransparentLabel.ShapeBorderStyles.ShapeBSFixedSingle;
			this.doaTransparentLabel1.Size = new System.Drawing.Size(171, 54);
			this.doaTransparentLabel1.TabIndex = 0;

			// 
			// propertyGrid1
			// 
			this.propertyGrid1.Dock = System.Windows.Forms.DockStyle.Right;
			this.propertyGrid1.Location = new System.Drawing.Point(388, 0);
			this.propertyGrid1.Name = "propertyGrid1";
			this.propertyGrid1.Size = new System.Drawing.Size(281, 266);
			this.propertyGrid1.TabIndex = 2;
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(669, 266);
			this.Controls.Add(this.propertyGrid1);
			this.Controls.Add(this.panel1);
			this.Name = "Form1";
			this.Text = "Transparent/Translucent Label";
			this.panel1.ResumeLayout(false);
			this.ResumeLayout(false);

		}

		#endregion

		private DOALibrary.DOATransparentLabel doaTransparentLabel1;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.PropertyGrid propertyGrid1;
	}
}



namespace DOALibrary
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Drawing;
	using System.Drawing.Drawing2D;
	using System.Data;
	using System.Text;
	using System.Windows.Forms;

	public partial class DOATransparentLabel : UserControl
	// A Label that can be translucent to the background
	{
		#region Local Variables

		public enum ShapeBorderStyles
		{
			ShapeBSNone,
			ShapeBSFixedSingle,
		};

		private ShapeBorderStyles _borderStyle = ShapeBorderStyles.ShapeBSNone;
		private System.Drawing.Color _backColor = Color.Black;
		private System.Drawing.Color _borderColor = Color.White;
		private int _radius = 20;
		private int _opacity = 125;
		private string _text = "doaTransparentLabel";
		
		//  Local Variables for text
		public enum TextAlignment
		{
			Left,
			Center,
			Right
		};

		public enum MoveType
		{
			None,
			RightToLeft,
			DownToUp,
			LeftToRight,
			UpToDown
		}

		protected TextAlignment _textAlign = TextAlignment.Center;
		protected MoveType _moving = MoveType.None;
		protected bool _isSelected = false;
		private System.Drawing.Color _dimmedColor = Color.LightGray;

		// Work Variables
		protected int pointX = 0;
		protected int pointY = 0;
		protected Rectangle iRect = new Rectangle();
		protected Rectangle txtRect = new Rectangle();


		#endregion

		#region Constructor
		
		private void aMouseClick(object sender, System.EventArgs e)
		{
			Console.WriteLine("hi");
		}

		
		public DOATransparentLabel()
		{
			InitializeComponent();

			this.Click += new EventHandler(aMouseClick);


			base.BackColor = Color.Transparent;
			SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer | ControlStyles.ResizeRedraw | ControlStyles.SupportsTransparentBackColor | ControlStyles.UserPaint, true);
			SetStyle(ControlStyles.Opaque, false);
			UpdateStyles();
			this.components = new System.ComponentModel.Container();
			this.timer1 = new System.Windows.Forms.Timer(this.components);
			// 
			// timer1
			// 
			this.timer1.Enabled = false;
			this.timer1.Tick += new System.EventHandler(this.timer1_Tick);
			this.timer1.Interval = 100;
		}

		#endregion

		#region Properties

		[DefaultValue(typeof(Color), "Black")]
		public new Color BackColor
		// Gets or sets the background color of the control.
		{
			get { return _backColor; }
			set { _backColor = value; Invalidate();}
		}

		[
		Bindable(true),
		Category("Appearance"),
		DefaultValue(ShapeBorderStyles.ShapeBSNone),
		Description("Style of border to be drawn around control")
		]
		public ShapeBorderStyles ShapeBorderStyle
		{
			get { return _borderStyle; }
			set { _borderStyle = value; this.Invalidate(); }
		}

		[DefaultValue(typeof(Color), "White"), Category("Appearance"), Description("The border color of the control.")]
		/// Gets or sets the outer border color of the control.
		public Color BorderColor
		{
			get { return _borderColor; }
			set {_borderColor = value; Invalidate();}
		}

		[
		Bindable(true),
		Category("Appearance"),
		DefaultValue(125),
		Description("The alpha value used to blend the control's background. Valid values are 0 through 255.")
		]
		public int Opacity 
		{
			get { return _opacity; }
			set { _opacity = value; this.Invalidate(); }
		}


		[
		Bindable(true),
		Category("Layout"),
		DefaultValue(20),
		Description("Radius of rounded borders")
		]
		public int Radius
		{
			get { return _radius; }
			set { _radius = value; this.Invalidate(); }
		}

		[
		Bindable(true),
		Category("Appearance"),
		DefaultValue("DOATransparentLabel"),
		Description("Text in the DOATransparentLabel")
		]
		public String Caption
		{
			get { return _text; }
			set { _text = value; this.Invalidate(); }
		}

		public override Font Font
		{
			get { return base.Font; }
			set { base.Font = value; this.Invalidate(); }
		}

		public override Color ForeColor
		{
			get { return base.ForeColor; }
			set { base.ForeColor = value; this.Invalidate(); }
		}

		[
		Bindable(true),
		Category("Appearance"),
		Description("Dimmed Color"),
		]
		public Color DimmedColor
		{
			get { return _dimmedColor; }
			set { _dimmedColor = value; this.Invalidate(); }
		}

		[
		Bindable(true),
		Category("Behavior"),
		Description("Text movement"),
		DefaultValue(MoveType.None)
		]
		public MoveType Moving
		{
			get { return _moving; }
			set { _moving = value; this.Invalidate(); }
		}

		[
		Bindable(true),
		Category("Appearance"),
		Description("Text alignment (Left, Right or Center), only with Moving None"),
		DefaultValue(TextAlignment.Center)
		]
		public TextAlignment TextAlign
		{
			get { return _textAlign; }
			set { _textAlign = value; this.Invalidate(); }
		}

		[
		Bindable(true),
		Category("Behavior"),
		Description("Active the text movement"),
		DefaultValue(false)
		]
		public bool MovingActive
		{
			get { return this.timer1.Enabled; }
			set
			{
				if (value == false) _moving = MoveType.None;
				this.timer1.Enabled = value;
				this.Invalidate();
			}
		}

		#endregion

		#region Methods

		private Graphics _g;
		protected override void OnPaint(PaintEventArgs e)
		{
			SmoothingMode sm = e.Graphics.SmoothingMode;
			e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
			if (_borderStyle == ShapeBorderStyles.ShapeBSFixedSingle)
				DrawBorder(e.Graphics);
			Icon myIcon = new Icon(@"C:\Documents and Settings\v-xiyu\桌面\ObjectDock_Green.ico");
			int x = 0;
				int y = 0;
				if (_isSelected == true)
				{
					x+=10;
					y+=10;
				}
			System.Drawing.Rectangle newRectangle = new Rectangle(new Point(x, y), myIcon.Size);

			_g = e.Graphics ;
			_g.DrawIcon(myIcon, newRectangle);

			DrawLabelBackground(e.Graphics);
			DrawText(e);
			e.Graphics.SmoothingMode = sm;
			Console.WriteLine("dr");
		}

		private void DrawBorder(Graphics g)
		{
			Rectangle rect = this.ClientRectangle;
			rect.Width--;
			rect.Height--;
			using (GraphicsPath bp = GetPath(rect, _radius))
			{
				using (Pen p = new Pen(_borderColor))
				{
					g.DrawPath(p, bp);
				}
			}
		}

		private void DrawLabelBackground(Graphics g)   
		{
			Rectangle rect = this.ClientRectangle;
			iRect = rect;
			rect.X++;
			rect.Y++;
			rect.Width -= 2;
			rect.Height -= 2;
			using (GraphicsPath bb = GetPath(rect, _radius))
			{
				using (Brush br = new SolidBrush(Color.FromArgb(_opacity, _backColor)))
				{
					g.FillPath(br, bb);
				}
			}
		}

		protected GraphicsPath GetPath(Rectangle rc, int r)
		//  Build the path with the round corners in the rectangle
		//  r is the radious of rounded corner.
		{
			int x = rc.X, y = rc.Y, w = rc.Width, h = rc.Height;
			r = r << 1;
			GraphicsPath path = new GraphicsPath();
			if (r > 0)
			//  If the radious of rounded corner is greater than one side then
			//  do the side rounded
			{
				if (r > h) { r = h; };							  //Rounded
				if (r > w) { r = w; };							  //Rounded
				path.AddArc(x, y, r, r, 180, 90);					//Upper left corner
				path.AddArc(x + w - r, y, r, r, 270, 90);			//Upper right corner
				path.AddArc(x + w - r, y + h - r, r, r, 0, 90);		//Lower right corner
				path.AddArc(x, y + h - r, r, r, 90, 90);			//Lower left corner
				path.CloseFigure();
			}
			else
			//  If the radious of rounded corner is zero then the path is a rectangle
			{
				path.AddRectangle(rc);
			}

			return path;
		}


		protected void DrawText(PaintEventArgs pe)
		{
			//This is a workaround to get MeasureString to work properly
			//pe.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;
			SizeF sz = pe.Graphics.MeasureString(_text, base.Font);
			switch (_moving)
			{
				case MoveType.None:
					NoMove();
					break;
				case MoveType.RightToLeft:
					MoveRightToLeft();
					break;
				case MoveType.DownToUp:
					MoveDownToUp();
					break;
				case MoveType.LeftToRight:
					MoveLeftToRight();
					break;
				case MoveType.UpToDown:
					MoveUpToDown();
					break;
			}
			//Rectangle bounds for the text
			txtRect = new Rectangle(this.pointX, this.pointY,
									(int)sz.Width + 1, (int)sz.Height);

			//If the mouse is passing over the text it is selected and will be dimmed
			//otherwise nothing.
			Brush brText = new SolidBrush(base.ForeColor);
			Brush brTextDimmed = new SolidBrush(_dimmedColor);
			if (_isSelected)
				pe.Graphics.DrawString(_text,
					base.Font,
					brTextDimmed,
					txtRect);
			else
				pe.Graphics.DrawString(_text,
					base.Font,
					brText,
					txtRect);
		}

		protected void NoMove()
		{
			//Align text
			switch (_textAlign)
			{
				case TextAlignment.Left:
					pointX = (int)this.iRect.X;
					break;
				case TextAlignment.Center:
					pointX = (this.iRect.Width - this.txtRect.Width) / 2;
					break;
				case TextAlignment.Right:
					pointX = (this.iRect.Width - this.txtRect.Width);
					break;
			}
			pointY = (this.iRect.Height - this.txtRect.Height) / 2;
		}

		protected void MoveRightToLeft()
		{
			if (pointX < -this.txtRect.Width)
			{ pointX = this.iRect.X + this.iRect.Width; }
			else
			{ pointX -= 2; }
			pointY = (this.iRect.Height - this.txtRect.Height) / 2;
		}

		protected void MoveDownToUp()
		{
			pointX = (this.iRect.Width - this.txtRect.Width) / 2;
			if (pointY < -this.txtRect.Height)
			{ pointY = (int)this.iRect.Y + this.iRect.Height; }
			else
			{ pointY -= 2; }
		}

		protected void MoveLeftToRight()
		{
			if (pointX > this.iRect.X + this.iRect.Width)
			{ pointX = this.iRect.X - this.txtRect.Width; }
			else
			{ pointX += 2; }
			pointY = (this.iRect.Height - this.txtRect.Height) / 2;
		}

		protected void MoveUpToDown()
		{
			pointX = (this.iRect.Width - this.txtRect.Width) / 2;
			if (pointY > this.iRect.Y + this.iRect.Height)
			{ pointY = (int)this.iRect.Y - this.iRect.Height; }
			else
			{ pointY += 2; }
		}

		protected override void OnMouseEnter(EventArgs e)
		{
			base.OnMouseEnter(e);
			_isSelected = true;
			this.Invalidate();
		}

		protected override void OnMouseLeave(EventArgs e)
		{
			base.OnMouseLeave(e);
			_isSelected = false;
			this.Invalidate();
		}

		private void timer1_Tick(object sender, System.EventArgs e)
		{
			this.Invalidate();
			this.Update();
		}
	}

		#endregion
}
namespace DOALibrary
{
	partial class DOATransparentLabel
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Component Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.timer1 = new System.Windows.Forms.Timer(this.components);
			this.SuspendLayout();
			// 
			// DOATransparentLabel
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.Name = "DOATransparentLabel";
			this.Size = new System.Drawing.Size(276, 106);
			this.ResumeLayout(false);

		}

		#endregion

		private System.Windows.Forms.Timer timer1;
	}
}

#T=透明控件 Transparent Control
namespace TranspControl_Test
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}
namespace TranspControl
{
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.ComponentModel.Design;
	using System.Drawing;
	using System.Windows.Forms;
	using System.Windows.Forms.Design;
	[Designer(typeof(TranspControlDesigner))]
	public class TranspControl:Control
	{
		public bool drag = false;
		public bool enab = false;
		private Color fillColor = Color.White;
		private int opacity = 100;
		private int alpha;
		
		public TranspControl()
		{
			SetStyle(ControlStyles.SupportsTransparentBackColor, true);
			SetStyle(ControlStyles.Opaque, true);
			this.BackColor = Color.Transparent;
		}
		
		public Color FillColor
		{
			get
			{
				return this.fillColor;
			}
			set
			{
				this.fillColor = value;
				if (this.Parent != null) Parent.Invalidate(this.Bounds, true);
			}
		}
		
		public int Opacity
		{
			get
			{
				if (opacity > 100) {opacity = 100;}
				else if (opacity < 1) {opacity = 1;}
				return this.opacity;
			}
			set
			{
				this.opacity = value;
				if (this.Parent != null) Parent.Invalidate(this.Bounds, true);
			}
		}
		
		protected override CreateParams CreateParams
		{
			get
			{
				CreateParams cp = base.CreateParams;
				cp.ExStyle |= 0x20;
				return cp;
			}
		}
		
		protected override void OnPaint(PaintEventArgs e)
		{	   
			Graphics g = e.Graphics;
			Rectangle bounds = new Rectangle(0, 0, this.Width-1, this.Height-1);

			Color frmColor = this.Parent.BackColor;
			Brush brushColor;
			Brush bckColor; 

			alpha = (opacity * 255) / 100;

			if (drag)
			{
				Color dragFillColor;
				Color dragBckColor;

				if (BackColor != Color.Transparent)
				{
					int Rb = BackColor.R * alpha / 255 + frmColor.R * (255 - alpha) / 255;
					int Gb = BackColor.G * alpha / 255 + frmColor.G * (255 - alpha) / 255;
					int Bb = BackColor.B * alpha / 255 + frmColor.B * (255 - alpha) / 255;
					dragBckColor = Color.FromArgb(Rb, Gb, Bb);
				}
				else dragBckColor = frmColor;

				if (fillColor != Color.Transparent)
				{
					int Rf = fillColor.R * alpha / 255 + frmColor.R * (255 - alpha) / 255;
					int Gf = fillColor.G * alpha / 255 + frmColor.G * (255 - alpha) / 255;
					int Bf = fillColor.B * alpha / 255 + frmColor.B * (255 - alpha) / 255;
					dragFillColor = Color.FromArgb(Rf, Gf, Bf);
				}
				else dragFillColor = dragBckColor;

				alpha = 255;
				brushColor = new SolidBrush(Color.FromArgb(alpha, dragFillColor));
				bckColor = new SolidBrush(Color.FromArgb(alpha, dragBckColor));				
			}
			else
			{
				Color color = fillColor;			 
				brushColor = new SolidBrush(Color.FromArgb(alpha, color));
				bckColor = new SolidBrush(Color.FromArgb(alpha, this.BackColor));
			}

			Pen pen = new Pen(this.ForeColor);

			if (this.BackColor != Color.Transparent | drag)
			{			   
				g.FillRectangle(bckColor, bounds);
			}

			if (FillColor != Color.Transparent | drag)
			{
				g.FillEllipse(brushColor, bounds);
			}
			else g.FillEllipse(new SolidBrush(Color.FromArgb(1, Color.White)), bounds);
			 
			g.DrawEllipse(pen, bounds);
	  
			pen.Dispose();
			brushColor.Dispose();
			bckColor.Dispose();
			g.Dispose();
			base.OnPaint(e);
		}

		protected override void OnBackColorChanged(EventArgs e)
		{
			if (this.Parent != null) Parent.Invalidate(this.Bounds, true);
			base.OnBackColorChanged(e);		 
		}

		protected override void OnParentBackColorChanged(EventArgs e)
		{
			this.Invalidate();
			base.OnParentBackColorChanged(e);
		}
	}

	internal class TranspControlDesigner : ControlDesigner
	{
		private TranspControl myControl;

		protected override void OnMouseDragMove(int x, int y)
		{
			myControl = (TranspControl)(this.Control);
			myControl.drag = true;
			base.OnMouseDragMove(x, y);
		}
	  
		protected override void OnMouseLeave()
		{
			myControl = (TranspControl)(this.Control);
			myControl.drag = false;
			base.OnMouseLeave();
		}
	}

}

#T=图片旋转
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Drawing;
	using System.Drawing.Imaging;
	public class ImageRotation
	{
		public Bitmap DoImageRotationCertainAngle(double angle, string path)
		{
			Bitmap source = GetImage2Bitmap(path);
			return DoImageRotationCertainAngle(angle, source);
		}
		public Bitmap DoImageRotationCertainAngle(double angle, Bitmap source)
		{
			int iw = 0, ih = 0;
			int sW = 0, sH = 0;
			int nW = 0, nH = 0;
			int rposH = 0, rposW = 0;
			int i = 0, cur = 0, pos = 0;
			double CH = 0.0, CW = 0.0;
			int[] validKey = new int[9];
			int[] validValue = new int[9];
			double correct = 0.5;
			double sinA = 0.0, cosA = 0.0;
			while (angle < 0) { angle += 360; }
			angle %= 360;
			if (angle > 180) { angle = angle - 360; }
			double radian = TranslateAngleToRadian(angle);
			sinA = Math.Sin(radian);
			cosA = Math.Cos(radian);
			sW = source.Width;
			sH = source.Height;
			nW = Convert.ToInt32(correct + Math.Abs(sH * sinA) + Math.Abs(sW * cosA));
			nH = Convert.ToInt32(correct + Math.Abs(sH * cosA) + Math.Abs(sW * sinA));
			CH = 0.5 * (nH - sH * cosA - sW * sinA);
			CW = 0.5 * (nW + sH * sinA - sW * cosA);
			while (nW % 4 != 0) { ++nW; }
			Bitmap destin = new Bitmap(nW, nH);
			BitmapData sourceData = source.LockBits(new Rectangle(0, 0, sW, sH), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
			BitmapData destinData = destin.LockBits(new Rectangle(0, 0, nW, nH), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
			unsafe
			{
				byte* sourcePtr = (byte*)sourceData.Scan0;
				byte* destinPtr = (byte*)destinData.Scan0;
				for (ih = 0; ih < nH; ++ih)
				{
					for (iw = 0; iw < nW; ++iw)
					{
						cur = ih * destinData.Stride + iw * 3;
						for (i = 0; i < 3; ++i)
						{
							destinPtr[cur + i] = 255;
						}
					}
				}
				for (ih = 0; ih < sH; ++ih)
				{
					for (iw = 0; iw < sW; ++iw)
					{
						cur = 0;
						pos = 0;
						rposH = Convert.ToInt32(iw * sinA + ih * cosA + CH);
						rposW = Convert.ToInt32(iw * cosA - ih * sinA + CW);
						cur = rposH * destinData.Stride + rposW * 3;
						pos = ih * sourceData.Stride + iw * 3;
						for (i = 0; i < 3; ++i)
						{
							destinPtr[cur + i] = sourcePtr[pos + i];
						}
					}
				}
				source.UnlockBits(sourceData);
				destin.UnlockBits(destinData);
			}
			GC.Collect(2);
			return destin;
		}
		public Bitmap GetImage2Bitmap(string path)
		{
			if (!File.Exists(path))
			{
				throw new Exception("File is not exist.");
			}
			Bitmap source = new Bitmap(path);
			return source;
		}
		public double TranslateAngleToRadian(double angle)
		{
			return Math.PI * angle / 180.0;
		}
	}
}
namespace Microshaoft
{
	using System;
	using System.IO;
	using System.Drawing;
	using System.Drawing.Imaging;
	public class ImageRotation2
	{
		public Bitmap DoImageRotationCertainAngle(double angle, string path)
		{
			Bitmap source = GetImage2Bitmap(path);
			return DoImageRotationCertainAngle(angle, source);
		}
		public Bitmap DoImageRotationCertainAngle(double angle, Bitmap source)
		{
			int iw = 0, ih = 0;
			int sW = 0, sH = 0;
			int nW = 0, nH = 0;
			int rposH = 0, rposW = 0;
			int i = 0, m = 0, n = 0;
			int tR = 0, tG = 0, tB = 0;
			int cur = 0, pos = 0, mask = 255;
			double CH = 0.0, CW = 0.0;
			int[] validKey = new int[9];
			int[] validValue = new int[9];
			double correct = 0.5;
			double sinA = 0.0, cosA = 0.0;
			while (angle < 0) { angle += 360; }
			angle %= 360;
			if (angle > 180) { angle = angle - 360; }
			double radian = TranslateAngleToRadian(angle);
			sinA = Math.Sin(radian);
			cosA = Math.Cos(radian);
			sW = source.Width;
			sH = source.Height;
			nW = Convert.ToInt32(correct + Math.Abs(sH * sinA) + Math.Abs(sW * cosA));
			nH = Convert.ToInt32(correct + Math.Abs(sH * cosA) + Math.Abs(sW * sinA));
			CH = 0.5 * (sH - nH * cosA + nW * sinA);
			CW = 0.5 * (sW - nH * sinA - nW * cosA);
			while (nW % 4 != 0) { ++nW; }
			Bitmap destin = new Bitmap(nW, nH);
			BitmapData sourceData = source.LockBits(new Rectangle(0, 0, sW, sH), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
			BitmapData destinData = destin.LockBits(new Rectangle(0, 0, nW, nH), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
			unsafe
			{
				byte* sourcePtr = (byte*)sourceData.Scan0;
				byte* destinPtr = (byte*)destinData.Scan0;
				for (ih = 0; ih < nH; ++ih)
				{
					for (iw = 0; iw < nW; ++iw)
					{
						cur = 0;
						pos = 0;
						rposH = Convert.ToInt32(ih * cosA - iw * sinA + CH);
						rposW = Convert.ToInt32(ih * sinA + iw * cosA + CW);
						for (i = 0; i < 9; validKey[i] = validValue[i] = -1, ++i) ;
						for (m = rposH - 1; m <= rposH + 1; ++m)
						{
							if (m >= 0 && m < sH)
							{
								for (n = rposW - 1; n <= rposW + 1; ++n)
								{
									if (n >= 0 && n < sW)
									{
										cur = m * sourceData.Stride + n * 3;
										tR = sourcePtr[cur + 0];
										tG = sourcePtr[cur + 1];
										tB = sourcePtr[cur + 2];
										cur = (tR << 16) | (tG << 8) | tB;
										for (i = 0; i < 9; ++i)
										{
											if (validKey[i] == cur)
											{
												validValue[i] += 1;
												break;
											}
										}
										if (i == 9)
										{
											validKey[pos] = cur;
											validValue[pos] = 1;
											pos += 1;
										}
									}
								}
							}
						}
						cur = 0;
						m = 16777215;
						for (i = 0; i < pos; ++i)
						{
							if (validValue[i] > cur)
							{
								m = validKey[i];
								cur = validValue[i];
							}
						}
						cur = ih * destinData.Stride + iw * 3;
						destinPtr[cur + 0] = (byte)(m >> 16);
						destinPtr[cur + 1] = (byte)((m >> 8) & mask);
						destinPtr[cur + 2] = (byte)(m & mask);
					}
				}
				source.UnlockBits(sourceData);
				destin.UnlockBits(destinData);
			}
			GC.Collect(2);
			return destin;
		}
		public Bitmap GetImage2Bitmap(string path)
		{
			if (!File.Exists(path))
			{
				throw new Exception("File is not exist.");
			}
			Bitmap source = new Bitmap(path);
			return source;
		}
		public double TranslateAngleToRadian(double angle)
		{
			return Math.PI * angle / 180.0;
		}
	}
}

#T=图像差异比较 Image Compare
namespace ComparerTest
{
	using System;
	using System.Collections.Generic;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());
		}
	}
}
namespace ComparerTest
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Text;
	using System.Windows.Forms;
	using System.Diagnostics;
	public partial class Form1 : Form
	{
		public Form1()
		{
			InitializeComponent();
		}
		private void 打开图像1ToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LoadImage(1);
		}
		private void 打开图像2ToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LoadImage(2);
		}
		private void LoadImage(object mdiId)
		{
			using (OpenFileDialog dialog = new OpenFileDialog())
			{
				dialog.Filter = "所有图片文件(*.bmp;*.png;*.jpg;*.jpeg)|*.bmp;*.png;*.jpg;*.jpeg";
				dialog.CheckFileExists = true;
				dialog.ShowReadOnly = false;
				if (dialog.ShowDialog() == DialogResult.OK)
				{
					Bitmap bmp = (Bitmap)Bitmap.FromFile(dialog.FileName);
					SetMdiForm(mdiId, bmp, "图片文件" + mdiId.ToString() + ":" + dialog.FileName);
				}
			}
		}
		/// <summary>
		/// 
		/// </summary>
		/// <param name="mdiId"></param>
		/// <param name="bmp"></param>
		private void SetMdiForm(object mdiId, Bitmap bmp, string title)
		{
			Form form = null;
			if (this.MdiChildren != null)
			{
				foreach (Form f in this.MdiChildren)
				{
					if (object.Equals(f.Tag, mdiId))
					{
						form = f;
						break;
					}
				}
			}
			if (form == null)
			{
				form = new Form();
				form.MdiParent = this;
				form.Size = this.Size;
				form.Tag = mdiId;
				form.AutoScroll = true;
				PictureBox pb = new PictureBox();
				pb.Size = bmp.Size;
				pb.Location = new Point(0, 0);
				form.Controls.Add(pb);
			}
			((PictureBox)form.Controls[0]).Image = bmp;
			form.Text = title;
			form.Show();
		}
		private void 比较图像ToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (this.MdiChildren != null && this.MdiChildren.Length == 2)
			{
				Bitmap bmp1 = (Bitmap)((PictureBox)this.MdiChildren[0].Controls[0]).Image;
				Bitmap bmp2 = (Bitmap)((PictureBox)this.MdiChildren[1].Controls[0]).Image;
				Stopwatch watch = new Stopwatch();
				watch.Start();
				List<Rectangle> rects = Core.ImageComparer.Compare(bmp1, bmp2);
				watch.Stop();
				if (rects.Count != 0)
				{
					using (Graphics g = Graphics.FromImage(bmp1))
					{
						g.DrawRectangles(new Pen(Brushes.Blue, 1f), rects.ToArray());
						g.Save();
						this.MdiChildren[0].Refresh();
					}
					using (Graphics g = Graphics.FromImage(bmp2))
					{
						g.DrawRectangles(new Pen(Brushes.Red, 1f), rects.ToArray());
						g.Save();
						this.MdiChildren[1].Refresh();
					}
				}
				this.MdiChildren[1].Text = "比较完成,共有 " + rects.Count.ToString() + " 处不同,花费:" + watch.ElapsedMilliseconds + " ms";
			}
		}
	}
}
namespace ComparerTest
{
	partial class Form1
	{
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		/// <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要
		/// 使用代码编辑器修改此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.menuStrip1 = new System.Windows.Forms.MenuStrip();
			this.文件ToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.打开图像1ToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.打开图像2ToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripSeparator();
			this.比较图像ToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.menuStrip1.SuspendLayout();
			this.SuspendLayout();
			// 
			// menuStrip1
			// 
			this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
			this.文件ToolStripMenuItem});
			this.menuStrip1.Location = new System.Drawing.Point(0, 0);
			this.menuStrip1.Name = "menuStrip1";
			this.menuStrip1.Size = new System.Drawing.Size(580, 24);
			this.menuStrip1.TabIndex = 0;
			this.menuStrip1.Text = "menuStrip1";
			// 
			// 文件ToolStripMenuItem
			// 
			this.文件ToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
			this.打开图像1ToolStripMenuItem,
			this.打开图像2ToolStripMenuItem,
			this.toolStripMenuItem1,
			this.比较图像ToolStripMenuItem});
			this.文件ToolStripMenuItem.Name = "文件ToolStripMenuItem";
			this.文件ToolStripMenuItem.Size = new System.Drawing.Size(41, 20);
			this.文件ToolStripMenuItem.Text = "操作";
			// 
			// 打开图像1ToolStripMenuItem
			// 
			this.打开图像1ToolStripMenuItem.Name = "打开图像1ToolStripMenuItem";
			this.打开图像1ToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.打开图像1ToolStripMenuItem.Text = "装载图像1";
			this.打开图像1ToolStripMenuItem.Click += new System.EventHandler(this.打开图像1ToolStripMenuItem_Click);
			// 
			// 打开图像2ToolStripMenuItem
			// 
			this.打开图像2ToolStripMenuItem.Name = "打开图像2ToolStripMenuItem";
			this.打开图像2ToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.打开图像2ToolStripMenuItem.Text = "装载图像2";
			this.打开图像2ToolStripMenuItem.Click += new System.EventHandler(this.打开图像2ToolStripMenuItem_Click);
			// 
			// toolStripMenuItem1
			// 
			this.toolStripMenuItem1.Name = "toolStripMenuItem1";
			this.toolStripMenuItem1.Size = new System.Drawing.Size(149, 6);
			// 
			// 比较图像ToolStripMenuItem
			// 
			this.比较图像ToolStripMenuItem.Name = "比较图像ToolStripMenuItem";
			this.比较图像ToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.比较图像ToolStripMenuItem.Text = "比较图像";
			this.比较图像ToolStripMenuItem.Click += new System.EventHandler(this.比较图像ToolStripMenuItem_Click);
			// 
			// Form1
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(580, 507);
			this.Controls.Add(this.menuStrip1);
			this.IsMdiContainer = true;
			this.MainMenuStrip = this.menuStrip1;
			this.Name = "Form1";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "图像比较";
			this.menuStrip1.ResumeLayout(false);
			this.menuStrip1.PerformLayout();
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		#endregion
		private System.Windows.Forms.MenuStrip menuStrip1;
		private System.Windows.Forms.ToolStripMenuItem 文件ToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem 打开图像1ToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem 打开图像2ToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripMenuItem1;
		private System.Windows.Forms.ToolStripMenuItem 比较图像ToolStripMenuItem;
	}
}
namespace ComparerTest.Core
{
	/* ***********************************************
	 * Author		:  kingthy
	 * Email		:  kingthy@gmail.com
	 * DateTime		:  2008-06-15
	 * Description	:  图像比较.用于找出两副图片之间的差异位置
	 * License	  :  MIT license
	 * ***********************************************/
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.Runtime.InteropServices;
	/// <summary>
	/// 图像比较.用于找出两副图片之间的差异位置
	/// </summary>
	public class ImageComparer
	{
		/// <summary>
		/// 图像颜色
		/// </summary>
		[StructLayout(LayoutKind.Explicit)]
		private struct ICColor
		{
			[FieldOffset(0)]
			public byte B;
			[FieldOffset(1)]
			public byte G;
			[FieldOffset(2)]
			public byte R;
		}
		/// <summary>
		/// 按20*20大小进行分块比较两个图像.
		/// </summary>
		/// <param name="bmp1"></param>
		/// <param name="bmp2"></param>
		/// <returns></returns>
		public static List<Rectangle> Compare(Bitmap bmp1, Bitmap bmp2)
		{
			return Compare(bmp1, bmp2, new Size(20, 20));
		}
		/// <summary>
		/// 比较两个图像
		/// </summary>
		/// <param name="bmp1"></param>
		/// <param name="bmp2"></param>
		/// <param name="block"></param>
		/// <returns></returns>
		public static List<Rectangle> Compare(Bitmap bmp1, Bitmap bmp2, Size block)
		{
			List<Rectangle> rects = new List<Rectangle>();
			PixelFormat pf = PixelFormat.Format24bppRgb;
			BitmapData bd1 = bmp1.LockBits(new Rectangle(0, 0, bmp1.Width, bmp1.Height), ImageLockMode.ReadOnly, pf);
			BitmapData bd2 = bmp2.LockBits(new Rectangle(0, 0, bmp2.Width, bmp2.Height), ImageLockMode.ReadOnly, pf);
			try
			{
				unsafe
				{
					int w = 0, h = 0;
					while (h < bd1.Height && h < bd2.Height)
					{
						byte* p1 = (byte*)bd1.Scan0 + h * bd1.Stride;
						byte* p2 = (byte*)bd2.Scan0 + h * bd2.Stride;
						w = 0;
						while (w < bd1.Width && w < bd2.Width)
						{
							//按块大小进行扫描
							for (int i = 0; i < block.Width; i++)
							{
								int wi = w + i;
								if (wi >= bd1.Width || wi >= bd2.Width) break;
								for (int j = 0; j < block.Height; j++)
								{
									int hj = h + j;
									if (hj >= bd1.Height || hj >= bd2.Height) break;
									ICColor* pc1 = (ICColor*)(p1 + wi * 3 + bd1.Stride * j);
									ICColor* pc2 = (ICColor*)(p2 + wi * 3 + bd2.Stride * j);
									if (pc1->R != pc2->R || pc1->G != pc2->G || pc1->B != pc2->B)
									{
										//当前块有某个象素点颜色值不相同.也就是有差异.
										int bw = Math.Min(block.Width, bd1.Width - w);
										int bh = Math.Min(block.Height, bd1.Height - h);
										rects.Add(new Rectangle(w, h, bw, bh));
										goto E;
									}
								}
							}
						E:
							w += block.Width;
						}
						h += block.Height;
					}
				}
			}
			finally
			{
				bmp1.UnlockBits(bd1);
				bmp2.UnlockBits(bd2);
			}
			return rects;
		}
	}
}

#T=委托定向发出事件
namespace Test
{
	using System;
	using System.Collections.Generic;
	using Microshaoft;

	class EventsConsumers
	{

		static void Main(string[] args)
		{
			EventsProvider.RegisterEvent(new EventsProvider.FireEventHandler(consumers_Fire), 0);
			EventsProvider.RegisterEvent(new EventsProvider.FireEventHandler(consumer1_Fire), 1);
			EventsProvider.RegisterEvent(new EventsProvider.FireEventHandler(consumer2_Fire), 2);
			EventsProvider.RegisterEvent(new EventsProvider.FireEventHandler(consumer3_Fire), 3);
			EventsProvider.Run();
		}
		public static void consumers_Fire(int consumer, string s)
		{
			Console.WriteLine("收到广播事件 consumers_Fire: From: {0}, Receive: {1}", consumer, s);
		}
		public static void consumer1_Fire(int consumer, string s)
		{
			Console.WriteLine
						(
							"收到{0}事件 consumer1_Fire: From: {1}, Receive: {2}"
							, (consumer == 1 ? "定向" : "广播")
							, consumer
							, s
						);
		}
		public static void consumer2_Fire(int consumer, string s)
		{
			Console.WriteLine
			(
				"收到{0}事件 consumer2_Fire: From: {1}, Receive: {2}"
				, (consumer == 2 ? "定向" : "广播")
				, consumer
				, s
			);
		}
		public static void consumer3_Fire(int consumer, string s)
		{
			Console.WriteLine
						(
							"收到{0}事件 consumer3_Fire: From: {1}, Receive: {2}"
							, (consumer == 3 ? "定向" : "广播")
							, consumer
							, s
						);
		}
	}
}

namespace Microshaoft
{
	using System;
	using System.Collections.Generic;

	class EventsProvider
	{
		public delegate void FireEventHandler(int consumer,string s);
		//public static event FireEventHandler Fire;
		private static bool b = false;
		private static Dictionary<int, FireEventHandler> dictionary = new Dictionary<int, FireEventHandler>();

		public static void Run()
		{
			string s;
			while (true)
			{
				s = Console.ReadLine();
				string[] a = s.Split(':');
				ConsoleColor x = Console.ForegroundColor;
				Console.ForegroundColor = ConsoleColor.Yellow;
				RaiseEvents(Convert.ToInt32(a[0]),a[1]);
				Console.ForegroundColor = x;
				if (b)
				{
					break;
				}
			}
		}

		public static void RegisterEvent(FireEventHandler handler, int consumer)
		{
			if (!dictionary.ContainsKey(consumer))
			{
				dictionary.Add(consumer, handler);
			}
		}

		public static void UnRegisterEvent(FireEventHandler handler, int consumer)
		{
			if (dictionary.ContainsKey(consumer))
			{
				dictionary[consumer] = null;
				dictionary.Remove(consumer);
			}
		}

		private static void RaiseEvents(int consumer, string s)
		{
			//if (Fire != null)
			{
				if (consumer == 0)
				{
					//广播
					foreach(int i in dictionary.Keys)
					{
						dictionary[i](consumer, s);
					}
					if (s == "q")
					{
						b = true;
					}
				}
				else
				{
					if (dictionary.ContainsKey(consumer))
					{
						dictionary[consumer](consumer, s);
					}
				}
			}
		}
	}
}

#T=线程同步 EventWaitHandle
/*
下面的代码示例使用 SignalAndWait(WaitHandle,WaitHandle)方法重载，以允许主线程发出阻止线程的信号，然后等待直到该线程完成任务。
此示例启动五个线程，并允许它们在使用 EventResetMode.AutoReset 标志创建的 EventWaitHandle 上阻止，然后用户每次按 Enter 键时释放一个线程。随后此示例对另外五个线程排队，并使用 EventResetMode.ManualReset 标志创建的 EventWaitHandle 释放所有线程。
*/

using System;
using System.Threading;

public class Example
{
	// The EventWaitHandle used to demonstrate the difference
	// between AutoReset and ManualReset synchronization events.
	//
	private static EventWaitHandle ewh;

	// A counter to make sure all threads are started and
	// blocked before any are released. A Long is used to show
	// the use of the 64-bit Interlocked methods.
	//
	private static long threadCount = 0;

	// An AutoReset event that allows the main thread to block
	// until an exiting thread has decremented the count.
	//
	private static EventWaitHandle clearCount = 
		new EventWaitHandle(false, EventResetMode.AutoReset);

	[MTAThread]
	public static void Main()
	{
		// Create an AutoReset EventWaitHandle.
		//
		ewh = new EventWaitHandle(false, EventResetMode.AutoReset);

		// Create and start five numbered threads. Use the
		// ParameterizedThreadStart delegate, so the thread
		// number can be passed as an argument to the Start 
		// method.
		for (int i = 0; i <= 4; i++)
		{
			Thread t = new Thread(
				new ParameterizedThreadStart(ThreadProc)
			);
			t.Start(i);
		}

		// Wait until all the threads have started and blocked.
		// When multiple threads use a 64-bit value on a 32-bit
		// system, you must access the value through the
		// Interlocked class to guarantee thread safety.
		//
		while (Interlocked.Read(ref threadCount) < 5)
		{
			Thread.Sleep(500);
		}

		// Release one thread each time the user presses ENTER,
		// until all threads have been released.
		//
		while (Interlocked.Read(ref threadCount) > 0)
		{
			Console.WriteLine("Press ENTER to release a waiting thread.");
			Console.ReadLine();

			// SignalAndWait signals the EventWaitHandle, which
			// releases exactly one thread before resetting, 
			// because it was created with AutoReset mode. 
			// SignalAndWait then blocks on clearCount, to 
			// allow the signaled thread to decrement the count
			// before looping again.
			//
			WaitHandle.SignalAndWait(ewh, clearCount);
		}
		Console.WriteLine();

		// Create a ManualReset EventWaitHandle.
		//
		ewh = new EventWaitHandle(false, EventResetMode.ManualReset);

		// Create and start five more numbered threads.
		//
		for(int i=0; i<=4; i++)
		{
			Thread t = new Thread(
				new ParameterizedThreadStart(ThreadProc)
			);
			t.Start(i);
		}

		// Wait until all the threads have started and blocked.
		//
		while (Interlocked.Read(ref threadCount) < 5)
		{
			Thread.Sleep(500);
		}

		// Because the EventWaitHandle was created with
		// ManualReset mode, signaling it releases all the
		// waiting threads.
		//
		Console.WriteLine("Press ENTER to release the waiting threads.");
		Console.ReadLine();
		ewh.Set();
		
	}

	public static void ThreadProc(object data)
	{
		int index = (int) data;

		Console.WriteLine("Thread {0} blocks.", data);
		// Increment the count of blocked threads.
		Interlocked.Increment(ref threadCount);

		// Wait on the EventWaitHandle.
		ewh.WaitOne();

		Console.WriteLine("Thread {0} exits.", data);
		// Decrement the count of blocked threads.
		Interlocked.Decrement(ref threadCount);

		// After signaling ewh, the main thread blocks on
		// clearCount until the signaled thread has 
		// decremented the count. Signal it now.
		//
		clearCount.Set();
	}
}
#T=协变 逆变 委托
class Mammals
{
}

class Dogs : Mammals
{
}

class Program
{
	// Define the delegate.
	public delegate Mammals HandlerMethod(Dogs x);

	public static Mammals FirstHandler(Dogs x)
	{
		return null;
	}

	public static Dogs SecondHandler(Mammals x)
	{
		return null;
	}
	static void Main()
	{
		HandlerMethod handler1 = FirstHandler;

		// Covariance allows this delegate.
		HandlerMethod handler2 = SecondHandler;
	}
}


#T=艺术字
namespace WindowsFormsApplication1
{
	using System;
	using System.Drawing;
	using System.Drawing.Drawing2D;
	using System.Drawing.Text;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Security.Principal;

	using Microshaoft.Win32;

	static class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			bool needFreeConsole = false;
			if (args != null)
			{
				if (args.Length > 0)
				{
					if (args[0].ToLower() == "/c")
					{
						needFreeConsole = true;
						NativeMethods.AllocConsole();
						Console.WriteLine("Alloc Console ...");

						Console.WriteLine("Current User Identity: {0}", WindowsIdentity.GetCurrent().Name);
						Console.WriteLine(".Net Framework version: {0}", Environment.Version.ToString());

					}
				}
			}

			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Form1());

			if (needFreeConsole)
			{
				Console.WriteLine("Free Console ...");
				NativeMethods.FreeConsole();
			}
		}
	}
}


namespace Microshaoft.Win32
{
	using System.Runtime.InteropServices;
	public class NativeMethods
	{
		/// <summary>
		/// 启动控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool AllocConsole();
		/// <summary>
		/// 释放控制台
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		public static extern bool FreeConsole();
	}
}

namespace WindowsFormsApplication1
{
		using System;
		using System.Drawing;
		using System.Drawing.Drawing2D;
		using System.Drawing.Text;
		using System.Collections;
		using System.ComponentModel;
		using System.Windows.Forms;
		using System.Data;


	/// <summary>
	/// Form1 的摘要说明。
	/// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button button1;
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form1()
		{
			//
			// Windows 窗体设计器支持所必需的
			//
			InitializeComponent();

			//
			// TODO: 在 InitializeComponent 调用后添加任何构造函数代码
			//
		}

		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要使用代码编辑器修改
		/// 此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(96, 112);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(88, 32);
			this.button1.TabIndex = 0;
			this.button1.Text = "button1";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// Form1
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
			this.ClientSize = new System.Drawing.Size(292, 273);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.Load += new System.EventHandler(this.Form1_Load);
			this.ResumeLayout(false);

		}
		#endregion

		private void Form1_Load(object sender, System.EventArgs e)
		{
			
		}
		private void DrawArtText(string text)
		{
			//投影文字
			Graphics g = this.CreateGraphics();
			//设置文本输出质量
			g.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
			g.SmoothingMode = SmoothingMode.AntiAlias;
			Font newFont = new Font("隶书", 48);
			Matrix matrix = new Matrix();
			//投射
			matrix.Shear(-1.5f, 0.0f);
			//缩放
			matrix.Scale(1, 0.5f);
			//平移
			matrix.Translate(130, 88);
			//对绘图平面实施坐标变换、、
			g.Transform = matrix;
			SolidBrush grayBrush = new SolidBrush(Color.Gray);
			SolidBrush colorBrush = new SolidBrush(Color.BlueViolet);
			//绘制阴影
			g.DrawString(text, newFont, grayBrush, new PointF(0, 30));
			g.ResetTransform();
			//绘制前景
			g.DrawString(text, newFont, colorBrush, new PointF(0, 30));


			//浮雕文字
			Brush backBrush = Brushes.Black;
			Brush foreBrush = Brushes.White;
			Font font = new Font("宋体", Convert.ToInt16(40), FontStyle.Regular);
//			Graphics g = this.CreateGraphics();
			//string text = "博客园";
			SizeF size = g.MeasureString(text, font);
			Single posX = (this.Width - Convert.ToInt16(size.Width)) / 2;
			Single posY = (this.Height - Convert.ToInt16(size.Height)) / 2;
			g.DrawString(text, font, backBrush, posX+1, posY+1);
			g.DrawString(text, font, foreBrush, posX, posY);

			//印版效果
			int i = 0;
			backBrush = Brushes.Black;
			foreBrush = Brushes.Violet;
			font = new Font("Times New Roman", System.Convert.ToInt16(40), FontStyle.Regular);
//			Graphics g = this.CreateGraphics();
//			g.Clear(Color.White);
//			string text = "博客园";
			size = g.MeasureString(text, font);
			posX = (this.Width - Convert.ToInt16(size.Width)) / 2;
			posY = (this.Height - Convert.ToInt16(size.Height)) / 3;
			while (i < Convert.ToInt16(20))
			{
				g.DrawString(text, font, backBrush, posX - i, posY + i);
				i = i + 1;
			}
			g.DrawString(text, font, foreBrush, posX, posY);


			//倒影文字
			//Brush
			backBrush = Brushes.Gray;
			//Brush
			foreBrush = Brushes.Black;
			//Font
			font = new Font("幼圆", Convert.ToInt16(40), FontStyle.Regular);
			//Graphics g = this.CreateGraphics();
			//string text = "博客园";
			//SizeF
			size = g.MeasureString(text, font);
			//int
			posX = (this.Width - Convert.ToInt16(size.Width)) / 2 + 20;
			//int
			posY = (this.Height - Convert.ToInt16(size.Height)) / 2 + 20;
			g.TranslateTransform(posX, posY);
			int ascent = font.FontFamily.GetCellAscent(font.Style);
			int spacing = font.FontFamily.GetLineSpacing(font.Style);
			int lineHeight = System.Convert.ToInt16(font.GetHeight(g));
			int height = lineHeight * ascent / spacing;
			GraphicsState state = g.Save();
			g.ScaleTransform(1, -1.0F);
			g.DrawString(text, font, backBrush, 0, -height);
			g.Restore(state);
			g.DrawString(text, font, foreBrush, 0, -height);

			//阴影文字
			//string text = "博客园";
			Brush
			shadowBrush = Brushes.Gray;
			//Brush
			foreBrush = Brushes.Black;
			//Font
			font = new Font("幼圆", Convert.ToInt16(40), FontStyle.Regular);
			//Graphics g = this.CreateGraphics();
			//SizeF
			size = g.MeasureString(text, font);
			//Single
			posX = (this.Width - Convert.ToInt16(size.Width)) / 4;
			//Single
			posY = (this.Height - Convert.ToInt16(size.Height)) / 3;
			g.DrawString(text, font, shadowBrush, posX + Convert.ToInt16(20), posY + Convert.ToInt16(20));
			g.DrawString(text, font, foreBrush, posX, posY);

			//纹理使用图像填充文字线条
			//TextureBrush brush = new TextureBrush(Image.FromFile(Application.StartupPath + "\\myPicture.jpg"));
			//Graphics g = e.Graphics;
			//g.DrawString(text, new Font("隶书", 60), brush, new PointF(0, 0)); 

			//倾斜效果
			//Brush
			foreBrush = Brushes.Blue;
			//Font
			font = new Font("幼圆", Convert.ToInt16(40), FontStyle.Regular);
			//Graphics g = this.CreateGraphics();
			//string text = "博客园";
			//SizeF
			size = g.MeasureString(text, font);
			//Single
			posX = (this.Width - Convert.ToInt16(size.Width)) / 2;
			//Single
			posY = (this.Height - Convert.ToInt16(size.Height)) / 2;
			g.TranslateTransform(posX, posY);
			Matrix transform = g.Transform;

			//右倾斜文字
			//float shearX = -0.230F; 

			//左倾斜文字
			float shearX = 0.550F; 
			float shearY = 0.10F;
			transform.Shear(shearX, shearY);
			g.Transform = transform;
			g.DrawString(text, font, foreBrush, 0, 0);

			//渐变色文字
			Brush ShadowBrush = Brushes.Gray;
			Brush ForeBrush = Brushes.Black;
			//Font 
			font = new Font("幼圆", System.Convert.ToInt16(40), FontStyle.Regular);
			//Graphics g = this.CreateGraphics();
			//g.Clear(Color.White);
			PointF point = new PointF(0, 0);
			//SizeF
			size = g.MeasureString(text, font);
			RectangleF rectangle = new RectangleF(point, size);
			Brush brush = new LinearGradientBrush(rectangle, Color.Red, Color.Green, LinearGradientMode.Horizontal);
			int width = (this.Width - Convert.ToInt16(size.Width)) / 2;
			//int
			height = (this.Height - Convert.ToInt16(size.Height)) / 2;
			g.DrawString(text, font, brush, width, height);

			//旋转显示文字
//			Graphics g = e.Graphics;
			g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
			for (i = 0; i <= 360; i += 10)
			{ 
				//平移Graphics对象到窗体中心
				g.TranslateTransform(this.Width / 2, this.Height / 2);
				//设置Graphics对象的输出角度
				g.RotateTransform(i);
				//设置文字填充颜色
				Brush ibrush = Brushes.DarkViolet;
				//旋转显示文字
				g.DrawString(text, new Font("Lucida Console", 11f), ibrush, 0, 0);
				//恢复全局变换矩阵
				g.ResetTransform();
			}
		}

		private void button1_Click(object sender, System.EventArgs e)
		{
			Console.WriteLine("test");
			DrawArtText("Microshaoft");
		}
	}
}

#T=异步委托编程示例
namespace Examples.AdvancedProgramming.AsynchronousOperations
{
	using System;
	using System.Threading;
	using System.Runtime.Remoting.Messaging;
	// Create a class that factors a number.
	public class PrimeFactorFinder
	{
		public static bool Factorize(
					int number,
					ref int primefactor1,
					ref int primefactor2)
		{
			primefactor1 = 1;
			primefactor2 = number;

			// Factorize using a low-tech approach.
			for (int i=2;i<number;i++)
			{
				if (0 == (number % i))
				{
					primefactor1 = i;
					primefactor2 = number / i;
					break;
				}
			}
			if (1 == primefactor1 )
			{
				return false;
			}
			else
			{
				return true;
			}
		}
	}

	// Create an asynchronous delegate that matches the Factorize method.
	public delegate bool AsyncFactorCaller (
				int number, 
				ref int primefactor1,
				ref int primefactor2);

	public class DemonstrateAsyncPattern
	{
		// The waiter object used to keep the main application thread
		// from terminating before the callback method completes.
		ManualResetEvent waiter;

		// Define the method that receives a callback when the results are available.
		public void FactorizedResults(IAsyncResult result)
				{
				int factor1=0;
				int factor2=0; 

				// Extract the delegate from the 
				// System.Runtime.Remoting.Messaging.AsyncResult.
				AsyncFactorCaller factorDelegate = (AsyncFactorCaller)((AsyncResult)result).AsyncDelegate;
				int number = (int) result.AsyncState;
				// Obtain the result.
				bool answer = factorDelegate.EndInvoke(ref factor1, ref factor2, result);
				// Output the results.
				Console.WriteLine("On CallBack: Factors of {0} : {1} {2} - {3}", 
					number, factor1, factor2, answer);
				waiter.Set();
				}

			// The following method demonstrates the asynchronous pattern using a callback method.
			public void FactorizeNumberUsingCallback()
			{
			AsyncFactorCaller factorDelegate = new AsyncFactorCaller (PrimeFactorFinder.Factorize);
			int number = 1000589023;
			int temp=0; 
			// Waiter will keep the main application thread from 
			// ending before the callback completes because
			// the main thread blocks until the waiter is signaled
			// in the callback.
				waiter = new ManualResetEvent(false);

			// Define the AsyncCallback delegate.
			AsyncCallback callBack = new AsyncCallback(this.FactorizedResults);

			// Asynchronously invoke the Factorize method.
			IAsyncResult result = factorDelegate.BeginInvoke(
									number, 
									ref temp, 
									ref temp, 
									callBack, 
									number); 

			// Do some other useful work while 
			// waiting for the asynchronous operation to complete.

			// When no more work can be done, wait.
			waiter.WaitOne();
			}

			// The following method demonstrates the asynchronous pattern 
			// using a BeginInvoke, followed by waiting with a time-out.
			public void FactorizeNumberAndWait()
			{
			AsyncFactorCaller factorDelegate = new AsyncFactorCaller (PrimeFactorFinder.Factorize);

			int number = 1000589023;
			int temp=0; 

			// Asynchronously invoke the Factorize method.
			IAsyncResult result = factorDelegate.BeginInvoke(
							number, 
							ref temp, 
							ref temp, 
							null, 
							null); 

			while (!result.IsCompleted)
			{
			// Do any work you can do before waiting.
			result.AsyncWaitHandle.WaitOne(10000, false);
			}
			// The asynchronous operation has completed.
			int factor1=0;
			int factor2=0; 

			// Obtain the result.
			bool answer = factorDelegate.EndInvoke(ref factor1, ref factor2, result);

			// Output the results.
			Console.WriteLine("Sequential : Factors of {0} : {1} {2} - {3}", 
								number, factor1, factor2, answer);
			}

			public static void Main()
			{
				DemonstrateAsyncPattern demonstrator = new DemonstrateAsyncPattern();
				demonstrator.FactorizeNumberUsingCallback();
				demonstrator.FactorizeNumberAndWait();
			}
	}
}
#T=运算符重载 简单样例: 版本大小比较
namespace Test
{
	using System;
	using Microshaoft;
	public class Class1
	{
		static void Main(string[] args)
		{
			Console.WriteLine("第一个\".\"和第二个\".\"之间的数字按小数比较,其他按整数比较");
			StringVersion v1 = new StringVersion("12.0390.001");
			StringVersion v2 = new StringVersion("21.039000.1");
			Console.WriteLine("版本: [{0}][{1}] ", v1.ToString(), v2.ToString());
			Console.WriteLine("GetHashCode: [{0}][{1}] ", v1.GetHashCode(), v2.GetHashCode());
			Console.WriteLine("Equals , {0} ", v1.Equals(v2));
			Console.WriteLine("== , {0} ", v1 == v2);
			Console.WriteLine("!= , {0} ", v1 != v2);
			Console.WriteLine("> , {0} ", v1 > v2);
			Console.WriteLine("< , {0} ", v1 < v2);
			Console.WriteLine(">= , {0} ", v1 >= v2);
			Console.WriteLine("<= , {0} ", v1 <= v2);
			Console.WriteLine(Environment.Version.ToString());
		}
	}
}
namespace Microshaoft
{
	using System;
	public class StringVersion
	{
		private string[] _versions;
		private string _version;
		protected string[] Versions
		{
			get
			{
				return _versions;
			}
		}
		public StringVersion(string version)
		{
			_version = version;
			char[] c = new char[]{'.'};
			_versions = version.Split(c);
		}
		public override string ToString()
		{
			return _version;
		}
		public override bool Equals(object o)
		{
			StringVersion x = this;
			StringVersion y = o as StringVersion;
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd != yd)
					{
						return false;
					}
				}
				else
				{
					if (xi != yi)
					{
						return false;
					}
				}
			}
			return true;
		}
		public override int GetHashCode()
		{
			string[] a = new string[_versions.Length];
			Array.Copy(_versions, 0, a, 0, a.Length);
			for(int i = 0; i < _versions.Length; i ++)
			{
				if (i == 1)
				{
					a[i] = _versions[i].TrimEnd('0');
				}
				else
				{
					a[i] = _versions[i].TrimStart('0');
				}
			}
			string s = string.Join(".", a);
			return s.GetHashCode();
		}
		public static bool operator == (StringVersion x, StringVersion y)
		{
			return x.Equals(y);
		}
		public static bool operator != (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd != yd)
					{
						return true;
					}
				}
				else
				{
					if (xi != yi)
					{
						return true;
					}
				}
			}
			return false;
		}
		public static bool operator > (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd > yd)
					{
						return true;
					}
					else if (xd < yd)
					{
						return false;
					}
				}
				else
				{
					if (xi > yi)
					{
						return true;
					}
					else if (xi < yi)
					{
						return false;
					}
				}
			}
			return false;
		}
		public static bool operator < (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd < yd)
					{
						return true;
					}
					else if (xd > yd)
					{
						return false;
					}
				}
				else
				{
					if (xi < yi)
					{
						return true;
					}
					else if (xi > yi)
					{
						return false;
					}
				}
			}
			return false;
		}
		public static bool operator >= (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			bool equal = true;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd > yd)
					{
						return true;
					}
					else if (xd < yd)
					{
						return false;
					}
					equal = equal && (xd == yd);
				}
				else
				{
					if (xi > yi)
					{
						return true;
					}
					else if (xi < yi)
					{
						return false;
					}
					equal = equal && (xi == yi);
				}
			}
			return equal;
		}
		public static bool operator <= (StringVersion x, StringVersion y)
		{
			int xl = x.Versions.Length;
			int yl = y.Versions.Length;
			bool equal = true;
			for (int i = 0; i < xl || i < yl; i ++)
			{
				uint xi = 0;
				uint yi = 0;
				double xd = 0.0d;
				double yd = 0.0d;
				if (i < xl)
				{
					if (i != 1)
					{
						uint.TryParse(x.Versions[i], out xi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", x.Versions[i])
										, out xd
									);
					}
				}
				if (i < yl)
				{
					if (i != 1)
					{
						uint.TryParse(y.Versions[i], out yi);
					}
					else
					{
						double.TryParse
									(
										string.Format("0.{0}", y.Versions[i])
										, out yd
									);
					}
				}
				if (i == 1)
				{
					if (xd < yd)
					{
						return true;
					}
					else if (xd > yd)
					{
						return false;
					}
					equal = equal && (xd == yd);
				}
				else
				{
					if (xi < yi)
					{
						return true;
					}
					else if (xi > yi)
					{
						return false;
					}
					equal = equal && (xi == yi);
				}
			}
			return equal;
		}
	}
}

#T=正文提取 html
//http://www.cnblogs.com/jasondan/p/3497757.html
namespace Demo
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Windows.Forms;
	static class Program
	{
		/// <summary>
		/// 应用程序的主入口点。
		/// </summary>
		[STAThread]
		static void Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new FrmMain());
		}
	}
}
namespace Demo
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Data;
	using System.Drawing;
	using System.Linq;
	using System.Text;
	using System.Windows.Forms;
	using System.IO;
	using System.Diagnostics;
	using StanSoft;
	public partial class FrmMain : Form
	{
		public FrmMain()
		{
			InitializeComponent();
		}
		private void btnOk_Click(object sender, EventArgs e)
		{
			if (String.IsNullOrEmpty(this.urlTextBox.Text))
			{
				MessageBox.Show("请输入网址!");
				return;
			}
			// 保存用户输入的Url,和追加模式设置
			//Properties.Settings.Default.Save();
			this.webBrowser.Navigate(this.urlTextBox.Text);
			this.webBrowser.DocumentCompleted += webBrowser_DocumentCompleted;
			SetDownloadState();
		}
		private void webBrowser_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)
		{
			if (e.Url != this.webBrowser.Document.Url)
			{
				return;
			}
			string encode = this.webBrowser.Document.Encoding;
			StreamReader sr = new StreamReader(this.webBrowser.DocumentStream, Encoding.GetEncoding(encode));
			string html = sr.ReadToEnd();
			//Html2Article.LimitCount = 100;
			//Html2Article.Depth = 8;
			// 设置是否使用正文追加模式
			Html2Article.AppendMode = this.appendCheckBox.CheckState == CheckState.Checked;
			Stopwatch sw = new Stopwatch();
			sw.Start();
			// 将Html解析为Article结构化数据
			Article article = Html2Article.GetArticle(html);
			sw.Stop();
			msgLabel.Text = "提取耗时：" + Environment.NewLine + sw.ElapsedMilliseconds + "毫秒";
			this.publishDateTextBox.Text = article.PublishDate.ToString();
			this.titleTextBox.Text = article.Title;
			this.contentTextBox.Text = article.Content;
			string articleHtml = UrlUtility.FixUrl(this.urlTextBox.Text, article.ContentWithTags);
			this.contentWebBrowser.DocumentText = articleHtml;
			ResetState();
		}
		private void SetDownloadState()
		{
			this.btnOk.Text = "下载中...";
			this.btnOk.Enabled = false;
			this.publishDateTextBox.Text = "";
			this.titleTextBox.Text = "";
			this.contentTextBox.Text = "";
			this.msgLabel.Text = "";
		}
		private void ResetState()
		{
			this.btnOk.Text = "提取正文";
			this.btnOk.Enabled = true;
		}
	}
}
namespace Demo
{
	partial class FrmMain
	{
		/// <summary>
		/// 必需的设计器变量。
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// 清理所有正在使用的资源。
		/// </summary>
		/// <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows 窗体设计器生成的代码
		/// <summary>
		/// 设计器支持所需的方法 - 不要
		/// 使用代码编辑器修改此方法的内容。
		/// </summary>
		private void InitializeComponent()
		{
			System.Windows.Forms.Label contentLabel;
			System.Windows.Forms.Label publishDateLabel;
			System.Windows.Forms.Label titleLabel;
			System.Windows.Forms.Label label1;
			this.btnOk = new System.Windows.Forms.Button();
			this.contentTextBox = new System.Windows.Forms.TextBox();
			this.titleTextBox = new System.Windows.Forms.TextBox();
			this.publishDateTextBox = new System.Windows.Forms.TextBox();
			this.webBrowser = new System.Windows.Forms.WebBrowser();
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.tabPage3 = new System.Windows.Forms.TabPage();
			this.contentWebBrowser = new System.Windows.Forms.WebBrowser();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.msgLabel = new System.Windows.Forms.Label();
			this.appendCheckBox = new System.Windows.Forms.CheckBox();
			this.urlTextBox = new System.Windows.Forms.TextBox();
			contentLabel = new System.Windows.Forms.Label();
			publishDateLabel = new System.Windows.Forms.Label();
			titleLabel = new System.Windows.Forms.Label();
			label1 = new System.Windows.Forms.Label();
			this.tabControl1.SuspendLayout();
			this.tabPage1.SuspendLayout();
			this.tabPage3.SuspendLayout();
			this.tabPage2.SuspendLayout();
			this.SuspendLayout();
			// 
			// contentLabel
			// 
			contentLabel.AutoSize = true;
			contentLabel.Location = new System.Drawing.Point(12, 113);
			contentLabel.Name = "contentLabel";
			contentLabel.Size = new System.Drawing.Size(59, 12);
			contentLabel.TabIndex = 6;
			contentLabel.Text = "正文内容:";
			// 
			// publishDateLabel
			// 
			publishDateLabel.AutoSize = true;
			publishDateLabel.Location = new System.Drawing.Point(12, 57);
			publishDateLabel.Name = "publishDateLabel";
			publishDateLabel.Size = new System.Drawing.Size(59, 12);
			publishDateLabel.TabIndex = 8;
			publishDateLabel.Text = "发布日期:";
			// 
			// titleLabel
			// 
			titleLabel.AutoSize = true;
			titleLabel.Location = new System.Drawing.Point(12, 86);
			titleLabel.Name = "titleLabel";
			titleLabel.Size = new System.Drawing.Size(35, 12);
			titleLabel.TabIndex = 10;
			titleLabel.Text = "标题:";
			// 
			// label1
			// 
			label1.AutoSize = true;
			label1.Location = new System.Drawing.Point(12, 30);
			label1.Name = "label1";
			label1.Size = new System.Drawing.Size(35, 12);
			label1.TabIndex = 8;
			label1.Text = "网址:";
			// 
			// btnOk
			// 
			this.btnOk.Location = new System.Drawing.Point(672, 25);
			this.btnOk.Name = "btnOk";
			this.btnOk.Size = new System.Drawing.Size(75, 23);
			this.btnOk.TabIndex = 1;
			this.btnOk.Text = "提取正文";
			this.btnOk.UseVisualStyleBackColor = true;
			this.btnOk.Click += new System.EventHandler(this.btnOk_Click);
			// 
			// contentTextBox
			// 
			this.contentTextBox.BackColor = System.Drawing.Color.White;
			this.contentTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
			this.contentTextBox.Location = new System.Drawing.Point(3, 3);
			this.contentTextBox.Multiline = true;
			this.contentTextBox.Name = "contentTextBox";
			this.contentTextBox.ReadOnly = true;
			this.contentTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
			this.contentTextBox.Size = new System.Drawing.Size(632, 366);
			this.contentTextBox.TabIndex = 7;
			// 
			// titleTextBox
			// 
			this.titleTextBox.BackColor = System.Drawing.Color.White;
			this.titleTextBox.Location = new System.Drawing.Point(101, 83);
			this.titleTextBox.Name = "titleTextBox";
			this.titleTextBox.ReadOnly = true;
			this.titleTextBox.Size = new System.Drawing.Size(565, 21);
			this.titleTextBox.TabIndex = 11;
			// 
			// publishDateTextBox
			// 
			this.publishDateTextBox.BackColor = System.Drawing.Color.White;
			this.publishDateTextBox.Location = new System.Drawing.Point(101, 54);
			this.publishDateTextBox.Name = "publishDateTextBox";
			this.publishDateTextBox.ReadOnly = true;
			this.publishDateTextBox.Size = new System.Drawing.Size(565, 21);
			this.publishDateTextBox.TabIndex = 11;
			// 
			// webBrowser
			// 
			this.webBrowser.Dock = System.Windows.Forms.DockStyle.Fill;
			this.webBrowser.Location = new System.Drawing.Point(3, 3);
			this.webBrowser.MinimumSize = new System.Drawing.Size(20, 20);
			this.webBrowser.Name = "webBrowser";
			this.webBrowser.ScriptErrorsSuppressed = true;
			this.webBrowser.Size = new System.Drawing.Size(632, 366);
			this.webBrowser.TabIndex = 12;
			// 
			// tabControl1
			// 
			this.tabControl1.Alignment = System.Windows.Forms.TabAlignment.Bottom;
			this.tabControl1.Controls.Add(this.tabPage1);
			this.tabControl1.Controls.Add(this.tabPage3);
			this.tabControl1.Controls.Add(this.tabPage2);
			this.tabControl1.Location = new System.Drawing.Point(101, 110);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(646, 398);
			this.tabControl1.TabIndex = 13;
			// 
			// tabPage1
			// 
			this.tabPage1.Controls.Add(this.contentTextBox);
			this.tabPage1.Location = new System.Drawing.Point(4, 4);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
			this.tabPage1.Size = new System.Drawing.Size(638, 372);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "正文文本";
			this.tabPage1.UseVisualStyleBackColor = true;
			// 
			// tabPage3
			// 
			this.tabPage3.Controls.Add(this.contentWebBrowser);
			this.tabPage3.Location = new System.Drawing.Point(4, 4);
			this.tabPage3.Name = "tabPage3";
			this.tabPage3.Padding = new System.Windows.Forms.Padding(3);
			this.tabPage3.Size = new System.Drawing.Size(638, 372);
			this.tabPage3.TabIndex = 2;
			this.tabPage3.Text = "带标签正文";
			this.tabPage3.UseVisualStyleBackColor = true;
			// 
			// contentWebBrowser
			// 
			this.contentWebBrowser.Dock = System.Windows.Forms.DockStyle.Fill;
			this.contentWebBrowser.Location = new System.Drawing.Point(3, 3);
			this.contentWebBrowser.MinimumSize = new System.Drawing.Size(20, 20);
			this.contentWebBrowser.Name = "contentWebBrowser";
			this.contentWebBrowser.Size = new System.Drawing.Size(632, 366);
			this.contentWebBrowser.TabIndex = 0;
			// 
			// tabPage2
			// 
			this.tabPage2.Controls.Add(this.webBrowser);
			this.tabPage2.Location = new System.Drawing.Point(4, 4);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
			this.tabPage2.Size = new System.Drawing.Size(638, 372);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "原始网页";
			this.tabPage2.UseVisualStyleBackColor = true;
			// 
			// msgLabel
			// 
			this.msgLabel.AutoSize = true;
			this.msgLabel.Location = new System.Drawing.Point(12, 478);
			this.msgLabel.Name = "msgLabel";
			this.msgLabel.Size = new System.Drawing.Size(0, 12);
			this.msgLabel.TabIndex = 15;
			// 
			// appendCheckBox
			// 
			this.appendCheckBox.AutoSize = true;
			this.appendCheckBox.Checked = true;//global::Demo.Properties.Settings.Default.appendMode;
			this.appendCheckBox.DataBindings.Add
								(
									new System.Windows.Forms.Binding
											(
												"Checked"
												, true //global::Demo.Properties.Settings.Default
												, "appendMode"
												, true
												, System.Windows.Forms.DataSourceUpdateMode.OnPropertyChanged
											)
								);
			this.appendCheckBox.Location = new System.Drawing.Point(675, 57);
			this.appendCheckBox.Name = "appendCheckBox";
			this.appendCheckBox.Size = new System.Drawing.Size(72, 16);
			this.appendCheckBox.TabIndex = 14;
			this.appendCheckBox.Text = "追加模式";
			this.appendCheckBox.UseVisualStyleBackColor = true;
			// 
			// urlTextBox
			// 
			this.urlTextBox.DataBindings.Add
					(
						new System.Windows.Forms.Binding
								(
									"Text"
									, true //global::Demo.Properties.Settings.Default
									, "url"
									, true
									, System.Windows.Forms.DataSourceUpdateMode.OnPropertyChanged
								)
					);
			this.urlTextBox.Location = new System.Drawing.Point(101, 25);
			this.urlTextBox.Name = "urlTextBox";
			this.urlTextBox.Size = new System.Drawing.Size(565, 21);
			this.urlTextBox.TabIndex = 0;
			this.urlTextBox.Text = "";//global::Demo.Properties.Settings.Default.url;
			// 
			// FrmMain
			// 
			this.AcceptButton = this.btnOk;
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(763, 520);
			this.Controls.Add(this.msgLabel);
			this.Controls.Add(this.appendCheckBox);
			this.Controls.Add(this.tabControl1);
			this.Controls.Add(contentLabel);
			this.Controls.Add(label1);
			this.Controls.Add(publishDateLabel);
			this.Controls.Add(titleLabel);
			this.Controls.Add(this.publishDateTextBox);
			this.Controls.Add(this.titleTextBox);
			this.Controls.Add(this.btnOk);
			this.Controls.Add(this.urlTextBox);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.Fixed3D;
			this.MaximizeBox = false;
			this.Name = "FrmMain";
			this.Text = "Html2Article - Author: 翟士丹 StanZhai jasondan325@163.com";
			this.tabControl1.ResumeLayout(false);
			this.tabPage1.ResumeLayout(false);
			this.tabPage1.PerformLayout();
			this.tabPage3.ResumeLayout(false);
			this.tabPage2.ResumeLayout(false);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		#endregion
		private System.Windows.Forms.TextBox urlTextBox;
		private System.Windows.Forms.Button btnOk;
		private System.Windows.Forms.TextBox contentTextBox;
		private System.Windows.Forms.TextBox titleTextBox;
		private System.Windows.Forms.TextBox publishDateTextBox;
		private System.Windows.Forms.WebBrowser webBrowser;
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.CheckBox appendCheckBox;
		private System.Windows.Forms.Label msgLabel;
		private System.Windows.Forms.TabPage tabPage3;
		private System.Windows.Forms.WebBrowser contentWebBrowser;
	}
}
namespace StanSoft
{
	// Author: StanZhai 翟士丹（jasondan325@163.com）. All rights reserved. See License.md in the project root for license information.
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Text.RegularExpressions;
	/// <summary>
	/// 文章正文数据模型
	/// </summary>
	public class Article
	{
		public string Title { get; set; }
		/// <summary>
		/// 正文文本
		/// </summary>
		public string Content { get; set; }
		/// <summary>
		/// 带标签正文
		/// </summary>
		public string ContentWithTags { get; set; }
		public DateTime PublishDate { get; set; }
	}
	/// <summary>
	/// 解析Html页面的文章正文内容,基于文本密度的HTML正文提取类
	/// Date:   2012/12/30
	/// Update: 
	///	 2013/7/10   优化文章头部分析算法，优化
	///		 
	/// </summary>
	public class Html2Article
	{
		#region 参数设置
		// 正则表达式过滤：正则表达式，要替换成的文本
		private static readonly string[][] _filters = new string[][]{
				new string[] { @"(?is)<script.*?>.*?</script>", "" },
				new string[] { @"(?is)<style.*?>.*?</style>", "" },
				// 针对链接密集型的网站的处理，主要是门户类的网站，降低链接干扰
				new string[] { @"(?is)</a>", "</a>\n"}				 
			};
		private static bool _appendMode = false;
		/// <summary>
		/// 是否使用追加模式，默认为false
		/// 使用追加模式后，会将符合过滤条件的所有文本提取出来
		/// </summary>
		public static bool AppendMode
		{
			get { return _appendMode; }
			set { _appendMode = value; }
		}
		private static int _depth = 6;
		/// <summary>
		/// 按行分析的深度，默认为6
		/// </summary>
		public static int Depth
		{
			get { return _depth; }
			set { _depth = value; }
		}
		private static int _limitCount = 180;
		/// <summary>
		/// 字符限定数，当分析的文本数量达到限定数则认为进入正文内容
		/// 默认180个字符数
		/// </summary>
		public static int LimitCount
		{
			get { return _limitCount; }
			set { _limitCount = value; }
		}
		// 确定文章正文头部时，向上查找，连续的空行到达_headEmptyLines，则停止查找
		private static int _headEmptyLines = 2;
		// 用于确定文章结束的字符数
		private static int _endLimitCharCount = 20;
		#endregion
		/// <summary>
		/// 从给定的Html原始文本中获取正文信息
		/// </summary>
		/// <param name="html"></param>
		/// <returns></returns>
		public static Article GetArticle(string html)
		{
			// 如果换行符的数量小于10，则认为html为压缩后的html
			// 由于处理算法是按照行进行处理，需要为html标签添加换行符，便于处理
			if (html.Count(c => c == '\n') < 10)
			{
				html = html.Replace(">", ">\n");
			}
			// 获取html，body标签内容
			string body = "";
			string bodyFilter = @"(?is)<body.*?</body>";
			Match m = Regex.Match(html, bodyFilter);
			if (m.Success)
			{
				body = m.ToString();
			}
			// 过滤样式，脚本等不相干标签
			foreach (var filter in Html2Article._filters)
			{
				body = Regex.Replace(body, filter[0], filter[1]);
			}
			// 标签规整化处理，将标签属性格式化处理到同一行
			// 处理形如以下的标签：
			//  <a 
			//   href='http://www.baidu.com'
			//   class='test'
			// 处理后为
			//  <a href='http://www.baidu.com' class='test'>
			body = Regex.Replace(body, @"(<[^<>]+)\s*\n\s*", FormatTag);
			string content;
			string contentWithTags;
			GetContent(body, out content, out contentWithTags);
			Article article = new Article
			{
				Title = GetTitle(html),
				PublishDate = GetPublishDate(html),
				Content = content,
				ContentWithTags = contentWithTags
			};
			return article;
		}
		/// <summary>
		/// 格式化标签，剔除匹配标签中的回车符
		/// </summary>
		/// <param name="match"></param>
		/// <returns></returns>
		private static string FormatTag(Match match)
		{
			StringBuilder sb = new StringBuilder();
			foreach (var ch in match.Value)
			{
				if (ch == '\r' || ch == '\n')
				{
					continue;
				}
				sb.Append(ch);
			}
			return sb.ToString();
		}
		/// <summary>
		/// 获取时间
		/// </summary>
		/// <param name="html"></param>
		/// <returns></returns>
		private static string GetTitle(string html)
		{
			string titleFilter = @"<title>[\s\S]*?</title>";
			string h1Filter = @"<h1.*?>.*?</h1>";
			string clearFilter = @"<.*?>";
			string title = "";
			Match match = Regex.Match(html, titleFilter, RegexOptions.IgnoreCase);
			if (match.Success)
			{
				title = Regex.Replace(match.Groups[0].Value, clearFilter, "");
			}
			// 正文的标题一般在h1中，比title中的标题更干净
			match = Regex.Match(html, h1Filter, RegexOptions.IgnoreCase);
			if (match.Success)
			{
				string h1 = Regex.Replace(match.Groups[0].Value, clearFilter, "");
				if (!String.IsNullOrEmpty(h1) && title.StartsWith(h1))
				{
					title = h1;
				}
			}
			return title;
		}
		/// <summary>
		/// 获取文章发布日期
		/// </summary>
		/// <param name="html"></param>
		/// <returns></returns>
		private static DateTime GetPublishDate(string html)
		{
			// 过滤html标签，防止标签对日期提取产生影响
			string text = Regex.Replace(html, "(?is)<.*?>", "");
			Match match = Regex.Match(
				text,
				@"((\d{4}|\d{2})(\-|\/)\d{1,2}\3\d{1,2})(\s?\d{2}:\d{2})?|(\d{4}年\d{1,2}月\d{1,2}日)(\s?\d{2}:\d{2})?",
				RegexOptions.IgnoreCase);
			DateTime result = new DateTime(1900, 1, 1);
			if (match.Success)
			{
				try
				{
					string dateStr = "";
					for (int i = 0; i < match.Groups.Count; i++)
					{
						dateStr = match.Groups[i].Value;
						if (!String.IsNullOrEmpty(dateStr))
						{
							break;
						}
					}
					// 对中文日期的处理
					if (dateStr.Contains("年"))
					{
						StringBuilder sb = new StringBuilder();
						foreach (var ch in dateStr)
						{
							if (ch == '年' || ch == '月')
							{
								sb.Append("/");
								continue;
							}
							if (ch == '日')
							{
								sb.Append(' ');
								continue;
							}
							sb.Append(ch);
						}
						dateStr = sb.ToString();
					}
					result = Convert.ToDateTime(dateStr);
				}
				catch (Exception)
				{ }
				if (result.Year < 1900)
				{
					result = new DateTime(1900, 1, 1);
				}
			}
			return result;
		}
		/// <summary>
		/// 从body标签文本中分析正文内容
		/// </summary>
		/// <param name="bodyText">只过滤了script和style标签的body文本内容</param>
		/// <param name="content">返回文本正文，不包含标签</param>
		/// <param name="contentWithTags">返回文本正文包含标签</param>
		private static void GetContent(string bodyText, out string content, out string contentWithTags)
		{
			string[] orgLines = null;   // 保存原始内容，按行存储
			string[] lines = null;	  // 保存干净的文本内容，不包含标签
			orgLines = bodyText.Split('\n');
			lines = new string[orgLines.Length];
			// 去除每行的空白字符,剔除标签
			for (int i = 0; i < orgLines.Length; i++)
			{
				string lineInfo = orgLines[i];
				// 处理回车，使用[crlf]做为回车标记符，最后统一处理
				lineInfo = Regex.Replace(lineInfo, "(?is)</p>|<br.*?/>", "[crlf]");
				lines[i] = Regex.Replace(lineInfo, "(?is)<.*?>", "").Trim();
			}
			StringBuilder sb = new StringBuilder();
			StringBuilder orgSb = new StringBuilder();
			int preTextLen = 0;		 // 记录上一次统计的字符数量
			int startPos = -1;		  // 记录文章正文的起始位置
			for (int i = 0; i < lines.Length - _depth; i++)
			{
				int len = 0;
				for (int j = 0; j < _depth; j++)
				{
					len += lines[i + j].Length;
				}
				if (startPos == -1)	 // 还没有找到文章起始位置，需要判断起始位置
				{
					if (preTextLen > _limitCount && len > 0)	// 如果上次查找的文本数量超过了限定字数，且当前行数字符数不为0，则认为是开始位置
					{
						// 查找文章起始位置, 如果向上查找，发现2行连续的空行则认为是头部
						int emptyCount = 0;
						for (int j = i - 1; j > 0; j--)
						{
							if (String.IsNullOrEmpty(lines[j]))
							{
								emptyCount++;
							}
							else
							{
								emptyCount = 0;
							}
							if (emptyCount == _headEmptyLines)
							{
								startPos = j + _headEmptyLines;
								break;
							}
						}
						// 如果没有定位到文章头，则以当前查找位置作为文章头
						if (startPos == -1)
						{
							startPos = i;
						}
						// 填充发现的文章起始部分
						for (int j = startPos; j <= i; j++)
						{
							sb.Append(lines[j]);
							orgSb.Append(orgLines[j]);
						}
					}
				}
				else
				{
					//if (len == 0 && preTextLen == 0)	// 当前长度为0，且上一个长度也为0，则认为已经结束
					if (len <= _endLimitCharCount && preTextLen < _endLimitCharCount)	// 当前长度为0，且上一个长度也为0，则认为已经结束
					{
						if (!_appendMode)
						{
							break;
						}
						startPos = -1;
					}
					sb.Append(lines[i]);
					orgSb.Append(orgLines[i]);
				}
				preTextLen = len;
			}
			string result = sb.ToString();
			// 处理回车符，更好的将文本格式化输出
			content = result.Replace("[crlf]", Environment.NewLine);
			content = System.Web.HttpUtility.HtmlDecode(content);
			// 输出带标签文本
			contentWithTags = orgSb.ToString();
		}
	}
}
namespace StanSoft
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Text.RegularExpressions;
	/// <summary>
	/// Url处理辅助类
	/// </summary>
	public class UrlUtility
	{
		/// <summary>
		/// 基于baseUrl，补全html代码中的链接
		/// </summary>
		/// <param name="baseUrl"></param>
		/// <param name="html"></param>
		public static string FixUrl(string baseUrl, string html)
		{
			html = Regex.Replace(html, "(?is)(href|src)=(\"|\')([^(\"|\')]+)(\"|\')", (match) =>
			{
				string org = match.Value;
				string link = match.Groups[3].Value;
				if (link.StartsWith("http"))
				{
					return org;
				}
				try
				{
					Uri uri = new Uri(baseUrl);
					Uri thisUri = new Uri(uri, link);
					string fullUrl = String.Format("{0}=\"{1}\"", match.Groups[1].Value, thisUri.AbsoluteUri);
					return fullUrl;
				}
				catch (Exception)
				{
					return org;
				}
			});
			return html;
		}
	}
}

#T=正则表达式常用
一、校验数字的表达式
1	数字：^[0-9]*$
2	n位的数字：^\d{n}$
3	至少n位的数字：^\d{n,}$
4	m-n位的数字：^\d{m,n}$
5	零和非零开头的数字：^(0|[1-9][0-9]*)$
6	非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
7	带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
8	正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
9	有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
10	有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
11	非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
12	非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
13	非负整数：^\d+$ 或 ^[1-9]\d*|0$
14	非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
15	非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
16	非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
17	正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
18	负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19	浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
二、校验字符的表达式
1	汉字：^[\u4e00-\u9fa5]{0,}$
2	英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3	长度为3-20的所有字符：^.{3,20}$
4	由26个英文字母组成的字符串：^[A-Za-z]+$
5	由26个大写英文字母组成的字符串：^[A-Z]+$
6	由26个小写英文字母组成的字符串：^[a-z]+$
7	由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
8	由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
9	中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
10	中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
11	可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
12	禁止输入含有~的字符：[^~\x22]+
三、特殊需求表达式
1	Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
2	域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
3	InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
4	手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
5	电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
6	国内电话号码(0511-4405222、 021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
7	身份证号(15位、18位数字)：^\d{15}|\d{18}$
8	短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
9	帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
10	密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
11	强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$  
12	日期格式：^\d{4}-\d{1,2}-\d{1,2}
13	一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
14	一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
15	钱的输入格式：
16	1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
17	2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
18	3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
19	4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
20	5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
21	6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
22	7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
23	8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
24	备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
25	xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
26	中文字符的正则表达式：[\u4e00-\u9fa5]
27	双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
28	空白行的正则表达式：\n\s*\r    (可以用来删除空白行)
29	HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
30	首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
31	腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)
32	中国邮政编码：[1-9]\d{5}(?!\d)    (中国邮政编码为6位数字)
33	IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)
#T=执行调用本机代码、汇编代码 shell Native Code
/*
	
	执行调用本机代码、汇编代码 shell Native Code

	解释
		本例中 IntPtr 其实是相当于 C 语言中的 (void *) 指向任何类型的指针，
			就是一个地址 32 位系统就是个 Int32，本例相当与一个函数指针
 
	核心技术流程
		变量：
			【本机代码字节数组】 byte[] codeBytes ; 一段加法本机代码
			【函数指针】 IntPtr handle ; 指向本机函数开始地址的变量
		流程：
			
		>> 给 【函数指针】划分非托管内存 ； 使用 Marshal.AllocHGlobal(codeBytes.Length) 
				划分大小等同于本机代码字节总数	因为函数本身还不存在于内存中所以先开辟一块内存；
				以便放置函数。
				
		>> 将 【本机代码字节数组】中的字节写入 【函数指针】 ；
				Marshal.Copy(codeBytes,0,handle,codeBytes.Length);
 
		
		>> 使用 Marshal.GetDelegateForFunctionPointer 【函数指针】 强制转换为托管委托 DelegateAdd；
				因为这时 handle 内的字节数组已经是内存中的一段本机方法的代码
				handle 的“起始地址”就相当于一个“本机函数的入口地址”
				所以可以成功转换为对应的委托
 
		>> 调用 委托 ；
 
		>> 释放本机句柄；Marshal.FreeHGlobal(this._handle);

修改记录
	2008-5-11 8:07 曲滨
		>> 基本实现预期功能
		[!] 明天进行优化
 
	2008-5-12 15:54 曲滨
		[E] 优化完成
		[N] 加入 NativeCodeHelper 类便于使用
*/
namespace NShellNativeCode
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Runtime.InteropServices;
	using System.IO;
	using System.Diagnostics;
	using System.Reflection;
	
	delegate int AddProc(int p1, int p2);
	class Program
	{
		

		static void Main(string[] args)
		{
			
			//一段加法函数本机代码；后面注释是给会 asm 看官看的
			//笔者本身也不是太明白汇编，简单的 10行8行的还可以
			
			byte[] codeBytes = { 
				  0x8B, 0x44, 0x24, 0x08	// mov eax,[esp+08h]
				, 0x8B, 0x4C, 0x24, 0x04	// mov ecx,[esp+04h]
				, 0x03, 0xC1				// add	eax,ecx
				, 0xC3						// ret
				};
						
			/*
			上面的字节数组，就是下面函数的本机代码；
			int add(int x,int y) {
				return x+y;
			} 
			 
			*/

			IntPtr handle = IntPtr.Zero;
			handle = Marshal.AllocHGlobal(codeBytes.Length);
			try
			{

				Marshal.Copy(codeBytes, 0, handle, codeBytes.Length);
								
				AddProc add
				   = Marshal.GetDelegateForFunctionPointer(handle, typeof(AddProc)) as AddProc;
				
				int r = add(1976, 1);

				Console.WriteLine("本机代码返回:{0}", r);


			}
			finally
			{
				Marshal.FreeHGlobal(handle);
			}
			 
			//本演示内包含的已经封装好的 本机字节代码，转换委托通用类
			//打开注释就可以用了；
			
			/*
			using (NativeCodeHelper helper = new NativeCodeHelper(codeBytes)) 
			{
				AddProc add = helper.ToDelegate<AddProc>();
				Type t =  add.Method.DeclaringType;
				int r = add(1976,1);
				Console.WriteLine("本机代码返回:{0}",r);
			}
			*/
					
			
			//Console.ReadLine();
		}	
			 
		
	}

/*
	结束语
		已知问题
			1)在操作系统打开 DEP 保护的情况下，这类代码会不灵；
				我没有测试，有兴趣的可以试验一下，估计是不会好用的；
			
			2)如果要在 本机代码 中调用 Win API 函数，因为在不同系统不同版本中 
				Win API 的地址是不同的； 
				要有一些编写 shell code 能力于黑客技术关系密切这里不做详细描述
	
		本文技术的适用范围
			>> 遗留系统，C/C++ 的某些算法、尤其汇编形式的是如果懒的改成.net 可以直接吧二进制copy 
				出来直接调用、不过需要C/VC、反汇编、汇编有点了解要不没法Copy；
 
			>> 有些代码不想被反编译，给破解者增加些破解难度、郁闷有可能会改你代码的人
				实用性有多少看官自己感觉吧，因为技术这东西是相对的
				如果你的程序中到处都是这类代码是很难维护的，就是熟悉汇编的人
				这种东西多了也很郁闷的、本机代码远比汇编难看的多  

			>> 忽悠小朋友
				把我的代码直接copy倒你的项目里，一点都不改，要算int加法的时候都这么用
				如果有小朋友看见一定会感觉你很 Cool
		
		重要声明：
			这种本机代码方式如果应用倒真实项目中一定要项目负责人的同意的情况下，否则出现
		任何人事问题，或刑事问题与本文作者无关；
			如
				>> 在真实项目中使用本文技术，在代码中坠入逻辑炸弹者；
				>> 在真实项目中使用本文技术，拒不上缴本机字节代码对应的源代码者；
				>> 在真实项目或共享软件中，捆绑病毒代码者；
		
*/

	/// <summary>
	/// 用于将本机代码 byte 数组转换为 .net 委托
	/// </summary>
	/// <remarks>
	/// 实现了 IDisposable 使用了非托管资源 使用时不要忘记释放 
	/// </remarks>
	public class NativeCodeHelper:IDisposable
	{
		
		private bool _disposed = false;
		private byte[] _codeBytes = {};
		private IntPtr _handle = IntPtr.Zero;
		
		public NativeCodeHelper(byte[] codeBytes)
		{
			 this._codeBytes =  codeBytes; 
		}
		
		/// <summary>
		/// 把byte数字转换为本机类型的指针 主要处理 this._handle
		/// </summary>
		private void CreateHandle()
		{
			if (_handle == IntPtr.Zero)
			{
				_handle = Marshal.AllocHGlobal( this._codeBytes.Length);
				Marshal.Copy(_codeBytes, 0, _handle, _codeBytes.Length);
			}		
		}
		/// <summary>
		/// 转换为指定的委托
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		public T ToDelegate<T>() where T:class
		{
			this.CreateHandle();
			
			//把指针转换为 委托方法
			T result = Marshal.GetDelegateForFunctionPointer(_handle, typeof(T)) as T;			
			
			return result;

		}
		
		#region IDisposable 成员
		
		~NativeCodeHelper()
		{
			Dispose(false);
		}
		
		public void Dispose()
		{
			Dispose(true);		
			GC.SuppressFinalize(this);

		}

		
		
		private void Dispose(bool disposing)
		{
			if (disposing)
			{
				//给调用者忘记 Dispose 释放的提示
				MethodBase mb = System.Reflection.MethodBase.GetCurrentMethod();
				Type t = mb.DeclaringType;
				
				Trace.WriteLine("not Dispose"
				, "" + t + "." + mb );
			}
			
			
			if (!this._disposed)
			{
				if (disposing)
				{
					//释放.net 需要 Dispose 的对象
				}

				Marshal.FreeHGlobal(this._handle);
				_handle = IntPtr.Zero;
			}
			_disposed = true;
		}		

		#endregion
	}
}

#T=抓屏
namespace Microshaoft
{
	using System;
	using System.Drawing;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Drawing.Imaging;
	using System.IO;
	using System.Runtime.InteropServices;

	public static class CaptureHelper
	{
		[DllImport("gdi32.dll")]
		private static extern bool BitBlt
		(
			IntPtr hdcDest, //目标设备的句柄
			int nXDest, // 目标对象的左上角的X坐标
			int nYDest, // 目标对象的左上角的X坐标
			int nWidth, // 目标对象的矩形的宽度
			int nHeight, // 目标对象的矩形的长度
			IntPtr hdcSrc, // 源设备的句柄
			int nXSrc, // 源对象的左上角的X坐标
			int nYSrc, // 源对象的左上角的X坐标
			int dwRop // 光栅的操作值
		);
		[DllImport("gdi32.dll")]
		private static extern IntPtr CreateDC
		(
			string lpszDriver, // 驱动名称
			string lpszDevice, // 设备名称
			string lpszOutput, // 无用，可以设定位"NULL"
			IntPtr lpInitData // 任意的打印机数据
		);
		public static void CaptureScreen
			(
				int x
				,int y
				,int width
				,int height
			)
		{
			IntPtr dc1 = CreateDC("DISPLAY", null, null, (IntPtr)null);
			//创建显示器的DC
			Graphics g1 = Graphics.FromHdc(dc1);
			//由一个指定设备的句柄创建一个新的Graphics对象
			Bitmap MyImage = new Bitmap
							(
								width
								, height
								, g1
							);
			//根据屏幕大小创建一个与之相同大小的Bitmap对象
			Graphics g2 = Graphics.FromImage(MyImage);
			//获得屏幕的句柄
			IntPtr dc3 = g1.GetHdc();
			//获得位图的句柄
			IntPtr dc2 = g2.GetHdc();
			//把当前屏幕捕获到位图对象中
			BitBlt
				(
					dc2
					, x
					, y
					, width
					, height
					, dc3
					, 0
					, 0
					, 13369376
				);
			//把当前屏幕拷贝到位图中
			g1.ReleaseHdc(dc3);
			//释放屏幕句柄
			g2.ReleaseHdc(dc2);
			//释放位图句柄
			MyImage.Save("c:\\MyJpeg.bmp", ImageFormat.Bmp);
			//MessageBox.Show("已经把当前屏幕保存到C:\\MyJpeg.jpg文件中！");
		}

	}
}

#T=抓屏 CopyFromScreen
namespace ConsoleApplication
{
	using System;
	using System.Drawing;
	using System.Drawing.Imaging;
	using System.Windows.Forms;
	public class Class1
	{
		static void Main(string[] args)
		{
			Bitmap bmp = new Bitmap
								(
									Screen.PrimaryScreen.Bounds.Width
									, Screen.PrimaryScreen.Bounds.Height
								); 
			Graphics g = Graphics.FromImage(bmp); 
			g.CopyFromScreen
						(
							new Point(0,0)
							, new Point(0, 0)
							, new Size(bmp.Width, bmp.Height)
						); 
			IntPtr dc1 = g.GetHdc(); 
			g.ReleaseHdc(dc1); 
			bmp.Save(@"c:\screen0.jpg" ,ImageFormat.Jpeg); 
		}
	}
}

#