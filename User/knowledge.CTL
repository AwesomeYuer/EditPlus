#TITLE=09.编程知识
#INFO
New Cliptext library
#SORT=y

#T=10件惹恼程序员的事
程序员是一个比较特殊的群体，他们因为长期和电脑打交道所养成的性格和脾气也是比较相近的。当然，既然是人，当然是会有性格的，也是会有脾气的。下面，让我来看看10种能把程序惹毛了的事情。一方面我们可以看看程序员的共性，另一方面我们也可以看看程序员的缺点。无论怎么样，我都希望他们对你的日常工作都是一种帮助。
第十位 程序注释
	程序注释本来是一些比较好的习惯，当程序员老手带新手的时候，总是会告诉新手，一定要写程序注释。于是，新手们当然会听从老手的吩咐。只不过，他们可能对程序注释有些误解，于是，我们经常在程序中看到一些如下的注释：
	代码:
	r = n/2; //r是n的一半 
	//循环，仅当r- n/r不大于t 
	while ((r-n/r) <=t){ 
	r =0.5* (r-n/r); // 设置r变量 
	}
	每当看到这样的注释只注释是什么，而不注释为什么，相信你一定会被惹火，这是谁写的程序注释啊?不找来骂一顿看来是不会解气了。程序注释应该是告诉别人你的意图和想法，而不是告诉别人程序的语法，这是为了程序的易读性和可维护性，这样的为了注释而注释的注释，分明不是在注释，而是在挑衅，惹毛别人当然毋庸置疑。
第九位 打断
	正当程序沉浸于编程算法的思考，或是灵感突现正在书写程序的时候，但却遭到别人的打断，那是一件非常痛苦的事情，如果被持续打断，那可能会让人一下子就烦躁起来。打断别人的人在这种情况下是非常不礼貌的。被打断的人就像函数调用一下，当其返回时，需要重新恢复断点时的现场，当然，人不是电脑，恢复现场通常是一个很痛苦的过程，极端的情况下可能需要从头开始寻找思绪，然后一点一点地回到断点。
	因此，我看到一些程序员在需要安静不被打扰的时候，要么会选择去一个没人找得到的地方，要么会在自己的桌子上方高挂一个条幅以示众人本人正执行内核程序，无法中断，请勿骚扰，谢谢！可见正在沉浸于工作的程序被打断是多么大的开销。自然，被打断所惹毛了的人也不在少数了。
第八位 需求变化
	这个事情估计不用多说了。只要是程序员，面对需求变化的时候可能总是很无奈的。一次两次可能还能接受，但也顶不住经常变啊。据说敏捷开发中有一套方法论可以让程序员们享受需求的变化，不知道是真是假。不过，今天让你做一个书桌，明天让你把书桌改成餐桌，后天让你把餐桌改成双人床，大后天让你把床改成小木屋，然后把小木屋再改成高楼大厦。哎，是人都会被惹毛了的。那些人只用30分钟的会议就可以作出任何决定，但后面那几十个程序员需要搭上几百个小时的辛苦工作。如果是我，可能我也需要神兽草泥马帮助解解气了。
	不过，这也正说明了，程序员并不懂得怎么和用户沟通，而用户也不懂得和程序员沟通，如果一个项目没有一个中间人(如：PM)在其中协调的话，那么整个项目可能就是鸡同鸭讲，用户和程序员都会被对方所惹毛了。如果要例举几个用户被惹毛的事情，估计程序员的那种一根筋的只从技术实现上思考问题的方法应该也能排进前5名。
第七位 经理不懂技术
	外行领导内行的事例还少吗?领导一句话，无论对不对，都是对的，我们必需照做，那怕是多么愚蠢多么错误的决定，我们也得照做。程序员其实并不怕经理不懂技术，最怕的就是不懂技术的经理装着很懂技术。最可气的是，当你据理力争的挑站领导权威的时候，领导还把你视为异类。哎，想起这样的领导别说是骂人了，打人的冲动都有了。
	其实，经理只不过是一个团队的支持者，他应该帮助团队，为团队排忧解难。而不是对团队发号施令。其实管理真的很简单，如果懂的话，就帮着做，如果不懂的话，就相信下属，放手让下属做。最怕的就是又不懂技术，还不信任下属的经理了。哎，这真是程序员的痛啊。
第六位 用户文档
	用户文档本来不应该那么的令人害怕。这些文档记录了一切和我们所开发的软件有关的一些话题。因为我们并不知道我们所面对的用户的电脑操作基础是什么样的，所以，在写下这样的文档的时候，我们必需假设这个用户什么也不懂。于是，需要用最清楚，最漂亮的语言写下一个最丰富的文档。那怕一个拷贝粘贴的操作，可能我们都要分成五、六步来完成，那怕是一个配置IP地址的操作，我们也要从开始菜单开始一步一步的描述。对于程序员来说，他们在开发过程中几乎天天都在使用自己开发的软件，到最后，可能都有点吐了，但还得从最简单的部份写这些文档，当然容易令他们烦燥，让程序员来完成这样的文档可能效果会非常不好。所以，对于这样的用户文档，应该由专门的文档人员来完成和维护。
第五位 没有文档
	正如上一条所说的，程序员本来就不喜欢写文档，而因为技术人员的表达能力和写作能力一般都不是太好，所以，文档写的也很烂。看看开源社区的文档可能就知道了。但是，我们可爱的程序员另一方面最生气的却是因为没有文档。当然，上面说的是用户的文档，这里我们说的是开发方面的文档，比如设计文档，功能规格，维护文档等等。不过，基本上都是一样的。反正，一方面，我们的程序员不喜欢写文档，另一方面，我们的程序又会被抱怨没有文档，文档太少，或者文档看不懂。呵呵。原来在抱怨方面也有递归啊。据说，敏捷开发可以降低程序开发中的文档，据说他们可以把代码写得跟文档和示图似的，不知道是真是假。不过，我听过太多太多的程序员抱怨没文档太少，文档太差了，这个方面要怪还是怪程序员自己。
第四位 部署环境
	虽然，程序员们开发的是软件，但是我们并不知道我们的程序会被部署或安装在什么样的环境下，比如，网络上的不同，RAID上的不同，BIOS上的不同，操作系统的不同(WinXP和Win2003)，有没有杀毒软件，和其它程序是否兼容，系统中有流氓软件或病毒等等。当然，只要你的软件出现错误，无论是你的程序的问题，还是环境的问题，反正都是你的问题，你都得全部解决。所以，程序员们并不是简单地在编程，很多时候，还要当好一个不错的系统管理员。每当最后确认问题的原因是环境问题的时候，可能程序员都是会心生怨气。
第三位 问题报告
	我的软件不工作了，程序出错了，每当我们听到这样的问题报告的时候，程序员总是感到很痛苦，因为这样的问题报告等于什么也没有说，但还要程序员去处理这种错误。没有明确的问题描述，没有说明如何重现问题，在感觉上，当然会显得有点被人质问的感觉，甚至，在某些时候还掺杂着看不起，训斥的语气，当然，程序员基本上都是很有个性的，都是软硬不吃的主儿。所以，每当有这样的语气报告问题的时候，他们一般也会把话给顶回去，当然，后面自己然发生一些不愉快的事情。所以，咱们还是需要一个客服部门来帮助我们的程序员和用户做好沟通。
第二位 程序员自己
	惹毛程序员的可能还是程序员自己，程序员是相轻的，他们基本上都是恃才傲物的，总是觉得自己才是最牛的，在程序员间，他们几乎每天都要吵架，而且一吵就吵得脸红脖子粗。在他们之间，他们总是被自己惹毛。
	技术上的不同见解。比如Linux和Win，VC++和VB，Vi和Emacus，Java和C++，PHP和Ruby等等，等等。什么都要吵。
	老手对新手的轻视。总是有一些程序员看不起另一些程序员，说话间都带着一种傲慢和训斥。当新手去问问题的时候，老手们总是爱搭不理。
	在技术上不给对方留面子。不知道为什么，程序员总是不给对方留面子，每当听到有人错误理解某个技术的时候，他们总是喜欢当众大声指证，用别人的错误来表明自己的博学，并证明他人的无知。
	喜好鄙视。他们喜好鄙视，其实，这个世界上没有一件事是完美的，有好就有不好，要挑毛病太容易了。程序员们特别喜欢鄙视别人，无论是什么的东西，他们总是喜欢看人短而不看人长。经常挂在他们嘴上的口头禅是太差、不行等等。
	程序员，长期和电脑打交道，编写出的代码电脑总是认真的运行，长期养成了程序员们目空一切的性格，却不知，这个世界上很多东西并不是能像电脑一样，只要我们输入正确的指令它就正确地运行这么简单。程序员，什么时候才能变得成熟起来
第一位 程序员的代码
	无论你当时觉得自己的设计和写的代码如何的漂亮和经典，过上一段时间后，再回头看看，你必然会觉得自己的愚蠢。当然，当你需要去维护他人的代码的时候，你一定要在一边维护中一边臭骂别人的代码。是否你还记得当初怎么怎么牛气地和别人讨论自己的设计和自己的代码如何如何完美的?可是，用不了两年，一刚从学校毕业的学生在维护你的代码的过程当中就可以对你的代码指指点点，让你的颜面完全扫地。
	呵呵。当然，也有的人始终觉得自己的设计和代码就是最好的，不过这是用一种比较静止的眼光来看问题。编程这个世界变化总是很快的的，很多事情，只有当我们做过，我们才熟悉他，熟悉了后才知道什么是更好的方法，这是循序渐进的。所以，当你对事情越来越熟悉的时候，再回头看自己以前做的设计和代码的时候，必然会觉得自己的肤浅和愚蠢，当然看别人的设计和代码时，可能也会开始骂人了。
#T=10十条不错的编程观点
在Stack Overflow上有这样的一个贴子《What’s your most controversial programming opinion?》，翻译成中文就是“你认为最有争议的编程观点是什么？”，不过，在400多个主回贴，以及千把个子回贴中，好像并不是很有争议，而是令人相当的茅塞顿开，下面罗列一些，并通过我自己的经历和理解发挥了一些，希望对你有帮助。
1） The only “best practice” you should be using all the time is “Use Your Brain”.
	唯一的“Best Practice”并不是使用各种各样被前人总结过的各种设计方法、模式，框架，那些著名的方法、模式、框架只代码赞同他们的人多，并不代表他们适合你，你应该更多的去使用你的大脑，独立地思考那些方法、模式、框架出现的原因和其背后的想法和思想，那才是“best practice”。事实上来说，那些所谓的“Best Practice”只不过是限制那些糟糕的程序员们的破坏力。
2）Programmers who don’t code in their spare time for fun will never become as good as those that do.
	如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的娱乐方式去生活，无论是编程，还是运动，还是去旅游，那么你只不过是在应付你的工作，无时无刻不扎在程序堆中，这样下来，就算是你是一个非常聪明，非常有才华的人，你也不会成为一个优秀的编程员，要么只会平平凡凡，要么只会整天扎在技术中成为书呆子。当然，这个观点是有争议，热情和能力的差距也是很大的。不过我们可以从中汲取其正面的观点。
3）Most comments in code are in fact a pernicious form of code duplication.
	注释应该是注释Why，而不是How和What，参看《惹恼程序员的十件事》，代码告诉你How，而注释应该告诉你Why。但大多数的程序并不知道什么是好的注释，那些注释其实和code是重复的，毫无意义。
4）XML is highly overrated
	XML可能被高估了。XML对于Web上的应用是不错的，但是我们把其用到了各种地方，好像没有XML，我们都不会编程了。
5）Not all programmers are created equal
	这是那些junior经理或是流程爱犯的错，他们总是认为，DeveloperA == DeveloperB，只要他们的title一样，他们以为他们的能力、工作速度、解决问题的方法，掌握的技能等等都是一样的。呵呵。更扯的是，在某些时候，就算是最差的程序员，他们也会认为其比别人强十倍，这就是现代的SB管理。
6）”Googling it” is okay!
	Google只会给你知识，并不会教给你技能。那里只有“鱼”，没有“渔”，过度的使用Google，只会让你越来越离不开他，你越来越去要去立马告诉你答案，而你越来越不会自己去思考，自己去探索，去专研。如果KFC快餐是垃圾食品对我们的身体没有好处，那么使用Google也一种快餐文化对我们的智力发展大大的没有好处。
7）If you only know one language, no matter how well you know it, you’re not a great programmer.
	如果你只懂一种语言，准确的说，如果你只懂一类语类，如：Java和C#，PHP和Perl，那么，你将会被局限起来，只有了解了各种各样的语言，了解了不同语言的不同方法 ，你才会有比较，只有了比较，你才会明白各种语言的长处和短处，才会让你有更为成熟的观点，而且不整天和别的程序在网上斗嘴争论是Windows好还是Unix好，是C好还是C++好，有这点工夫能干好多事了。世界因为不同而精彩，只知道事物的一面是有害的。
8）Your job is to put yourself out of work.
	你的工作不是保守，那种教会徒弟，饿死师父的想法，不但是相当短浅的，而且还是相当脑残的。因为，在计算机世界里，你掌握的老技术越多，你就越没用，因为技术更新的太快。你对工作越保守，这个工作就越来越离不开你，你就越不越不能抽身去学新的东西，你也就越来越OUT了。记住：If you can’t be replaced then you can’t be promoted!
9）Design patterns are hurting good design more than they’re helping it.
	很多程序员把设计模式奉为天神，他们过度的追求设计模式以至都都忘了需求是什么，结果整个系统设计被设计模式搞得乱七八糟，我们叫这种编程为“设计模式驱动编程”，正如第一点所说，如果你不懂得用自己的大脑思考的话，知其然，不知所以然的话，那么你不但得不到其好处，反而受其所累。
10）Unit Testing won’t help you write good code
	准确地说，我们可以认为这是Test-Driven开发，其实，这种开发就是先写unit test case，这样的开发方式的主要目的是，为了防止你不会因为一个改动而引入Bug，但这并不会让你能写出更好的代码。这只会让你写出不会出错的代码。同第一点，这样的方法，只不过是防止糟糕的程序员，而并不是让程序员或代码质量更有长进。反而，通过Unit Test会为程序员的为自己代码做辩解的一种托辞。
	最后，顺便说一下，以前去那个敏捷的公司面试，发现那个公司的某些技术人员中毒不浅，具体表现在上述的1）9）10）观点上。
#T=OOD
OCP(Open-Closed Principle):
	开放-关闭原则
	对扩展要说YES，对修改说NO。
LSP(Liskov Substitution Principle):
	LSP原则
 	父母要对孩子负责。
SRP(Single Responsibility Principle):
	单一职责原则
	感情要单一，不要脚踏两支船。
DIP(Dependency Inversion Principle):
	关系返转原则
	不要一天打10个电话给我，有结果我会通知你。
ISP(Interface Segregation Principle):
	接口隔离原则
	让李部长只负责开发吧，市场就让辛部长做吧




面向对象三要素
	封装(Encapsulation)
	继承(Inheritance)
	多态(Polymorphism)
面向对象六视点
	复用(Reusibility)
	扩展(Extensibility)
	分离(Separability)
面向对象五原则
	单一职责原则(SRP)
	开放-封闭原则(OCP)
	Liskov替换原则(LSP)
	依赖倒置原则(DIP)
	接口隔离原则(ISP)


#T=OOD 三要素 五原则
目录
面向对象三要素
	封装(Encapsulation)
	继承(Inheritance)
	多态(Polymorphism)
面向对象六视点
	复用(Reusibility)
	扩展(Extensibility)
	分离(Separability)
面向对象五原则(SOLID)
	单一职责原则(SRP)
	开放-封闭原则(OCP)
	Liskov替换原则(LSP)
	接口隔离原则(ISP)
	依赖倒置原则(DIP)

	变化(Change)
	简约(Simplicity)
	一致(Coherance)
面向对象三要素
	封装
	继承
	多态
	封装
封装=合理的隐藏
	数据的隐藏（隐藏在方法背后）
	实现的隐藏（隐藏在接口背后）
	变化的隐藏（隐藏在抽象背后）
封装能够：
	提高对象的复用性
	降低对象的耦合度
良好的封装=对象的高内聚
	封装
	继承
	继承
		基于差异式编程
		继承与合成/聚合
			合成/聚合复用原则
	继承方式
		类的继承
		接口继承
	继承与实现
多态
	多态是指对象在不同时刻体现为不同类型
	的能力
抽象与多态
多态的形式：
	基类继承式多态
	接口实现式多态
多态
面向对象五原则
	单一职责原则(SRP)
	开放-封闭原则(OCP)
	Liskov替换原则(LSP)
	依赖倒置原则(DIP)
	接口隔离原则(ISP)
单一职责原则
单一职责原则
单一职责原则保证了：
	对象的细粒度――便于复用
	对象的单一性――利于稳定
	单一职责原则分离了不变与变
	不要创建“上帝”类，Facade类除外
开放-封闭原则
	开放-封闭原则
	对于扩展是开放的，对于更改是封闭的
	开放-封闭原则的关键是“抽象”
	多态保证了扩展的开放性
	开放意味着实现是可替换的
	开放-封闭原则
Liskov替换原则
	Liskov替换原则
	子类型必须能够完全替换其父类型
	Liskov替换原则关注的是行为的可
	替换
	Liskov替换原则：
		可以作为验证继承关系(is-a)正
	确性的准则
		体现了多个实现在接口的一致性
		如果违背该原则，通常的做法是
	引入一个新的超类，将父子关系
	修改为兄弟关系
依赖倒置原则
	依赖倒置原则
面向接口编程
抽象不应该依赖于细节。细节应该依赖于
抽象。
高层模块和低层模块以及客户端模块和服
务模块都应该依赖于接口，而不是具体实
现
依赖倒置原则的核心是“抽象”和“间接”
接口隔离原则
接口隔离原则
接口尽量小，防止接口污染；
接口若要稳定，就应承担较少责任，本原
则同时符合单一职责原则。
使用多个专门的接口比使用单一的总接口
好；
可以合理利用接口的继承；
同一个类可以同时实现多个接口，站在调
用者的角度，不同的接口代表不同的关注
点，不同的职责，甚至是不同的角色。
面向对象六视点
	复用(Reusibility)
	扩展(Extensibility)
	分离(Separability)
	变化(Change)
	简约(Simplicity)
	一致(Coherance)
复用
软件设计最大的敌人是重复。
重复的代码会导致解决方案蔓延。
细粒度
封装复用
高内聚
相关模式：
	Prototype模式
	Proxy模式
复用
如何提高软件的复用性？
	方法级
 重构之方法提取
 辅助方法
 利用静态工厂复用对象的创建逻辑
	对象级
 遵循单一职责原则
 合理的封装
 辅助类
 AOP（面向方面编程）
	模块级
 根据依赖关系划分包
 复用的粒度就是发布的粒度
 一个包中的所有类应该是共同复用的
扩展
不修改原有代码增加新的功能，谓之扩展
实现扩展的方式：
	利用继承实现扩展
	利用组合实现扩展
	利用继承和组合实现扩展
	利用抽象实现扩展
相关设计模式
	Decorator模式
	Visitor模式
	Proxy模式
分离
软件设计需重视职责的分离
分离需与抽象结合，实现依赖的解耦
职责分离体现了
	单一职责原则
	接口隔离原则
职责分离表现为
	如何定义职责
	如何分解职责
	如何抽象职责
分离
分离的目标：
	分离变与不变
	分离接口与实现
	分离数据与行为
相关设计模式
	Factory Method模式
	Bridge模式
	Iterator模式
变化
封装变化是解决之道
封装变化的核心是抽象
	封装创建的变化
	封装结构的变化
	封装行为的变化
解决变化应遵循：
	开放-封闭原则
	依赖倒置原则
封装变化的本质是隔离变化
变化
隔离变化
	通过分离
	通过抽象
	依赖注入
相关模式
	Factory Method模式
	Abstract Factory模式
	Strategy模式
简约
简约需遵循：
	KISS原则
	场景驱动设计
	避免设计过度
如何实现简约：
	封装有利于简约：职责的封装
	继承有利于简约：职责的复用
	多态有利于简约：职责的委托
简约
简约不等于简陋，等于简单加优雅
简约需要重构和精益求精
如何考量简约？
	可复用性
	可扩展性
	可测试性
相关模式
	Facade模式
	Singleton模式
	Composite模式
	Template Method模式
	Strategy模式
一致
一致体现了软件结构的和谐与平衡
一致体现为：
	接口的一致――对于实现可替换
	形式的一致――窥一斑而知全豹
	调用的一致――客户可透明访问
相关模式：
	Composite模式
	Adapter模式
#T=Web安全入门
http://www.cnblogs.com/onlytiancai/p/3297525.html

信息安全基础
信息安全目标

真实性：对信息的来源进行判断，能对伪造来源的信息予以鉴别, 就是身份认证。
保密性：保证机密信息不被窃听，盗取，或窃听者不能了解信息的真实含义。
完整性：保证数据的一致性，防止数据被非法用户篡改或部分丢失。
可用性：保证合法用户对信息和资源的使用不会被不正当地拒绝。
不可抵赖性：建立有效的责任机制，防止用户否认其行为。
常见攻击手段

破坏信息的完整性，篡改信息
拒绝服务
窃听,拦截信息
假冒
抵赖
重放
猜测预测
拖库, 信息泄露
密码学基础
HASH

介绍
摘要性，把任意大小的数据映射成固定长大小的摘要信息，不同信息有不同的哈希值。
不可逆性，通过hash值不能反推出原始数据。
用途：
防止信息被篡改
保证信息完整性
数据去重
常见算法：
checksum: 就是简单的总和校验码，一般在通信中用于保证数据的完整性和准确性,比如tcp协议。
crc32：32bit,性能好，碰撞率高，一般用于图片去重。
md5: 128bit,一般用户密码加密，文件校验，对于密码加密已经不安全，因为已经找到了碰撞条件
sha1: 基本同md5, 已经找到了碰撞条件, 但用于文件校验还是没问题的
sha256: 相对安全，可以用于密码加密
Bloom Filter: 多个hash函数组合进行去重，一般用于大数据量的去重，比如搜索引擎网页收录。 如果它说一个项目不在一个集合里，那肯定不在，如果说在，那有很小的可能不在。
随机数

介绍
指定一个范围和种子，随机的生成一个数字
用途：
防猜测预测，让黑客猜测不到信息地址或加密因子。
防止重放，每次请求里的随机数不一致，用户重放请求时随机数已被使用而拒绝请求。
Hash里当作salt，让相同的明文加盐后生成不同的hash值，防止被人用字典攻击破解密码。
加密算法中当作iv(初始化向量)，让相同的明文块生成不同的密文，增加破解难度。
从集合里随机抽取数据，保证一段时间内唯一，比如tcp的seq。
动态口令，和时间，种子相关的随机数。
常用算法：
线性同余: 最常用的伪随机数生成算法，如果知道种子有可能被预测到。
GUID: 全球唯一字符串，很难被猜测到。
对称加密

介绍：加密和解密需要使用相同的密钥，有流加密和块加密之分，一般可以进行大数据量的加密。
用途：
防止信息泄露
防止信息拦截
常见算法：
DES: 64bit密钥, 破解难度较低
3DES: 三重DES，128bit密钥，破解难度较高
RC2: DES的建议替代算法, 密钥长度可变,1-128bit, 速度较快
RC4: 强度高，速度快, 不安全
AES: 广泛使用的加密算法，速度快，安全级别高，已经成为美国加密标准, 目前 AES 标准的一个实现是 Rijndael 算法
非对称加密

介绍：
加密和解密使用不同的密钥，一般只能加密很少量的数据，而且性能较差。
公钥可以公开，公钥加密的数据私钥可以解密，反之也是。
私钥需要秘密保管，私钥签名的数据，公钥可以验证签名。
非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。
用途：
验证身份，数字签名, 可以解决否认、伪造、篡改及冒充等问题
数据加密, 防止信息泄露和拦截
常见算法：
RSA: 基于大数运算和数学原理，可以让加密和解密使用不同的密钥。
DSA: 数据签名算法，
身份认证方案
HTTP基本认证

介绍：用户名追加一个冒号然后串接上口令，并将得出的结果字符串再用Base64算法编码。
优点：
浏览器支持广泛。
缺点：
不能防止信息泄露，base64只是编码，不是加密。
不能防窃听
不能防重放
不能防拖库
使用场景：
在可信网络环境中可使用基本认证。
使用HTTPS做传输层。
HMAC

介绍：
用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。
消息认证码是基于密钥和消息摘要【hash】所获得的一个值，可用于数据源发认证和完整性校验。
原理：
图
client要给server发送message，先用key和message加起来，然后哈希得出一个MAC
然后用户把明文message和MAC发给server
server知道key，用同样的算法得到MAC，看和client请求的MAC是否一致
如果MAC一致，说明message是拥有key的人发送的，而且message没有被篡改
优点：
实现了身份认证，实现了不可抵赖性
保证了数据完整性，达到了防篡改的效果
HMAC与一般的加密重要的区别在于它具有“瞬时”性，即认证只在当时有效
缺点：
message是明文，不能防窃听
不能防重放
应用：
挑战/响应（Challenge/Response）身份认证,如SIP，HTTP
Cookie签名
HTTP摘要认证(Digest access authentication, rfc2069)

介绍
它在密码发出前，先对其应用哈希函数，这相对于HTTP基本认证发送明文而言，更安全。
图
原理
client请求认证页面, 不提供用户名和密码
server返回401应答
realm：认证域, 明文，
nonce: 随机数, 明文，只使用一次
client再次发起请求
对用户名、认证域(realm)以及密码的合并值计算 MD5 哈希值，结果称为 HA1。
对HTTP方法以及URI的摘要的合并值计算 MD5 哈希值，例如，"GET" 和 "/dir/index.html"，结果称为 HA2。
对 HA1、服务器密码随机数(nonce)、请求计数(nc,防止重放)、客户端密码随机数(cnonce)、 HA2 的合并值计算 MD5得到response 值以及cnonce。
server收到应答，因为服务器拥有与客户端同样的信息，因此服务器可以进行同样的计算，以验证客户端提交的 response 值的正确性。
优点
密码明文不需要传输，所以明文不会被泄露,这样server可以不存明文密码，而是只存HA1。
可以客户端随机数cnonce，够防止选择明文攻击(劫持到密文后猜测加密算法及明文)。
nonce允许包含时间戳, 过期后就失效，防止重放攻击。
服务器也可以维护一个最近发出的nonce的列表以防止nonce重用。
防监听，防重放, 防抵赖，身份认证
缺点
RFC 2617 中的许多安全选项都是可选的, 某些时候会降级为RFC 2616。
容易受到中间人攻击, 摘要访问认证没有提供任何机制帮助客户端验证服务器的身份。
使用HTTPS加密同时使用这些弱明文协议解决了许多摘要访问认证试图要防止的许多威胁。
使用md5是使用到了md5的不可逆性，但md5现在有可以攻击的方式，如穷举攻击(密码比较简单时)，字典攻击，
如何面对冲突攻击(不同明文哈希后相同)（rfc2617）。
其它说明
可以允许每一个nonce只使用一次，但这样就会迫使客户端在发送每个请求的时候重复认证过程
nonce在生成后立刻过期是不行的，因为客户端将没有任何机会来使用这个nonce。
客户端多次请求可以重用nonce,但得提供新的cnonce。在后续的请求中，nc比前一次要大。
https/tls

介绍：它是一个安全传输协议，但也可以进行身份认证。
加密传输数据: 服务端和客户端之间的所有通讯，都是加密的。
用于身份验证: 保证服务器就是他声称的服务器。
维护数据的完整性，确保数据在传输过程中不被改变。
RC4, X509
握手机制-简化版
client要访问一个server, 知道server的域名domain
client向server发起请求 2.1. ssl版本号 2.2. 加密算法类型 2.3. 随机数
server给client返回应答 3.1 ssl版本号 3.2 加密算法类型 3.3 随机数 3.4 自己的证书(公钥) 3.5 随机数签名。
client验证服务端返回的应答 4.1 证书是否过期 4.2 发型证书的CA是否可靠（会和本地的可信任CA列表对比） 4.3 server的公钥能否解开server返回的随机数签名 # 确认server有该证书的私钥 4.4 server的证书授权的域名是否是server的域名
client随机产生一个用于对称加密密钥，然后用server的公钥加密，发给Server
server用自己三私钥解密出对称加密密钥。
后续的通信都用对称加密密钥进行加解密。
优点：
防窃听
防重放
防中间人攻击，
保证数据完整性性
防止会话劫持
缺点
不能防止信息泄露，拖库，只是保证传输层安全
一般不能用于客户端身份验证，需要配合http基本认证
建立连接速度慢
oauth

介绍：OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。
原理：
用户访问客户端的网站，想操作自己存放在服务提供方的资源。
客户端向服务提供方请求一个临时令牌。
服务提供方验证客户端的身份后，授予一个临时令牌。
客户端获得临时令牌后，将用户引导至服务提供方的授权页面请求用户授权。在这个过程中将临时令牌和客户端的回调连接发送给服务提供方。
用户在服务提供方的网页上输入用户名和密码，然后授权该客户端访问所请求的资源。
授权成功后，服务提供方引导用户返回客户端的网页。
客户端根据临时令牌从服务提供方那里获取访问令牌 。
服务提供方根据临时令牌和用户的授权情况授予客户端访问令牌。
客户端使用获取的访问令牌访问存放在服务提供方上的受保护的资源。
双因素认证，动态口令

介绍： 1.简单来说，双因素身份认证就是通过你所知道再加上你所能拥有的这二个要素组合到一起才能发挥作用的身份认证系统, 如ATM。
目前主流的双因素认证系统是基于时间同步型，
市场占有率高的有DKEY双因素认证系统、RSA双因素认证系统等
主流的有硬件令牌、手机短信密码、USB KEY、混合型令牌（USBKEY+动态口令）, 密保卡，手机令牌
优点
密码丢失后，黑客不能登录你的账户
缺点
使用不方便
用密钥加密用户密码

介绍：
本机生成一个密钥key存磁盘上，对称加密密钥。
创建用户时，用户提供password, 然后数据库里保存db_password = encrypt(key, hash(password))
这样黑客把数据库拖走后，因为没有key解开用db_password，所以用户密码还是安全的。
用户登录时提供密码password, 哈希后是hash(password), 然后uncrypt(key, db_password)，
两者比较，一致就是认证通过
不一致就是终止认证
优点：
防止拖库
缺点
key丢了就完蛋了，谁也登录不上了。
Secure Remote Password protocol

介绍

一个认证和密钥交换系统，它用来在不可靠的网络中保护口令和交换密钥。
通过消除了在网络上发送明文口令的需要，并且通过安全的密钥交换机制来使用加密，改进了安全性。
服务器不保存密码或密码的散列值, 防止字典攻击. 而只是保存验证因子(verifier).
客户端和服务器可以各自计算出一个会话秘钥(session key), 其值相同. 防止窃听和会话劫持.
好多游戏服务端用SRP认证，比如魔兽世界。
优点

防窃听
防暴力破解，字典攻击, 弱口令也不容易被破解
即使口令数据库被公之于众，攻击者仍然需要一个庞大的字典去搜索来获得口令。
速度快，不需要证书和第三方认证机构
缺点

浏览器不支持，得自己实现
原理

N     一个安全的大质数, 比如N=2q+1,q 是一个素数
g     一个以N为模的生成元，对任何X，有0 < X < N，存在一个值x，使得g^x % N == X。
k     k = H(N,G) 在 SRP6 中 k = 3
s     User’s Salt
I     用户名
p     明文密码
H()   单向 hash 函数
^     求幂运算
u     随机数
a,b   保密的临时数字
A,B   公开的临时数字
x     私有密匙（从 p 和 s 计算得来）
v     密码验证数字

N和g的值必须由双方讨论来达成一致。它们可以被提前设置好，或者主机把它们发送给客户端。

服务器存储如下信息
x = H(s, p)               (s is chosen randomly)
v = g^x                   (computes password verifier)

服务器的数据库保存 {I, s, v} 整个验证流程如下:

User -> Host:  I, A = g^a                  (标识自己是谁, a是随机数)
Host -> User:  s, B = kv + g^b             (把salt发送给user, b是随机数)

        Both:  u = H(A, B)

        User:  x = H(s, p)                 (用户输入密码)
        User:  S = (B - kg^x) ^ (a + ux)   (计算会话密钥)
        User:  K = H(S)

        Host:  S = (Av^u) ^ b              (计算会话密钥)
        Host:  K = H(S)

这样双方都有一个会话密钥S, 后续的消息传输可以用S做加解密，从而保证安全。
为了完成认证过程，双方还得向对方证明自己拥有正确的S，
S不能让第三方知道，所以不能直接传输给对方做比较，一个可能的办法是:

User -> Host:  M = H(H(N) xor H(g), H(I), s, A, B, K)
Host -> User:  H(A, M, K)

双方需要做如下保障
    1. 如果客户端收到B == 0 (mod N) 或u == 0, 客户端停止认证。
    2. 如果服务器发现 A == 0 (mod N)则停止认证。
    3. 用户必须得证明自己拥有正确的K，否则服务器就会终止认证。
相关链接
HTTPS的七个误解（译文）
#T=Windows消息大全
Windows消息大全
消息，就是指Windows发出的一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows发送一个消息给应用程序。消息本身是作为一个记录传递给应用程序的，这个记录中包含了消息的类型以及其他信息。例如，对于单击鼠标所产生的消息来说，这个记录中包含了单击鼠标时的坐标。这个记录类型叫做TMsg，
它在Windows单元中是这样声明的：
type
TMsg = packed record
hwnd: HWND; / /窗口句柄
message: UINT; / /消息常量标识符
wParam: WPARAM ; // 32位消息的特定附加信息
lParam: LPARAM ; // 32位消息的特定附加信息
time: DWORD; / /消息创建时的时间
pt: TPoint; / /消息创建时的鼠标位置
end;
消息中有什么？
是否觉得一个消息记录中的信息像希腊语一样？如果是这样，那么看一看下面的解释：
hwnd 32位的窗口句柄。窗口可以是任何类型的屏幕对象，因为Win32能够维护大多数可视对象的句柄(窗口、对话框、按钮、编辑框等)。
message 用于区别其他消息的常量值，这些常量可以是Windows单元中预定义的常量，也可以是自定义的常量。
wParam 通常是一个与消息有关的常量值，也可能是窗口或控件的句柄。
lParam 通常是一个指向内存中数据的指针。由于WParam、lParam和Pointer都是32位的，因此，它们之间可以相互转换。
WM_NULL = $0000;
WM_CREATE = $0001;
应用程序创建一个窗口
WM_DESTROY = $0002;
一个窗口被销毁
WM_MOVE = $0003;
移动一个窗口
WM_SIZE = $0005;
改变一个窗口的大小
WM_ACTIVATE = $0006;
一个窗口被激活或失去激活状态；
WM_SETFOCUS = $0007;
获得焦点后
WM_KILLFOCUS = $0008;
失去焦点
WM_ENABLE = $000A;
改变enable状态
WM_SETREDRAW = $000B;
设置窗口是否能重画
WM_SETTEXT = $000C;
应用程序发送此消息来设置一个窗口的文本
WM_GETTEXT = $000D;
应用程序发送此消息来复制对应窗口的文本到缓冲区
WM_GETTEXTLENGTH = $000E;
得到与一个窗口有关的文本的长度（不包含空字符）
WM_PAINT = $000F;
要求一个窗口重画自己
WM_CLOSE = $0010;
当一个窗口或应用程序要关闭时发送一个信号
WM_QUERYENDSESSION = $0011;
当用户选择结束对话框或程序自己调用ExitWindows函数
WM_QUIT = $0012;
用来结束程序运行或当程序调用postquitmessage函数
WM_QUERYOPEN = $0013;
当用户窗口恢复以前的大小位置时，把此消息发送给某个图标
WM_ERASEBKGND = $0014;
当窗口背景必须被擦除时（例在窗口改变大小时）
WM_SYSCOLORCHANGE = $0015;
当系统颜色改变时，发送此消息给所有顶级窗口
WM_ENDSESSION = $0016;
当系统进程发出WM_QUERYENDSESSION消息后，此消息发送给应用程序，
通知它对话是否结束
WM_SYSTEMERROR = $0017;
WM_SHOWWINDOW = $0018;
当隐藏或显示窗口是发送此消息给这个窗口
WM_ACTIVATEAPP = $001C;
发此消息给应用程序哪个窗口是激活的，哪个是非激活的；
WM_FONTCHANGE = $001D;
当系统的字体资源库变化时发送此消息给所有顶级窗口
WM_TIMECHANGE = $001E;
当系统的时间变化时发送此消息给所有顶级窗口
WM_CANCELMODE = $001F;
发送此消息来取消某种正在进行的摸态（操作）
WM_SETCURSOR = $0020;
如果鼠标引起光标在某个窗口中移动且鼠标输入没有被捕获时，就发消息给某个窗口
WM_MOUSEACTIVATE = $0021;
当光标在某个非激活的窗口中而用户正按着鼠标的某个键发送此消息给当前窗口
WM_CHILDACTIVATE = $0022;
发送此消息给MDI子窗口当用户点击此窗口的标题栏，或当窗口被激活，移动，改变大小
WM_QUEUESYNC = $0023;
此消息由基于计算机的训练程序发送，通过WH_JOURNALPALYBACK的hook程序
分离出用户输入消息
WM_GETMINMAXINFO = $0024;
此消息发送给窗口当它将要改变大小或位置；
WM_PAINTICON = $0026;
发送给最小化窗口当它图标将要被重画
WM_ICONERASEBKGND = $0027;
此消息发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画
WM_NEXTDLGCTL = $0028;
发送此消息给一个对话框程序去更改焦点位置
WM_SPOOLERSTATUS = $002A;
每当打印管理列队增加或减少一条作业时发出此消息
WM_DRAWITEM = $002B;
当button，combobox，listbox，menu的可视外观改变时发送
此消息给这些空件的所有者
WM_MEASUREITEM = $002C;
当button, combo box, list box, list view control, or menu item 被创建时
发送此消息给控件的所有者
WM_DELETEITEM = $002D;
当the list box 或 combo box 被销毁 或 当 某些项被删除通过LB_DELETESTRING, LB_RESETCONTENT, CB_DELETESTRING, or CB_RESETCONTENT 消息
WM_VKEYTOITEM = $002E;
此消息有一个LBS_WANTKEYBOARDINPUT风格的发出给它的所有者来响应WM_KEYDOWN消息
WM_PAINTICON = $0026;
发送给最小化窗口当它图标将要被重画
WM_ICONERASEBKGND = $0027;
此消息发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画
WM_NEXTDLGCTL = $0028;
发送此消息给一个对话框程序去更改焦点位置
WM_SPOOLERSTATUS = $002A;
每当打印管理列队增加或减少一条作业时发出此消息
WM_DRAWITEM = $002B;
当button，combobox，listbox，menu的可视外观改变时发送
此消息给这些空件的所有者
WM_MEASUREITEM = $002C;
当button, combo box, list box, list view control, or menu item 被创建时
发送此消息给控件的所有者
WM_DELETEITEM = $002D;
当the list box 或 combo box 被销毁 或 当 某些项被删除通过LB_DELETESTRING, LB_RESETCONTENT, CB_DELETESTRING, or CB_RESETCONTENT 消息
WM_VKEYTOITEM = $002E;
此消息有一个LBS_WANTKEYBOARDINPUT风格的发出给它的所有者来响应WM_KEYDOWN消息
WM_GETOBJECT = $003D;
WM_COMPACTING = $0041;
显示内存已经很少了
WM_WINDOWPOSCHANGING = $0046;
发送此消息给那个窗口的大小和位置将要被改变时，来调用setwindowpos函数或其它窗口管理函数
WM_WINDOWPOSCHANGED = $0047;
发送此消息给那个窗口的大小和位置已经被改变时，来调用setwindowpos函数或其它窗口管理函数
WM_POWER = $0048;（适用于16位的windows）
当系统将要进入暂停状态时发送此消息
WM_COPYDATA = $004A;
当一个应用程序传递数据给另一个应用程序时发送此消息
WM_CANCELJOURNAL = $004B;
当某个用户取消程序日志激活状态，提交此消息给程序
WM_NOTIFY = $004E;
当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口
WM_INPUTLANGCHANGEREQUEST = $0050;
当用户选择某种输入语言，或输入语言的热键改变
WM_INPUTLANGCHANGE = $0051;
当平台现场已经被改变后发送此消息给受影响的最顶级窗口
WM_TCARD = $0052;
当程序已经初始化windows帮助例程时发送此消息给应用程序
WM_HELP = $0053;
此消息显示用户按下了F1，如果某个菜单是激活的，就发送此消息个此窗口关联的菜单，否则就发送给有焦点的窗口，如果当前都没有焦点，就把此消息发送给当前激活的窗口
WM_USERCHANGED = $0054;
当用户已经登入或退出后发送此消息给所有的窗口，当用户登入或退出时系统更新用户的具体设置信息，在用户更新设置时系统马上发送此消息；
WM_NOTIFYFORMAT = $0055;
公用控件，自定义控件和他们的父窗口通过此消息来判断控件是使用ANSI还是UNICODE结构
在WM_NOTIFY消息，使用此控件能使某个控件与它的父控件之间进行相互通信
WM_CONTEXTMENU = $007B;
当用户某个窗口中点击了一下右键就发送此消息给这个窗口
WM_STYLECHANGING = $007C;
当调用SETWINDOWLONG函数将要改变一个或多个 窗口的风格时发送此消息给那个窗口
WM_STYLECHANGED = $007D;
当调用SETWINDOWLONG函数一个或多个 窗口的风格后发送此消息给那个窗口
WM_DISPLAYCHANGE = $007E;
当显示器的分辨率改变后发送此消息给所有的窗口
WM_GETICON = $007F;
此消息发送给某个窗口来返回与某个窗口有关连的大图标或小图标的句柄；
WM_SETICON = $0080;
程序发送此消息让一个新的大图标或小图标与某个窗口关联；
WM_NCCREATE = $0081;
当某个窗口第一次被创建时，此消息在WM_CREATE消息发送前发送；
WM_NCDESTROY = $0082;
此消息通知某个窗口，非客户区正在销毁
WM_NCCALCSIZE = $0083;
当某个窗口的客户区域必须被核算时发送此消息
WM_NCHITTEST = $0084;//移动鼠标，按住或释放鼠标时发生
WM_NCPAINT = $0085;
程序发送此消息给某个窗口当它（窗口）的框架必须被绘制时；
WM_NCACTIVATE = $0086;
此消息发送给某个窗口 仅当它的非客户区需要被改变来显示是激活还是非激活状态；
WM_GETDLGCODE = $0087;
发送此消息给某个与对话框程序关联的控件，widdows控制位键和TAB键使输入进入此控件
通过响应WM_GETDLGCODE消息，应用程序可以把他当成一个特殊的输入控件并能处理它
WM_NCMOUSEMOVE = $00A0;
当光标在一个窗口的非客户区内移动时发送此消息给这个窗口 //非客户区为：窗体的标题栏及窗的边框体
WM_SETICON = $0080;
程序发送此消息让一个新的大图标或小图标与某个窗口关联；
WM_NCCREATE = $0081;
当某个窗口第一次被创建时，此消息在WM_CREATE消息发送前发送；
WM_NCDESTROY = $0082;
此消息通知某个窗口，非客户区正在销毁
WM_NCCALCSIZE = $0083;
当某个窗口的客户区域必须被核算时发送此消息
WM_NCHITTEST = $0084;//移动鼠标，按住或释放鼠标时发生
WM_NCPAINT = $0085;
程序发送此消息给某个窗口当它（窗口）的框架必须被绘制时；
WM_NCACTIVATE = $0086;
此消息发送给某个窗口 仅当它的非客户区需要被改变来显示是激活还是非激活状态；
WM_GETDLGCODE = $0087;
发送此消息给某个与对话框程序关联的控件，widdows控制位键和TAB键使输入进入此控件
通过响应WM_GETDLGCODE消息，应用程序可以把他当成一个特殊的输入控件并能处理它
WM_NCMOUSEMOVE = $00A0;
当光标在一个窗口的非客户区内移动时发送此消息给这个窗口 //非客户区为：窗体的标题栏及窗的边框体
//释放一个键
WM_CHAR = $0102;
//按下某键，并已发出WM_KEYDOWN， WM_KEYUP消息
WM_DEADCHAR = $0103;
当用translatemessage函数翻译WM_KEYUP消息时发送此消息给拥有焦点的窗口
WM_SYSKEYDOWN = $0104;
当用户按住ALT键同时按下其它键时提交此消息给拥有焦点的窗口；
WM_SYSKEYUP = $0105;
当用户释放一个键同时ALT 键还按着时提交此消息给拥有焦点的窗口
WM_SYSCHAR = $0106;
当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后提交此消息给拥有焦点的窗口
WM_SYSDEADCHAR = $0107;
当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后发送此消息给拥有焦点的窗口
WM_KEYLAST = $0108;
WM_INITDIALOG = $0110;
在一个对话框程序被显示前发送此消息给它，通常用此消息初始化控件和执行其它任务
WM_COMMAND = $0111;
当用户选择一条菜单命令项或当某个控件发送一条消息给它的父窗口，一个快捷键被翻译
WM_SYSCOMMAND = $0112;
当用户选择窗口菜单的一条命令或当用户选择最大化或最小化时那个窗口会收到此消息
WM_TIMER = $0113; //发生了定时器事件
WM_HSCROLL = $0114;
当一个窗口标准水平滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件
WM_VSCROLL = $0115;
当一个窗口标准垂直滚动条产生一个滚动事件时发送此消息给那个窗口也，发送给拥有它的控件WM_INITMENU = $0116;
当一个菜单将要被激活时发送此消息，它发生在用户菜单条中的某项或按下某个菜单键，它允许程序在显示前更改菜单
WM_INITMENUPOPUP = $0117;
当一个下拉菜单或子菜单将要被激活时发送此消息，它允许程序在它显示前更改菜单，而不要改变全部
WM_MENUSELECT = $011F;
当用户选择一条菜单项时发送此消息给菜单的所有者（一般是窗口）
WM_MENUCHAR = $0120;
当菜单已被激活用户按下了某个键（不同于加速键），发送此消息给菜单的所有者；
WM_ENTERIDLE = $0121;
当一个模态对话框或菜单进入空载状态时发送此消息给它的所有者，一个模态对话框或菜单进入空载状态就是在处理完一条或几条先前的消息后没有消息它的列队中等待
WM_MENURBUTTONUP = $0122;
WM_MENUDRAG = $0123;
WM_MENUGETOBJECT = $0124;
WM_UNINITMENUPOPUP = $0125;
WM_MENUCOMMAND = $0126;
WM_CHANGEUISTATE = $0127;
WM_UPDATEUISTATE = $0128;
WM_QUERYUISTATE = $0129;
WM_CTLCOLORMSGBOX = $0132;
在windows绘制消息框前发送此消息给消息框的所有者窗口，通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置消息框的文本和背景颜色
WM_CTLCOLOREDIT = $0133;
当一个编辑型控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口
可以通过使用给定的相关显示设备的句柄来设置编辑框的文本和背景颜色
WM_CTLCOLORLISTBOX = $0134;
当一个列表框控件将要被绘制前发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置列表框的文本和背景颜色
WM_CTLCOLORBTN = $0135;
当一个按钮控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置按纽的文本和背景颜色
WM_CTLCOLORDLG = $0136;
当一个对话框控件将要被绘制前发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置对话框的文本背景颜色
WM_CTLCOLORSCROLLBAR= $0137;
当一个滚动条控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置滚动条的背景颜色
WM_CTLCOLORSTATIC = $0138;
当一个静态控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置静态控件的文本和背景颜色
WM_MOUSEFIRST = $0200;
WM_MOUSEMOVE = $0200;
// 移动鼠标
WM_LBUTTONDOWN = $0201;
在windows绘制消息框前发送此消息给消息框的所有者窗口，通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置消息框的文本和背景颜色
WM_CTLCOLOREDIT = $0133;
当一个编辑型控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口
可以通过使用给定的相关显示设备的句柄来设置编辑框的文本和背景颜色
WM_CTLCOLORLISTBOX = $0134;
当一个列表框控件将要被绘制前发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置列表框的文本和背景颜色
WM_CTLCOLORBTN = $0135;
当一个按钮控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置按纽的文本和背景颜色
WM_CTLCOLORDLG = $0136;
当一个对话框控件将要被绘制前发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置对话框的文本背景颜色
WM_CTLCOLORSCROLLBAR= $0137;
当一个滚动条控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置滚动条的背景颜色
WM_CTLCOLORSTATIC = $0138;
当一个静态控件将要被绘制时发送此消息给它的父窗口；通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置静态控件的文本和背景颜色
WM_MOUSEFIRST = $0200;
WM_MOUSEMOVE = $0200;
// 移动鼠标
WM_LBUTTONDOWN = $0201;
　WM_MOUSELAST = $020A;
WM_PARENTNOTIFY = $0210;
当MDI子窗口被创建或被销毁，或用户按了一下鼠标键而光标在子窗口上时发送此消息给它的父窗口
WM_ENTERMENULOOP = $0211;
发送此消息通知应用程序的主窗口that已经进入了菜单循环模式
WM_EXITMENULOOP = $0212;
发送此消息通知应用程序的主窗口that已退出了菜单循环模式
WM_NEXTMENU = $0213;
WM_SIZING = 532;
当用户正在调整窗口大小时发送此消息给窗口；通过此消息应用程序可以监视窗口大小和位
置也可以修改他们
WM_CAPTURECHANGED = 533;
发送此消息 给窗口当它失去捕获的鼠标时；
WM_MOVING = 534;
当用户在移动窗口时发送此消息，通过此消息应用程序可以监视窗口大小和位置也可以修改他们；
WM_POWERBROADCAST = 536;
此消息发送给应用程序来通知它有关电源管理事件；
WM_DEVICECHANGE = 537;
当设备的硬件配置改变时发送此消息给应用程序或设备驱动程序
WM_IME_STARTCOMPOSITION = $010D;
WM_IME_ENDCOMPOSITION = $010E;
WM_IME_COMPOSITION = $010F;
WM_IME_KEYLAST = $010F;
WM_IME_SETCONTEXT = $0281;
WM_IME_NOTIFY = $0282;
WM_IME_CONTROL = $0283;
WM_IME_COMPOSITIONFULL = $0284;
WM_IME_SELECT = $0285;
WM_IME_CHAR = $0286;
WM_IME_REQUEST = $0288;
WM_IME_KEYDOWN = $0290;
WM_IME_KEYUP = $0291;
WM_MDICREATE = $0220;
应用程序发送此消息给多文档的客户窗口来创建一个MDI 子窗口
WM_MDIDESTROY = $0221;
应用程序发送此消息给多文档的客户窗口来关闭一个MDI 子窗口
WM_MDIACTIVATE = $0222;
应用程序发送此消息给多文档的客户窗口通知客户窗口激活另一个MDI子窗口，当客户窗口收到此消息后，它发出WM_MDIACTIVE消息给MDI子窗口（未激活）激活它；
WM_MDIRESTORE = $0223;
程序发送此消息给MDI客户窗口让子窗口从最大最小化恢复到原来大小
WM_MDINEXT = $0224;
程序发送此消息给MDI客户窗口激活下一个或前一个窗口
WM_MDIMAXIMIZE = $0225;
程序发送此消息给MDI客户窗口来最大化一个MDI子窗口；
WM_MDITILE = $0226;
程序发送此消息给MDI客户窗口以平铺方式重新排列所有MDI子窗口
WM_MDICASCADE = $0227;
程序发送此消息给MDI客户窗口以层叠方式重新排列所有MDI子窗口
WM_MDIICONARRANGE = $0228;
程序发送此消息给MDI客户窗口重新排列所有最小化的MDI子窗口
WM_MDIGETACTIVE = $0229;
程序发送此消息给MDI客户窗口来找到激活的子窗口的句柄
WM_MDISETMENU = $0230;
程序发送此消息给MDI客户窗口用MDI菜单代替子窗口的菜单
WM_ENTERSIZEMOVE = $0231;
WM_EXITSIZEMOVE = $0232;
WM_DROPFILES = $0233;
WM_MDIREFRESHMENU = $0234;
WM_MOUSEHOVER = $02A1;
WM_MOUSELEAVE = $02A3;
WM_CU = $0300;
程序发送此消息给一个编辑框或combobox来删除当前选择的文本
WM_COPY = $0301;
程序发送此消息给一个编辑框或combobox来复制当前选择的文本到剪贴板
WM_PASTE = $0302;
程序发送此消息给editcontrol或combobox从剪贴板中得到数据
WM_CLEAR = $0303;
程序发送此消息给editcontrol或combobox清除当前选择的内容；
WM_UNDO = $0304;
程序发送此消息给editcontrol或combobox撤消最后一次操作
WM_RENDERFORMAT = $0305；
WM_RENDERALLFORMATS = $0306;
WM_DESTROYCLIPBOARD = $0307;
当调用ENPTYCLIPBOARD函数时 发送此消息给剪贴板的所有者
WM_DRAWCLIPBOARD = $0308;
当剪贴板的内容变化时发送此消息给剪贴板观察链的第一个窗口；它允许用剪贴板观察窗口
来显示剪贴板的新内容；
WM_PAINTCLIPBOARD = $0309;
当剪贴板包含CF_OWNERDIPLAY格式的数据并且剪贴板观察窗口的客户区需要重画；
WM_VSCROLLCLIPBOARD = $030A;
WM_SIZECLIPBOARD = $030B;
当剪贴板包含CF_OWNERDIPLAY格式的数据并且剪贴板观察窗口的客户区域的大小已经改变是
此消息通过剪贴板观察窗口发送给剪贴板的所有者；
WM_ASKCBFORMATNAME = $030C;
通过剪贴板观察窗口发送此消息给剪贴板的所有者来请求一个CF_OWNERDISPLAY格式的剪贴板的名字
WM_CHANGECBCHAIN = $030D;
当一个窗口从剪贴板观察链中移去时发送此消息给剪贴板观察链的第一个窗口；
WM_HSCROLLCLIPBOARD = $030E;
此消息通过一个剪贴板观察窗口发送给剪贴板的所有者 ；它发生在当剪贴板包含CFOWNERDISPALY格式的数据并且有个事件在剪贴板观察窗的水平滚动条上；所有者应滚动剪贴板图象并更新滚动条的值；
WM_QUERYNEWPALETTE = $030F;
此消息发送给将要收到焦点的窗口，此消息能使窗口在收到焦点时同时有机会实现他的逻辑调色板
WM_PALETTEISCHANGING= $0310;
当一个应用程序正要实现它的逻辑调色板时发此消息通知所有的应用程序
WM_PALETTECHANGED = $0311;
此消息在一个拥有焦点的窗口实现它的逻辑调色板后发送此消息给所有顶级并重叠的窗口，以此来改变系统调色板
WM_HOTKEY = $0312;
当用户按下由REGISTERHOTKEY函数注册的热键时提交此消息
WM_PRINT = 791;
应用程序发送此消息仅当WINDOWS或其它应用程序发出一个请求要求绘制一个应用程序的一部分；
WM_PRINTCLIENT = 792;
WM_HANDHELDFIRST = 856;
WM_HANDHELDLAST = 863;
WM_PENWINFIRST = $0380;
WM_PENWINLAST = $038F;
WM_COALESCE_FIRST = $0390;
WM_COALESCE_LAST = $039F;
WM_DDE_FIRST = $03E0;
WM_DDE_INITIATE = WM_DDE_FIRST + 0;
一个DDE客户程序提交此消息开始一个与服务器程序的会话来响应那个指定的程序和主题名；
WM_DDE_TERMINATE = WM_DDE_FIRST + 1;
一个DDE应用程序（无论是客户还是服务器）提交此消息来终止一个会话；
WM_DDE_ADVISE = WM_DDE_FIRST + 2;
一个DDE客户程序提交此消息给一个DDE服务程序来请求服务器每当数据项改变时更新它
WM_DDE_UNADVISE = WM_DDE_FIRST + 3;
一个DDE客户程序通过此消息通知一个DDE服务程序不更新指定的项或一个特殊的剪贴板格式
的项
WM_DDE_ACK = WM_DDE_FIRST + 4;
此消息通知一个DDE（动态数据交换）程序已收到并正在处理WM_DDE_POKE, WM_DDE_EXECUTE, WM_DDE_DATA, WM_DDE_ADVISE, WM_DDE_UNADVISE, or WM_DDE_INITIAT消息
WM_DDE_DATA = WM_DDE_FIRST + 5;
一个DDE服务程序提交此消息给DDE客户程序来传递个一数据项给客户或通知客户的一条可用数据项WM_DDE_REQUEST = WM_DDE_FIRST + 6;
一个DDE客户程序提交此消息给一个DDE服务程序来请求一个数据项的值；
WM_DDE_POKE = WM_DDE_FIRST + 7;
一个DDE客户程序提交此消息给一个DDE服务程序，客户使用此消息来请求服务器接收一个未经同意的数据项；服务器通过答复WM_DDE_ACK消息提示是否它接收这个数据项；
WM_DDE_EXECUTE = WM_DDE_FIRST + 8;
一个DDE客户程序提交此消息给一个DDE服务程序来发送一个字符串给服务器让它象串行命令一样被处理，服务器通过提交WM_DDE_ACK消息来作回应；
WM_DDE_LAST = WM_DDE_FIRST + 8;
WM_APP = $8000;
WM_USER = $0400;
此消息能帮助应用程序自定义私有消息；
通知消息(Notification message)是指这样一种消息，一个窗口内的子控件发生了一些事情，需要通知父窗口。通知消息只适用于标准的窗口控件如按钮、列表框、组合框、编辑框，以及Windows 95公共控件如树状视图、列表视图等。例如，单击或双击一个控件、在控件中选择部分文本、操作控件的滚动条都会产生通知消息。
按扭
B N _ C L I C K E D //用户单击了按钮
B N _ D I S A B L E //按钮被禁止
B N _ D O U B L E C L I C K E D //用户双击了按钮
B N _ H I L I T E //用户加亮了按钮
B N _ PA I N T按钮应当重画
B N _ U N H I L I T E加亮应当去掉
组合框
C B N _ C L O S E U P组合框的列表框被关闭
C B N _ D B L C L K用户双击了一个字符串
C B N _ D R O P D O W N组合框的列表框被拉出
C B N _ E D I T C H A N G E用户修改了编辑框中的文本
C B N _ E D I T U P D AT E编辑框内的文本即将更新
C B N _ E R R S PA C E组合框内存不足
C B N _ K I L L F O C U S组合框失去输入焦点
C B N _ S E L C H A N G E在组合框中选择了一项
C B N _ S E L E N D C A N C E L用户的选择应当被取消
C B N _ S E L E N D O K用户的选择是合法的
C B N _ S E T F O C U S组合框获得输入焦点
　编辑框
E N _ C H A N G E编辑框中的文本己更新
E N _ E R R S PA C E编辑框内存不足
E N _ H S C R O L L用户点击了水平滚动条
E N _ K I L L F O C U S编辑框正在失去输入焦点
E N _ M A X T E X T插入的内容被截断
E N _ S E T F O C U S编辑框获得输入焦点
E N _ U P D AT E编辑框中的文本将要更新
E N _ V S C R O L L用户点击了垂直滚动条消息含义
列表框
L B N _ D B L C L K用户双击了一项
L B N _ E R R S PA C E列表框内存不够
L B N _ K I L L F O C U S列表框正在失去输入焦点
L B N _ S E L C A N C E L选择被取消
L B N _ S E L C H A N G E选择了另一项
L B N _ S E T F O C U S列表框获得输入焦点


#T=测试人员应该具备怎样的软技能
软技能实际上是指那些“不易看见的技能”，是一个人“激发自己潜能和通过赢得他人认可和合作放大自己的资源，以获得超越自身独立能力的更大成功的技能”的总和。

软技能其实是情商 EQ（Emotional Intelligency Quotient）的社会学术语，它由一系列能够反映个人特质的要素组成，这些要素包括一个人的人格特质、社交能力、沟通能力、语言能力、个人行为习惯、待人友善、积极乐观等。软技能与硬技能（那些作为工作硬性要求并能够部分反映一个人智商的能力）是互补的。软技能（情商）可在一个组织的成功中扮演非常重要的角色。总的来说，软技能一方面体现在工作和生活中解决问题、处理问题的能力；另一方面体现在通过赢得他人认可和合作，放大本人资源以获取更大成功的能力。

测试人员在软件开发生命周期中，除了独立完成测试任务以外，还需要和项目的不同利益相关者进行合作，包括项目经理、开发人员或者用户等。测试人员需要向项目经理/测试经理反馈测试进度、产品质量等信息，同时还需要从项目经理/测试经理处获得项目的进展和状态，例如：项目内容或进度的变更。在测试过程中，无论是提交缺陷还是文档评审，测试人员都离不开和开发人员的合作和沟通。测试人员还可能需要从客户那里了解用户是如何使用产品的，或者因为产品的质量问题，从用户那里得到反馈甚至抱怨。因此，在复杂的测试工作环境中，测试人员除了必备的专业知识和测试技能以外，还需要具备一定的软技能。下面介绍测试人员在测试过程中需要具备的软技能。

怀疑精神

发现缺陷是测试过程中的主要目的之一，因此，测试人员对被测产品要有怀疑精神，即怀疑测试对象存在缺陷或者是无法正常工作的。很难想象，缺乏怀疑精神的测试人员能够有效地发现软件产品中的缺陷，从而达到尽量多地发现缺陷这样的目标。在静态测试过程中（例如：评审），无论是系统的需求规格说明还是设计规格说明，测试人员都应该以怀疑的态度去对它们进行分析和评估；在动态测试过程中，也同样需要怀疑精神，这样才能更有效地发现缺陷。同时，怀疑精神不仅仅适用于开发活动的交付物上，同样也适用于测试团队的交付物上，例如：对于测试团队设计的测试用例，也不能盲目相信它们不会存在错误和缺陷，这些测试用例同样需要经过项目利益相关者的评审，例如：开发人员或客户，在测试执行的时候，发现实际结果和预期结果不一致的时候，首先需要确保测试用例是否正确，同时确保测试执行的过程、数据、操作等没有问题，然后确认是否是测试对象没有实现规格说明中要求的功能或者不一致，这都需要测试人员具有怀疑精神。如图 1：软件测试人员职业能力框架图。

图 1. 软件测试员职业能力框架图

SoftAbilityPic1

好奇心

好奇心是人们希望自己能知道或了解更多事物的不满足心态。好奇心不仅是要对某一事物感到疑惑和好奇，还要继续思索以求明白事情的真相，所以好奇心是创造的出发点、动机和推动力，也是产生无穷毅力和耐心的源泉。测试人员尤其是参与集成测试和系统测试的人员需要了解很多知识，他们不仅要掌握软件系统的多个功能模块，甚至是整个系统的需求和设计，同时还要从用户的角度思考系统的使用方式。如果测试人员只关注很小范围内的信息或知识，那么他不会成为一名优秀的测试人员。测试人员对整个产品和用户环境要充满好奇心，才能驱使自己不断地学习和进步，掌握更全面的知识。

另外，除了怀疑精神，好奇心也是测试人员找到更多缺陷的基础。当测试人员在测试软件系统的过程中，碰到了一个异常的系统表现行为，对于有好奇心的测试人员而言，他会深入研究为什么会出现异常行为，并通过不断地分析和探索，找到其中的原因，例如：由于软件产品中存在的隐秘缺陷，在偶然触发的情况下导致了这样的异常行为。而对于没有好奇心的测试人员，可能就会遗漏了这样的缺陷。

创新能力

创新能力是运用知识和理论，在科学、艺术、技术和各种实践活动领域中不断提供具有经济价值、社会价值、生态价值的新思想、新理论、新方法和新发明的能力。创新能力能够根据已经存在的基础事物来创造一些新的特别的元素。创新能力可以通过一些好的实践来进行提高。在日常工作中，对问题的思考角度能够影响一个人的创新能力，当出现问题的时候，要尝试从不同的角度来分析问题，这样才能创造性地解决问题。还有一些好的习惯都有利于提高创新能力。当人处于比较放松的状态下、全面阅读尽可能多的知识、认为每个问题都是特别的、推迟做出决定和对新奇的想法保持开放的态度都有助于创新能力的提高。创新同时也意味着要打破常规，避免重复性的思考。想要获得更好的创新能力，就不能害怕尝试新鲜事物，也不要对一个想法迅速做出肯定或否定的判断。从测试计划一直到测试结束活动，整个测试过程将会遇到各种各样的问题，这个时候就需要测试人员充分应用自己的创新能力，创造性地解决这些问题，以帮助项目获得更大的成功。

分析能力

分析能力是指把一件事情、一种现象、一个概念分成较简单的组成部分，找出这些部分的本质属性和彼此之间的关系单独进行剖析、分辨、观察和研究的一种能力。随着软件系统和产品功能的不断增强，软件产品变得越来越复杂，这就使得测试活动也变得越来越困难，因此，对测试人员的分析能力要求也越来越高。测试过程是一个不断计划、分析和评估的过程，测试人员没有良好的分析能力，就无法高质量地完成测试任务，例如：测试计划和控制阶段，测试团队需要分析测试的范围、测试采用的技术和方法、测试的工作量、测试的风险等，根据测试过程中得到的信息和状态，分析计划和实际进度之间的偏差，调整测试资源、测试优先级和测试计划等；在测试分析和设计阶段，测试人员需要不断学习和了解被测试对象的测试依据文档（例如：需求规格说明），对被测试对象进行详细分析，确定如何采用测试计划中定义的测试技术和方法来设计相应的测试用例；在测试实现和执行阶段，根据测试执行过程中发现的失效，分析其失效的影响，并判断失效的严重程度和优先级，从而不断地调整测试资源的分配和测试任务的优先级。

耐心

软件开发一般被看做是建设性的活动，而软件测试常常在一定程度上被看成是破坏性的活动。但是软件测试的这种破坏性的活动并不是每次都能“破坏”成功的。在测试过程中经常出现这样的现象：尽管运行了很多的测试用例，但是没有在测试对象中发现任何的失效。这个时候，就要求测试人员具有足够的耐心。开发人员的重要输出是软件产品的代码，软件代码的数量会随着开发的深入持续不断地增长，这将极大地激发开发人员的成就感。但是测试人员不同，测试人员就像猎人一样，要经过漫长的“狩猎”过程才可能发现一个“猎物”。即使测试对象出现了异常行为，也需要测试人员经过耐心地分析和研究，才可能最终确定是否是缺陷。通常来说，测试对象的异常现象经常隐藏在大量的系统正常行为之中。因此，需要测试人员耐心检查各种数据、操作和系统表现行为，才能够发现其中的异常。

沟通技巧

所谓沟通技巧，对软件测试者来说，是具有收集和发送信息的能力，能通过书写、口头与肢体语言的媒介，有效与明确地向他人表达自己的想法、感受与态度，亦能较快、正确地解读他人的信息，从而了解他人的想法、感受与态度。 沟通技能涉及许多方面，如简化运用语言、积极倾听、重视反馈、控制情绪等等。虽然拥有沟通技能并不意味着成为一个有效的软件测试者，但缺乏沟通技能又会使软件测试者遇到许多麻烦和障碍。测试并不是独立存在的，而是软件开生命周期中的重要组成部分。实际的软件项目通常是由各种不同角色的人合作完成的，这样就难免会遇到需要和他人合作完成一项任务的问题，这个时候沟通就很关键。尤其是在当今全球化程度越来越高的情况下，很多项目由位于世界各地的团队共同完成，沟通就更加重要。沟通的方式有很多，可以是面对面的交流、电话或 Email，也可以通过文档和缺陷报告来交流信息。测试人员在整个项目开发过程中可能需要和项目经理、开发人员或用户等多种角色进行交流，良好的沟通能力有利于测试活动的开展。

团队精神

团队精神，在软件开发与测试周期过程中来说就是大局意识、协作精神和服务精神的集中体现。团队精神的基础是尊重个人的兴趣和成就。核心是协同合作，最高境界是全体成员的向心力、凝聚力，反映的是个体利益和整体利益的统一，并进而保证组织的高效率运转。随着社会的发展，社会的分工越来越细化，这同样适用于软件开发和软件测试，软件开发生命周期中的任务通常都需要通过团队来完成。团队并不是一群人的机械组合，真正的团队应该有共同的目标，其成员之间的行为相互依存和影响，并且团队成员之间能够很好地合作，从而追求集体的成功。团队是一个有机整体，团队成员除了具有独立完成工作的能力之外，同时还需要具有与他人合作共同完成工作的能力。团队的绩效源于团队成员个人的贡献，同时永远大于单个团队成员贡献的总和。团队精神是大局意识、协作精神和服务精神的集中体现。团队精神要求团队成员有统一的奋斗目标或价值观，而且需要相互信赖，需要正确而统一的企业文化理念的传递和灌输。团队精神强调的是组织内部成员间的合作态度，为了一个统一的目标，成员自觉地认同肩负的责任并愿意为此目标共同奉献。在测试人员的工作中，团队不仅是指测试人员之间应该有团队意识，作为项目的一分子，测试人员和开发人员也是一个团队。只有整个项目具备了团队精神，项目才能获得最终的成功。

工作热情

测试活动充满了艰辛和挑战。测试人员只有始终保持积极的态度和工作热情，才能够出色地完成各种测试任务和接受各种挑战。没有激情的测试人员，只会满足于完成基本的测试任务；而充满激情的测试人员不仅能够完成基本测试任务，还能够用积极的态度思考测试过程中遇到的各种问题，努力寻找解决方案，创造性地解决这些问题。同时还可以积极地对自己进行反省，不断地寻找团队和自己的不足，从而进行持续的改进。

技术能力

就总体而言，大多数开发人员对那些不懂技术的人有时或许持一种轻视的态度。一旦测试小组的某个成员做出了一个错误的断定，或者在没完全正确理解产品特性的基础上冒失的提出一个错误的软件缺陷，那么测试团队的可信度就会受到开发团队以及项目经理的挑战。测试人员必须既熟悉被测软件系统的原理、流程又要掌握一定的代码能力。既能读懂开发人员写的代码，同时也要能发现代码中存在的问题。

超强记忆力以及自我督促能力

一个优秀的软件测试人员应该具备超强的记忆力。能够把之前遇到过的各种产品缺陷深入理解后，进行分类记忆存储。当在以后的测试中遇到与之前软件缺陷缺陷类似的软件缺陷时，从记忆深处快速挖掘出之前的软件缺陷，相互比较，找到该缺陷的根源。这一能力在测试过程中的价值是无法衡量的。因为许多新出现的问题和我们已经发现的问题相差无几。

同时干测试工作，尤其是经常用手工进行回归测试时，由于该测试已经在各个场景下跑了太多的次数，所以会让测试人员变得索然无味，同时很难调动测试人员的工作积极性，同时容易使你变得懒散。当测试人员是一个具有自我督促能力的人才能够使自己每天正常地工作。认真全面的执行每一条测试。

持续学习能力

学习能力为智力结构中与学习密切相关的那一部分能力，主要包括理解力、记忆力、问题解决能力及评价能力。软件测试人员必须保持不断学习的状态。计算机技术日新月异，无论从理论还是实践，知识更新都非常快。所以测试人员必须不断学习，了解掌握最新的测试理论、测试技术、以及其他领域的计算机技术例如云计算、敏捷开发与测试等。并在测试中，将这些理论知识付诸实践，让测试人员的测试边变得更有效、更高效。
#T=测试面试题
1.	需求
1)	你能给出一些非功能性（或者质量）需求的例子么？
2)	如果客户需要高性能、使用极其方便而又高度安全，你会给他什么建议？
3)	你能给出一些用来描述需求的不同技术么？它们各自适用于什么场景？
4)	需求跟踪是什么意思？什么是向前追溯，什么是向后追溯？
5)	你喜欢用什么工具跟踪需求？
6)	你怎么看待需求变化？它是好是坏？给出你的理由。
7)	你怎样研究需求，发现需求？有哪些资源可以用到？
8)	你怎么给需求制定优先级？有哪些技术？
9)	在需求过程中，用户、客户、开发人员各自的职责是什么？
10)	你怎么对待不完整或是令人费解的需求？


2.	功能设计
1)	在功能设计中有哪些隐喻？给出几个成功的例子。
2)	如果有些功能的执行时间很长，怎么能让用户感觉不到太长的等待？
3)	如果用户必须要在一个很小的区域内，从一个常常的列表中选择多个条目，你会用什么控件？
4)	有哪些方法可以保证数据项的完整？
5)	建立系统原型有哪些技术？
6)	应用程序怎样建立对用户行为的预期？给出一些例子。
7)	如何入手设计一组数量庞大而又复杂的特性，你能举出一些设计思路吗？
8)	有一个列表，其中有10个元素，每个元素都有20个字段可以编辑，你怎样设计这种情况？如果是1000个元素，每个元素有3个字段呢？
9)	用不同的颜色对一段文本中的文字标记高亮，这种做法有什么问题？
10)	Web环境和Windows环境各有些什么限制？


3.	技术设计
1)	什么是低耦合和高聚合？封装原则又是什么意思？
2)	在Web应用中，你怎样避免几个人编辑同一段数据所造成的冲突？
3)	你知道设计模式吗？你用过哪些设计模式？在什么场合下用的？
4)	是否了解什么是无状态的业务层？长事务如何与之相适应？
5)	在搭建一个架构，或是技术设计时，你用过几种图？
6)	在N层架构中都有哪些层？它们各自的职责是什么？
7)	有哪些方法可以确保架构中数据的正确和健壮？
8)	面向对象设计和面向组件设计有哪些不同之处？
9)	怎样在数据库中对用户授权、用户配置、权限管理这几项功能建模？
10)	怎样按照等级制度给动物王国（包括各种物种和各自的行为）建模？


4.	程序设计
1)	你怎样保证你的代码可以处理各种错误事件？
2)	解释一下什么是测试驱动开发，举出极限编程中的一些原则。
3)	看别人代码的时候，你最关心什么地方？
4)	什么时候使用抽象类，什么时候使用接口？
5)	除了IDE以外，你还喜欢哪些必不可少的工具？
6)	你怎么保证代码执行速度快，而又不出问题？
7)	什么时候用多态，什么时候用委派？
8)	什么时候使用带有静态成员的类，什么时候使用单例？
9)	你在代码里面怎么提前处理需求的变化？给一些例子。
10)	描述一下实现一段代码的过程，从需求到最终交付。


5.	算法
1)	怎样知道一个数字是不是2的乘方？怎样判断一个数是不是奇数？
2)	怎样找出链表中间的元素？
3)	怎样改变10,000个静态HTML页面中所有电话号码的格式？
4)	举出一个你所用过的递归的例子。
5)	在散列表和排序后的列表中找一个元素，哪个查找速度最快？
6)	不管是书、杂志还是网络，你从中所学到的最后一点算法知识是什么？
7)	怎样把字符串反转？你能不用临时的字符串么？
8)	你愿意用什么类型的语言来编写复杂的算法？
9)	有一个数组，里面是从1到1,000,000的整数，其中有一个数字出现了两次，你怎么找出那个重复的数字？
10)	你知道“旅行商问题（Traveling Salesman Problem）”么？


6.	数据结构
1)	怎样在内存中实现伦敦地铁的结构？
2)	怎样以最有效的方式在数据库中存储颜色值？
3)	队列和堆栈区别是什么？
4)	用堆或者栈存储数据的区别是什么？
5)	怎样在数据库中存储N维向量？
6)	你倾向于用哪种类型的语言编写复杂的数据结构？
7)	21的二进制值是什么？十六制值呢？
8)	不管是书、杂志还是网络，你从中所学到的最后一点数据结构的知识是什么？
9)	怎样在XML文档中存储足球比赛结果（包括队伍和比分）？
10)	有哪些文本格式可以保存Unicode字符？


7.	测试
1)	什么是回归测试？怎样知道新引入的变化没有给现有的功能造成破坏？
2)	如果业务层和数据层之间有依赖关系，你该怎么写单元测试？
3)	你用哪些工具测试代码质量？
4)	在产品部署之后，你最常碰到的是什么类型的问题？
5)	什么是代码覆盖率？有多少种代码覆盖率？
6)	功能测试和探索性测试的区别是什么？你怎么对网站进行测试？
7)	测试套件、测试用例、测试计划，这三者之间的区别是什么？你怎么组织测试？
8)	要对电子商务网站做冒烟测试，你会做哪些类型的测试？
9)	客户在验收测试中会发现不满意的东西，怎样减少这种情况的发生？
10)	你去年在测试和质量保证方面学到了哪些东西？


8.	维护
1)	你用哪些工具在维护阶段对产品进行监控？
2)	要想对一个正在产品环境中被使用的产品进行升级，该注意哪些重要事项？
3)	如果在一个庞大的文件中有错误，而代码又无法逐步跟踪，你怎么找出错误？
4)	你怎样保证代码中的变化不会影响产品的其他部分？
5)	你怎样为产品编写技术文档？
6)	你用过哪些方式保证软件产品容易维护？
7)	怎样在产品运行的环境中进行系统调试？
8)	什么是负载均衡？负载均衡的方式有哪些种？
9)	为什么在应用程序的生命周期中，软件维护费用所占的份额最高？
10)	再造工程（re-engineering）和逆向工程（reverse engineering）的区别是什么？


9.	配置管理
1)	你知道配置管理中基线的含义么？怎样把项目中某个重要的时刻冻结？
2)	你一般会把哪些东西纳入版本控制？
3)	怎样可以保证团队中每个人都知道谁改变了哪些东西？
4)	Tag和Branch的区别是什么？在什么情况下该使用tag，什么时候用branch？
5)	怎样管理技术文档――如产品架构文档――的变化？
6)	你用什么工具管理项目中所有数字信息的状态？你最喜欢哪种工具？
7)	如果客户想要对一款已经发布的产品做出变动，你怎么处理？
8)	版本管理和发布管理有什么差异？
9)	对文本文件的变化和二进制文件的变化进行管理，这二者有什么不同？
10)	同时处理多个变更请求，或是同时进行增量开发和维护，这种事情你怎么看待？


10.	项目管理
1)	范围、时间、成本，这三项中哪些是可以由客户控制的？
2)	谁该对项目中所要付出的一切做出估算？谁有权设置最后期限？
3)	减少交付的次数，或是减少每个每个交付中的工作量，你喜欢哪种做法？
4)	你喜欢用哪种图来跟踪项目进度？
5)	迭代和增量的区别在哪里？
6)	试着解释一下风险管理中用到的实践。风险该如何管理？
7)	你喜欢任务分解还是滚动式计划？
8)	你需要哪些东西帮助你判断项目是否符合时间要求，在预算范围内运作？
9)	DSDM、Prince2、Scrum，这三者之间有哪些区别？
10)	如果客户想要的东西太多，你在范围和时间上怎样跟他达成一致呢？
#T=测试人员面试题 microshaoft
你认为用户、客户、开发人员、测试人员（需求阶段、研发阶段）各自的职责是什么？
请给出非功能性（质量特性）测试例子？及尝试如何设计测试方法？工具？
如何进行缺陷管理？跟踪？工具？
请设计一组在分布式并发环境下，保障应用程序（数据库）数据一致性的测试用例，包括输入参数、期望输出结果等
用户认证与用户授权的主要区别是什么？请设计相关测试用例：从“登陆框（用户名、密码）”开始包括输入参数、期望输出结果，考虑安全性
在测试过程中你是如何保障测试进度的？需求变更？（范围、时间）如何看待？
你会在什么情况下去寻求他人（如：开发人员、项目经理）的直接支持或帮助或者沟通？如何沟通？如何准备？
CS程序与Web B/S程序的主要区别是什么？在多层架构中都有哪些层？它们各自的职责是什么？
常见的Web Http Status 返回码有哪些？含义是什么？
你做过版本管理、配置管理、构建部署相关的工作吗
自动化测试手段？

#T=测试心得
不知不觉已经从事软件测试六年了，2006毕业到进入外包公司外包给微软做软件测试， 到现在加入著名的外企。六年的时间过得真快。 长期的测试工作也让我对软件测试有了比较深入的认识。但是我至今还是一个底层的测试人员，我的看法都比较狭隘，如有错误还请批评改正。
 
阅读目录：
软件测试人员应该居安思危
测试人员应该比开发人员更熟悉业务需求
学会如何和开发人员相处
测试人员应该懂一些基本的编程
测试人员搭建开发环境
写文档是测试人员的核心能力
测试后期应该做两天交叉测试
测试人员的瓶颈
尽量实现自动化
自动化测试VS手动测试
自动化测试的技术和开发用到的技术相差太远
最郁闷的是无法听懂开发人员讨论技术
优秀的测试人员非常稀少
大部分的测试经理都是有开发背景的
软件测试的确非常枯燥，需要花费大量精力
英语是测试人员的救命稻草
尽量少用UI自动化测试，多使用单元测试，接口测试
 
软件测试人员应该居安思危

每当经济不好，公司业绩不好的时候，公司都可能进行裁员。 首先裁的就是测试人员。 因为测试人员的技术水平相对来说比较低，容易被替代，招起来也比较容易。 公司往往先拿测试人员开刀。
身为测试人员，虽然我们平常的工作大部分都比较安逸。 但是千万不能温水煮青蛙。 应该自强不息， 要像开发人员一样， 不断学习，提高自己的编程水平。这样就算被裁也能很快找到新的工作。
 
测试人员应该比开发人员更熟悉业务需求

测试人员的水平主要体现在测试用例的设计上。 要设计出全面，覆盖广的测试用例，需要测试人员对自己所测试的项目的业务需求非常熟悉，甚至要比开发人员还要熟悉。
如果是测试银行系统，通信行业，或者ERP软件。 这些业务知识非常有用的，学习起来比较有激情。
要做到精通业务需求谈何容易。
1. 要熟读功能需求文档， 任何有疑问的地方都要去和PM确认。
2. 把自己当成最终用户， 经常使用自己所测试的软件。模拟用户的行为。
3. 熟记软件的每个功能。 
 
假如倒霉碰到一些又没用，又繁琐的软件， 真的是不想去学习它的业务（出了这个公司就再也用不到的业务）
 
学会如何跟开发人员相处

测试人员必须跟开发人员密切合作， 所以跟开发人员搞好关系是相当重要的。
1. 和开发人员成为朋友。
 熟悉了干啥都方便
2. 不要打扰开发人员
看到开发在聚精会神写代码的时候，千万不要去打扰人家。 写代码需要集中精力，如果被打扰，就会中断思考。 
3. 集中问问题。
把需要问的问题都总结起来， 集中起来问开发，这样能节省大量的时间。
4. 写好Bug，不被开发人员烦。
如果开发人员看到一个Bug 描述不清楚，还无法重现，他肯定会骂测试人员。 所以测试人员一定要写好Bug，描述精确，简洁，没有歧义，详细简洁的重现步骤，加截图。
 
测试人员应该懂一些基本的编程

你的产品是用C# 开发的，那测试人员应该有C#的入门知识。  你测试web程序，你起码要了解HTML,CSS, Javascript, Jquery吧，否则你测了一两年web程序，都不知道这东西是怎么做的，悲剧了吧。
只有懂代码你才能和开发人员交流，不被开发鄙视。
 
测试人员搭建开发环境

产品的代码是最好的学习资料了，我们不能总跟在开发屁股后面做测试，不能老是等开发build一个版本后，我们就测试这个版本，开发check in了什么代码，测试人员一点都不知道。偶尔我们应该了解下产品代码是怎么设计的，了解下开发人员是如何修复bug的。说不定编程水平高了，还能帮开发做code review.
使用源代码工具把产品代码check out到本机。 经常看看代码，经常看看开发修复bug时候提交的代码.
 
写文档是测试人员的核心能力

我记得我以前的test lead说，之所以她能当lead, 是因为她很会写文档发邮件。 写文档需要总结归纳的能力，还要逻辑清晰。 她非常擅长分析几十页的Spec，写出几十页的测试计划。 她还非常擅长汇总测试报告。 每天将完整，清晰，漂亮的测试报告发给各个组， 让公司所有的人都能清晰的看到测试组的工作。
在她的带领下，我们总结出很多文档，比如，"New hire checklist",   "on boarding traning", 测试工具使用的文档，等等。
写多了博客后我发现我写文档能力提高了很多。
 
测试后期应该做两天交叉测试

 交叉测试，就是指两个测试工程师，互相交换下测试的项目。 这样做有很多好处。
1. 有利于找出bug, 测试工程师测久了自己的项目，容易形成眼盲。会对一些Bug熟视无睹。 
2. 有利于知识和业务共享，避免人员离职，请假，造成无人测试的情况。
3. 测试思想不一样，可以互相找出很多问题
 
测试人员的瓶颈

手动测试工作做个两三年，基本上就能掌握测试需要的大部分知识，如果没有爬到test lead的位置， 很多人就感觉到发展瓶颈了，每天重复测试，学不到东西，很快就会对测试工作失去激情。
学不到东西，技术水平低下，是测试这个行业最大的毛病。
如何突破瓶颈？ 我也不知道。
 
尽量实现自动化

一点要抽时间尽量把自己的测试工作实现自动化，可以节省测试的时间，提高自己的技术水平，也可以避免老是重复测试。
 
自动化测试VS手动测试

现在很多公司招测试的要求越来越高，很多好公司招senior QA,都要求5年工作经验以上，掌握一门编程语言，有丰富的自动化测试经验。当然自动化测试的待遇也会比手动测试好很多。
自动化是趋势， 只会做手动测试的人，以后肯定会失去竞争力。
 
自动化测试的技术和开发用到的技术相差太远

以前很多同事想由测试转开发，现在几年过去了，还是没转成，他们原先想利用自动化测试的技术积累，转去做开发。哪知道自动化测试用到的技术跟开发用到的技术相比，实在是相差太远。
测试转开发？ 难
努力学习编码，然后用于测试，才是正道
 
做测试最郁闷的是无法听懂开发人员讨论技术

有时候跟开发人员一起开会， 会议上开发人员都热烈讨论。 而我做为测试人员基本上听不懂这群开发在说什么，根本插不上话。 很多会议我甚至都没说过一句话。
 
优秀的测试人员非常稀少

想把测试做好非常不容易， 优秀的测试人员需要很广的知识面，良好的沟通能力（不但要和开发人员和项目经理打交道，还要跟其他组的人交流）。  丰富的测试经验，对测试工作有极大的热情， 耐心。还需要测试人员有丰富的业务知识，还要会写代码。
代码写得好的人，肯定就不会做测试，而是做开发去了。
 
大部分的测试经理都是有开发背景的

我发现我的几任上司都是由开发转来做测试的。 他们都是有几年的开发经验，然后不知道什么原因转行做测试经理了。他们既能开发又能测试，啥都会，能给手下的测试人员提供技术支持。
 
假如一个测试经理啥技术都不懂，对内hold不住手下的人，对外其他组的人不鸟你。
 
软件测试的确非常枯燥，需要花费大量精力

不可否认测试工作需要耗费大量的精力，所以欧美才会把大量的测试职位外包给中国， 一遍又一遍的重复测试，不停地执行测试用例， 测得天昏地暗， 头发晕。
我还记得我以前测试过一个程序的各个版本在Windows update中的升级，  先安装老版本的程序，然后Windows update 重启后看看有没有升级，最后卸载。 然后又安装，又卸载。最后测的差点吐血。
 
英语是测试人员的救命稻草

技术上已经不如开发了。 在英语上一定占有一些优势。
同等的技术水平下，英语好的测试人员可以进外企，比一个英语不好的测试人员的待遇要高不少。
 
尽量少用UI自动化测试，多使用单元测试，接口测试

能找到bug的自动化测试，才是有用的，否则就是个噱头
UI自动化测试比较不稳定，对于测试结果的分析也困难。 而且UI改动也大。 所以应该尽量多做一些底层的的自动化测试，比如ASP.NET MVC 中UI和逻辑分开了，针对逻辑的自动化测试就比较好做了。
#T=程序员装逼速成手册
1. 着装
一根牛逼的程序员是根本没有时间打理自己外貌的，发型就要像爱因斯坦一样，顶着一脑袋鸡窝，凌乱蓬松美，给人随时能从头发里掏出一个鸡 蛋的感觉。胡子一大把，彰显自信又从容，不近视则以，近视就要戴酒瓶底子那么厚的大眼镜，一种科研工作者的风格。牛逼程序员对自己着装是有高要求的，无论 是春夏秋冬，白天晚上，刮风下雨，一个牛逼的程序员都要十分在意自己着装，T恤+大花裤衩子+拖鞋是标配，一年365天风雨无阻。换衣服保持一年3-5件 T恤的更新频率就可以，T恤大多是参见开源大会免费获得的，上面印着ruby on rails、eclipse、apache……天冷的实在熬不住了，就弄一个大棉脑，大耳包，款式随意，把自己裹上，以冻不死为标准。

2.装备
程 序员电脑配置都极高，但是外表很糟烂，磕碰的外表+沾满了炉灰渣滓的破包，随背随走。开会的时候，把笔记本往桌子上一砸，咣当一声，掉一堆烟灰和方便面 渣。从不用壁纸，无任何美化，给人一种WIN98的感觉。只装文本编辑器+开发工具软件。越简朴越纯粹，代表你越牛逼。能不用IDE就不要用，实在装不 了，无论IDE是什么，一定要调成DOS或linux那种黑色背景的，给人一种你随时敲几行代码，朝鲜的大浦洞导弹就要射向白宫的感觉。牛逼程序员的桌面 必须乱糟糟一大片，开发文档，代码，图片混杂其中，除了自己没有人能知道核心文件放哪了，进来商业间谍想偷都偷不走，但是需要指定文件的时候，自己分分钟 就能找到。

3.环境
程序员不用和客户直接打交道，办公室一般选在阴暗的角落里就行了。硕大的办公桌上，至少要摆两台电脑，一个笔 记本，一个台式连接双显示器，一个横屏，一个竖屏。竖屏编写代码，横屏调试效果。显示出你信息量很大，效率很高。桌子上可以随意放几本书，一定要是英文原 版，最次也是影印版，越厚越好，不要整齐的罗列在书架上，一定要堆在桌上，半打开状，上面全是手印子，菜汤，大鼻涕。其他锅碗瓢盆，方便面，快餐盒子随意 摆放，显示出你废寝忘食的工作状态，让人刮目相看。

4.工作
提溜一个糖水黄桃罐头瓶，放在桌边，坐下以后，脖子略微后仰，翘着二 郎腿，低头盯着屏幕看需求。最好点一根烟，牌子无所谓，能冒烟就行，要得就是云山雾绕的感觉，从烟雾中眯着眼睛看出去，一副胸有成竹的样。一根烟抽完，流 程图也在脑子里走完了，啪一下把烟头掐灭到茶缸子里。再点燃一根，开始闷声敲代码。心无旁骛的专心敲，烟灰都不要弹，敲好之后，编译，调试，再编译，再调 试，功能跑通，SVN提交代码。(地震火灾，也一定要先提交代码再行离开)，“啪”，笔记本合上，下班走人，喝啤酒撸串子去了。

5.经历
程 序员在一起最喜欢的就是吹牛逼，谈一些什么时尚炫酷的技术，整个啥云计算，web3.0，移动互联网开发……你要是也谈论这些，你就too young了，太低端。那玩意各大IT网站哪都有，一抓一大把，都被人说烂了。至少你也得谈点什么小榕，流光，冰河木马显示出你一个有资历的老黑客，你要 是没有参与过中国红客联盟，没入侵过美国国防部，你都不好意思跟人打招呼，再高端点，你就得说凯文・米特尼克的事迹了，15岁闯入了北美空中防护指挥系统 的计算机主机，翻遍了美国指向前苏联的所有核弹头的数据资料，然后又悄然无息的溜了出来，这他妈才叫牛逼。给人家一根电话线，分分钟黑了五角大楼。

6.情感
谈 到情感，不得不说这是程序员的硬伤。程序员通常都是智商很高，情商却很低。我每次谈恋爱，都是在loop循环里面用select语句，循环一次，就需要遍 历，select一次，而不是全部select出来，然后再剔除。这都是深受谭浩强的垃圾初级读物《C语言程序设计》的毒害。造成了大量时间的损耗和我体 能的透支。我把我写程序的思维用在了恋爱上，恋爱的时候脑子里是一张大大的流程图。都是IF，Y的时候走一条路，N的时候走另一条路，没有第三条路的选 择。就是爱约约，不约滚的节奏，这也导致了我多次被人利用却无法辩解。所以，这一章节，我自己目前还仍在研究之中。
#T=概念
AOP
IoC
DI
#T=开源协议 GPL
BSD开源协议

一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。

Apache Licence

著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。

GPL协议

和BSD， Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代 码做为闭源的商业软件发布和销售。我们很熟悉的Linux就是采用了GPL。

GUN LGPL
　　LGPL 是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用（link）方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。

MIT
　　MIT是和BSD一样宽范的许可协议，作者只想保留版权，而无任何其他了限制。也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。MIT协议又称麻省理工学院许可证，最初由麻省理工学院开发。被授权人权利：1、被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本。2、被授权人可根据程式的需要修改授权条款为适当的内容。被授权人义务：在软件和软件的所有副本中都必须包含版权声明和许可声明。

　　　  
#T=那些有争议的编程观点
那些争议最大的编程观点
知名问答网站 StackOverflow 之所以成功，合理的规则与严格执行是重要的原因，所以删帖是经常的。不过有时候执行得过严了，被删的问答不时会有惊艳之作。这不，他们的博客 8 月 29 日的文章“20个最受争议的编程观点”说的就是这样一个被删帖。此文一出，立刻在 Reddit/Programming、Hacker News 等各大技术新闻站上引起了热议。
实际上陈皓曾经翻译介绍过其中的十条，但观点本身没有翻译。
最初的问题“你最受争议的编程观点是什么？”（这里还能看到存档），由 Jon Skeet 在 2009 年 1 月提出。此人可不是无名小卒，C# 社区大名鼎鼎的人物，多年微软 MVP，所著《深入理解C#》（英文版C# in Depth）一书是 C# 领域少数不可不读的名著（老赵就说过C#他只推荐两本，这本和 CLR via C#），现在 Google 英国公司任工程师（还真不知道他在那里干什么）。
那么，这个问题当时都有哪些热门答案呢？顺序是随机的。
1、业余时间不会为了好玩而编程的程序员，永远比不上那些以编程为乐的同学。
	我认为即使是最聪明、最有才华的人，如果只是将编程作为工作，也永远成不了真正优秀的程序员。以编程为乐的人会在业余时也搞些小项目，或者弄弄各种不同的编程语言和编程思想。
2、单元测试无助于编写优秀代码。
	编写单元测试的唯一理由仅仅是确保已经能工作的代码不会出问题。先写测试或者按测试来写代码是无比荒谬的。如果在代码之前写测试，你都不知道边界情况是什么。虽然能让代码通过测试，但是在没有预见到的情况时还是会出问题。而且，好的开发人员会尽量降低内聚性，新增代码不可能使已有的出问题。
3、唯一能放之四海而皆准的最佳实践，是“用脑子思考”。
	太多人喜欢追逐众多时髦技术，想方设法把各种方法、模式、框架用到不适合的地方。新技术和名人大牛的观点不一定于适用于实际情况。
4、大多数代码中的注释实际上都是代码重复的恶性表现。
	我们大部分时间是在维护其他人（或者我们自己）写的代码，而糟糕、错误、过时和误导性的注释肯定是代码中最令人纠结的东西之一。很多人最终会将它们干掉。应该把精力放在提高代码的可读性、必要时就重构、少用惯用法和奇技淫巧上。另外，许多教材还在宣扬什么注释甚至比代码还重要，结果导致了大量废话连篇的注释。
5、依赖 Google 没什么错。
	这种言论肯定会让那些学富五车的饱学之士恼火。但是谁都需要查资料不是？正确答案就是正确答案，管它是来自哪本秘籍或者私下传授，还是 Google 出来的呢？重要的是能真正理解，并给出成功的编程解决方案，让客户和老板满意。
6、程序员不是生而平等的。
	经理往往认为程序员A == 程序员B，因为他们的年头差不多。实际上，一个开发者的效能可以是另一个的十倍甚至百倍。
7、我实在不能理解为什么 Java 是最适合大学教学的第一门语言。
	首先，我相信第一门编程语言应该重在学习控制流和变量，而不是对象和语法。其次，我认为没有调试 C/C++ 内存泄漏经验的人，根本无法完全理解 Java 的初衷。而且，自然的发展过程应该是从“我怎样做这事”到“我怎样找到能做这事的库”，而不是倒过来。
8、如果你只会一门语言，无论多么精通，仍然不是优秀的程序员。
	有人认为，只要精通了 C#、Java 或者其他什么你学会的第一门语言，就足够了。我不敢苟同。我学习的每一种新语言，都教了不少编程新知，能够反过来用于工作中。任何人只局限于一种语言，都无法充分发挥自己的潜力。而且缺乏求知欲和探索意愿，都不符合优秀程序员的特质。
9、偶尔写写垃圾代码也无妨。
	有时候一些特定任务，快而脏的代码能搞定就行了。模式、ORM、SRP（单一职责原则）啥的算了吧。
10、print 语句是合法的调试方式。
	我认为用 System.out.println 之类的输出语句调试代码挺好。这经常比正式的调试要快，而且可以比较不同运行的输出结果。但是投入生产环境之前一定要删除这些语句，或者将它们放入日志语句中。
11、你的工作是要把自己摘出来。
	你写的软件都应该让其他任何开发人员花一点时间就能理解并接手。软件应该设计优雅，代码清晰和一致，格式干净，文档合适，每日构建，有恰当的版本管理。如果你被车撞了、被开了、辞职了，公司应该很快能有人很快替代你。如果不能，那你就太悲剧了。有意思的是，你越这样做，你对公司的价值越大。
	原帖下面有人评论：你如果无法被替代，也就无法升职啦。
12、getter 和 setter 被极度滥用了。
	成千上万的人都说公共字段是罪恶的，应该设为私有，提供 getter 和 setter。我觉得其实没啥不同，除非程序是多线程的，或者访问方法中有业务或者展示逻辑（这可够怪的）。我并不是赞成用公共字段，只是反对用访问方法或者属性包一下，就号称封装、信息隐藏了。
13、SQL 也是代码，请等而视之。
	SQL 和 C#，Java 或者其他对象、过程语言没什么不同，请注意代码的格式、可读性和可维护性。
14、UML 图被高估了。
	有些图当然是有用的，比如 Composite 模式的类图。但许多 UML 图都毫无价值。
	CSDN 编者注：记得 Robert Martin 在《敏捷软件开发（C#版）》里讲 UML 时，基本上是讲一个图然后说，好像没什么用，我就没怎么用过……同一个问题下面还有一个相关的答案：代码==设计。认为高级语言代码比 UML 图和文档更有效。
15、可读性是代码最重要的方面。
	比正确性还重要。可读的代码也容易修正，容易优化、修改、理解。而且其他开发者也能从中获益。
16、XML 被大大高估了。
	很多随波逐流跳上 XML 这黑船的人都没过脑子。XML 用于 Web 应用不错，因为它本来就是干这个的。此外的问题定义、设计思路应该尽量不用 XML。
17、软件开发只是一份工作而已。
	我热爱软件开发， 我现在一家创业公司干，每周公司 60 小时，而且工资不高，只因为团队很棒，工作很有趣。但站得高一点来看，这仍然只是一份工作而已。它不如家庭、我的女友、其他朋友、幸福等等重要。要是有足够的钱，我宁愿去玩摩托、游艇或单板滑雪。许多开发者忘记了写程序不是最终目的，它只是为我们提供条件，去高高兴兴地做生命中最重要的事情。
	CSDN 编者注：这条和第 1 条好像有点对着来嘛。
18、开发人员就应该能够写代码。
	去年做了很多面试，我主要会测人们的思路，如何在白板上实现比较简单的算法。我往往从这样的问题开始：
	已知 Pi 可以用函数 4 * (1 C 1/3 + 1/5 C 1/7 + …) 计算，项越多越精确，请写一个函数，计算小数点后 5 位的 Pi。
	这是一个 10 行 C# 就能搞定的问题。但许多面试者甚至毫无思路。所以我只好接着问这样的问题：
	已知圆的面积是 Pi 乘以半径的平方，写一个函数计算。
	居然有超过半数的人无法用任何语言完成这个函数！唉，开发人员应该能够写代码，现在连这个都成有争议的观点了……
19、设计模式弊大于利。
	软件设计，尤其是好的软件设计千变万化，没法有意义地用模式去总结，尤其是那些大家记得住的几个模式，而且这些模式也太抽象了，其实没几个人真正记得住太多。所以设计模式其实没啥用。而另一方面呢，又有太多的人被设计模式的概念迷住，想方设法到处用 ―― 结果代码中往往除了一些毫无意义的单例和抽象工厂之外，几乎找不到什么设计。
20、代码少少益善。
	如果用户看不到你的工作，才是做对了。荣耀在别处。
	其他比较热门的答案还有：
21、性能真的很重要。
22、企业应用很滑稽。需要n年经验是胡扯。计算机科学学位课程纯忽悠。（链接）
23、单元测试无助于编写好代码，软件工程大多数所谓的最佳实践都是为了防范烂程序员搞太多破坏。（链接）
24、每个程序员都应该熟悉现代计算机的体系结构。
25、编写小方法。
26、PH、真烂！
27、C+、是有史以来最差的语言之一。（链接）
28、大多数职业程序员都很烂。
29、要想成为程序员，你得先学会打字。
30、编程之外的各种流程规矩越多，代码质量越差。（链接）
	资深的游戏程序、Jame、Hague（名、Prog21是也）也看到此文，觉得这些观点都没啥太大争议性。他专门写了一篇博客，又提出了他自认为更具争议性的观点，其中不少观点指向他之前发表的其他文章。
31、计算机科学专业应该只作为辅修学位。
32、新程序员还没有弄懂分解问题和将解决方法变成代码之前，就给他们介绍面向对象是大错特错。
33、复杂的编译器优化几乎都没什么价值，即使能得到更快的代码。它们会大大降低编译速度，而且很可能产生难以处理、bug，使性能问题的处理更加困难。
34、不能允许没有十年编程经验的人编写供他人使用的库。忽略此条，抱憾终身。
35、代码丑陋与否无关紧要。有没有格式与代码是否工作、可靠没什么关系，可以让自动化工具来整理格式。
36、纯函数式编程没啥用。但在命令式代码里杂用一些效果不错。
37、软件工程的既定思维反而会阻碍你做出伟大作品。

对这些编程观点你怎么看？你有什么值得争议的惊人之语吗，欢迎晒出来大家共赏析。

那些有争议的编程观点
英文原文：What's your most controversial programming opinion?
以下观点本身就有很大的争议性，以下观点不代表我的观点:-D

1)不在空闲的时间开发有趣内容的程序员不是好程序员
	热情和能力当然不能画上等号，但是不能不说没有关系。
2)唯一的最佳实践就是使用你的大脑
	最佳实践是用来限制那些糟糕程序员的破坏力。
3)”Googling it” is okay!
	Google 可以用来寻找答案，但并不能提升你自己的思考能力。
4)很多的注释和代码是重复的
	注释应该是注释 Why，而不是 How 和 What。
5)XML 的能力是被高估的
6)不是所有的程序员可以画为等号
7)我不明白为什么大学教程里说 Java 是最好的“第一”编程语言
	个人认为大学里第一要学的语言是那些着重讲述控制流程和变量的，不是对象和语法。自然的流程应该是我是学习我是怎么实现它，然后再使用我怎么使用它。
8)如果你只会一种语言，不管你有多精通都不会成为一个好程序员。
9)性能确实很重要
10)打印代码执行结果是一个最有效的调试方案
11)你的工作是让你脱离现有的工作
12)Getter 和 Setter 被过度的使用
13)UML 的作用被高估了
14)SQL 是代码，你需要格式化它
15)代码可读性是你代码最重要的指标
16)不是所有的开发人员都应该会写代码
17)使用匈牙利命名法的人应该被处死
18)设计模式正在破坏好的设计
19)代码越少越好
20)PHP 是糟糕的
	你使用才才会明白为什么
21)单元测试不会帮助你写好代码
22)写简短的方法
23)在一段时间内写垃圾代码是可以接受的
24)软件开发只是个工作
25)软件设计和架构是被高估的
	反对者表示很多软件架构师不再每天写代码但是要教别人怎么写代码是不可取的。
26)代码==设计
27)软件开发中没有银弹
28)每个开发人员都应该熟悉基本的架构和技术及知识


在Stack Overflow上有这样的一个贴子《What’s your most controversial programming opinion?》，翻译成中文就是“你认为最有争议的编程观点是什么？”，不过，在400多个主回贴，以及千把个子回贴中，好像并不是很有争议，而是令人相当的茅塞顿开，下面罗列一些，并通过我自己的经历和理解发挥了一些，希望对你有帮助。
1） The only “best practice” you should be using all the time is “Use Your Brain”.
	唯一的“Best Practice”并不是使用各种各样被前人总结过的各种设计方法、模式，框架，那些著名的方法、模式、框架只代码赞同他们的人多，并不代表他们适合你，你应该更多的去使用你的大脑，独立地思考那些方法、模式、框架出现的原因和其背后的想法和思想，那才是“best practice”。事实上来说，那些所谓的“Best Practice”只不过是限制那些糟糕的程序员们的破坏力。
2）Programmers who don’t code in their spare time for fun will never become as good as those that do.
	如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的娱乐方式去生活，无论是编程，还是运动，还是去旅游，那么你只不过是在应付你的工作，无时无刻不扎在程序堆中，这样下来，就算是你是一个非常聪明，非常有才华的人，你也不会成为一个优秀的编程员，要么只会平平凡凡，要么只会整天扎在技术中成为书呆子。当然，这个观点是有争议，热情和能力的差距也是很大的。不过我们可以从中汲取其正面的观点。
3）Most comments in code are in fact a pernicious form of code duplication.
	注释应该是注释Why，而不是How和What，参看《惹恼程序员的十件事》，代码告诉你How，而注释应该告诉你Why。但大多数的程序并不知道什么是好的注释，那些注释其实和code是重复的，毫无意义。
4）XML is highly overrated
	XML可能被高估了。XML对于Web上的应用是不错的，但是我们把其用到了各种地方，好像没有XML，我们都不会编程了。
5）Not all programmers are created equal
	这是那些junior经理或是流程爱犯的错，他们总是认为，DeveloperA == DeveloperB，只要他们的title一样，他们以为他们的能力、工作速度、解决问题的方法，掌握的技能等等都是一样的。呵呵。更扯的是，在某些时候，就算是最差的程序员，他们也会认为其比别人强十倍，这就是现代的SB管理。
6）”Googling it” is okay!
	Google只会给你知识，并不会教给你技能。那里只有“鱼”，没有“渔”，过度的使用Google，只会让你越来越离不开他，你越来越去要去立马告诉你答案，而你越来越不会自己去思考，自己去探索，去专研。如果KFC快餐是垃圾食品对我们的身体没有好处，那么使用Google也一种快餐文化对我们的智力发展大大的没有好处。
7）If you only know one language, no matter how well you know it, you’re not a great programmer.
	如果你只懂一种语言，准确的说，如果你只懂一类语类，如：Java和C#，PHP和Perl，那么，你将会被局限起来，只有了解了各种各样的语言，了解了不同语言的不同方法 ，你才会有比较，只有了比较，你才会明白各种语言的长处和短处，才会让你有更为成熟的观点，而且不整天和别的程序在网上斗嘴争论是Windows好还是Unix好，是C好还是C++好，有这点工夫能干好多事了。世界因为不同而精彩，只知道事物的一面是有害的。
8）Your job is to put yourself out of work.
	你的工作不是保守，那种教会徒弟，饿死师父的想法，不但是相当短浅的，而且还是相当脑残的。因为，在计算机世界里，你掌握的老技术越多，你就越没用，因为技术更新的太快。你对工作越保守，这个工作就越来越离不开你，你就越不越不能抽身去学新的东西，你也就越来越OUT了。记住：If you can’t be replaced then you can’t be promoted!
9）Design patterns are hurting good design more than they’re helping it.
	很多程序员把设计模式奉为天神，他们过度的追求设计模式以至都都忘了需求是什么，结果整个系统设计被设计模式搞得乱七八糟，我们叫这种编程为“设计模式驱动编程”，正如第一点所说，如果你不懂得用自己的大脑思考的话，知其然，不知所以然的话，那么你不但得不到其好处，反而受其所累。
10）Unit Testing won’t help you write good code
	准确地说，我们可以认为这是Test-Driven开发，其实，这种开发就是先写unit test case，这样的开发方式的主要目的是，为了防止你不会因为一个改动而引入Bug，但这并不会让你能写出更好的代码。这只会让你写出不会出错的代码。同第一点，这样的方法，只不过是防止糟糕的程序员，而并不是让程序员或代码质量更有长进。反而，通过Unit Test会为程序员的为自己代码做辩解的一种托辞。
	最后，顺便说一下，以前去那个敏捷的公司面试，发现那个公司的某些技术人员中毒不浅，具体表现在上述的1）9）10）观点上。
#T=异常
1. 让命名变得有意义。

在你的代码中使用有意义的名称去命名你的变量和方法等。我们应该通过名称就可以知道该变量或者方法的大致用途，优雅的代码应该是自解释的。一个好的名称要比一个泛泛的命名加上一堆注释行之有效。

2. 编写简洁可读性强的代码。

代码不仅仅是为了让程序能够运行起来，代码还得供人阅读和修改，因此代码的简洁性和可读性对于代码的维护甚为重要。用尽量少的代码做尽量多的事，这样可以降低出错的几率，也可以使代码更加优雅和简洁。一个方法只负责一件事，不要将多件事的不同逻辑放在一个方法内。让你的方法的行数控制在一屏之内，这样方便阅读。简洁优雅的代码需要我们不断的努力和尝试，直到可以随心所欲写出优雅的代码。

3. 为你的代码添加注释。

“靠！为什么这里要乘以0.75？”你在看代码的时候是不是会经常发生这种事？有没有过自己写的代码过了一段时间看不懂了？所以在你代码必要的地方加上注释！为了你和将来维护你代码的人，在必要的地方写上你为什么这么做、为什么要引入这个变量，从而让你的代码具有更佳的可读性和管理性。

4. 不要复制现有的代码。

复制、粘贴现有代码会导致一个代码片段在应用程序中多处出现。将来如果需要改变这些代码时，一旦忘记修改所有的，就会产生bug了。而且复制、粘贴现有的代码也会让文件变得混乱和臃肿，不利于文件的管理。

5. 只捕获你能处理的异常。

当我们在代码中使用try{...}catch(...Exception){...}捕获异常时，这就表明我们察觉到代码中包含着可能失败出错的代码，并且我们知道怎么处理该异常并恢复错误的逻辑。如果我们捕获了我们不能处理的异常，这就会导致逻辑不能恢复到正常状态，但是应用程序却还继续运行，这样就会导致应用程序存在安全隐患了，我想应该没有那个人愿意用一个不会崩溃但是却不能得到正确输出的应用程序。因此我们应该只捕获那些我们能够处理的异常，对于不能处理的应该让其顺着堆栈往上抛出直到遇到能处理该异常的逻辑代码。

6. 在性能出现问题时再优化代码。

对于一段已经运行稳定的代码，不要轻易地去改进优化，尤其在项目的前期。你的改动随时有可能会引入新的bug，除非性能提示你非得这么做，而性能测试一般的是在项目后期。

7. 删除不用的代码而不仅仅是注释。

删除掉那些不用的代码而不仅仅是注释掉它。注释是应该用来解释和说明代码的，其目的是为了让别人更加容易看懂代码，从而增强代码的可读性的。不要在你的程序中用它来注释那些不用的代码，取而代之的是你应该将这些不用的代码删掉，即使将来你重新需要用到这些代码，你也可以从版本控制软件里面得到这些代码。

7. 不要将多个类放到一个文件里面。

将类定义到单独的文件里面，通过文件名就可以知道是什么类了，而不需要打开文件或者使用全局搜索去查找类定义的位置。将类定义到单独的文件里还可以让你通过文件结构可以映射出程序的结构。
#T=争议最大的那些编程观点
那些争议最大的编程观点
知名问答网站 StackOverflow 之所以成功，合理的规则与严格执行是重要的原因，所以删帖是经常的。不过有时候执行得过严了，被删的问答不时会有惊艳之作。这不，他们的博客 8 月 29 日的文章“20个最受争议的编程观点”说的就是这样一个被删帖。此文一出，立刻在 Reddit/Programming、Hacker News 等各大技术新闻站上引起了热议。
实际上陈皓曾经翻译介绍过其中的十条，但观点本身没有翻译。
最初的问题“你最受争议的编程观点是什么？”（这里还能看到存档），由 Jon Skeet 在 2009 年 1 月提出。此人可不是无名小卒，C# 社区大名鼎鼎的人物，多年微软 MVP，所著《深入理解C#》（英文版C# in Depth）一书是 C# 领域少数不可不读的名著（老赵就说过C#他只推荐两本，这本和 CLR via C#），现在 Google 英国公司任工程师（还真不知道他在那里干什么）。
那么，这个问题当时都有哪些热门答案呢？顺序是随机的。
1、业余时间不会为了好玩而编程的程序员，永远比不上那些以编程为乐的同学。
	我认为即使是最聪明、最有才华的人，如果只是将编程作为工作，也永远成不了真正优秀的程序员。以编程为乐的人会在业余时也搞些小项目，或者弄弄各种不同的编程语言和编程思想。
2、单元测试无助于编写优秀代码。
	编写单元测试的唯一理由仅仅是确保已经能工作的代码不会出问题。先写测试或者按测试来写代码是无比荒谬的。如果在代码之前写测试，你都不知道边界情况是什么。虽然能让代码通过测试，但是在没有预见到的情况时还是会出问题。而且，好的开发人员会尽量降低内聚性，新增代码不可能使已有的出问题。
3、唯一能放之四海而皆准的最佳实践，是“用脑子思考”。
	太多人喜欢追逐众多时髦技术，想方设法把各种方法、模式、框架用到不适合的地方。新技术和名人大牛的观点不一定于适用于实际情况。
4、大多数代码中的注释实际上都是代码重复的恶性表现。
	我们大部分时间是在维护其他人（或者我们自己）写的代码，而糟糕、错误、过时和误导性的注释肯定是代码中最令人纠结的东西之一。很多人最终会将它们干掉。应该把精力放在提高代码的可读性、必要时就重构、少用惯用法和奇技淫巧上。另外，许多教材还在宣扬什么注释甚至比代码还重要，结果导致了大量废话连篇的注释。
5、依赖 Google 没什么错。
	这种言论肯定会让那些学富五车的饱学之士恼火。但是谁都需要查资料不是？正确答案就是正确答案，管它是来自哪本秘籍或者私下传授，还是 Google 出来的呢？重要的是能真正理解，并给出成功的编程解决方案，让客户和老板满意。
6、程序员不是生而平等的。
	经理往往认为程序员A == 程序员B，因为他们的年头差不多。实际上，一个开发者的效能可以是另一个的十倍甚至百倍。
7、我实在不能理解为什么 Java 是最适合大学教学的第一门语言。
	首先，我相信第一门编程语言应该重在学习控制流和变量，而不是对象和语法。其次，我认为没有调试 C/C++ 内存泄漏经验的人，根本无法完全理解 Java 的初衷。而且，自然的发展过程应该是从“我怎样做这事”到“我怎样找到能做这事的库”，而不是倒过来。
8、如果你只会一门语言，无论多么精通，仍然不是优秀的程序员。
	有人认为，只要精通了 C#、Java 或者其他什么你学会的第一门语言，就足够了。我不敢苟同。我学习的每一种新语言，都教了不少编程新知，能够反过来用于工作中。任何人只局限于一种语言，都无法充分发挥自己的潜力。而且缺乏求知欲和探索意愿，都不符合优秀程序员的特质。
9、偶尔写写垃圾代码也无妨。
	有时候一些特定任务，快而脏的代码能搞定就行了。模式、ORM、SRP（单一职责原则）啥的算了吧。
10、print 语句是合法的调试方式。
	我认为用 System.out.println 之类的输出语句调试代码挺好。这经常比正式的调试要快，而且可以比较不同运行的输出结果。但是投入生产环境之前一定要删除这些语句，或者将它们放入日志语句中。
11、你的工作是要把自己摘出来。
	你写的软件都应该让其他任何开发人员花一点时间就能理解并接手。软件应该设计优雅，代码清晰和一致，格式干净，文档合适，每日构建，有恰当的版本管理。如果你被车撞了、被开了、辞职了，公司应该很快能有人很快替代你。如果不能，那你就太悲剧了。有意思的是，你越这样做，你对公司的价值越大。
	原帖下面有人评论：你如果无法被替代，也就无法升职啦。
12、getter 和 setter 被极度滥用了。
	成千上万的人都说公共字段是罪恶的，应该设为私有，提供 getter 和 setter。我觉得其实没啥不同，除非程序是多线程的，或者访问方法中有业务或者展示逻辑（这可够怪的）。我并不是赞成用公共字段，只是反对用访问方法或者属性包一下，就号称封装、信息隐藏了。
13、SQL 也是代码，请等而视之。
	SQL 和 C#，Java 或者其他对象、过程语言没什么不同，请注意代码的格式、可读性和可维护性。
14、UML 图被高估了。
	有些图当然是有用的，比如 Composite 模式的类图。但许多 UML 图都毫无价值。
	CSDN 编者注：记得 Robert Martin 在《敏捷软件开发（C#版）》里讲 UML 时，基本上是讲一个图然后说，好像没什么用，我就没怎么用过……同一个问题下面还有一个相关的答案：代码==设计。认为高级语言代码比 UML 图和文档更有效。
15、可读性是代码最重要的方面。
	比正确性还重要。可读的代码也容易修正，容易优化、修改、理解。而且其他开发者也能从中获益。
16、XML 被大大高估了。
	很多随波逐流跳上 XML 这黑船的人都没过脑子。XML 用于 Web 应用不错，因为它本来就是干这个的。此外的问题定义、设计思路应该尽量不用 XML。
17、软件开发只是一份工作而已。
	我热爱软件开发， 我现在一家创业公司干，每周公司 60 小时，而且工资不高，只因为团队很棒，工作很有趣。但站得高一点来看，这仍然只是一份工作而已。它不如家庭、我的女友、其他朋友、幸福等等重要。要是有足够的钱，我宁愿去玩摩托、游艇或单板滑雪。许多开发者忘记了写程序不是最终目的，它只是为我们提供条件，去高高兴兴地做生命中最重要的事情。
	CSDN 编者注：这条和第 1 条好像有点对着来嘛。
18、开发人员就应该能够写代码。
	去年做了很多面试，我主要会测人们的思路，如何在白板上实现比较简单的算法。我往往从这样的问题开始：
	已知 Pi 可以用函数 4 * (1 C 1/3 + 1/5 C 1/7 + …) 计算，项越多越精确，请写一个函数，计算小数点后 5 位的 Pi。
	这是一个 10 行 C# 就能搞定的问题。但许多面试者甚至毫无思路。所以我只好接着问这样的问题：
	已知圆的面积是 Pi 乘以半径的平方，写一个函数计算。
	居然有超过半数的人无法用任何语言完成这个函数！唉，开发人员应该能够写代码，现在连这个都成有争议的观点了……
19、设计模式弊大于利。
	软件设计，尤其是好的软件设计千变万化，没法有意义地用模式去总结，尤其是那些大家记得住的几个模式，而且这些模式也太抽象了，其实没几个人真正记得住太多。所以设计模式其实没啥用。而另一方面呢，又有太多的人被设计模式的概念迷住，想方设法到处用 ―― 结果代码中往往除了一些毫无意义的单例和抽象工厂之外，几乎找不到什么设计。
20、代码少少益善。
	如果用户看不到你的工作，才是做对了。荣耀在别处。
	其他比较热门的答案还有：
21、性能真的很重要。
22、企业应用很滑稽。需要n年经验是胡扯。计算机科学学位课程纯忽悠。（链接）
23、单元测试无助于编写好代码，软件工程大多数所谓的最佳实践都是为了防范烂程序员搞太多破坏。（链接）
24、每个程序员都应该熟悉现代计算机的体系结构。
25、编写小方法。
26、PH、真烂！
27、C+、是有史以来最差的语言之一。（链接）
28、大多数职业程序员都很烂。
29、要想成为程序员，你得先学会打字。
30、编程之外的各种流程规矩越多，代码质量越差。（链接）
	资深的游戏程序、Jame、Hague（名、Prog21是也）也看到此文，觉得这些观点都没啥太大争议性。他专门写了一篇博客，又提出了他自认为更具争议性的观点，其中不少观点指向他之前发表的其他文章。
31、计算机科学专业应该只作为辅修学位。
32、新程序员还没有弄懂分解问题和将解决方法变成代码之前，就给他们介绍面向对象是大错特错。
33、复杂的编译器优化几乎都没什么价值，即使能得到更快的代码。它们会大大降低编译速度，而且很可能产生难以处理、bug，使性能问题的处理更加困难。
34、不能允许没有十年编程经验的人编写供他人使用的库。忽略此条，抱憾终身。
35、代码丑陋与否无关紧要。有没有格式与代码是否工作、可靠没什么关系，可以让自动化工具来整理格式。
36、纯函数式编程没啥用。但在命令式代码里杂用一些效果不错。
37、软件工程的既定思维反而会阻碍你做出伟大作品。

对这些编程观点你怎么看？你有什么值得争议的惊人之语吗，欢迎晒出来大家共赏析。

那些有争议的编程观点
英文原文：What's your most controversial programming opinion?
以下观点本身就有很大的争议性，以下观点不代表我的观点:-D

1)不在空闲的时间开发有趣内容的程序员不是好程序员
	热情和能力当然不能画上等号，但是不能不说没有关系。
2)唯一的最佳实践就是使用你的大脑
	最佳实践是用来限制那些糟糕程序员的破坏力。
3)”Googling it” is okay!
	Google 可以用来寻找答案，但并不能提升你自己的思考能力。
4)很多的注释和代码是重复的
	注释应该是注释 Why，而不是 How 和 What。
5)XML 的能力是被高估的
6)不是所有的程序员可以画为等号
7)我不明白为什么大学教程里说 Java 是最好的“第一”编程语言
	个人认为大学里第一要学的语言是那些着重讲述控制流程和变量的，不是对象和语法。自然的流程应该是我是学习我是怎么实现它，然后再使用我怎么使用它。
8)如果你只会一种语言，不管你有多精通都不会成为一个好程序员。
9)性能确实很重要
10)打印代码执行结果是一个最有效的调试方案
11)你的工作是让你脱离现有的工作
12)Getter 和 Setter 被过度的使用
13)UML 的作用被高估了
14)SQL 是代码，你需要格式化它
15)代码可读性是你代码最重要的指标
16)不是所有的开发人员都应该会写代码
17)使用匈牙利命名法的人应该被处死
18)设计模式正在破坏好的设计
19)代码越少越好
20)PHP 是糟糕的
	你使用才才会明白为什么
21)单元测试不会帮助你写好代码
22)写简短的方法
23)在一段时间内写垃圾代码是可以接受的
24)软件开发只是个工作
25)软件设计和架构是被高估的
	反对者表示很多软件架构师不再每天写代码但是要教别人怎么写代码是不可取的。
26)代码==设计
27)软件开发中没有银弹
28)每个开发人员都应该熟悉基本的架构和技术及知识


在Stack Overflow上有这样的一个贴子《What’s your most controversial programming opinion?》，翻译成中文就是“你认为最有争议的编程观点是什么？”，不过，在400多个主回贴，以及千把个子回贴中，好像并不是很有争议，而是令人相当的茅塞顿开，下面罗列一些，并通过我自己的经历和理解发挥了一些，希望对你有帮助。
1） The only “best practice” you should be using all the time is “Use Your Brain”.
	唯一的“Best Practice”并不是使用各种各样被前人总结过的各种设计方法、模式，框架，那些著名的方法、模式、框架只代码赞同他们的人多，并不代表他们适合你，你应该更多的去使用你的大脑，独立地思考那些方法、模式、框架出现的原因和其背后的想法和思想，那才是“best practice”。事实上来说，那些所谓的“Best Practice”只不过是限制那些糟糕的程序员们的破坏力。
2）Programmers who don’t code in their spare time for fun will never become as good as those that do.
	如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的娱乐方式去生活，无论是编程，还是运动，还是去旅游，那么你只不过是在应付你的工作，无时无刻不扎在程序堆中，这样下来，就算是你是一个非常聪明，非常有才华的人，你也不会成为一个优秀的编程员，要么只会平平凡凡，要么只会整天扎在技术中成为书呆子。当然，这个观点是有争议，热情和能力的差距也是很大的。不过我们可以从中汲取其正面的观点。
3）Most comments in code are in fact a pernicious form of code duplication.
	注释应该是注释Why，而不是How和What，参看《惹恼程序员的十件事》，代码告诉你How，而注释应该告诉你Why。但大多数的程序并不知道什么是好的注释，那些注释其实和code是重复的，毫无意义。
4）XML is highly overrated
	XML可能被高估了。XML对于Web上的应用是不错的，但是我们把其用到了各种地方，好像没有XML，我们都不会编程了。
5）Not all programmers are created equal
	这是那些junior经理或是流程爱犯的错，他们总是认为，DeveloperA == DeveloperB，只要他们的title一样，他们以为他们的能力、工作速度、解决问题的方法，掌握的技能等等都是一样的。呵呵。更扯的是，在某些时候，就算是最差的程序员，他们也会认为其比别人强十倍，这就是现代的SB管理。
6）”Googling it” is okay!
	Google只会给你知识，并不会教给你技能。那里只有“鱼”，没有“渔”，过度的使用Google，只会让你越来越离不开他，你越来越去要去立马告诉你答案，而你越来越不会自己去思考，自己去探索，去专研。如果KFC快餐是垃圾食品对我们的身体没有好处，那么使用Google也一种快餐文化对我们的智力发展大大的没有好处。
7）If you only know one language, no matter how well you know it, you’re not a great programmer.
	如果你只懂一种语言，准确的说，如果你只懂一类语类，如：Java和C#，PHP和Perl，那么，你将会被局限起来，只有了解了各种各样的语言，了解了不同语言的不同方法 ，你才会有比较，只有了比较，你才会明白各种语言的长处和短处，才会让你有更为成熟的观点，而且不整天和别的程序在网上斗嘴争论是Windows好还是Unix好，是C好还是C++好，有这点工夫能干好多事了。世界因为不同而精彩，只知道事物的一面是有害的。
8）Your job is to put yourself out of work.
	你的工作不是保守，那种教会徒弟，饿死师父的想法，不但是相当短浅的，而且还是相当脑残的。因为，在计算机世界里，你掌握的老技术越多，你就越没用，因为技术更新的太快。你对工作越保守，这个工作就越来越离不开你，你就越不越不能抽身去学新的东西，你也就越来越OUT了。记住：If you can’t be replaced then you can’t be promoted!
9）Design patterns are hurting good design more than they’re helping it.
	很多程序员把设计模式奉为天神，他们过度的追求设计模式以至都都忘了需求是什么，结果整个系统设计被设计模式搞得乱七八糟，我们叫这种编程为“设计模式驱动编程”，正如第一点所说，如果你不懂得用自己的大脑思考的话，知其然，不知所以然的话，那么你不但得不到其好处，反而受其所累。
10）Unit Testing won’t help you write good code
	准确地说，我们可以认为这是Test-Driven开发，其实，这种开发就是先写unit test case，这样的开发方式的主要目的是，为了防止你不会因为一个改动而引入Bug，但这并不会让你能写出更好的代码。这只会让你写出不会出错的代码。同第一点，这样的方法，只不过是防止糟糕的程序员，而并不是让程序员或代码质量更有长进。反而，通过Unit Test会为程序员的为自己代码做辩解的一种托辞。
	最后，顺便说一下，以前去那个敏捷的公司面试，发现那个公司的某些技术人员中毒不浅，具体表现在上述的1）9）10）观点上。
#T=重构
重构是一种对软件进行修改的行为，但它并不改变软件的功能特征，而是通过让软件程序更清晰，
更简洁和更条理来改进软件的质量。代码重构之于软件，相当于结构修改之于散文。每次人们对
如何对代码进行重构的讨论就像是讨论如何对一篇文学作品进行修订一样无休无止。所有人都知
道应该根据项目的自身情况来对代码进行重构，而重构是无止境的。莫扎特从来不不对他的作品
进行修订，特罗洛普对自己作品修订的恰到好处，大多数作家认为他们俩这样做都是合适的，但
他们的合适对于你我来说未必是合适的。
最常见的基本重构方法可以归纳为两个方向。
通过"归纳方法"将一个长的过程分解为小的可以重用的组件，
和通过"内联(inline)方法"来消除那些不够份量的小方法。
我们可以"提炼方法"来让大量的子类共享相同的功能特征，
我们可以"下放方法"来让只有用到这些功能的子类才知道它们的存在。
"重构"就是爬山，通过一步一步的小的提高来逐渐的改进整体的质量，
但在重构时，我们如何知道哪种方法是上山的正确道路？

关于代码地形学的这个问题公认的方法有两种。
去除有异味的代码和重构成模式。如果能做到这样，当然是很好的。
就像是纠正作文里的一个语法错误或不恰当的比喻。
如果我们可以找到这些四处隐藏的有异味的代码，将它们重写成整洁的，条理的，结构化的形式，何乐而不为。
但这些都是特殊情况。
如果没有明显的模式来重构，或没有很直接的方法来去除代码异味，那该怎么办呢？

这才是我们如今编程艺术的中心问题，而很少人讨论这些。
通常我们讨论这些问题时都是罗列出更多更长的有异味的代码模式的清单，但这并不是解决问题的方法。
代码异味应该是我们公认的不好的东西，而不是那些置之不理也无妨的事情。
我们经常会说到老板不给我们重构的机会，甚至代码有明显的异味，老板们认为这是浪费时间。
并不是每个人都有懂软件的老板。我很吃惊为什么只有很少的讨论谈到点子上。
也许我这篇文章才说到问题关键处。

我的观点，当重构没有现成的明显的方向时，我们可以遵循下面的原则：

1.当属性、方法或类存在任何的需要复用的意向时，归纳提炼它们。
2.不要低估小方法对代码整洁的作用。使用小方法能让你节省很多笔墨。
3.能让代码长度变短的提炼都应该去提炼，包括注释。
4.用多形代替switch()――即使这样做会使代码变长。
5.用封装控制可见度。
6.消除依赖。
7.简化构造方法――即使这样做会使代码变复杂。
8.封装或避免条件表达式。使用guard语句，避免使用else语句。
9.使用常量代替魔幻数字。
10.不确定时，偏向使用组合而不是继承。
11.不确定时，将计算操作移入到这些数据的所有者对象里，或将数据移动到执行计算操作的对象里(也就是迪米特法则(Law of Demeter))。
12.使用小对象，松耦合，避免大对象，高聚合。
13.不确定时，偏向使用递归而不是循环。
14.使用代理对象，模拟对象和辅助对象来隔离网络，数据库，文件和用户接口。
15.不确定时，尽量在model里添加代码，必要时才往controler添加代码。view里添加的都应该是便捷功能和简写方法，但不要局限于此。
16.偏向使用apply, each, mapcar，而不是loop.
17.尽量使用新技术。
#